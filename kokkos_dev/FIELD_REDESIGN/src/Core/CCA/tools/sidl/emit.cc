
#include "Spec.h"
#include "SymbolTable.h"
#ifdef __sgi
extern "C" {
#include <sys/uuid.h>
}
#endif
#include <algorithm>
#include <iostream>
#include <map>
#include <sstream>

using std::cerr;
using std::for_each;
using std::map;
using std::replace;
using std::string;
using std::vector;
extern bool doing_cia;

static string handle_class = "\
class @ {\n\
    @_interface* ptr;\n\
public:\n\
    static const ::Component::PIDL::TypeInfo* _getTypeInfo();\n\
    typedef @_interface interfacetype;\n\
    inline @()\n\
    {\n\
        ptr=0;\n\
    }\n\
    inline @(@_interface* ptr)\n\
        : ptr(ptr)\n\
    {\n\
        if(ptr)\n\
            ptr->_addReference();\n\
    }\n\
    inline ~@()\n\
    {\n\
        if(ptr)\n\
            ptr->_deleteReference();\n\
    }\n\
    inline @(const @& copy)\n\
        : ptr(copy.ptr)\n\
    {\n\
        if(ptr)\n\
            ptr->_addReference();\n\
    }\n\
    inline @& operator=(const @& copy)\n\
    {\n\
        if(&copy != this){\n\
            if(ptr)\n\
                ptr->_deleteReference();\n\
            if(copy.ptr)\n\
                copy.ptr->_addReference();\n\
        }\n\
        ptr=copy.ptr;\n\
        return *this;\n\
    }\n\
    inline @_interface* getPointer() const\n\
    {\n\
        return ptr;\n\
    }\n\
    inline @_interface* operator->() const\n\
    {\n\
        return ptr;\n\
    }\n\
    inline operator bool() const\n\
    {\n\
        return ptr != 0;\n\
    }\n\
    inline operator ::Component::PIDL::Object() const\n\
    {\n\
        return ptr;\n\
    }\n\
";

struct Leader {
};
static Leader leader;

struct SState : public std::ostringstream {
    std::string leader;
    SymbolTable* currentPackage;
    EmitState*e;
    SState(EmitState* e) : e(e) {
	currentPackage=0;
	leader="";
    }
    void begin_namespace(SymbolTable*);
    void close_namespace();
    void recursive_begin_namespace(SymbolTable*);
    std::ostream& operator<<(const Leader&) {
	*this << leader;
	return *this;
    }
    std::string push_leader() {
	string oldleader=leader;
	leader+="    ";
	return oldleader;
    }
    void pop_leader(const std::string& oldleader) {
	leader=oldleader;
    }
};

struct EmitState {
    int instanceNum;
    int handlerNum;
    EmitState();

    SState fwd;
    SState decl;
    SState out;
    SState proxy;
};

EmitState::EmitState()
    : fwd(this), decl(this), out(this), proxy(this)
{
    instanceNum=0;
    handlerNum=0;
}

void Specification::emit(std::ostream& out, std::ostream& hdr,
			 const std::string& hname) const
{
    EmitState e;
    // Emit code for each definition
    globals->emit(e);
    e.fwd.close_namespace();
    e.decl.close_namespace();
    e.out.close_namespace();
    e.proxy.close_namespace();

    hdr << "/*\n";
    hdr << " * This code was automatically generated by sidl,\n";
    hdr << " * do not edit directly!\n";
    hdr << " */\n";
    hdr << "\n";
    string ifname(hname);
    replace(ifname.begin(), ifname.end(), '/', '_');
    replace(ifname.begin(), ifname.end(), '.', '_');
    hdr << "#ifndef _sidl_generated_" << ifname << '\n';
    hdr << "#define _sidl_generated_" << ifname << '\n';
    hdr << "\n";
    hdr << "#include <Component/PIDL/Object.h>\n";
    hdr << "#include <Component/PIDL/pidl_cast.h>\n";
    hdr << "#include <Component/CIA/CIA_sidl.h>\n";
    hdr << "#include <Component/CIA/array.h>\n";
    hdr << "#include <Component/CIA/string.h>\n";
    hdr << "\n";
    hdr << e.fwd.str();
    hdr << e.decl.str();
    hdr << "\n#endif\n\n";

    // Emit #includes
    out << "/*\n";
    out << " * This code was automatically generated by sidl,\n";
    out << " * do not edit directly!\n";
    out << " */\n";
    out << "\n";
    out << "#include \"" << hname << "\"\n";
    out << "#include <SCICore/Exceptions/InternalError.h>\n";
    out << "#include <Component/PIDL/GlobusError.h>\n";
    out << "#include <Component/PIDL/Object_proxy.h>\n";
    out << "#include <Component/PIDL/ProxyBase.h>\n";
    out << "#include <Component/PIDL/ReplyEP.h>\n";
    out << "#include <Component/PIDL/Reference.h>\n";
    out << "#include <Component/PIDL/ServerContext.h>\n";
    out << "#include <Component/PIDL/TypeInfo.h>\n";
    out << "#include <Component/PIDL/TypeInfo_internal.h>\n";
    out << "#include <SCICore/Util/NotFinished.h>\n";
    out << "#include <SCICore/Thread/Thread.h>\n";
    out << "#include <iostream>\n";
    out << "#include <globus_nexus.h>\n";
    out << "\n";
    out << e.proxy.str();
    out << e.out.str();
}

void SymbolTable::emit(EmitState& e) const
{
    for(map<string, Symbol*>::const_iterator iter=symbols.begin();
	iter != symbols.end();iter++){
	iter->second->emit(e);
    }
}

void Symbol::emit(EmitState& e)
{
    switch(type){
    case PackageType:
	definition->getSymbolTable()->emit(e);
	break;
    case InterfaceType:
    case ClassType:
	definition->emit(e);
	break;
    case MethodType:
	cerr << "Symbol::emit called for a method!\n";
	exit(1);
    }
    emitted_forward=true;
}

void Symbol::emit_forward(EmitState& e)
{
    if(emitted_forward)
	return;
    switch(type){
    case PackageType:
	cerr << "Why is emit forward being called for a package?\n";
	exit(1);
    case InterfaceType:
    case ClassType:
	if(definition->emitted_declaration){
	    emitted_forward=true;
	    return;
	}
	e.fwd.begin_namespace(symtab);
	e.fwd << leader << "class " << name << ";\n";
	break;
    case MethodType:
	cerr << "Symbol::emit_forward called for a method!\n";
	exit(1);
    }
    emitted_forward=true;
}	

void Package::emit(EmitState&)
{
    cerr << "Package::emit should not be called...\n";
    exit(1);
}

void SState::begin_namespace(SymbolTable* stab)
{
    if(currentPackage == stab)
	return;
    // Close off previous namespace...
    close_namespace();

    // Open new namespace...
    recursive_begin_namespace(stab);
    currentPackage=stab;
}

void SState::close_namespace()
{
    if(currentPackage){
	while(currentPackage->getParent()){
	    for(SymbolTable* p=currentPackage->getParent();p->getParent()!=0;p=p->getParent())
		*this << "    ";
	    *this << "} // End namespace " << currentPackage->getName() << '\n';
	    currentPackage=currentPackage->getParent();
	}
	*this << "\n";
    }
    leader="";
}

void SState::recursive_begin_namespace(SymbolTable* stab)
{
    SymbolTable* parent=stab->getParent();
    if(parent){
	recursive_begin_namespace(parent);
	*this << leader << "namespace " << stab->getName() << " {\n";
	push_leader();
    }
}

bool CI::iam_class()
{
    bool iam=false;
    if(dynamic_cast<Class*>(this))
	iam=true;
    return iam;
}

void CI::emit(EmitState& e)
{
    if(emitted_declaration)
	return;
    // Emit parent classes...
    if(parentclass)
	parentclass->emit(e);
    for(std::vector<Interface*>::iterator iter=parent_ifaces.begin();
	iter != parent_ifaces.end(); iter++){
	(*iter)->emit(e);
    }

    emit_proxyclass(e);
    if(!do_emit){
	emitted_declaration=true;
	return;
    }

    emit_header(e);

    e.instanceNum++;

    // Emit handler functions
    emit_handlers(e);

    // Emit handler table
    emit_handler_table(e);

    emit_typeinfo(e);

    emit_interface(e);

    emit_proxy(e);
    emitted_declaration=true;
}

void CI::emit_typeinfo(EmitState& e)
{
    std::string fn=cppfullname(0);
#ifdef __sgi
    uuid_t uuid;
    uint_t status;
    uuid_create(&uuid, &status);
    if(status != uuid_s_ok){
	cerr << "Error creating uuid!\n";
	exit(1);
    }
    char* uuid_str;
    uuid_to_string(&uuid, &uuid_str, &status);
    if(status != uuid_s_ok){
	cerr << "Error creating uuid string!\n";
	exit(1);
    }
#endif
    e.out << "const ::Component::PIDL::TypeInfo* " << fn << "::_getTypeInfo()\n";
    e.out << "{\n";
    e.out << "    static ::Component::PIDL::TypeInfo* ti=0;\n";
    e.out << "    if(!ti){\n";
    e.out << "        ::Component::PIDL::TypeInfo_internal* tii=\n";
    e.out << "            new ::Component::PIDL::TypeInfo_internal(\"" << cppfullname(0) << "\", \"" << uuid_str << "\",\n";
    e.out << "                                                     _handler_table" << e.instanceNum << ",\n";
    e.out << "                                                     sizeof(_handler_table" << e.instanceNum << ")/sizeof(globus_nexus_handler_t),\n";
    e.out << "                                                     &" << fn << "_proxy::create_proxy);\n\n";
    SymbolTable* localScope=symbols->getParent();
    if(parentclass)
	e.out << "        tii->add_parentclass(" << parentclass->cppfullname(localScope) << "::_getTypeInfo(), " << parentclass->vtable_base << ");\n";
    for(vector<Interface*>::iterator iter=parent_ifaces.begin();
	iter != parent_ifaces.end(); iter++){
	e.out << "        tii->add_parentiface(" << (*iter)->cppfullname(localScope) << "::_getTypeInfo(), " << (*iter)->vtable_base << ");\n";
    }
    e.out << "        ti=new ::Component::PIDL::TypeInfo(tii);\n";
    e.out << "    }\n";
    e.out << "    return ti;\n";
    e.out << "}\n\n";

    free(uuid_str);
}

void CI::emit_handlers(EmitState& e)
{
    // Emit isa handler...
    e.out << "// methods from " << name << " " << curfile << ":" << lineno << "\n\n";
    e.out << "// isa handler\n";
    isaHandler=++e.handlerNum;
    e.out << "static void _handler" << isaHandler << "(globus_nexus_endpoint_t* _ep,\n";
    e.out << "                      globus_nexus_buffer_t* _recvbuff, globus_bool_t)\n";
    e.out << "{\n";
    e.out << "    int classname_size;\n";
    e.out << "    globus_nexus_get_int(_recvbuff, &classname_size, 1);\n";
    e.out << "    char* classname=new char[classname_size+1];\n";
    e.out << "    globus_nexus_get_char(_recvbuff, classname, classname_size);\n";
    e.out << "    classname[classname_size]=0;\n";
    e.out << "    int uuid_size;\n";
    e.out << "    globus_nexus_get_int(_recvbuff, &uuid_size, 1);\n";
    e.out << "    char* uuid=new char[uuid_size+1];\n";
    e.out << "    globus_nexus_get_char(_recvbuff, uuid, uuid_size);\n";
    e.out << "    uuid[uuid_size]=0;\n";
    e.out << "    globus_nexus_startpoint_t _sp;\n";
    e.out << "    int _addRef;\n";
    e.out << "    globus_nexus_get_int(_recvbuff, &_addRef, 1);\n";
    e.out << "    if(int _gerr=globus_nexus_get_startpoint(_recvbuff, &_sp, 1))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"get_startpoint\", _gerr);\n";
    e.out << "    if(int _gerr=globus_nexus_buffer_destroy(_recvbuff))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
    e.out << "    const ::Component::PIDL::TypeInfo* ti=" << cppfullname(0) << "::_getTypeInfo();\n";
    e.out << "    int result=ti->isa(classname, uuid);\n";
    e.out << "    delete[] classname;\n";
    e.out << "    delete[] uuid;\n";
    e.out << "    int flag;\n";
    e.out << "    if(result == ::Component::PIDL::TypeInfo::vtable_invalid) {\n";
    e.out << "        flag=0;\n";
    e.out << "    } else {\n";
    e.out << "        flag=1;\n";
    e.out << "        if(_addRef){\n";
    e.out << "            void* _v=globus_nexus_endpoint_get_user_pointer(_ep);\n";
    e.out << "            ::Component::PIDL::ServerContext* _sc=static_cast<::Component::PIDL::ServerContext*>(_v);\n";
    e.out << "            _sc->d_objptr->_addReference();\n";
    e.out << "        }\n";
    e.out << "    }\n";
    e.out << "    globus_nexus_buffer_t sendbuff;\n";
    e.out << "    int rsize=globus_nexus_sizeof_int(2);\n";
    e.out << "    if(int gerr=globus_nexus_buffer_init(&sendbuff, rsize, 0))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_init\", gerr);\n";
    e.out << "    globus_nexus_put_int(&sendbuff, &flag, 1);\n";
    e.out << "    globus_nexus_put_int(&sendbuff, &result, 1);\n";
    e.out << "    if(int _gerr=globus_nexus_send_rsr(&sendbuff, &_sp, 0, GLOBUS_TRUE, GLOBUS_FALSE))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"send_rsr\", _gerr);\n";
    e.out << "    if(int _gerr=globus_nexus_startpoint_eventually_destroy(&_sp, GLOBUS_FALSE, 30))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"startpoint_eventually_destroy\", _gerr);\n";
    e.out << "}\n\n";

    // Emit delete reference handler...
    e.out << "// methods from " << name << " " << curfile << ":" << lineno << "\n\n";
    e.out << "// delete reference handler\n";
    deleteReferenceHandler=++e.handlerNum;
    e.out << "static void _handler" << deleteReferenceHandler << "(globus_nexus_endpoint_t* _ep,\n";
    e.out << "                      globus_nexus_buffer_t* _recvbuff, globus_bool_t)\n";
    e.out << "{\n";
    e.out << "    if(int _gerr=globus_nexus_buffer_destroy(_recvbuff))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
    e.out << "    void* _v=globus_nexus_endpoint_get_user_pointer(_ep);\n";
    e.out << "    ::Component::PIDL::ServerContext* _sc=static_cast<::Component::PIDL::ServerContext*>(_v);\n";
    e.out << "    _sc->d_objptr->_deleteReference();\n";
    e.out << "}\n\n";

    // Emit method handlers...
    std::vector<Method*> vtab;
    gatherVtable(vtab, false);
    int handlerOff=0;
    for(vector<Method*>::const_iterator iter=vtab.begin();
	iter != vtab.end();iter++){
	Method* m=*iter;
	e.handlerNum++;
	m->handlerNum=e.handlerNum;
	m->handlerOff=handlerOff++;
	m->emit_handler(e, this);
    }
}

void CI::emit_recursive_vtable_comment(EmitState& e, bool top)
{
    e.out << "  // " << (top?"":"and ") << (iam_class()?"class ":"interface ") << name << "\n";
    if(parentclass)
	parentclass->emit_recursive_vtable_comment(e, false);

    for(vector<Interface*>::const_iterator iter=parent_ifaces.begin();
	iter != parent_ifaces.end(); iter++){
	(*iter)->emit_recursive_vtable_comment(e, false);
    }
}

bool CI::singly_inherited() const
{
    // A class is singly inherited if it has one parent class,
    // or one parent interface, and it's parent is singly_inherited
    if((parentclass && parent_ifaces.size() > 0)
       || parent_ifaces.size()>1)
	return false;
    if(parentclass){
	if(!parentclass->singly_inherited())
	    return false;
    } else if(parent_ifaces.size()>0){
	// First element...
	if(!(*parent_ifaces.begin())->singly_inherited())
	    return false;
    }
    return true;
}

void CI::emit_handler_table_body(EmitState& e, int& vtable_base, bool top)
{
    bool single=singly_inherited();
    if(single)
	emit_recursive_vtable_comment(e, true);
    else
	e.out << "  // " << (iam_class()?"class ":"interface ") << name << "\n";
    e.out << "  // vtable_base = " << vtable_base << '\n';
    std::vector<Method*> vtab;
    gatherVtable(vtab, false);
    for(vector<Method*>::const_iterator iter=vtab.begin();
	iter != vtab.end();iter++){
	if(iter != vtab.begin())
	    e.out << ",\n";
	Method* m=*iter;
	m->emit_comment(e, "    ", false);
	e.out << "    {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, _handler" << m->handlerNum << "}";
    } 
    e.out << ",\n    // Red zone\n";    
    e.out << "    {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, 0},\n";

    if(single){
	if(top){
	    if(parentclass)
		parentclass->vtable_base=vtable_base;
	    for(vector<Interface*>::iterator iter=parent_ifaces.begin();
		iter != parent_ifaces.end(); iter++){
		(*iter)->vtable_base=vtable_base;
	    }
	}
	vtable_base+=vtab.size()+1;
	return;
    }
    // For each parent, emit the handler table...
    vtable_base+=vtab.size()+1;
    if(parentclass){
	if(top)
	    parentclass->vtable_base=vtable_base;
	parentclass->emit_handler_table_body(e, vtable_base, false);
    }
    for(vector<Interface*>::iterator iter=parent_ifaces.begin();
	iter != parent_ifaces.end(); iter++){
	if(top)
	    (*iter)->vtable_base=vtable_base;
	(*iter)->emit_handler_table_body(e, vtable_base, false);
    }
}

void CI::emit_handler_table(EmitState& e)
{
    e.out << "// handler table for " << (iam_class()?"class ":"interface ") << name << "\n";
    e.out << "//" << curfile << ":" << lineno << "\n\n";
    e.out << "static globus_nexus_handler_t _handler_table" << e.instanceNum << "[] =\n";
    e.out << "{\n";
    e.out << "    {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, _handler" << isaHandler << "},\n";
    e.out << "    {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, _handler" << deleteReferenceHandler << "},\n";
    e.out << "    {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, 0},\n";
    int vtable_base=3;

    emit_handler_table_body(e, vtable_base, true);

    e.out << "\n}; // vtable_size=" << vtable_base << "\n\n";
}

bool Method::reply_required() const
{
    return true; // For now
}

string Method::get_classname() const
{
    string n;
    if(myclass)
	n=myclass->cppfullname(0);
    else if(myinterface)
	n=myinterface->cppfullname(0);
    else {
	cerr << "ERROR: Method does not have an associated class or interface\n";
	exit(1);
    }
    return n+"_interface";
}

void Method::emit_comment(EmitState& e, const std::string& leader,
			  bool print_filename) const
{
    if(print_filename)
	e.out << leader << "// from " << curfile << ":" << lineno << '\n';
    e.out << leader << "// " << fullsignature() << '\n';
}

void Method::emit_prototype(SState& out, Context ctx,
			    SymbolTable* localScope) const
{
    out << leader << "// " << fullsignature() << '\n';
    out << leader << "virtual ";
    return_type->emit_prototype(out, Type::ReturnType, localScope);
    out << " " << name << "(";
    std::vector<Argument*>& list=args->getList();
    int c=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	if(c++>0)
	    out << ", ";
	Argument* arg=*iter;
	arg->emit_prototype(out, localScope);
    }
    out << ")";
    if(ctx == PureVirtual && !doing_cia)
	out << "=0";
    out << ";\n";
}

void Method::emit_prototype_defin(EmitState& e, const std::string& prefix,
				  SymbolTable* localScope) const
{
    e.out << "// " << fullsignature() << '\n';
    return_type->emit_prototype(e.out, Type::ReturnType, 0);
    e.out << " " << prefix << name << "(";
    std::vector<Argument*>& list=args->getList();
    int c=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	if(c++>0)
	    e.out << ", ";
	Argument* arg=*iter;
	std::ostringstream argname;
	argname << "_arg" << c;
	arg->emit_prototype_defin(e.out, argname.str(), localScope);
    }
    e.out << ")";
}

void Method::emit_handler(EmitState& e, CI* emit_class) const
{
    // Server-side handlers
    emit_comment(e, "", true);
    e.out << "static void _handler" << e.handlerNum << "(globus_nexus_endpoint_t* _ep,\n";
    e.out << "                      globus_nexus_buffer_t* _recvbuff, globus_bool_t)\n";
    e.out << "{\n";

    string oldleader=e.out.push_leader();
    std::vector<Argument*>& list=args->getList();
    int argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	argNum++;
	Argument* arg=*iter;
	if(arg->getMode() != Argument::Out) {
	    std::ostringstream argname;
	    argname << "_arg" << argNum;
	    arg->emit_unmarshal(e, argname.str(), "1", "_recvbuff", true);
	}
    }
    e.out.pop_leader(oldleader);

    // If we are sending a reply, unmarshal the startpoint
    e.out << "\n";
    if(reply_required()){
	e.out << "    globus_nexus_startpoint_t _sp;\n";
	e.out << "    if(int _gerr=globus_nexus_get_startpoint(_recvbuff, &_sp, 1))\n";
	e.out << "        throw ::Component::PIDL::GlobusError(\"get_startpoint\", _gerr);\n";
    }
    // Destroy the buffer...
    e.out << "    if(int _gerr=globus_nexus_buffer_destroy(_recvbuff))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
    e.out << "    void* _v=globus_nexus_endpoint_get_user_pointer(_ep);\n";
    string myclass=emit_class->cppfullname(0)+"_interface";
    e.out << "    ::Component::PIDL::ServerContext* _sc=static_cast<::Component::PIDL::ServerContext*>(_v);\n";
    e.out << "    " << myclass << "* _obj=static_cast<" << myclass << "*>(_sc->d_ptr);\n";
    e.out << "\n";

    // Declare out arguments...
    argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	argNum++;
	Argument* arg=*iter;
	if(arg->getMode() == Argument::Out) {
	    std::ostringstream argname;
	    argname << "_arg" << argNum;
	    arg->emit_declaration(e, argname.str());
	}
    }
    
    e.out << "    // Call the method\n";
    // Call the method...
    e.out << "    ";
    if(return_type){
	if(!return_type->isvoid()){
	    return_type->emit_rettype(e, "_ret");
	    e.out << " = ";
	}
    }
    e.out << "_obj->" << name << "(";
    argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	if(argNum > 0)
	    e.out << ", ";
	argNum++;
	e.out << "_arg" << argNum;
    }
    e.out << ");\n";

    // Clean up in arguments
    if(reply_required()){
	// Set up startpoints for any objects...
	e.out << "    // Size the reply...\n";
	e.out << "    unsigned long _rsize=globus_nexus_sizeof_int(1);\n";
	string oldleader=e.out.push_leader();
	if(return_type){
	    if(!return_type->isvoid()){
		return_type->emit_marshalsize(e, "_ret", "_rsize", "1");
	    }
	}
	argNum=0;
	for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	    argNum++;
	    Argument* arg=*iter;
	    if(arg->getMode() != Argument::In) {
		std::ostringstream argname;
		argname << "_arg" << argNum;
		arg->emit_marshalsize(e, argname.str(), "_rsize", "1");
	    }
	}
	e.out << "    globus_nexus_buffer_t _sendbuff;\n";
	e.out << "    if(int _gerr=globus_nexus_buffer_init(&_sendbuff, _rsize, 0))\n";
	e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_init\", _gerr);\n";
	e.out << "    int _flag=0;\n";
	e.out << "    globus_nexus_put_int(&_sendbuff, &_flag, 1);\n";
	if(return_type){
	    if(!return_type->isvoid()){
		e.out << "    // Marshal return value\n";
		return_type->emit_marshal(e, "_ret", "1", "&_sendbuff", true);
	    }
	}
	if(list.size() != 0)
	    e.out << "    // Marshal arguments\n";
	argNum=0;
	for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	    argNum++;
	    Argument* arg=*iter;
	    if(arg->getMode() != Argument::In) {
		std::ostringstream argname;
		argname << "_arg" << argNum;
		arg->emit_marshal(e, argname.str(), "1", "&_sendbuff", true);
	    }
	}
	e.out.pop_leader(oldleader);

	e.out << "    // Send the reply...\n";
	int reply_handler_id=0; // Always 0
	e.out << "    if(int _gerr=globus_nexus_send_rsr(&_sendbuff, &_sp, " << reply_handler_id << ", GLOBUS_TRUE, GLOBUS_FALSE))\n";
	e.out << "        throw ::Component::PIDL::GlobusError(\"send_rsr\", _gerr);\n";
	e.out << "    if(int _gerr=globus_nexus_startpoint_eventually_destroy(&_sp, GLOBUS_FALSE, 30))\n";
	e.out << "        throw ::Component::PIDL::GlobusError(\"startpoint_eventually_destroy\", _gerr);\n";
    }
    // Clean up inout and out arguments
    
    e.out << "}\n\n";
}

class output_sub {
    SState& out;
    std::string classname;
public:
    output_sub(SState& out, const std::string& classname)
	: out(out), classname(classname) {}
    void operator()(char x) {
	if(x=='@')
	    out << classname;
	else if(x=='\n')
	    out << '\n' << out.leader;
	else
	    out << x;
    }
};

void CI::emit_proxyclass(EmitState& e)
{
    e.proxy.begin_namespace(symbols->getParent());

    // Proxy
    std::string pname=name+"_proxy";
    std::string iname=name+"_interface";

    e.proxy << leader << "class " << pname << " : public ::Component::PIDL::ProxyBase, public " << iname << " {\n";
    e.proxy << leader << "public:\n";
    e.proxy << leader << "    " << pname << "(const ::Component::PIDL::Reference&);\n";
    std::string oldleader=e.proxy.push_leader();
    std::vector<Method*> vtab;
    gatherVtable(vtab, false);

    for(vector<Method*>::const_iterator iter=vtab.begin();
	iter != vtab.end();iter++){
	e.proxy << '\n';
	Method* m=*iter;
	m->emit_prototype(e.proxy, Method::Normal, symbols->getParent());
    }
    e.proxy.pop_leader(oldleader);
    e.proxy << leader << "protected:\n";
    e.proxy << leader << "    virtual ~" << pname << "();\n";
    e.proxy << leader << "private:\n";
    e.proxy << leader << "    virtual void _getReference(::Component::PIDL::Reference&, bool copy) const;\n";
    e.proxy << leader << "    friend const ::Component::PIDL::TypeInfo* " << name << "::_getTypeInfo();\n";
    e.proxy << leader << "    static ::Component::PIDL::Object_interface* create_proxy(const ::Component::PIDL::Reference&);\n";
    e.proxy << leader << "    " << pname << "(const " << pname << "&);\n";
    e.proxy << leader << "    " << pname << "& operator=(const " << pname << "&);\n";
    e.proxy << leader << "};\n\n";
    e.proxy.close_namespace();
}

void CI::emit_header(EmitState& e)
{
    e.decl.begin_namespace(symbols->getParent());

    std::vector<Method*>& mymethods=myMethods();

    // interface
    std::string iname=name+"_interface";
    e.decl << leader << "class " << iname << " : ";

    // Parents
    bool haveone=false;
    if(parentclass){
	e.decl << "public " << parentclass->cppfullname(e.decl.currentPackage) << "_interface";
	haveone=true;
    }
    for(vector<Interface*>::iterator iter=parent_ifaces.begin();
	iter != parent_ifaces.end(); iter++){
	if(!haveone){
	    haveone=true;
	} else {
	    e.decl << ", ";
	}
	e.decl << "virtual public " << (*iter)->cppfullname(e.decl.currentPackage) << "_interface";
    }
    if(!haveone)
	e.decl << "virtual public ::Component::PIDL::Object_interface";
    e.decl << " {\n";

    // The interace class body
    e.decl << leader << "public:\n";
    e.decl << leader << "    virtual ~" << iname << "();\n";
    std::string oldleader=e.decl.push_leader();
    for(vector<Method*>::const_iterator iter=mymethods.begin();
	iter != mymethods.end();iter++){
	e.decl << '\n';
	Method* m=*iter;
	m->emit_prototype(e.decl, Method::PureVirtual, symbols->getParent());
    }
    e.decl.pop_leader(oldleader);
    // The type signature method...
    e.decl << leader << "    virtual const ::Component::PIDL::TypeInfo* _getTypeInfo() const;\n";
    e.decl << leader << "protected:\n";
    e.decl << leader << "    " << iname << "(bool initServer=true);\n";
    e.decl << leader << "private:\n";
    e.decl << leader << "    " << iname << "(const " << iname << "&);\n";
    e.decl << leader << "    " << iname << "& operator=(const " << iname << "&);\n";
    e.decl << leader << "};\n\n";

    // The Handle
    e.decl << leader;
    for_each(handle_class.begin(), handle_class.end(), output_sub(e.decl, name));
    e.decl << "    // Conversion operations\n";
    // Emit an operator() for each parent class and interface...
    vector<CI*> parents;
    gatherParents(parents);
    for(std::vector<CI*>::iterator iter=parents.begin();
	iter != parents.end(); iter++){
	if(*iter != this){
	    e.decl << leader << "    inline operator " << (*iter)->cppfullname(e.decl.currentPackage) << "() const\n";
	    e.decl << leader << "    {\n";
	    e.decl << leader << "        return ptr;\n";
	    e.decl << leader << "    }\n";
	    e.decl << "\n";
	}
    }
    e.decl << leader << "};\n\n";
}

void CI::emit_interface(EmitState& e)
{
    std::string fn=cppfullname(0)+"_interface";
    std::string cn=cppclassname()+"_interface";
    e.out << fn << "::" << cn << "(bool initServer)\n";
    if(parent_ifaces.size() != 0 || parentclass)
	e.out << " : ";
    if(parentclass)
	e.out << parentclass->cppclassname() << "_interface(false)";
    if(parent_ifaces.size() > 0){
	vector<Interface*> parents;
	gatherParentInterfaces(parents);
	SymbolTable* localScope=symbols->getParent();
	for(vector<Interface*>::iterator iter=parents.begin();
	    iter != parents.end(); iter++){
	    if(*iter != this){
		if(parentclass || iter != parents.begin())
		    e.out << ",\n   ";
		e.out << (*iter)->cppfullname(localScope) << "_interface(false)";
	    }
	}
    }
    e.out << "\n{\n";
    e.out << "    if(initServer)\n";
    e.out << "        initializeServer(" << cppfullname(0) << "::_getTypeInfo(), this);\n";
    e.out << "}\n\n";

    e.out << fn << "::~" << cn << "()\n";
    e.out << "{\n";
    e.out << "}\n\n";

    e.out << "const ::Component::PIDL::TypeInfo* " << fn << "::_getTypeInfo() const\n";
    e.out << "{\n";
    e.out << "    return " << cppfullname(0) << "::_getTypeInfo();\n";
    e.out << "}\n\n";
}

void CI::emit_proxy(EmitState& e)
{
    std::string fn=cppfullname(0)+"_proxy";
    if(fn[0] == ':' && fn[1] == ':')
	fn=fn.substr(2);
    std::string cn=cppclassname()+"_proxy";
    e.out << fn << "::" << cn << "(const ::Component::PIDL::Reference& ref)\n";
    SymbolTable* localScope=symbols->getParent();
    e.out << " : " << cppfullname(localScope) << "_interface(false)";
    vector<Interface*> parents;
    gatherParentInterfaces(parents);
    for(vector<Interface*>::iterator iter=parents.begin();
	iter != parents.end(); iter++){
	e.out  << ",\n   "<< (*iter)->cppfullname(localScope) << "_interface(false)";
    }
    e.out << ",\n   ";
    e.out << "::Component::PIDL::ProxyBase(ref)";
    e.out << "\n";
    e.out << "{\n";
    e.out << "}\n\n";
    e.out << fn << "::~" << cn << "()\n";
    e.out << "{\n";
    e.out << "}\n\n";
    e.out << "void " << fn << "::_getReference(::Component::PIDL::Reference& ref, bool copy) const\n";
    e.out << "{\n";
    e.out << "    _proxyGetReference(ref, copy);\n";
    e.out << "}\n\n";
    e.out << "::Component::PIDL::Object_interface* " << fn << "::create_proxy(const ::Component::PIDL::Reference& ref)\n";
    e.out << "{\n";
    e.out << "    return new " << cn << "(ref);\n";
    e.out << "}\n\n";

    std::vector<Method*> vtab;
    gatherVtable(vtab, false);
    for(vector<Method*>::const_iterator iter=vtab.begin();
	iter != vtab.end();iter++){
	e.out << '\n';
	Method* m=*iter;
	m->emit_proxy(e, fn, localScope);
    }
}

void Method::emit_proxy(EmitState& e, const string& fn,
			SymbolTable* localScope) const
{
    emit_prototype_defin(e, fn+"::", localScope);
    e.out << "\n{\n";
    if(reply_required())
	e.out << "    ::Component::PIDL::ReplyEP* _reply=::Component::PIDL::ReplyEP::acquire();\n";
    e.out << "    globus_nexus_startpoint_t _sp;\n";
    e.out << "    _reply->get_startpoint_copy(&_sp);\n\n";
    std::vector<Argument*>& list=args->getList();
    e.out << "    // Size the buffer\n";
    e.out << "    int _size=";
    if(reply_required())
	e.out << "globus_nexus_sizeof_startpoint(&_sp, 1);\n";
    else
	e.out << "0;\n";
    string oldleader=e.out.push_leader();
    int argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	argNum++;
	Argument* arg=*iter;
	if(arg->getMode() != Argument::Out) {
	    std::ostringstream argname;
	    argname << "_arg" << argNum;
	    arg->emit_marshalsize(e, argname.str(), "_size", "1");
	}
    }
    e.out << "    globus_nexus_buffer_t _buffer;\n";
    e.out << "    if(int _gerr=globus_nexus_buffer_init(&_buffer, _size, 0))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_init\", _gerr);\n";
    if(list.size() != 0)
	e.out << "    // Marshal the arguments\n";
    argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	argNum++;
	Argument* arg=*iter;
	if(arg->getMode() != Argument::Out) {
	    std::ostringstream argname;
	    argname << "_arg" << argNum;
	    arg->emit_marshal(e, argname.str(), "1", "&_buffer", true);
	}
    }
    e.out.pop_leader(oldleader);

    if(reply_required()){
	e.out << "    // Marshal the reply startpoint\n";
	e.out << "    globus_nexus_put_startpoint_transfer(&_buffer, &_sp, 1);\n";
    }
    e.out << "    // Send the message\n";
    e.out << "    ::Component::PIDL::Reference _ref;\n";
    e.out << "    _proxyGetReference(_ref, false);\n";
    e.out << "    int _handler=_ref.getVtableBase()+" << handlerOff << ";\n";
    e.out << "    if(int _gerr=globus_nexus_send_rsr(&_buffer, &_ref.d_sp,\n";
    e.out << "                                       _handler, GLOBUS_TRUE, GLOBUS_FALSE))\n";
    e.out << "        throw ::Component::PIDL::GlobusError(\"send_rsr\", _gerr);\n";
    if(reply_required()){
	e.out << "    globus_nexus_buffer_t _recvbuff=_reply->wait();\n";
	//... emit unmarshal...;
	e.out << "    int _flag;\n";
	e.out << "    globus_nexus_get_int(&_recvbuff, &_flag, 1);\n";
	e.out << "    if(_flag != 0)\n";
	e.out << "        NOT_FINISHED(\"Exceptions not implemented\");\n";
	string oldleader=e.out.push_leader();
	if(return_type){
	    if(!return_type->isvoid()){
		e.out << "    // Unmarshal the return value\n";
		return_type->emit_unmarshal(e, "_ret", "1", "&_recvbuff", true);
	    }
	}
	if(list.size() != 0)
	    e.out << "    // Unmarshal the return arguments\n";
	argNum=0;
	for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
	    argNum++;
	    Argument* arg=*iter;
	    if(arg->getMode() != Argument::In) {
		std::ostringstream argname;
		argname << "_arg" << argNum;
		arg->emit_unmarshal(e, argname.str(), "1", "&_recvbuff", false);
	    }
	}
	e.out.pop_leader(oldleader);
	e.out << "    ::Component::PIDL::ReplyEP::release(_reply);\n";
	e.out << "    if(int _gerr=globus_nexus_buffer_destroy(&_recvbuff))\n";
	e.out << "        throw ::Component::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
	if(return_type){
	    if(!return_type->isvoid()){
		e.out << "    return _ret;\n";
	    }
	}
    }
    e.out << "}\n";
}

void Argument::emit_unmarshal(EmitState& e, const string& arg,
			      const string& qty,
			      const string& bufname,
			      bool declare) const
{
    e.out << "    // " << arg << ": " << fullsignature() << "\n";
    type->emit_unmarshal(e, arg, qty, bufname, declare);
}

void Argument::emit_marshalsize(EmitState& e, const string& arg,
				const string& sizevar,
				const string& qty) const
{
    type->emit_marshalsize(e, arg, sizevar, qty);
}

void Argument::emit_declaration(EmitState& e, const string& arg) const
{
    type->emit_declaration(e, arg);
}

void Argument::emit_marshal(EmitState& e, const string& arg,
			    const string& qty,
			    const string& bufname, bool top) const
{
    type->emit_marshal(e, arg, qty, bufname, top);
}

void Argument::emit_prototype(SState& out, SymbolTable* localScope) const
{
    Type::ArgContext ctx;
    switch(mode){
    case In:
	ctx=Type::ArgIn;
	break;
    case Out:
	ctx=Type::ArgOut;
	break;
    case InOut:
	ctx=Type::ArgInOut;
	break;
    }
    type->emit_prototype(out, ctx, localScope);
    if(id != "" && id != "this")
	out << " " << id;
}

void Argument::emit_prototype_defin(SState& out, const std::string& arg,
				    SymbolTable* localScope) const
{
    Type::ArgContext ctx;
    switch(mode){
    case In:
	ctx=Type::ArgIn;
	break;
    case Out:
	ctx=Type::ArgOut;
	break;
    case InOut:
	ctx=Type::ArgInOut;
	break;
    }
    type->emit_prototype(out, ctx, localScope);
    out << " " << arg;
}

void ArrayType::emit_unmarshal(EmitState& e, const string& arg,
			       const string& qty,
			       const string& bufname,
			       bool declare) const
{
    if(qty != "1"){
	cerr << "ArrayType::emit_unmarshall, qty != 1: " << qty << '\n';
	exit(1);
    }
    e.out << leader << "int " << arg << "_dim[" << dim << "];\n";
    e.out << leader << "globus_nexus_get_int(" << bufname << ", &" << arg << "_dim[0], " << dim << ");\n";
    if(declare){
	e.out << leader << cppfullname(0) << " " << arg << "(";
    } else {
	e.out << leader << arg << ".resize(";
    }
    for(int i=0;i<dim;i++){
	if(i != 0)
	    e.out << ", ";
	e.out << arg << "_dim[" << i << "]";
    }
    e.out << ");\n";
    if(subtype->array_use_pointer()){
	string pname=arg+"_uptr";
	string sizename=arg+"_totalsize";
	e.out << leader << "int " << sizename << "=";
	for(int i=0;i<dim;i++){
	    if(i != 0)
		e.out << "*";
	    e.out << arg << "_dim[" << i << "]";
	}
	e.out << ";\n";
	e.out << leader << cppfullname(0) << "::pointer " << pname << "=const_cast<" << cppfullname(0) << "::pointer>(" << arg << ".begin());\n";
	subtype->emit_unmarshal(e, pname, sizename, bufname, false);
    } else {
	string pname=arg+"_iter";
	e.out << leader << "for(" << cppfullname(0) << "::iterator " << pname << "=" << arg << ".begin();";
	e.out << pname << " != " << arg << ".end(); " << pname << "++){\n";
	string oldleader=e.out.push_leader();
	e.out << leader << cppfullname(0) << "::reference " << arg << "_el = *" << pname << ";\n";
	subtype->emit_unmarshal(e, arg+"_el", "1", bufname, false);
	e.out.pop_leader(oldleader);
	e.out << leader << "}\n";
    }
}

void ArrayType::emit_marshalsize(EmitState& e, const string& arg,
				 const string& sizevar,
				 const string& /* qty */) const
{
    e.out << leader << sizevar << " += globus_nexus_sizeof_int(" << dim << "); // array dims\n";
    if(subtype->uniformsize()){
	string sizename=arg+"_mtotalsize";
	if(dim == 1){
	    e.out << leader << "int " << sizename << "=" << arg << ".size();\n";
	} else {
	    string dimname=arg+"_mdim";
	    e.out << leader << "int " << dimname << "[" << dim << "];\n";
	    for(int i=0;i<dim;i++)
		e.out << leader << dimname << "[" << i << "]=" << arg << ".size" << i+1 << "();\n";
	    e.out << leader << "int " << sizename << "=" << dimname << "[0]";
	    for(int i=1;i<dim;i++)
		e.out << "*" << dimname << "[" << i << "]";
	    e.out << ";\n";
	}
	subtype->emit_marshalsize(e, "", sizevar, arg+"_mtotalsize");
    } else {
	string pname=arg+"_iter";
	e.out << leader << "for(" << cppfullname(0) << "::const_iterator " << pname << "=" << arg << ".begin();";
	e.out << pname << " != " << arg << ".end(); " << pname << "++){\n";
	string oldleader=e.out.push_leader();
	e.out << leader << cppfullname(0) << "::const_reference " << arg << "_el = *" << pname << ";\n";
	subtype->emit_marshalsize(e, arg+"_el", sizevar, "1");
	e.out.pop_leader(oldleader);
	e.out << leader << "}\n";
    }
}

void ArrayType::emit_declaration(EmitState& e, const string& arg) const
{
    e.out << leader << cppfullname(0) << " " << arg << ";\n";
}

bool ArrayType::array_use_pointer() const
{
    return false; // Always use iterator for array of array
}

bool ArrayType::uniformsize() const
{
    return false;
}

void ArrayType::emit_marshal(EmitState& e, const string& arg,
			     const string& qty,
			     const std::string& bufname, bool top) const
{
    string pname;
    if(subtype->array_use_pointer()){
	pname=arg+"_mptr";
	e.out << leader << cppfullname(0) << "::pointer " << pname << "=const_cast<" << cppfullname(0) << "::pointer>(" << arg << ".begin());\n";
    } else {
	pname=arg+"_iter";
    }
    string sizename=arg+"_mtotalsize";
    string dimname=arg+"_mdim";
    if(!top || !subtype->uniformsize()){
	if(dim == 1){
	    e.out << leader << "int " << sizename << "=" << arg << ".size();\n";
	} else {
	    e.out << leader << "int " << dimname << "[" << dim << "];\n";
	    for(int i=0;i<dim;i++)
		e.out << leader << dimname << "[" << i << "]=" << arg << ".size" << i+1 << "();\n";
	    e.out << leader << "int " << sizename << "=" << dimname << "[0]";
	    for(int i=1;i<dim;i++)
		e.out << "*" << dimname << "[" << i << "]";
	    e.out << ";\n";
	}
    }
    if(dim == 1){
	e.out << leader << "globus_nexus_put_int(" << bufname << ", &" << sizename << ", 1);\n";
    } else {
	e.out << leader << "globus_nexus_put_int(" << bufname << ", &" << dimname << "[0], " << dim << ");\n";
    }

    if(subtype->array_use_pointer()){
	subtype->emit_marshal(e, pname, sizename, bufname, false);
    } else {
	e.out << leader << "for(" << cppfullname(0) << "::const_iterator " << pname << "=" << arg << ".begin();";
	e.out << pname << " != " << arg << ".end(); " << pname << "++){\n";
	e.out << leader << cppfullname(0) << "::const_reference " << arg << "_el = *" << pname << ";\n";
	string oldleader=e.out.push_leader();
	subtype->emit_marshal(e, arg+"_el", "1", bufname, false);
	e.out.pop_leader(oldleader);
	e.out << leader << "}\n";
    }
}

void ArrayType::emit_rettype(EmitState& e, const string& arg) const
{
    e.out << cppfullname(0) << " _ret";
}

void ArrayType::emit_prototype(SState& out, ArgContext ctx,
			       SymbolTable* localScope) const
{
    if(ctx == ArgIn){
	out << "const ";
    }
    out << cppfullname(0);
    if(ctx == ArgOut || ctx == ArgInOut || ctx == ArgIn)
	out << "&";
}

void BuiltinType::emit_unmarshal(EmitState& e, const string& arg,
				 const string& qty,
				 const string& bufname,
				 bool declare) const
{
    if(cname == "void"){
	// What?
	cerr << "Trying to unmarshal a void!\n";
	exit(1);
    } else if(cname == "bool"){
	if(qty != "1"){
	    cerr << "emit_unmarshal called for bool with qty != 1:" << qty << "\n";
	    exit(1);
	}
	e.out << leader << "globus_byte_t " << arg << "_tmp;\n";
	e.out << leader << "globus_nexus_get_byte(" << bufname << ", &" << arg << "_tmp, 1);\n";
	if(declare)
	    e.out << leader << "bool ";
	e.out << arg << "=(bool)" << arg << "_tmp;\n";
    } else if(cname == "string"){
	if(qty != "1"){
	    cerr << "emit_unmarshal call for bool with qty != 1:" << qty << "\n";
	    exit(1);
	}
	e.out << leader << "int " << arg << "_length;\n";
	e.out << leader << "globus_nexus_get_int(" << bufname << ", &" << arg << "_length, 1);\n";
	if(declare)
	    e.out << leader << "::CIA::string " << arg << "(" << arg << "_length, ' ');\n";
	else
	    e.out << leader << arg << ".resize(" << arg << "_length);\n";
	e.out << leader << "globus_nexus_get_char(" << bufname << ", " << arg << ".begin(), " << arg << "_length);\n";
    } else {
	if(declare)
	    e.out << leader << cname << " " << arg << ";\n";
	e.out << leader << "globus_nexus_get_" << nexusname << "(" << bufname << ", ";
	if(qty == "1")
	    e.out << "&";
	e.out << arg << ", " << qty << ");\n";
    }
}

void BuiltinType::emit_marshalsize(EmitState& e, const string& arg,
				   const string& sizevar,
				   const string& qty) const
{
    if(cname == "void"){
	// What?
	cerr << "Trying to size a void!\n";
	exit(1);
    } else if(cname == "string"){
	if(qty != "1"){
	    cerr << "emit_marshalsize call for string with qty != 1:" << qty << "\n";
	    exit(1);
	}
	e.out << leader << sizevar << "+=globus_nexus_sizeof_int(1)+globus_nexus_sizeof_char(" << arg << ".length());\n";
    } else {
	e.out << leader << sizevar << "+=globus_nexus_sizeof_" << nexusname << "(" << qty << ");\n";
    }
}

void BuiltinType::emit_declaration(EmitState& e, const string& arg) const
{
    if(cname == "void"){
	// What?
	cerr << "Trying to declare a void!\n";
	exit(1);
    } else if(cname == "string"){
	e.out << leader << "::CIA::string " << arg << ";\n";
    } else {
	e.out << leader << cname << " " << arg << ";\n";
    }
}
	

void BuiltinType::emit_marshal(EmitState& e, const string& arg,
			       const string& qty, 
			       const string& bufname, bool/* top*/) const
{
    if(cname == "void"){
	// What?
	cerr << "Trying to unmarshal a void!\n";
	exit(1);
    } else if(cname == "bool"){
	if(qty != "1"){
	    cerr << "marshal bool called with qty != 1: " << qty << '\n';
	    exit(1);
	}
	e.out << leader << "globus_byte_t " << arg << "_tmp = " << arg << ";\n";
	e.out << leader << "globus_nexus_put_byte (" << bufname << ", &" << arg << "_tmp, 1);\n";
    } else if(cname == "string"){
	if(qty != "1"){
	    cerr << "marshal string called with qty != 1: " << qty << '\n';
	    exit(1);
	}
	e.out << leader << "int " << arg << "_len=" << arg << ".length();\n";
	e.out << leader << "globus_nexus_put_int(" << bufname << ", &" << arg << "_len, 1);\n";
	e.out << leader << "globus_nexus_put_char(" << bufname << ", const_cast<char*>(" << arg << ".begin()), " << arg << "_len);\n";
    } else {
	e.out << leader << "globus_nexus_put_" << nexusname << "(" << bufname << ", ";
	if(qty == "1")
	    e.out << "&";
	e.out << arg << ", " << qty << ");\n";
    }
}

void BuiltinType::emit_rettype(EmitState& e, const string& arg) const
{
    if(cname == "void"){
	// Nothing
	return;
    } else if(cname == "string"){
	e.out << "::CIA::string " << arg;
    } else {
	e.out << cname << " " << arg;
    }
}

void BuiltinType::emit_prototype(SState& out, ArgContext ctx,
				 SymbolTable*) const
{
    if(cname == "void"){
	// Nothing
	if(ctx == ReturnType)
	    out << "void";
	else {
	    cerr << "Illegal void type in argument list\n";
	    exit(1);
	}
    } else if(cname == "string"){
	switch(ctx){
	case ReturnType:
	case ArrayTemplate:
	    out << "::CIA::string";
	    break;
	case ArgIn:
	    out << "const ::CIA::string&";
	    break;
	case ArgOut:
	case ArgInOut:
	    out << "::CIA::string&";
	    break;
	}
    } else {
	switch(ctx){
	case ReturnType:
	case ArgIn:
	case ArrayTemplate:
	    out << cname;
	    break;
	case ArgOut:
	case ArgInOut:
	    out << cname << "&";
	    break;
	}
    }
}

bool BuiltinType::array_use_pointer() const
{
    if(cname == "string" || cname == "bool")
	return false;
    else
	return true;
}

bool BuiltinType::uniformsize() const
{
    if(cname == "string")
	return false;
    else
	return true;
}

void NamedType::emit_unmarshal(EmitState& e, const string& arg,
			       const string& qty,
			       const string& bufname,
			       bool declare) const
{
    if(qty != "1"){
	cerr << "NamedType::emit_unmarshal called with qty != 1: " << qty << '\n';
	exit(1);
    }    
    e.out << leader << "int " << arg << "_vtable_base;\n";
    e.out << leader << "globus_nexus_get_int(" << bufname << ", &" << arg << "_vtable_base, 1);\n";
    if(declare)
	e.out << leader << name->cppfullname(0) << " " << arg << ";\n";
    e.out << leader << "if(" << arg << "_vtable_base == -1){\n";
    e.out << leader << "    " << arg << "=0;\n";
    e.out << leader << "} else {\n";
    e.out << leader << "    ::Component::PIDL::Reference _ref;\n";
    e.out << leader << "    globus_nexus_get_startpoint(" << bufname << ", &_ref.d_sp, 1);\n";
    e.out << leader << "    _ref.d_vtable_base=" << arg << "_vtable_base;\n";
    e.out << leader << "    if(globus_nexus_startpoint_to_current_context(&_ref.d_sp)){\n";
    e.out << leader << "        globus_nexus_endpoint_t* _ep;\n";
    e.out << leader << "        if(int _gerr=globus_nexus_startpoint_get_endpoint(&_ref.d_sp, &_ep))\n";
    e.out << leader << "            throw ::Component::PIDL::GlobusError(\"get_endpoint\", _gerr);\n";
    e.out << leader << "        void* _ptr=globus_nexus_endpoint_get_user_pointer(_ep);\n";
    e.out << leader << "        ::Component::PIDL::ServerContext* _sc=static_cast<::Component::PIDL::ServerContext*>(_ptr);\n";
    e.out << leader << "        " << arg << "=dynamic_cast<" << name->cppfullname(0) << "_interface*>(_sc->d_objptr);\n";
    e.out << leader << "        if(int _gerr=globus_nexus_startpoint_destroy(&_ref.d_sp))\n";
    e.out << leader << "            throw ::Component::PIDL::GlobusError(\"startpoint_destroy\", _gerr);\n";
    e.out << leader << "    } else {\n";
    e.out << leader << "        " << arg << "=new " << name->cppfullname(0) << "_proxy(_ref);\n";
    e.out << leader << "    }\n";
    e.out << leader << "}\n";
}

void NamedType::emit_marshalsize(EmitState& e, const string& arg,
				 const string& sizevar,
				 const string& qty) const
{
    if(qty != "1"){
	cerr << "NamedType::emit_marshalsize called with qty != 1: " << qty << '\n';
	exit(1);
    }
    e.out << leader << "::Component::PIDL::Reference " << arg << "_ref;\n";
    e.out << leader << "if(" << arg << "){\n";
    e.out << leader << "    " << arg << "->_addReference();\n";
    e.out << leader << "    " << arg << "->_getReference(" << arg << "_ref, true);\n";
    e.out << leader << "}\n";
    e.out << leader << sizevar << "+=globus_nexus_sizeof_int(1)+(";
    e.out << arg << "?globus_nexus_sizeof_startpoint(&" << arg << "_ref.d_sp, 1):0);\n";
}

void NamedType::emit_declaration(EmitState& e, const string& arg) const
{
    e.out << leader << name->cppfullname(0) << " " << arg << ";\n";
}

void NamedType::emit_marshal(EmitState& e, const string& arg,
			     const string& qty,
			     const string& bufname, bool /*top*/) const
{
    if(qty != "1"){
	cerr << "NamedType::emit_marshal called with qty != 1: " << qty << '\n';
	exit(1);
    }
    e.out << leader << "if(" << arg << "){\n";
    e.out << leader << "    const ::Component::PIDL::TypeInfo* _dt=" << arg << "->_getTypeInfo();\n";
    e.out << leader << "    const ::Component::PIDL::TypeInfo* _bt=" << name->cppfullname(0) << "::_getTypeInfo();\n";
    e.out << leader << "    int _vtable_offset=_dt->computeVtableOffset(_bt);\n";
    e.out << leader << "    ::Component::PIDL::Reference " << arg << "_ref;\n";
    e.out << leader << "    " << arg << "->_getReference(" << arg << "_ref, true);\n";
    e.out << leader << "    int _vtable_base=" << arg << "_ref.getVtableBase()+_vtable_offset;\n";
    e.out << leader << "    globus_nexus_put_int(" << bufname << ", &_vtable_base, 1);\n";
    e.out << leader << "    globus_nexus_put_startpoint_transfer(" << bufname << ", &" << arg << "_ref.d_sp, 1);\n";
    e.out << leader << "} else {\n";
    e.out << leader << "    int _vtable_base=-1; // Null ptr\n";
    e.out << leader << "    globus_nexus_put_int(" << bufname << ", &_vtable_base, 1);\n";
    e.out << leader << "}\n";
}

void NamedType::emit_rettype(EmitState& e, const string& arg) const
{
    e.out << name->cppfullname(0) << " " << arg;
}

void NamedType::emit_prototype(SState& out, ArgContext ctx,
			       SymbolTable* localScope) const
{
    // Ensure that it is forward declared...
    name->getSymbol()->emit_forward(*out.e);
    switch(ctx){
    case ReturnType:
    case ArrayTemplate:
	out << name->cppfullname(localScope);
	break;
    case ArgIn:
	out << "const " << name->cppfullname(localScope) << "&";
	break;
    case ArgOut:
    case ArgInOut:
	out << name->cppfullname(localScope) << "&";
	break;
    }
}

bool NamedType::array_use_pointer() const
{
    return false; // Always use iterator for array of references
}

bool NamedType::uniformsize() const
{
    return false; // Startpoints can vary in size
}

//
// $Log$
// Revision 1.8  2000/03/17 09:31:19  sparker
// New makefile scheme: sub.mk instead of Makefile.in
// Use XML-based files for module repository
// Plus many other changes to make these two things work
//
// Revision 1.7  1999/10/07 02:08:40  sparker
// use standard iostreams and complex type
//
// Revision 1.6  1999/09/29 07:35:18  sparker
// Finished marshal/unmarshaling of all different kinds of arrays (1D).
// Cleaned up marshal/unmarshal code
//
// Revision 1.5  1999/09/28 08:21:43  sparker
// Added support for arrays (incomplete)
// Added support for strings
// Added support for out and inout variables
//
// Revision 1.4  1999/09/26 06:13:01  sparker
// Added (distributed) reference counting to PIDL objects.
// Began campaign against memory leaks.  There seem to be no more
//   per-message memory leaks.
// Added a test program to flush out memory leaks
// Fixed other Component testprograms so that they work with ref counting
// Added a getPointer method to PIDL handles
//
// Revision 1.3  1999/09/24 06:26:30  sparker
// Further implementation of new Component model and IDL parser, including:
//  - fixed bugs in multiple inheritance
//  - added test for multiple inheritance
//  - fixed bugs in object reference send/receive
//  - added test for sending objects
//  - beginnings of support for separate compilation of sidl files
//  - beginnings of CIA spec implementation
//  - beginnings of cocoon docs in PIDL
//  - cleaned up initalization sequence of server objects
//  - use globus_nexus_startpoint_eventually_destroy (contained in
// 	the globus-1.1-utah.patch)
//
// Revision 1.2  1999/09/21 06:13:01  sparker
// Fixed bugs in multiple inheritance
// Added round-trip optimization
// To support this, we store Startpoint* in the endpoint instead of the
//    object final type.
//
// Revision 1.1  1999/09/17 05:07:26  sparker
// Added nexus code generation capability
//
//
