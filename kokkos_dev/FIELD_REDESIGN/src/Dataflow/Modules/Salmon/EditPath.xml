<?xml version='1.0' encoding='us-ascii' ?>
<!DOCTYPE spec SYSTEM "spec.dtd">
<spec>
  <info>
    <name>EditPath</name>
    <creation>make_EditPath</creation>
    <description>
      <summary>EditPath module allows to edit and playback camera path in Salmon module</summary>

      <info-builder>
	<para> EditPath module provides a set of interactive tools for creation and manipulation of
	camera path in Salmon module. The basic features of the modules are as follows:</para> 
	<para> </para>
	<para>  - Interactive adding/inserting/deleting of key frames of current camera position in edited path</para>
	<para>  - Navigation through existing key frames</para>
	<para>  - Three interpolation modes - Linear, Cubic and no interpolation (key frames only playback)</para>
	<para>  - Two acceleration modes - smooth start/end(in interpolated mode) and no acceleration</para>
	<para>  - Path step(smoothness) and sampling rate specification for current path</para>
	<para>  - Automatic generation of circle path based on current camera position and position of reference widget</para>
	<para>  - Looped and reversed path modes</para>
	<para>  - Switching output directions</para>
	<para> </para>

	<para> EditPath module could be used in any module network where automatic predefined/interpolated
	camera movement is required. Some modules, for example, view dependent isosurface extraction module (???), require
	EditPath module for supplying path views as input.</para>
	
	<para> There are some useful hints in working with the EditPath module. If one is going to use interpolation between keyframes,
	the quidelines are simple - the more points you specify, the better result will be. While using generated circle path, keyframed
	playback or linear interpolation is often enough (about 40 keyframes are generated in the path then). The module is using initially
	the distance-based parametrization of the path. That is why no key frame is added to the path if the camera has the same position 
	at the neighbooring key frames.</para>
	<img> </img>
      </info-builder>

      <info-developer>
	
	<para> Design of EditPath module and related classes (Path datatype, PieseWise interpolation classes,
	Quaternion representation) was supposed to satisfy the following guidelines:</para>
	<para> - Little overhead of related calculations while running interpolated path</para>
	<para> - Well-defined interaction between GUI and code parts of the module</para>
	<para> - Minimization of using TCL variables (TCLvar) in defining current module/path state</para>
	<para> - Providing easy-to-tune framework for testing other models of camera path interpolation</para>
	<para>  </para>
	<para> Path datatype (SCICore::Datatypes::Path):
	Path datatype implements basic functionality of the EditPath module. It takes care of key frames (Array1<View> keyViews),
	path type (KEYFRAMED, LINEAR, CUBIC), direction and looping of the path, the smoothness of the path (double step_size),
	acceleration and speed. The path is supposed to be sampled with some external rate (given by EditPath module), so the speed
	regulation is made by calculating path step at every point.
	Available modes: 
	KEYFRAMED - no interpolation and acceleration patterns, key frames are iterateted one after another
	LINEAR - Simple linear piecewise interpolation of the eye and lookat points using Linear3DPWI interpolation class (SCICore::Math)
	CUBIC  - CatmullRom splines interpolation of eye and lookat points using Cubic3DPWI class (SCICore::Math)
	
	NO_ACC - No acceleration (path step is constant)
	SMOOTH - path step (speed) is increased/decreased in fixed number of steps (30) by sinus. While in loop, the mode is working only
	for initial acceleration to constant speed.

	Changing of path parameters(looping, direction, interpolation, acceleration, path step) could be done on-fly. For more info, 
	see source file comments

	Quaternion interpolation:
	By now using quaternion interpolation of the camera frame was not implemented in reliable way. The reason is that this interpolation
	is using parametrization by angle, that imposes additional problems for reparametrizing from initial parametrization by square root
	of inter-frames distances. To make reliable reparametrization in most cases one needs to specify the center of angular motion from one 
	frame to another, i.e. the arc between corresponding camera postions. However, the framework for further improvements using quaternion
	Slerp (spherical linear) and Squad (cubic) interpolations exists (SCICore::Geometry::Quaternion).

	EditPath Module:
	The module is using message driven execution. tcl_command() function specifies messages for execution one at a time, using counting
	semaphore. The module is using self-messaging mode while in path playback.	
	</para>	
	<para>  </para>
	<img> </img>
      </info-developer>
    </description>

    <author>
      <name>Alexei Samsonov, July 2000</name>
    </author>
    <version> Version/Revision 1.1</version>
    <IO>
      <ports>
	<in>
	  <port>PathIPort</port>
	  <datatype>SCICore::Datatypes::Path</datatype>
	  <usage>
	    <para> Used for getting Path datatype object handle from PathReader module or another EditPath module</para>
	  </usage>
	</in>
	<out>
	  <port>PortOPort</port>
	  <datatype>SCICore::Datatypes::Path</datatype>
	  <usage>
	    <para> Used for sending Path datatype object handle to PathWriter module or another EditPath module</para>
	  </usage>
	  
	  <port>GeometryOPort</port>
	  <datatype>SCICore::GeomSpace::GeomObj</datatype>
	  <usage>
	    <para> Used for sending Crosswidget object handle and SCICore::GeomSpace::View objects to other modules 
	    (Salmon or view-dependent isosurface extracting module)</para>
	  </usage>

	  <port>CameraViewOPort</port>
	  <datatype>SCICore::Datatypes::CameraView</datatype>
	  <usage>
	    <para> Used for sending handle to CameraView datatype object containing current path view </para>
	  </usage>

	</out>
      </ports>

      <modules>
	<typin>
	  <name> PathReader </name>
	</typin>
	<typout>
	  <name> PathWriter, Salmon, IsoSurfaceSAGE (???) </name>
	</typout>
      </modules>
      <example></example>
    </IO>
    <also>
      <ref>
      </ref>
      <link></link>
    </also>

    <caution>
      <knownbugs>
	<bugNum>
	</bugNum>
      </knownbugs>
      <platformIssues>
	<issue>
	</issue>
      </platformIssues>
    </caution>

    <enhancements>
      <para> The possible enhancements to the module may be creating different interpolation models or predefined paths.
      The existing interpolation scheme of generating smooth "path" through limited number of path points is cubic splines
      curve. Splines often exhibit "jumping" behaviour. Some other approaches or tuning existing scheme may be useful.
      </para>
    </enhancements>
  </info>

  <gui>
    <parameter>
      <label></label>
      <guidance>
	<para></para>
      </guidance>
      <gui-developer>
	<widgets></widgets>
	<use></use>
      </gui-developer>
    </parameter>
    <img>./doc/EditPathGui.gif</img>
  </gui>

  <testing>
    <plan>
      <procedure>
	<para></para>
      </procedure>
      <steps>
	<step></step>
	<step></step>
      </steps>
    </plan>
  </testing>
</spec>




