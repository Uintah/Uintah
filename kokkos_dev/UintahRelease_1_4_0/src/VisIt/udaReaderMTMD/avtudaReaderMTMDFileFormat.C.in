/*****************************************************************************
 *
 * Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
 * Produced at the Lawrence Livermore National Laboratory
 * LLNL-CODE-400142
 * All rights reserved.
 *
 * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
 * full copyright notice is contained in the file COPYRIGHT located at the root
 * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
 *
 * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of  source code must  retain the above  copyright notice,
 *    this list of conditions and the disclaimer below.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
 *    documentation and/or other materials provided with the distribution.
 *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
 * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
 * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
 * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
 * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
 * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
 * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 *****************************************************************************/

// ************************************************************************* //
//                            avtudaReaderMTMDFileFormat.C                   //
// ************************************************************************* //

#include <VisIt/udaReaderMTMD/avtudaReaderMTMDFileFormat.h>

#include <stdio.h>
#include <cstring>
#include <cmath>
#include <dlfcn.h>
#include <string>

#ifdef PARALLEL
#  include <mpi.h>
#endif

#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkCellData.h>
#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkIntArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtParallel.h>
#include <avtDatabase.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtStructuredDomainNesting.h>
#include <avtVariableCache.h>
#include <avtMaterial.h>

#include <DebugStream.h>
#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>
#include <DBOptionsAttributes.h>


using std::max;
using std::min;

//#ifdef PARALLEL
// we only get the option for  serialized reads if compiling the parallel version
//#  define SERIALIZED_READS
//#endif



// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat constructor
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************
avtudaReaderMTMDFileFormat::avtudaReaderMTMDFileFormat(const char *filename, DBOptionsAttributes* attrs) :
  avtMTMDFileFormat(filename),
  archive(NULL),
  grid(NULL),
  useExtraCells(true)
{
  debug5 << "\nIn avtudaReaderFileFormat\n";

  for (int i=0; attrs!=0 && i<attrs->GetNumberOfOptions(); ++i) {
    if (attrs->GetName(i) == "Load extra cells") {
      useExtraCells = attrs->GetBool("Load extra cells");
    }
  }
    

  // Verify that it is a UDA index.xml file:
  // The 2nd line should look like this <Uintah_DataArchive>.

  FILE * fp = fopen( filename, "r" );
  if( fp == NULL ) {
    string error = string( "Failed to open file: " ) + filename;
    EXCEPTION1( InvalidDBTypeException, error.c_str() );
  }

  char line[1024];
  char * result = fgets( line, 1024, fp );
  if( result ) { 
    result = fgets( line, 1024, fp );
  }

  string lineStr = line;
  if( !result || lineStr.find( "<Uintah_DataArchive>" ) == string::npos ) {
    string error = string( filename ) + " does not appear to be a <Uintah_DataArchive>.";
    printf("here: %s\n", error.c_str());
    EXCEPTION1( InvalidDBTypeException, error.c_str() );
  }
  fclose( fp );



  const char * lib = "@UINTAH_UDA_TO_VIS_LIB@";

  // This environment variable prevents Core/Thread/Thread_pthreads.cc
  // from adding it's atexit handler, which will kill visit's process
  // when dlclose is called.
  char *tmp = new char[50];
  strcpy(tmp, "THREAD_NO_ATEXIT=1");
  putenv(tmp);
  
  libHandle = dlopen(lib, RTLD_NOW); // The dylib locn should be changed
  if (!libHandle) {
    char* errString = dlerror();
    cerr << "Error: " << string( errString ) << "\n"; 
    cerr << "The library libuda2vis could not be located!!!\n"; 
    cerr << "Tried to load: " << lib << "\n";
    EXCEPTION1(InvalidDBTypeException, errString);
  }

  // All possible function calls - check here
  char *error;

  openDataArchive = (DataArchive* (*)(const std::string&)) dlsym(libHandle, "openDataArchive");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function openDataArchive could not be located in the library!!!");
  }

  closeDataArchive = (void (*)(DataArchive*)) dlsym(libHandle, "closeDataArchive");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function closeDataArchive could not be located in the library!!!");
  }

  getGrid = (GridP* (*)(DataArchive*, int)) dlsym(libHandle, "getGrid");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getGrid could not be located in the library!!!");
  }

  releaseGrid = (void (*)(GridP*)) dlsym(libHandle, "releaseGrid");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function releaseGrid could not be located in the library!!!");
  }


  getCycleTimes = (std::vector<double> (*)(DataArchive*)) dlsym(libHandle, "getCycleTimes");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getCycleTimes could not be located in the library!!!");
  }

  getTimeStepInfo = (TimeStepInfo* (*)(DataArchive*, GridP*, int, bool)) dlsym(libHandle, "getTimeStepInfo");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getTimeStepInfo could not be located in the library!!!");
  }

  getGridData = (GridDataRaw* (*)(DataArchive*, GridP*, int, int, std::string, int, int, int[3], int[3])) dlsym(libHandle, "getGridData");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getGridData could not be located in the library!!!");
  }

  getParticleData = (ParticleDataRaw* (*)(DataArchive*, GridP*, int, int, std::string, int, int)) dlsym(libHandle, "getParticleData");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getParticleData could not be located in the library!!!");
  }


  // use the folder name, not the index.xml file name to open the archive
  string folder(filename);
  size_t found = folder.find_last_of("/");
  folder = folder.substr(0, found);
  archive = (*openDataArchive)(folder);

  // timestep times
  cycleTimes = (*getCycleTimes)(archive);

  // haven't loaded any timestep data yet
  stepInfo = NULL;  
  currTimeStep = -1;

  debug5 << "Out avtudaReaderFileFormat\n";
}


// Destructor
avtudaReaderMTMDFileFormat::~avtudaReaderMTMDFileFormat()
{
  if (grid)
    (*releaseGrid)(grid);

  if (archive)
    (*closeDataArchive)(archive);

  if (stepInfo)
    delete stepInfo;

  dlclose(libHandle);
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

int
avtudaReaderMTMDFileFormat::GetNTimesteps(void)
{
  return cycleTimes.size();
}


// ****************************************************************************
// Method: avtudaReaderMTMDFileForma::GetTime
//
// Purpose: 
//   Get the time.
//
// Programmer: sshankar 
// Creation:   Fri Feb 6 15:31 MST 2009 
//
// ****************************************************************************

double 
avtudaReaderMTMDFileFormat::GetTime(int ts)
{
  return cycleTimes[ts];
}


// ****************************************************************************
// Method: avtudaReaderMTMDFileForma::ActivateTimestep
//
// Purpose: 
//   Get ready to read data for the given timestep
//
// ****************************************************************************

void
avtudaReaderMTMDFileFormat::ActivateTimestep(int ts)
{
  if (currTimeStep == ts)
    return;

  // get the uda grid for the new timestep
  if (grid)
    (*releaseGrid)(grid);
  grid = (*getGrid)(archive, ts);

  if (stepInfo)
    delete stepInfo;
  stepInfo = (*getTimeStepInfo)(archive, grid, ts, useExtraCells);

  currTimeStep = ts; 
}



// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::AddExpressionsToMetadata
// ****************************************************************************
void avtudaReaderMTMDFileFormat::AddExpressionsToMetadata(avtDatabaseMetaData *md) {
  string home(getenv("HOME"));
  string fname = home +"/.visit/udaExpressions.txt";
  FILE *f = fopen(fname.c_str(), "r");
  if (!f) {
    debug5<<"couldn't open uda expressions file"<<endl;
    return;
  }


  int line = 0;
  char cline[2048];
  while (fgets(cline, 2048, f)) {
    line++;

    string line(cline);
    if (line[0] == '#' ||
        line.length() == 0 ||
        line == "\n" || line=="\r\n")
      continue;

    // first token is the expression name
    int space = line.find(" ");
    if (space < 0) {
      debug5<<"uda expression syntax error on line "<<line<<endl;
      continue;
    }
    string name = line.substr(0, space);
    line = line.substr(space+1);

    // second token is the expression type
    space = line.find(" ");
    if (space < 0) {
      debug5<<"uda expression syntax error on line "<<line<<endl;
      continue;
    }
    string type = line.substr(0, space);
    line = line.substr(space+1);

    Expression::ExprType etype = Expression::Unknown;
    if (type == "scalar")
      etype = Expression::ScalarMeshVar;
    if (type == "vector")
      etype = Expression::VectorMeshVar;
    if (type == "tensor")
      etype = Expression::TensorMeshVar;
    if (type == "symtensor")
      etype = Expression::SymmetricTensorMeshVar;
    if (type == "array")
      etype = Expression::ArrayMeshVar;
    if (type == "curve")
      etype = Expression::CurveMeshVar;

    if (etype == Expression::Unknown) {
      debug5<<"uda expression - unknown type on line "<<line<<endl;
      continue;
    }


    Expression e;
    e.SetName(name);
    e.SetType(etype);
    e.SetDefinition(line);
    md->AddExpression(&e);
  }


  fclose(f);
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::ReadMetaData
//
//  Purpose:
//      Does the actual work for PopulateMetaData().
//
// ****************************************************************************
void
avtudaReaderMTMDFileFormat::ReadMetaData(avtDatabaseMetaData *md, int timeState)
{
  //
  // CODE TO ADD A MESH
  //
  debug5 << "\nIn PopulateDatabaseMetaData\n";

  ActivateTimestep(timeState);

  int numLevels = stepInfo->levelInfo.size();

  int totalPatches = 0;
  for (int i = 0; i < numLevels; i++)
    totalPatches +=  stepInfo->levelInfo[i].patchInfo.size();

  debug5 << "Levels: " << numLevels << " Patches: " << totalPatches << endl;

  vector<int> groupIds(totalPatches);
  vector<string> pieceNames(totalPatches);

  for (int i = 0; i < totalPatches; i++) {
    char tmpName[64];
    int level, local_patch;

    GetLevelAndLocalPatchNumber(i, level, local_patch);
    sprintf(tmpName,"level%d, patch%d", level, local_patch);

    groupIds[i] = level;
    pieceNames[i] = tmpName;
  }
  debug5<<"num domains: "<<totalPatches<<endl;

  // compute the bounding box of the mesh from the grid indices of level 0
  LevelInfo &level0Info = stepInfo->levelInfo[0];
  int index_low[3] = { level0Info.patchInfo[0].cc_extra_low[0],
                       level0Info.patchInfo[0].cc_extra_low[1],
                       level0Info.patchInfo[0].cc_extra_low[2] };
  int index_high[3] = { level0Info.patchInfo[0].cc_extra_high[0],
                        level0Info.patchInfo[0].cc_extra_high[1],
                        level0Info.patchInfo[0].cc_extra_high[2] };
  for (int i=1; i<(int)level0Info.patchInfo.size(); i++) {
    for (int j=0; j<3; j++) {
      index_low[j]  = min(index_low[j],  level0Info.patchInfo[i].cc_extra_low[j]);
      index_high[j] = max(index_high[j], level0Info.patchInfo[i].cc_extra_high[j]);
    }
  }

  double box_min[3] = { level0Info.anchor[0] + index_low[0] * level0Info.spacing[0],
                        level0Info.anchor[1] + index_low[1] * level0Info.spacing[1],
                        level0Info.anchor[2] + index_low[2] * level0Info.spacing[2] };
  double box_max[3] = { level0Info.anchor[0] + index_high[0] * level0Info.spacing[0],
                        level0Info.anchor[1] + index_high[1] * level0Info.spacing[1],
                        level0Info.anchor[2] + index_high[2] * level0Info.spacing[2] };
                        

  // grid meshes are shared between materials, and particle meshes are
  // shared between variables - keep track of what has been added so they're only added once
  std::set<string> meshes_added;

  // If a variable exists in multiple materials, we don't want to add it more than
  // once to the meta data - it can mess up visit's expressions variable lists.
  std::set<string> mesh_vars_added;


  for (int i=0; i<(int)stepInfo->varInfo.size(); i++) {
    if (stepInfo->varInfo[i].type.find("ParticleVariable") == string::npos) {
      string varname = stepInfo->varInfo[i].name;
      string vartype = stepInfo->varInfo[i].type;

      string mesh_for_this_var;
      avtCentering cent=AVT_ZONECENT;

      if (vartype.find("NC") != string::npos) {
        cent = AVT_NODECENT;
        mesh_for_this_var.assign("NC_Mesh"); 
      }  
      else if (vartype.find("CC") != string::npos) {  
        cent = AVT_ZONECENT;
        mesh_for_this_var.assign("CC_Mesh"); 
      }
      else if (vartype.find("SFC") != string::npos) { 
        cent = AVT_ZONECENT;

        if (vartype.find("SFCX") != string::npos)		
          mesh_for_this_var.assign("SFCX_Mesh");
        else if (vartype.find("SFCY") != string::npos)		
          mesh_for_this_var.assign("SFCY_Mesh");
        else if (vartype.find("SFCZ") != string::npos)		
          mesh_for_this_var.assign("SFCZ_Mesh");
      }  

      
      if (meshes_added.find(mesh_for_this_var)==meshes_added.end()) {
        avtMeshMetaData *mesh = new avtMeshMetaData;

        mesh->name = mesh_for_this_var;
        mesh->meshType = AVT_AMR_MESH;
        mesh->topologicalDimension = 3;
        mesh->spatialDimension = 3;

        mesh->numBlocks = totalPatches;
        mesh->blockTitle = "patches";
        mesh->blockPieceName = "patch";
        mesh->numGroups = numLevels;
        mesh->groupTitle = "levels";
        mesh->groupPieceName = "level";
        mesh->blockNames = pieceNames;
        mesh->containsExteriorBoundaryGhosts = true;

        mesh->hasSpatialExtents = true; 
        mesh->minSpatialExtents[0] = box_min[0];
        mesh->maxSpatialExtents[0] = box_max[0];
        mesh->minSpatialExtents[1] = box_min[1];
        mesh->maxSpatialExtents[1] = box_max[1];
        mesh->minSpatialExtents[2] = box_min[2];
        mesh->maxSpatialExtents[2] = box_max[2];

        md->Add(mesh);
        meshes_added.insert(mesh_for_this_var);
      }

      for (int j=0; j<(int)stepInfo->varInfo[i].materials.size(); j++) {
        char buffer[128];
        string newVarname = varname;
        sprintf(buffer, "%d", stepInfo->varInfo[i].materials[j]);
        newVarname.append("/");
        newVarname.append(buffer);


        if (mesh_vars_added.find(mesh_for_this_var+newVarname)==mesh_vars_added.end()) {
          mesh_vars_added.insert(mesh_for_this_var+newVarname);

          if (vartype.find("Vector") != string::npos)
            AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
          else if (vartype.find("Matrix3") != string::npos)
            AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
          else 
            AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
        }
      }
    }   
  }


  // add a proc id enum variable for CC_Mesh
  int max_proc = 0;
  for (int l=0; l<numLevels; l++) {
    for (int p=0; p<(int)stepInfo->levelInfo[l].patchInfo.size(); p++) {
      max_proc = std::max(max_proc, stepInfo->levelInfo[l].patchInfo[p].proc_id);
    }
  }

  {
    avtScalarMetaData *scalar = new avtScalarMetaData();

    scalar->SetEnumerationType(avtScalarMetaData::ByValue);
    for (int p=0; p<=max_proc; p++) {
      char tmp[100];
      sprintf(tmp, "%d", p);
      scalar->AddEnumNameValue(tmp,p);
    }

    scalar->name = "proc_id";
    scalar->meshName = "CC_Mesh";
    scalar->centering = AVT_ZONECENT;
    scalar->hasDataExtents = false;
    scalar->treatAsASCII = false;
    md->Add(scalar);
  }
  

  // Nothing needs to be modifed for particle data, as they exist only on a single level
  for (int i=0; i<(int)stepInfo->varInfo.size(); i++) {
    if (stepInfo->varInfo[i].type.find("ParticleVariable") != string::npos) {
      string varname = stepInfo->varInfo[i].name;
      string vartype = stepInfo->varInfo[i].type;

      // j=-1 -> all materials (*)
      for (int j=-1; j<(int)stepInfo->varInfo[i].materials.size(); j++) {
        string mesh_for_this_var = string("Particle_Mesh/");
        string newVarname = varname+"/";

        if (j >= 0) {
          char buffer[128];
          sprintf(buffer, "%d", stepInfo->varInfo[i].materials[j]);
          mesh_for_this_var.append(buffer);
          newVarname.append(buffer);
        }
        else {
          mesh_for_this_var.append("*");
          newVarname.append("*");
        }

        if (meshes_added.find(mesh_for_this_var)==meshes_added.end()) {

          avtMeshMetaData *mesh = new avtMeshMetaData;

          mesh->name = mesh_for_this_var;
          mesh->meshType = AVT_POINT_MESH;
          mesh->topologicalDimension = 0;
          mesh->spatialDimension = 3;

          mesh->numBlocks = totalPatches;
          mesh->blockTitle = "patches";
          mesh->blockPieceName = "patch";
          mesh->numGroups = numLevels;
          mesh->groupTitle = "levels";
          mesh->groupPieceName = "level";
          mesh->blockNames = pieceNames;

          mesh->hasSpatialExtents = true; 
          mesh->minSpatialExtents[0] = box_min[0];
          mesh->maxSpatialExtents[0] = box_max[0];
          mesh->minSpatialExtents[1] = box_min[1];
          mesh->maxSpatialExtents[1] = box_max[1];
          mesh->minSpatialExtents[2] = box_min[2];
          mesh->maxSpatialExtents[2] = box_max[2];

          md->Add(mesh); 
          meshes_added.insert(mesh_for_this_var);
        }

        if (mesh_vars_added.find(mesh_for_this_var+newVarname)==mesh_vars_added.end()) {
          mesh_vars_added.insert(mesh_for_this_var+newVarname);

          avtCentering cent = AVT_NODECENT;
          if ((vartype.find("Vector") != string::npos) ||
              (vartype.find("Point") != string::npos))
            AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
          else if (vartype.find("Matrix3") != string::npos)
            AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
          else
            AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
        }
      }
    }   
  }
  
  md->AddGroupInformation(numLevels, totalPatches, groupIds);
  md->AddDefaultSILRestrictionDescription(std::string("!TurnOnAll"));


  AddExpressionsToMetadata(md);
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************
void
avtudaReaderMTMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
#ifdef SERIALIZED_READS

  int numProcs, rank;
  int msg = 128, tag = 256;
  MPI_Status status;

  MPI_Comm_size(VISIT_MPI_COMM, &numProcs);
  MPI_Comm_rank(VISIT_MPI_COMM, &rank);

  debug5 << "Proc: " << rank << " sent to mdserver" << endl;  

  if (rank == 0) {
    ReadMetaData(md, timeState);
    MPI_Send(&msg, 1, MPI_INT, 1, tag, VISIT_MPI_COMM);
  }
  else {
    MPI_Recv(&msg, 1, MPI_INT, rank - 1, tag, VISIT_MPI_COMM, &status);
    if (msg == 128 && tag == 256) {
      ReadMetaData(md, timeState);
      if (rank < (numProcs - 1))
        MPI_Send(&msg, 1, MPI_INT, rank + 1, tag, VISIT_MPI_COMM);
    }
  }
#else      
  ReadMetaData(md, timeState);
#endif
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetLevelAndLocalPatchNumber
//
//  Purpose:
//      Translates the global patch identifier to a refinement level and patch
//      number local to that refinement level.
//  
//  Programmer: sshankar, taken from implementation of the plugin, CHOMBO
//  Creation:   May 20, 2008
//
// ****************************************************************************
void
avtudaReaderMTMDFileFormat::GetLevelAndLocalPatchNumber(int global_patch, 
                                                        int &level, int &local_patch)
{
  int num_levels = stepInfo->levelInfo.size();
  int num_patches = 0;
  int tmp = global_patch;
  level = 0;
  while (level < num_levels) {
    num_patches = stepInfo->levelInfo[level].patchInfo.size();
    if (tmp < num_patches)
      break;
    tmp -= num_patches;
    level++;
  }
  local_patch = tmp;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetGlobalDomainNumber
//
//  Purpose:
//      Translates the level and local patch number into a global patch id.
//  
// ****************************************************************************
int avtudaReaderMTMDFileFormat::GetGlobalDomainNumber(int level, int local_patch) {
  int g=0;
  for (int l=0; l<level; l++)
    g += stepInfo->levelInfo[l].patchInfo.size();
  g += local_patch;

  return g;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::CalculateDomainNesting
//
//  Purpose:
//      Calculates two important data structures.  One is the structure domain
//      nesting, which tells VisIt how the AMR patches are nested, which allows
//      VisIt to ghost out coarse zones that are refined by smaller zones.
//      The other structure is the rectilinear domain boundaries, which tells
//      VisIt which patches are next to each other, allowing VisIt to create
//      a layer of ghost zones around each patch.  Note that this only works
//      within a refinement level, not across refinement levels.
//  
//  Programmer: Hank Childs / Modified for re-use by sshankar
//  Creation:   January 22, 2006
//
// ****************************************************************************
void
avtudaReaderMTMDFileFormat::CalculateDomainNesting(int timestate, const std::string &meshname)
{
  //
  // First, look to see if we don't already have it cached
  // Note that we compute BOTH domain nesting and domain boundary
  // information here. However, we use only existance of domain
  // nesting object in cache as trigger for whether to compute
  // both objects or not.
  //

  void_ref_ptr vrTmp = cache->GetVoidRef("any_mesh",
                                         //meshname.c_str(),
                                         AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
                                         timestate, -1);
  if (*vrTmp != NULL)
    return;

  //
  // Calculate some info we will need in the rest of the routine.
  //
  int num_levels = stepInfo->levelInfo.size();
  int totalPatches = 0;
  for (int level = 0 ; level < num_levels ; level++)
    totalPatches += stepInfo->levelInfo[level].patchInfo.size();


  //
  // Now set up the data structure for patch boundaries.  The data 
  // does all the work ... it just needs to know the extents of each patch.
  //
  avtRectilinearDomainBoundaries *rdb 
    = new avtRectilinearDomainBoundaries(true);
  rdb->SetNumDomains(totalPatches);

  for (int patch = 0 ; patch < totalPatches ; patch++) {
    int my_level, local_patch;
    GetLevelAndLocalPatchNumber(patch, my_level, local_patch);

    PatchInfo &patchInfo = stepInfo->levelInfo[my_level].patchInfo[local_patch];

    const int *low = patchInfo.cc_low;
    const int *high = patchInfo.cc_high;

    int e[6] = { low[0], high[0],
                 low[1], high[1],
                 low[2], high[2] };
    rdb->SetIndicesForAMRPatch(patch, my_level, e);
  }

  rdb->CalculateBoundaries();


  void_ref_ptr vrdb = void_ref_ptr(rdb,
                                   avtStructuredDomainBoundaries::Destruct);
  cache->CacheVoidRef("any_mesh",
                      //meshname.c_str(),
                      AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION,
                      timestate, -1, vrdb);



  //
  // Domain Nesting
  //

  avtStructuredDomainNesting *dn = new avtStructuredDomainNesting(totalPatches, num_levels);
  dn->SetNumDimensions(3);

  //
  // Calculate what the refinement ratio is from one level to the next.
  //
  for (int level = 0 ; level < num_levels ; level++) {
    // SetLevelRefinementRatios requires data as a vector<int>
    vector<int> rr(3);
    for (int i=0; i<3; i++)
      rr[i] = stepInfo->levelInfo[level].refinementRatio[i];

    dn->SetLevelRefinementRatios(level, rr);
  }


  //
  // Calculating the child patches really needs some better sorting than
  // what I am doing here.  This is likely to become a bottleneck in extreme
  // cases.  Although this routine has performed well for a previous 55K
  // patch run.
  //
  vector< vector<int> > childPatches(totalPatches);
  for (int level = num_levels-1 ; level > 0 ; level--) {
    int prev_level = level-1;
    LevelInfo &levelInfoParent = stepInfo->levelInfo[prev_level];
    LevelInfo &levelInfoChild = stepInfo->levelInfo[level];

    for (int child=0; child<(int)levelInfoChild.patchInfo.size(); child++) {
      PatchInfo &childPatchInfo = levelInfoChild.patchInfo[child];
      const int *child_low = childPatchInfo.cc_low;
      const int *child_high = childPatchInfo.cc_high;

      for (int parent=0; parent<(int)levelInfoParent.patchInfo.size(); parent++) {
        PatchInfo &parentPatchInfo = levelInfoParent.patchInfo[parent];
        const int *parent_low = parentPatchInfo.cc_low;
        const int *parent_high = parentPatchInfo.cc_high;


        int mins[3], maxs[3];
        for (int i=0; i<3; i++) {
          mins[i] = max(child_low[i],  parent_low[i] *levelInfoChild.refinementRatio[i]);
          maxs[i] = min(child_high[i], parent_high[i]*levelInfoChild.refinementRatio[i]);
        }
        bool overlap = (mins[0]<maxs[0] &&
                        mins[1]<maxs[1] &&
                        mins[2]<maxs[2]);

        if (overlap) {
          int child_gpatch = GetGlobalDomainNumber(level, child);
          int parent_gpatch = GetGlobalDomainNumber(prev_level, parent);
          childPatches[parent_gpatch].push_back(child_gpatch);
        }
      }
    }
  }


  //
  // Now that we know the extents for each patch and what its children are,
  // tell the structured domain boundary that information.
  //
  for (int p=0; p<totalPatches ; p++) {
    int my_level, local_patch;
    GetLevelAndLocalPatchNumber(p, my_level, local_patch);

    PatchInfo &patchInfo = stepInfo->levelInfo[my_level].patchInfo[local_patch];
    const int *low = patchInfo.cc_low;
    const int *high = patchInfo.cc_high;

    vector<int> e(6);
    for (int i=0; i<3; i++) {
      e[i+0] = low[i];
      e[i+3] = high[i]-1;
    }
    dn->SetNestingForDomain(p, my_level, childPatches[p], e);
  }


  //
  // Register this structure with the generic database so that it knows
  // to ghost out the right cells.
  //
  void_ref_ptr vr = void_ref_ptr(dn, avtStructuredDomainNesting::Destruct);
  cache->CacheVoidRef("any_mesh",
                      //meshname.c_str(),
                      AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
                      timestate, -1, vr);
}


// ***************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

vtkDataSet *
avtudaReaderMTMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
  ActivateTimestep(timestate);

  string meshName(meshname);

  int level, local_patch;
  GetLevelAndLocalPatchNumber(domain, level, local_patch);

  // volume data
  if (meshName.find("Particle_Mesh") == string::npos) {

    // make sure we have ghosting info for this mesh
    CalculateDomainNesting(timestate, meshname);

    LevelInfo &levelInfo = stepInfo->levelInfo[level];
    PatchInfo &patchInfo = levelInfo.patchInfo[local_patch];

    int low[3], high[3];
    int extra_low[3], extra_high[3];

    for (int i=0; i<3; i++) {
      low[i]  = patchInfo.cc_low[i];
      high[i] = patchInfo.cc_high[i];

      extra_low[i] =  low[i];
      extra_high[i] = high[i];
    }

    // If there are extra cells, we need to store them on ALL sides.
    int nextra = max(max(levelInfo.extraCells[0], levelInfo.extraCells[1]),
                     levelInfo.extraCells[2]);

    if( useExtraCells ) {
      for (int i=0; i<3; i++) {
        low[i]  += nextra;
        high[i] -= nextra;
      }
    }


    // Node centered data uses the same mesh as cell centered,
    // face centered meshes need an extra value for one axis.
    int extra_for_faces[3] = {0,0,0};
    if (meshName.find("SFCX") != string::npos) {
      extra_for_faces[0]=1;
      high[0]++; extra_high[0]++;
    }

    if (meshName.find("SFCY") != string::npos) {
      extra_for_faces[1]=1;
      high[1]++; extra_high[1]++;
    }

    if (meshName.find("SFCZ") != string::npos) {
      extra_for_faces[2]=1;
      high[2]++; extra_high[2]++;
    }



    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();

    int dims[3];
    for (int i=0; i<3; i++)
      dims[i] = extra_high[i]-extra_low[i]+1;
    rgrid->SetDimensions(dims);


    // Set the coordinates of the grid points in each direction.
    for (int c=0; c<3; c++) {
      vtkFloatArray *coords = vtkFloatArray::New(); 
      coords->SetNumberOfTuples(dims[c]); 
      float *array = (float *)coords->GetVoidPointer(0); 
      for (int i=0; i<dims[c]; i++) {

        // Face centered data gets shifted towards -inf by half a cell, except
        // for the first and last nodes, which have an extra half cell movement
        // to keep the spatial range the same as it otherwise would be.
        float face_offset=0;
        if (extra_for_faces[c]) {
          if (i==0)
            face_offset = 0;
          else if (i==dims[c]-1)
            face_offset = -1;
          else
            face_offset = -0.5;
        }

        array[i] = levelInfo.anchor[c] +
          (i + extra_low[c] + face_offset) * levelInfo.spacing[c];
      }

      switch(c) {
      case 0:
        rgrid->SetXCoordinates(coords); break;
      case 1:
        rgrid->SetYCoordinates(coords); break;
      case 2:
        rgrid->SetZCoordinates(coords); break;
      }

      coords->Delete();
    }

    if (nextra) {
      // If we have extra cells, we need to specify where in the data chunk
      // the interior cells lay.
      vtkIntArray *baseIndex = vtkIntArray::New();
      baseIndex->SetNumberOfTuples(3);
      baseIndex->SetValue(0, low[0]);
      baseIndex->SetValue(1, low[1]);
      baseIndex->SetValue(2, low[2]);
      baseIndex->SetName("base_index");
      rgrid->GetFieldData()->AddArray(baseIndex);
      baseIndex->Delete();

      vtkIntArray *realDims = vtkIntArray::New();
      realDims->SetNumberOfTuples(6);
      realDims->SetValue(0, low[0]-extra_low[0]);
      realDims->SetValue(1, high[0]-extra_low[0]);
      realDims->SetValue(2, low[1]-extra_low[1]);
      realDims->SetValue(3, high[1]-extra_low[1]);
      realDims->SetValue(4, low[2]-extra_low[2]);
      realDims->SetValue(5, high[2]-extra_low[2]);
      realDims->SetName("avtRealDims");
      rgrid->GetFieldData()->AddArray(realDims);
      realDims->Delete();

      // Mark all of the ghost cells.
      unsigned char ghostExternal=0;
      avtGhostData::AddGhostZoneType(ghostExternal,
                                     ZONE_EXTERIOR_TO_PROBLEM);
      unsigned char ghostInternal=0;
      avtGhostData::AddGhostZoneType(ghostInternal,
                                     DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);

      unsigned char ghostNA=0;
      avtGhostData::AddGhostZoneType(ghostNA,
                                     ZONE_NOT_APPLICABLE_TO_PROBLEM);


      vtkUnsignedCharArray *ghostCells = vtkUnsignedCharArray::New();
      ghostCells->SetName("avtGhostZones");
      ghostCells->Allocate(rgrid->GetNumberOfCells());

      for (int z=extra_low[2]; z<extra_high[2]; z++) {
        bool extraz=(z<low[2] || z>=high[2]);
        bool isboundaryz = (extraz &&
                            (z>=patchInfo.cc_extra_low[2] && z<patchInfo.cc_extra_high[2]));

        for (int y=extra_low[1]; y<extra_high[1]; y++) {
          bool extray=(y<low[1] || y>=high[1]);
          bool isboundaryy = (extray &&
                              (y>=patchInfo.cc_extra_low[1] && y<patchInfo.cc_extra_high[1]));

          for (int x=extra_low[0]; x<extra_high[0]; x++) {
            bool extrax=(x<low[0] || x>=high[0]);
            bool isboundaryx = (extrax &&
                                (x>=patchInfo.cc_extra_low[0] && x<patchInfo.cc_extra_high[0]));

            bool extra = (extraz||extray||extrax);
            bool isboundary = (isboundaryx||isboundaryy||isboundaryz);

            if (extra) {
              if (isboundary)
                ghostCells->InsertNextValue(ghostExternal);
              else
                ghostCells->InsertNextValue(ghostInternal);
            }
            else
              ghostCells->InsertNextValue(0);
          }
        }
      }
     
      rgrid->GetCellData()->AddArray(ghostCells);
      rgrid->SetUpdateGhostLevel(level);
      ghostCells->Delete();
    }


    return rgrid;
  }

  // particle data
  else if (meshName.find("Particle_Mesh") != string::npos) {

    size_t found = meshName.find("/");
    string matl = meshName.substr(found + 1);

    int matlNo = -1;
    if (matl.compare("*") != 0)
      matlNo = atoi(matl.c_str());

    // we always want p.x when setting up the mesh
    string vars = "p.x";

    ParticleDataRaw *pd = (*getParticleData)(archive, grid, level, local_patch, vars, matlNo, timestate);

    // Create the vtkPoints object and copy points into it.
    vtkDoubleArray *doubleArray = vtkDoubleArray::New();
    doubleArray->SetNumberOfComponents(3);
    doubleArray->SetArray(pd->data, pd->num*pd->components, 0);

    vtkPoints *points = vtkPoints::New();
    points->SetData(doubleArray);
    doubleArray->Delete();

    // 
    // Create a vtkUnstructuredGrid to contain the point cells. 
    // 
    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
    ugrid->SetPoints(points); 
    points->Delete(); 
    ugrid->Allocate(pd->num); 
    vtkIdType onevertex; 

    for(int i = 0; i < pd->num; ++i) {
      onevertex = i; 
      ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex); 
    } 

    // don't delete pd->data - vtk owns it now!
    delete pd;

    return ugrid;
  }

  return NULL;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkDoubleArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************
vtkDataArray *
avtudaReaderMTMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
  ActivateTimestep(timestate);

  string varName(varname);
  bool isParticleVar = false;
    
  size_t found = varName.find("/");
  string tmpVarName = varName;
    
  string matl = varName.substr(found + 1);
  varName = varName.substr(0, found);
    
  string varType;

  for (int k=0; k<(int)stepInfo->varInfo.size(); k++) {
    if (stepInfo->varInfo[k].name == varName) {
      varType = stepInfo->varInfo[k].type;
      if (stepInfo->varInfo[k].type.find("ParticleVariable") != string::npos) {
        isParticleVar = true;
        break;
      }
    }
  }

  vtkDoubleArray *rv = vtkDoubleArray::New();

  int level, local_patch;
  GetLevelAndLocalPatchNumber(domain, level, local_patch);

  // volume data
  if (!isParticleVar) { 

    LevelInfo &levelInfo = stepInfo->levelInfo[level];
    PatchInfo &patchInfo = levelInfo.patchInfo[local_patch];


    int low[3], high[3];   // region that visit expects

    for (int i=0; i<3; i++) {
      low[i]  = patchInfo.cc_low[i];
      high[i] = patchInfo.cc_high[i];
    }


    // Node centered data needs an extra value in each direction,
    // face centered meshes need an extra value for one axis.
    // This is bad because it requires reading data from neighboring
    // patches, but there's no way around that right now.
    if (varType.find("SFCX") != string::npos ||
        varType.find("NC") != string::npos) {
      high[0]++;
    }

    if (varType.find("SFCY") != string::npos ||
        varType.find("NC") != string::npos) {
      high[1]++;
    }

    if (varType.find("SFCZ") != string::npos ||
        varType.find("NC") != string::npos) {
      high[2]++;
    }

    GridDataRaw *gd=NULL;

    if (strcmp(varname, "proc_id")==0) {
      gd = new GridDataRaw;
      for (int i=0; i<3; i++) {
        gd->low[i ] = low[i];
        gd->high[i] = high[i];
      }
      gd->components=1;

      int ncells = (high[0]-low[0])*(high[1]-low[1])*(high[2]-low[2]);
      gd->data = new double[ncells];
      for (int i=0; i<ncells; i++) 
        gd->data[i] = patchInfo.proc_id;
    }

    else {
#ifdef SERIALIZED_READS
      int numProcs, rank;
      int msg = 128, tag = 256;
      MPI_Status status;

      MPI_Comm_size(VISIT_MPI_COMM, &numProcs);
      MPI_Comm_rank(VISIT_MPI_COMM, &rank);

      int totalPatches = 0;
      for (int i = 0; i < stepInfo->levelInfo.size(); i++)
        totalPatches += stepInfo->levelInfo[i].patchInfo.size();

      // calculate which process we should wait for a message from
      // if we're processing doiman 0 don't wait for anyone else
      int prev = (rank+numProcs-1)%numProcs;
      int next = (rank+1)%numProcs;

      // domain 0 always reads right away
      if (domain==0)
        prev = -1;
    
      debug5 << "Proc: " << rank << " sent to GetVar" << endl;

      // wait for previous read to finish
      if (prev>=0)
        MPI_Recv(&msg, 1, MPI_INT, prev, tag, VISIT_MPI_COMM, &status);

      gd = (*getGridData)(archive, grid, level, local_patch, varName, atoi(matl.c_str()), timestate, low, high);

      // let the next read go
      if (next>=0)
        MPI_Send(&msg, 1, MPI_INT, next, tag, VISIT_MPI_COMM);

#else
      gd = (*getGridData)(archive, grid, level, local_patch, varName, atoi(matl.c_str()), timestate, low, high);
#endif
    }

    int n = (high[0]-low[0])*(high[1]-low[1])*(high[2]-low[2]);

    // replace nan's with a large negative number
    for (int i=0; i<n*gd->components; i++) {
      if (std::isnan(gd->data[i]))
        gd->data[i] = -1e16;
    }

    rv->SetNumberOfComponents(gd->components);
    rv->SetArray(gd->data, n*gd->components, 0);

    // don't delete gd->data - vtk owns it now!
    delete gd;
  }

  // particle data
  else {
    int matlNo = -1;
    if (matl.compare("*") != 0)
      matlNo = atoi(matl.c_str());

    ParticleDataRaw *pd = NULL;

#ifdef SERIALIZED_READS
    int numProcs, rank;
    int msg = 128, tag = 256;
    MPI_Status status;

    MPI_Comm_size(VISIT_MPI_COMM, &numProcs);
    MPI_Comm_rank(VISIT_MPI_COMM, &rank);

    int totalPatches = 0;
    for (int i = 0; i < stepInfo->levelInfo.size(); i++)
      totalPatches += stepInfo->levelInfo[i].patchInfo.size();

    // calculate which process we should wait for a message from
    // if we're processing doiman 0 don't wait for anyone else
    int prev = (rank+numProcs-1)%numProcs;
    int next = (rank+1)%numProcs;

    // domain 0 always reads right away
    if (domain==0)
      prev = -1;
    
    debug5 << "Proc: " << rank << " sent to GetVar" << endl;

    // wait for previous read to finish
    if (prev>=0)
      MPI_Recv(&msg, 1, MPI_INT, prev, tag, VISIT_MPI_COMM, &status);

    pd = (*getParticleData)(archive, grid, level, local_patch, varName, matlNo, timestate);

    // let the next read go
    if (next>=0)
      MPI_Send(&msg, 1, MPI_INT, next, tag, VISIT_MPI_COMM);

#else
    pd = (*getParticleData)(archive, grid, level, local_patch, varName, matlNo, timestate);
#endif

    // replace nan's with a large negative number
    for (int i=0; i<pd->num*pd->components; i++) {
      if (std::isnan(pd->data[i]))
        pd->data[i] = -1e16;
    }

    rv->SetNumberOfComponents(pd->components);
    rv->SetArray(pd->data, pd->num*pd->components, 0);

    // don't delete pd->data - vtk owns it now!
    delete pd;
  }

  return rv;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkDoubleArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************
vtkDataArray *
avtudaReaderMTMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
  // we handle vector variables exactly the same way as scalars
  return GetVar(timestate, domain, varname);
}


// ****************************************************************************
//  Method: avtBoxlib2DFileFormat::GetAuxiliaryData
//
//  Purpose:
//      Gets the auxiliary data specified.
//
//  Arguments:
//      var        The variable of interest.
//      dom        The domain of interest.
//      type       The type of auxiliary data.
//      <unnamed>  The arguments for that type -- not used.
//      df         Destructor function.
//
//  Returns:    The auxiliary data.
//
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
//  Modifications:
//    Kathleen Bonnell, Mon Aug 14 16:40:30 PDT 2006
//    API change for avtIntervalTree.
//
//    Gunther H. Weber, Tue Aug  7 16:01:28 PDT 2007
//    Return material information
// ****************************************************************************
void *
avtudaReaderMTMDFileFormat::GetAuxiliaryData(const char *var, int dom,
                                             const char * type, void *,
                                             DestructorFunction &df)
{
  return NULL;
}
