<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE component SYSTEM "../../../../Dataflow/XML/component.dtd">
<?xml-stylesheet href="../../../../../doc/package-component.xsl" type="text/xsl"?>
<?cocoon-process type="xslt"?>

<!--
   For more information, please see: http://software.sci.utah.edu

   The MIT License

   Copyright (c) 2004 Scientific Computing and Imaging Institute,
   University of Utah.

   License for the specific language governing rights and limitations under
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
-->

<component name="Matlab2" category="DataIO">
  <overview>
    <authors>
      <author>Jeroen Stinstra</author>
    </authors>
    <summary>
      Interactive Matlab Interface: This module accomplishes a number of steps to integrate MATLAB code into
      SCIRun, (1) it translates a SCIRun object (field/matrix/nrrd) into a matlabarray and puts the object in
      the current workspace of matlab, (2) it executes MATLAB code that can be provided within the interface, 
      (3) It translates back matlabarrays in matlabs workspace into SCIRun objects
    </summary>
    <description>

    <section>
    <title>Overview</title>

    <p>
    This module launches MATLAB as a separate process under control of SCIRun. The process can be on a remote 
    machine or a local machine. In case the module is running on a remote machine the communication with matlab
    will be through sockets. In the latter case the entry fields on top of the GUI will need to be filled out 
    with the ip address (it will automatically do a DNS lookup), the port number and a password. In order to run
    multiple MATLAB processes simultaneously different session can be launched. Each session on the same machine
    will share the global workspace in MATLAB and code is being executed sequentially for all modules making use
    of that session. 
    </p>

    <p>
    Once matlab is launched the intro message will appear in the MATLAB OUTPUT window. The module needs to be executed
    in order to launch matlab, but will then remain active until the module is destroyed. The latter is done to smoothen
    the executing of matlab networks and as well to be able to store variables inmatlab's workspace for later usage.
    However before the module is executed the translation table of SCIRun objects to matlab objects needs to be setup.
    This is accomplished by connecting the SCIRun object to one of the input ports on the module. Note that there are
    ports for Matrices, Fields and Nrrds. In the translation menu the Field section deals with the translation of fields,
    the Matrix section with the translation of Matrices and the Nrrd section with the translation of the nrrds. Each line
    in this translation table refers to one set of input and output ports. First of all the module will need to know how
    the object should be called in MATLAB, it is going to be a matlab array and thus needs to have a name. Then depending 
    on the SCIRun object the object can be translated into structured arrays or numeric arrays, whose numeric format can be 
    set as well. See the sections below for more details. Then at the end of the line the name of the matlabarray that needs
    to be translated back into a SCIRun object. Here a name is sufficient as the translation process will do the rest. The
    name can be the same as the input array, but it might refer to another array as well.
    </p>

    <p>
    The process of running code in matlab is accomplished as follows: SCIRun will translate the SCIRun objects into matlab
    compatible objects and write them in a file and then instructs matlab to read this file. Since all communication is through
    the stdin of matlab, using files makes sure that the data does not have to be written out in ASCII readable code. The 
    module is smart enough to recognize that it translated objects before. If this is the case it will not do the translation
    again and it will use the file already generated. When loading data into matlab the objects that were already there with 
    the same name will be overwritten. Subsequently the module will take the code the user entered in the GUI and wrap it in
    a 'try/catch' environment and execute it in matlab. All output generated on the stdout will be displayed in the module.
    It will write a tag of when the code starts executing as well one on when the code finished executing. These are markers
    for the module to keep track of when matlab finishes executing code. Please make sure that your progam does NOT generate
    output that resembles these markers as it will confuse the Matlab Interface. Once the end marker is encountered, the module
    will instruct matlab to save the variables in the workspace so they can be read in by SCIRun.
    </p>

    <p>
    The third window on the bottom will show the current status of the matlab engine. Note when session 0 is requested a new 
    session number will be assigned to the matlab process, which has not been used before. The new session number will appear
    in this status window. This option is used to give each MatlabInterface Module its own matlab process running in the background. 
    </p>  
    </section>

    <section>
    <title>Local configuration</title>

    <p>
    Before the module can be used, SCIRun needs to know how to run matlab on the local machine. This is accomplished by the
    configuration file 'matlabengine.rc', which will be created in the SCIRun/services directory in your local HOME directory.
    This file is copied out of the src tree the first time SCIRun is run. This file configures how matlab should be run. Edit
    the line 'startmatlab=' to instruct SCIRun how matlab should be started from an 'sh'-compatible shell. If matlab can already be
    found using the PATH settings in the shell launching SCIRun, this line probably does not need to be altered. All other fields
    in this file refer to running matlab on a remote machine. In case SCIRun will not be able to launch matlab a message will be 
    displayed asking to check the configuration file.
    </p>

    <p>
    Since the current version is experimental, the support for running external applications must be activated when launching matlab:
    </p>
    <p>
    scrirun -eai
    </p>
    <p>
    The latter instruction will switch on the support for external applications. With this option switched on a process will be forked
    from the central SCIRun process, which will be used to start other processes with a minimal memory overhead. Hence when enabling this
    option there will be suddenly more threads and processes.
    </p>
    <p>
    To open a matlab process on the local machine the 'MATLAB ENIGNE ADDRESS' in the GUI needs to have an empty Address and does not require
    a port. SCIRun will in this case automatically launch matlab locally. In the latter case no password checks are done. The local manager
    does support multiple sessions. To clarify the word session: a session is a matlab process. When multiple Matlab2 modules make use of the
    same session the workspace in matlab is shared. Hence one module can be used to load a large matrix into matlab, whereas another one can
    be used to iterate over a process with small matrices, while using the big matrix stored by the first one. This will allow for some 
    efficiency improvements.
    </p>    

    </section>

    <section>
    <title>Remote configuration</title>
    
    <p>  
    In order to run matlab on a different machine then SCIRun, a small server program needs to be run on the remote machine. The
    latter is called 'scirunremote', this program sets up a socket for listening and launches matlab when a request is made on its
    socket. This program uses the same 'matlabengine.rc' file as the module (though it will look in the local HOME directory of the 
    remote machine). This configuration file can be used to set a password, restrict login to only certain machines in a certain domain.
    Currently the communication is over an open socket in the future an openssl implementation will be used for secure connections.
    In order to launch the scirunremote program, type 'scirunremote -port 5678', or which ever port you want to use. The latter program
    must be run on the remote system and serves as a daemon for starting all kinds of external programs. When launching this application
    a list of services will be displayed. For the matlab engine to work properly two services need to be switched on: matlabengine and 
    matlabenginefiletransfer. The currently implementation requires the last one even if there is a shared home directory. in the latter
    case no files are transfered, and only the names of the directories in which temporary files are stored are exchanged. The latter
    mechanism will reduce the amount of network traffic and hopefully speed up the function of this module.
    </p>
    </section>

    <section>
    <title>Configuration file</title>	
    <p>
    This section shortly lists the different options that can be set in the configuration file 'SCIRun/services/matlabengine.rc'
    </p>
    <p>
    START MATLAB: This line describes how a sh-shell should start matlab. This instruction is executed to launch matlab
    </p>
    <p>
    DISABLE: This will disable the matlabengine in scirunremote. The service cannot be launched and any request for starting
    the matlabengine will be denied.
    </p>
    <p>
    PASSWORD: A simple password, as a first line of defense. Better ways will follow.
    </p>
    <p>
    RHOSTS: A list of machines that are allowed to log into scirunremote to request the matlabengine service. This list should contain
    all the machines you want to use for running SCIRun. Any machine not on the list will be denied access. If no machine is listed
    all machines are welcome to log in.
    </p>
    <p>
    MATLABTIMEOUT: How long should we wait before giving up. Note that matlab often needs a couple of minutes to startup. The time
    entered here is in seconds.
    </p>
    </section>

    <section>
    <title>How to use the GUI</title>

    </section>

    <section>	
    <title>Translation of FIELDS</title>
    <p>
    The following is an incomplete overview of the translation between SCIRun and MATLAB field objects. The following describes how
    fields are to be prepared in matlab for it to be used in SCIRun. The opposite process will be done for the input ports.
    Note that there one can specify whether one ones a structured or numerical matlab array. In case of numerical array only the data from the
    field is taken and the rest is thrown away. In case of a structured matlab array the data is fitted into a structure with the same fields
    as described below. 
    </p>

	<p>
	The following sections describe the fields of the structure matrix can be defined and are recognized by the module.
	</p>
		
	<section> 
	<title>Unstructured Meshes </title>
	
	<desclist>
		<desclistitem>
			<desclistterm> FIELDNAME .node </desclistterm>
			<desclistdef> 
			This field is required for unstructured meshes and defines the position of the nodes within the mesh. 
			This matrix should be a dense 3 by M matrix, where M is the number of nodes.
			</desclistdef>
		</desclistitem>
		<desclistitem>
			<desclistterm> FIELDNAME .edge </desclistterm>
			<desclistdef> 
			This field is required for curve meshes and defines the line elements in the mesh. This matrix should be
			a dense 2 by N matrix, where N is the number of line segments. The numbers in this mesh refer to the node
			positions in the NODE matrix. By default it is assumed that the numbering of nodes starts at one. However if
			one of the indices in this EDGE matrix is zero, a zero base is assumed. 
			</desclistdef>
		</desclistitem>
		<desclistitem>
			<desclistterm> FIELDNAME .face </desclistterm>
			<desclistdef> 
			This field is required for surfaces meshes and defines the surface elements in the mesh. This matrix should be
			a dense 3 by N matrix for triangulated meshes and a 4 by N matrix for quadsurf meshes. Here N is the number of 
			surface elements. The numbers in this mesh refer to the node
			positions in the NODE matrix. By default it is assumed that the numbering of nodes starts at one. However if
			one of the indices in this FACE matrix is zero, a zero base is assumed.
			</desclistdef>
		</desclistitem>		
		<desclistitem>
			<desclistterm> FIELDNAME .cell </desclistterm>
			<desclistdef> 
			This field is required for volume meshes and defines the volume elements in the mesh. This matrix should be
			a dense 4 by N matrix for tetrahedral meshes, or a 6 by N matrix for prism shaped volume elements, or a 8 by N matrix
			for hexahedral elements. Here N is the number of volume elements. The numbers in this mesh refer to the node
			positions in the NODE matrix. By default it is assumed that the numbering of nodes starts at one. However if
			one of the indices in this CELL matrix is zero, a zero base is assumed.
			</desclistdef>
		</desclistitem>		
	</desclist>
	</section>

	
	<section>
	<title>Structured Meshes</title> 
	  
	<desclist>
		<desclistitem>
			<desclistterm> FIELDNAMES x , y , AND z</desclistterm>
			<desclistdef> 
			The fields X, Y, and Z form the description of a structured mesh. These fields are 1D, 2D, or 3D matrices defining
			the structured line, surface, or volume data. The connectivity of these meshes is defined by the position of the 
			matrix, neighboring elements are connected. In this definition matrix X defines the x cartesian co-ordinate of each node,
			matrix Y the y cartesian co-ordinate and matrix Z the z cartesian co-ordinate. This kind of definition is compatible
			with MATLAB functions such as ndmesh() and sphere(). 
			</desclistdef> 
		</desclistitem>
	</desclist>
	</section>  
	
	<section>
	<title>Structured regular Meshes</title>
	
	<p>
	As structured matlab arrays:
	</p>
	<p>
	<desclist>
		<desclistitem>
			<desclistterm> FIELDNAME .dims </desclistterm>
			<desclistdef>
			This field describes the dimensions of the regular grid and is required for making a regular structured mesh. This field
			is a vector with 1, 2, or 3 elements describing the dimensions in each direction. Hence depending on this field the 
			module creates a line, a surface, or a volume. This field is required for structured regular meshes.
			</desclistdef>
		</desclistitem>
		<desclistitem>
		<desclistterm> FIELDNAME .transform </desclistterm>
			<desclistdef>
			This field describes a 4x4 matrix which defines an affine transformation, which is applied to the mesh. This matrix describes
			rotation, translation and scaling of each node in the regular mesh. This field is optional and does not need to be supplied.
			In case on transform matrix is defined a regular grid with spacing of 1 in each direction will be generated.
			[NEED TO ADD MORE DETAILS]
			</desclistdef>
		</desclistitem>
	</desclist>	
	</p>
	
	<p>
	As regular dense matrices:
	</p>
	<p>
	ImageFields and LatVolFields can be entered as well as dense matrices. A 2D matrix will be translated into an ImageField, and a 3D matrix will
	be translated into a LatVolField. When entering data as regular matrices, the data is assumed to be on the nodes and to be a scalar double field.
	</p>
	<p>
	Note: The displaying dimensions between matlab and SCIRun are flipped, in matlab the first dimension is along the vertical axis, whereas in
	SCIRun it is along the horizontal axis. Depending on the application the data may need to be transposed, in order to make to obtain the proper vertical
	alignment.
	</p>
	</section>		
	
	
	<section>
	<title>Field Data</title>
	
	<desclist>
		<desclistitem>
			<desclistterm> FIELDNAME .field </desclistterm>
			<desclistdef>
			A matrix specifying scalar/vector/tensor data for each node/element in the mesh. Each subsequent element in this vector is added to the
			next node/element in the field. Use the field FIELDLOCATION to specify where the data should be located. The module detects
			the type of data. The tensor and respectively the vector dimension is assumed to be the first one.
			</desclistdef>
		</desclistitem>
		<desclistitem>		
			<desclistterm> FIELDNAME .fieldtype </desclistterm>
			<desclistdef>
			A string specifying the type of data stored in field. Currently three value are accepted: 'scalar', 'vector', and 'tensor'. If this type
			information is omitted it defaults to 'scalar'
			</desclistdef>
		</desclistitem>
		<desclistitem>
			<desclistterm> FIELDNAME .fieldat </desclistterm>
			<desclistdef>
			The location of the data. This field is a string describing where the data should be located.
			The default field location is assumed to be the nodes, meaning each node has a scalar, vector, or tensor value. 
			In case the data is at the nodes, this field does not to be specified.
			This field is a string with the following options: "node", "edge", "face", or "cell".
			This field can be a number as well, which will describe the basis order of the element.
			</desclistdef>
		</desclistitem>
	</desclist>
	</section>
	<note>
	The way of specifying a field was different in version 1.22 of SCIRun. The modules still support input through the fields 'vectorfield', 'tensorfield',
	and 'scalarfield'. However to be compatible with future additions this has been changed to a combination of 'field' and 'fieldtype'. The new fieldwriters
	will use this convention instead of the old one.
	</note>	
	<note>
	The module will try to reconstruct data, for instance if a matrix is transposed, it will detect this and read the data properly.
	Most of the fields mentioned are optional and are not necessary. Only choose those fields from the list that are needed to 
	describe your data. Currently not every field type supported by SCIRun is implemented in this module. Hopefully future versions
	will support more data types and have even less restrictive converters.
	</note>
	</section>
	
	<section>
	<title> Example 1: preparing MATLAB file </title>
	
	<p> The following lines of MATLAB code demonstrate how to structure a matrix for the use in SCIRun: </p>
	
	<p>Assuming that the nodes are specified in nodematrix and the connectivity of these nodes is specified in facematrix </p>
	
	<p> >> geom.node = nodematrix </p>
	<p> >> geom.face = facematrix </p>
	
	<p> Opening the file with the MatlabFieldsReader module will show that there is one data matrix called "geom" whose contents
	is a TRISURFMESH with no data on any of the node points </p>
	
	<note>
	In case MATLAB is not available to structure the data, use the <modref package="MatlabInterface" name="MatlabNrrdsReader"/> module to read a MATLAB matrix data directly and
	use the <modref package="Teem" name="NrrdToField"/> module to construct a Field out of the Nrrd object. 
	</note>
	</section>
	  
	<section>
	<title> Example 2: Creating a structured mesh </title>
	 
	<p> The following lines of MATLAB code demonstrate the creation of a matlab file with the matlab logo on a structured mesh: </p>
	
	<p> >> [X,Y,DATA] = peaks(100); </p>
	<p> >> field.x = X; </p>
	<p> >> field.y = Y; </p>
	<p> >> field.z = DATA; </p>
	<p> >> field.scalarfield = DATA; </p>
	
	<p> This will create a surface mesh in the shape of the peaks logo and uses the z value as its data values. Be sure to specify
	all the three cartensian coordinates, omitting one will result in the module not to recognise the mesh and it will not display
	the object in its selection box.</p>
	
	</section>  
	
	<section>
	<title> Exampe 3: Creating an unstructured mesh </title>
	
	<p> The following lines of MATLAB code demonstrate the creation of a matlab fiel with an unstructured tesselated surface: </p>
	
	<p> >> [X,Y,Z] = ndmesh(1:10,1:10,0); </p>
	<p> >> field.node = [X(:)'; Y(:)'; Z(:)']; </p>
	<p> >> field.face = delauney(X,Y); </p>
	<p> >> field.scalarfield = X(:).^2; </p>

    </section>
    
	<section>
	<title>See Also </title>
	<p>
	<modref package="MatlabInterface" name="Matlab2" />,	
	<modref package="MatlabInterface" name="MatlabDataReader" />,	
	<modref package="MatlabInterface" name="MatlabDataWriter" />,	
	<modref package="MatlabInterface" name="MatlabFieldsReader" />,
	<modref package="MatlabInterface" name="MatlabFieldsWriteer" />,
	<modref package="MatlabInterface" name="MatlabMatricesReader" />,
	<modref package="MatlabInterface" name="MatlabFieldsReader" />,
	<modref package="MatlabInterface" name="MatlabMatricesWriter" />,
	<modref package="MatlabInterface" name="MatlabFieldsWriter" />	
	</p>
	</section>  


    </description>
  </overview>
  <implementation>
  </implementation>
  <io>
    <inputs lastportdynamic="yes">
      <port>
        <name>i1</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>i2</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>i3</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>i4</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>i5</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>fieldi1</name>
        <datatype>SCIRun::Field</datatype>
      </port>
      <port>
        <name>fieldi2</name>
        <datatype>SCIRun::Field</datatype>
      </port>
      <port>
        <name>fieldi3</name>
        <datatype>SCIRun::Field</datatype>
      </port>
      <port>
        <name>nnrdi1</name>
        <datatype>SCIRun::Nrrd</datatype>
      </port>
      <port>
        <name>nrrdi2</name>
        <datatype>SCIRun::Nrrd</datatype>
      </port>
      <port>
        <name>nrrdi3</name>
        <datatype>SCIRun::Nrrd</datatype>
      </port>
    </inputs>
    <outputs>
      <port>
        <name>o1</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>o2</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>o3</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>o4</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
      <port>
        <name>o5</name>
        <datatype>SCIRun::Matrix</datatype>
      </port>
     <port>
        <name>fieldo1</name>
        <datatype>SCIRun::Field</datatype>
      </port>
      <port>
        <name>fieldo2</name>
        <datatype>SCIRun::Field</datatype>
      </port>
      <port>
        <name>fieldo3</name>
        <datatype>SCIRun::Field</datatype>
      </port>
      <port>
        <name>nnrdo1</name>
        <datatype>SCIRun::Nrrd</datatype>
      </port>
      <port>
        <name>nrrdo2</name>
        <datatype>SCIRun::Nrrd</datatype>
      </port>
      <port>
        <name>nrrdo3</name>
        <datatype>SCIRun::Nrrd</datatype>
      </port>
    </outputs>
  </io>
  <gui>
  </gui>
  <testing>
  </testing>
</component>












