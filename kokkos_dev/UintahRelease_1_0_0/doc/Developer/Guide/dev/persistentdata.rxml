
<!--
   For more information, please see: http://software.sci.utah.edu

   The MIT License

   Copyright (c) 2004 Scientific Computing and Imaging Institute,
   University of Utah.

   License for the specific language governing rights and limitations under
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
-->


  <chapter id="dev.persistentdata">
    <title>Persistent Data</title>

    
      <para>
      This chapter explains how SCIRun reads and writes data to and
      from streams.
    </para>
    

    <section>
      <title>Introduction</title>

      <para>
     To maximize their usefulness, all software systems must be able
     to store data to disk at the end of execution, and retrieve that
     data later for additional processing.  As the SW system becomes
     larger and more complex, especially if numerous different groups
     are contributing to it, there needs to be a consistent, powerful,
     and straight forward strategy for performing this data storage
     and retrieval.  Core/Persistent encapsulates the SCIRun data
     storage and retrieval philosophy which attempts to provide such a
     solution to this problem.
    </para>

      <para>
     Core/Persistent provides a direct and uniform method for saving
     to disk the complex data structures used by SCIRun.  Through its
     use, a user can save and later retrieve data that is distributed
     across a large number of classes and sub-classes, and need not
     worry about manually handling dynamically allocated (and possibly
     cross referenced) memory.  
    </para>
    </section>

    <section>
      <title>Programming with SCIRun Persistent data</title>
      <para>
       Because most of the code added to SCIRun will use a large
       number of complex SCIRun data structures, it is necessary for
       the developer to be able to manage storing data in a consistent
       manner.  Core/Persistent provides this ability by specifying a
       set of routines that are implemented by each of the SCIRun data
       structures.  It also allows the user to implement these
       routines in his or her code and thus have a complete and
       consistent method of storing and retrieving data.
      </para>

      <para>
       Many module implementors will need to include routines in their
       module for saving to and retrieve data from disk. Software
       engineers who develop parts of the SCIRun core will also many
       times need to add routines to provide the IO for these Core
       codes.  By using Core/Persistent, programmers will be able to
       easily define routines to save the data specifically created by
       their codes as well as save the data stored in any of the
       SCIRun data structures that they use.
      </para>

      <para>
       Specifically, programmers will, for the most part, use the
       Core/Persistent paradigm in "Datatypes" files.  Programmers are
       also encouraged to use Core/Persistent for their own data
       structures for two reasons: 1) If their data structure is every
       used by other people (migrated to the "Datatypes" directory)
       then it will need to use Persistent.  2) Using Core/Persistent
       encourages the implementor to consider and provide for the
       ability to handle multiple "versions" of data files,
       transparently to the rest of the code.
      </para>

      <section>
        <title>Persistent Data</title>
	<para>
      Persistent Data is a general term for any data that will at some
      point need to be written to disk, and then, later, read back in
      for further processing.
    </para>
      </section>

      <section>
        <title>Persistent Object</title>
	<para>
      A Persistent Object is a specific instance of "Persistent Data"
      and include all SCIRun datatypes that have been subclassed from
      the Persistent class.  (Classes found in Core/Datatypes usually
      inherit from Class Datatype, which in turn inherits from
      Persistent.)  Persistent Objects have the ability to save and
      restore themselves from disk.  The data is stored on disk by
      specifying the "type" of object that created the data and
      version of that object.
    </para>
      </section>
      
      <section>
        <title>PersistentTypeID</title>

	<para>
      Each "Persistent Object" has an unique "type id".  This type id
      allows SCIRun to load the object back from disk by first,
      creating a "new" object of this type, and then telling the
      object to load its data.  "PersistentTypeID"s consist of a
      string representing the type (similar to the C++ character
      string that specifies the type), the parent class of the object,
      and the "maker" function that will be used to create new objects
      of this type.
    </para>
	<para>
      For templated types, the "type_name()" function is implemented.
      This function turns, for example, the type vector&lt;int&gt;, into the
      string, "vector&lt;int&gt;".  
    </para>
      </section>
      <section>
        <title>Maker Functions</title>
	<para>
      Maker functions are used to created a new Persistent Object.
      They are very straight forward consisting of code that
      allocates an object and then returns a pointer to the object.
    </para>
      </section>

      <section>
        <title>Pio Streams</title>
	<para>
      Pio Streams are used by Persistent Objects to read/write data
      from/to disk.  There are several types of Pio Streams, all of
      which inherit from the base class Piostream.  The subclasses of
      Piostream are: BinaryPiostream, TextPiostream, and
      GzipPiostream.  These correspond to binary output, text output,
      and zipped output.  (The type of output is usually set by the
      user at the time the data is to be written out.)
    </para>
      </section>

      <section>
        <title>Pio() versus io()</title>

	<para>
      Every persistent object has an a member function (and thus needs
      to implement) the io() function.  This function (an example is
      given below) implements the saving and loading of the data
      unique to that object.  The Pio() functions are not member
      functions.  They are defined for all data types and simply are
      used to start the saving of the data (see below.)
    </para>

      </section>
    </section>
    
    <section>
      <title>Examples</title>

      <para>
      In order to make a "Datatype" (or any data structure for that
      matter) persistent, you must follow these steps:
    </para>

      <para>
        <orderedlist>
          <listitem><para>
      Inherit from class Persistent (or from class Datatype.)
      </para>
	  </listitem>
	  <listitem><para>
      Add the following to your class:
      </para>
	    <programlisting>
 	 void    io(Piostream &amp;stream);
	 static  PersistentTypeID type_id;

         static const string type_name(int n = -1);
         virtual const string get_type_name(int n = -1) const;

       private:
         static Persistent *maker();
      </programlisting>
	  </listitem>
	</orderedlist>
    </para>

      <para>
      To save a persistent object, you simply create a persistent
      stream:
    </para>
      
      <programlisting>
      Piostream * stream = auto_istream( file_name );
    </programlisting>

      <para>
      Then you call the Pio function for the object, with the stream:
    </para>

      <programlisting>
      Pio( *stream, object );
    </programlisting>
      
      <para>
      The Pio() function will use the io() function provided by (or,
      in the case of built in types, provided for) the type.
    </para>

      <para>
      All Persistent objects need to define their current version:
    </para>

      <programlisting>

      // Pio defs.
      const int MY_CLASS_VERSION = 1;      
    </programlisting>

      <para>
      The version information can be used to successfully read in old
      data files.  Various "new" object data members can be defaulted
      to a reasonable value for these old data files.
    </para>

      <para>
      All Persistent objects must implement the io() function.  This
      is the function that will be called by Pio() to save/load the
      object.  This is an example io() function:
    </para>
      
      <programlisting>
      void 
      MyClass::io( Piostream &amp; stream )
      {
        // All input/ouptut starts with this line:
#IF THERE IS MORE THAN ONE VERSION
        int version = stream.begin_class("ColorMap", MY_CLASS_VERSION);
#ELSE IF YOU ONLY HAVE ONE VERSION CURRENTLY
        stream.begin_class( type_name().c_str(), MY_CLASS_VERSION );

	// Save/Load Base Class fields first:
	MyBaseClass::io( stream );

	if( version &gt; 1 ) {
	  Pio( stream, new_data_field_ );
        }

	// Save/Load individual fields:
	Pio( stream, my_data_ );
	Pio( stream, more_data_ );

	// All input/output ends with this line:
	stream.end_class();
      }
      </programlisting>
    </section>
  </chapter>


<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-default-dtd-file:"../../../Utilities/XML/docbook.ced"
sgml-omittag:nil
sgml-shorttag:nil
End:
-->
