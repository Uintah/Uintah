///////////////////////////////////////////////////////////////////////////////
// File: genColorMap.cc
//
// Description: Program to generate the minimal coloring of the Visible Human
//              Adjacency Map (generated by GE Research's auto-segmentation)
//              and assign a palette of colors to it.
//
// Inputs: AdjacencyMapping.csv -- formatted ASCII file containing the
//         adjacency information.
//
// Output: SCIRun ASCII colorMap '.cmap' file.
//
// Author: Stewart Dickson
///////////////////////////////////////////////////////////////////////////////

#include <math.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/times.h>

#include <Core/Geom/ColorMap.h>
#include <Core/Persistent/Pstreams.h>
#include <Core/Containers/HashTable.h>
#include <StandAlone/convert/FileUtils.h>
#if defined(__APPLE__)
#  include <Core/Datatypes/MacForceLoad.h>
#endif
#include <iostream>
#include <fstream>
#include <sstream>
#include <stdlib.h>
#include <vector>

#include <Packages/VS/Dataflow/Modules/DataFlow/labelmaps.h>

#include "libtrick.h"

using std::cout;
using std::ifstream;
using std::endl;
                                                                                
using namespace SCIRun;

int
main()
{
  int m,i,j,val;
  bool *valid;
  int *clique;
  int place;
  Dsatur graph;

  VH_AdjacencyMapping *adjacencymap;
  adjacencymap = new VH_AdjacencyMapping();
  // read the Visible Human Male segmentation adjacency map
  adjacencymap->readFile(
      "/home/dickson/Digital_Human_Work/FMAAtlas/AdjacencyMappingFMA.csv"
  //  "/Users/dickson/Digital_Human_Work/VS_atlas/csv/AdjacencyMapping.csv"
      );
  cout << "Adjacency Map file contains " << adjacencymap->get_num_names();
  cout << " entries" << endl;

  graph.adj = new (bool *)[adjacencymap->get_num_names()];
  graph.ColorAdj = new (int *)[adjacencymap->get_num_names()];
  valid = new bool[adjacencymap->get_num_names()];
  clique = new int[adjacencymap->get_num_names()];
  graph.ColorClass = new int[adjacencymap->get_num_names()];
  graph.Order = new int[adjacencymap->get_num_names()];
  graph.Handled = new bool[adjacencymap->get_num_names()];
  graph.ColorCount = new int[adjacencymap->get_num_names()];
                                                                               
  // allocate and initialize adjacency graph
  for (i=0;i<adjacencymap->get_num_names();i++)
  {
    graph.adj[i] = new bool[adjacencymap->get_num_names()];
     graph.ColorAdj[i] = new int[adjacencymap->get_num_names()];
    for (j=0;j<adjacencymap->get_num_names();j++) 
    {
      graph.adj[i][j] = false;
      graph.ColorAdj[i][j] = 0;
    }
  }

  m = 0;
  // convert the adjacency map to a graph table
  VH_Adj_to_adjTable(adjacencymap, graph.adj, &m);

  graph.num_node = adjacencymap->get_num_names();
  graph.prob_count = 0;

  // graph algorithm initialization
  for (i=0;i<graph.num_node;i++)
    for (j=0;j<graph.num_node;j++)
      if (graph.adj[i][j]) graph.ColorAdj[i][0]++;

  for (i=0;i<graph.num_node;i++)
    graph.ColorCount[i]=0;
  times(&graph.buffer);
  graph.start_time=graph.buffer.tms_utime;
  cout << "Adjecency Graph with " << graph.num_node << " nodes and ";
  cout << m << " edges" << endl;

  for (i=0;i < graph.num_node;i++)
    graph.Handled[i] = false;
  graph.BestColoring = graph.num_node+1;

  for (i=0;i<graph.num_node;i++) valid[i] = true;
  graph.best_clique = 0;
  graph.num_prob = 0;
  graph.max_prob = 10000;
   
  // find the maximum clique of the graph
  graph.lb = max_w_clique(&graph,valid,clique,0,graph.num_node);
  place = 0;

  // assign color indices to the graph
  for (i=0;i<graph.num_node;i++)
    {
      if (clique[i])
        {
          graph.Order[place] = i;
          graph.Handled[i] = true;
          place++;
          AssignColor(&graph,i,place);
          for (j=0;j<graph.num_node;j++)
            if ((i!=j)&&clique[j] && (!graph.adj[i][j]))
               cout << "Result is not a clique!\n";
           
        }
    }
   
  cout << "Lower bound is " << graph.lb << endl;
  if (graph.num_prob >=graph.max_prob) cout << " (not confirmed)\n";
  else cout << "\n";
  val = color(&graph,place,place);
  times(&graph.buffer);
  graph.current_time=graph.buffer.tms_utime;
   
  cout << "Best coloring has value " << val << ", subproblems: ";
  cout << graph.prob_count << " time: ";
  cout << (float)(graph.current_time-graph.start_time)/60.0 << "\n";

  // clean up after graph algorithm
  for (i=0;i<adjacencymap->get_num_names();i++)
  {
    delete [] graph.adj[i];
    delete [] graph.ColorAdj[i];
  }
  delete [] graph.adj;
  delete [] graph.ColorAdj;
  delete [] valid;
  delete [] clique;
  delete [] graph.Order;
  delete [] graph.Handled;
  delete [] graph.ColorCount;

  // build the color map for output
  int ncolors, palette_size;
  ncolors = graph.num_node;
  palette_size = val;
  vector<Color> rgb(ncolors);
  vector<float> rgbT(ncolors);
  vector<float> alphas(ncolors);
  vector<float> alphaT(ncolors);

  // assigned a pre-determined palette of
  // size = the minimal coloring of the graph
  vector<Color> palette(val);
  palette[0] = Color(1.0, 0.0, 1.0);
  palette[1] = Color(0.83, 0.0, 1.0);
  palette[2] = Color(0.67, 0.0, 1.0);
  palette[3] = Color(0.5, 0.0, 1.0);
  palette[4] = Color(0.33, 0.0, 1.0);
  palette[5] = Color(0.17, 0.0, 1.0);
  palette[6] = Color(0.0, 1.0, 1.0);
  palette[7] = Color(0.0, 0.83, 1.0);
  palette[8] = Color(0.0, 0.67, 1.0);
  palette[9] = Color(0.0, 0.5, 1.0);
  palette[10] = Color(0.0, 0.33, 1.0);
  palette[11] = Color(0.0, 0.17, 1.0);
  palette[12] = Color(0.0, 1.0, 1.0);
  palette[13] = Color(0.0, 1.0, 0.83);
  palette[14] = Color(0.0, 1.0, 0.67);
  palette[15] = Color(0.0, 1.0, 0.5);
  palette[16] = Color(0.0, 1.0, 0.33);
  palette[17] = Color(0.0, 1.0, 0.17);

  for (i=0; i<ncolors; i++)
  {
    cerr << "ColorClass[" << i << "](" << graph.ColorClass[i] << ")" << endl;
    Color clr(palette[graph.ColorClass[i]]);
    rgb[i]=clr;
    rgbT[i]=(float)i;
    alphas[i]=1.0;
    alphaT[i]=(float)i;

  } // end for (i=0; i<ncolors; i++)

  ColorMap *cm = new ColorMap(rgb, rgbT, alphas, alphaT);
  ColorMapHandle cmH(cm);

  string colormapName(
         "/home/dickson/Digital_Human_Work/FMAAtlas/AdjacencyMappingFMA.cmap"
         );
  TextPiostream out_stream(colormapName, Piostream::Write);
  Pio(out_stream, cmH);

  return 0;
} // end main()
