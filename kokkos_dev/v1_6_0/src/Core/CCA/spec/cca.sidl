version gov 0.0.0;
version cca 0.5.5;

package gov {
package cca {




/** Mapping of standard exceptional event types
 occuring in the Services interface to integers. 
*/
enum CCAExceptionType
{

   /** Someone caught a non-CCAException that was declared
       at an interface that claims it throws ONLY CCAException. 
    */
   Unexpected = -1,

   /** A CCAException that is carrying a non-standard message. */
   Nonstandard = 1,

   /** Action attempted on a port name that is neither registered
       nor added. 
    */
   PortNotDefined = 2,

   /** Adding/registering an already added/registered Port was
       attempted. 
    */
   PortAlreadyDefined = 3,

   /** Attempt to getPort, getPortNonblocking, or releasePort
       with a port named that is not connected. 
    */
   PortNotConnected = 4,

   /** Redundant attempt to release a Port. */
   PortNotInUse = 5,

   /** Attempt to unregister a Port that is still being used. */
   UsesPortNotReleased = 6,

   /** Port name given to createPortInfo is bogus. */
   BadPortName = 7,

   /** Port class/type given to createPortInfo is bogus. */
   BadPortType = 8,

   /** Port properties given to createPortInfo is bogus.
       Note: null is NOT a bogus input, but a fairly common one. */
   BadProperties = 9,

   /** PortInfo given in port add/register call is bogus or null. */
   BadPortInfo = 10,

   /** Services implementation failed to allocate memory. */
   OutOfMemory = 11,

   /** Port (or function within it) died on a remote error. */
   NetworkError = 12,

} // end enum CCAExceptionType



/* $Source$ */




/* # we're in cca core.  */















/** The CCA exception type definition.
 */
// Implementation Class
class CCAException  extends CIA.Throwable  {



  /** @return a member of the enumeration in CCAExceptionType. */
   CCAExceptionType getType() ;

  /** @return a (we hope) human parseable error. */
   string getMessage() ;

  /** Set the type of an exception. */
   void setType(in CCAExceptionType type) ;

  /** Set the string message in an exception. The method creates a copy
      for its own internal use. 
   */
   void setMessage(in string message) ;

}  // end interface CCAException

class Matrix
{
	double getElement(in int row, in int col);
	void setElement(in int row, in int col, in double val);
	int numOfRows();
	int numOfCols();
}



/* $Source$ */




/* # we're in cca core.  */














/** 
    This is an interface presented by a CCA-compliant framework to access its 
    application framing capabilities. Most of the manipulation of the 
    underlying framework is expected to be be done with the 
    gov.cca.BuilderService Port. This class exists as a sort of bootstrap 
    to get a Services object necessary to retrieve Port's, including 
    BuilderService, from the underlying framework. How the interface and 
    the underlying framework is created is entirely unspecified and is up 
    to the devices of the programmer and the framework provider.

    <p>Example</p>
    <p>
    Here it is assumed that an instance of AbstractFramework
    is created in the main() from some hypothetical implementation.
    The idea is to allow a complete swap of framework choice by 
    changing out the specified implementation class of a framework.
    </p>

    <code><pre>
    // java
    main() {
      cca.reference.Framework fwkimpl = new cca.reference.Framework();
      // change fwkimpl above to use different cca implementations when
      // AbstractFramework becomes part of the standard.
      gov.cca.AbstractFramework fwk = (gov.cca.AbstractFramework)fwkimpl;
      gov.cca.Services svc = 
          fwk.getServices("instance0","AppDriver",null);
      // From here on, access all services, components, etc
      // through svc.
      ...
      // when done
      fwk.releaseServices(svc);
      fwk.shutdownFramework();
    }

    // c++
    int functionName() {
      ::gov::sandia::ccafe::Framework fwkimpl;
      ::gov::cca::AbstractFrameworkPtr fwk;

      fwk = fwkimpl.getStandardFramework();
      ::gov::cca::Services_Interface * svc = 0;
      svc = fwk->getServices("instance0","AppDriver",0);
      // From here on, access all services, components, etc
      // through svc.
      ...
      // when done
      fwk->releaseServices(svc);
      svc = 0;
      fwk->shutdownFramework();

      // at scope exit, all memory is automatically cleaned up.
    }
    </pre></code>

  */
// abstract interface
interface AbstractFramework  
{

  /** Create an empty TypeMap. Presumably this would be used in 
      an ensuing call to getServices(). The "normal" method of
      creating typemaps is found in the Services interface. It
      is duplicated here to break the "chicken and egg" problem.
  */
   TypeMap createTypeMap() ;

  /** Retrieve a Services handle to the underlying framework. 
      This interface effectively causes the calling program to 
      appear as the image of a component inside the framework.
      This method may be called any number of times
      with different arguments, creating a new component image 
      each time. 
      The only proper method to destroy a Services obtained 
      from this interface is to pass it to releaseServices.

      @param selfInstanceName the Component instance name,
      as it will appear in the framework.

      @param selfClassName the Component type of the 
      calling program, as it will appear in the framework. 

      @param selfProperties (which can be null) the properties 
      of the component image to appear. 

      @throws CCAException in the event that selfInstanceName 
      is already in use by another component.

      @return  A Services object that pertains to the
               image of the this component. This is identical
	       to the object passed into Component.setServices() 
	       when a component is created.
   */
    Services getServices(in string selfInstanceName, in string selfClassName, in TypeMap selfProperties) throws CCAException ;

  // in the C++ binding,the services is released as a  
  // so that in the calling  the  becomes 0.
  /** Inform framework that the Services handle is no longer needed by the 
      caller and that the reference to its component image is to be
      deleted from the context of the underlying framework. This invalidates
      any ComponentID's or ConnectionID's associated with the given
      Services' component image. 

      @param svc The result of getServices earlier obtained.

      @throws CCAException if the Services handle has already been
	     released or is otherwise rendered invalid or was not
	     obtained from getServices.
   */
   void releaseServices(in Services svc) throws CCAException ;

  /** Tell the framework it is no longer needed and to clean up after itself. 
      @throws CCAException if the framework has already been shutdown.
   */  
   void shutdownFramework() ;

  /** Creates a new framework instance based on the same underlying 
      framework implementation. This does not copy the existing 
      framework, nor are any of the user-instantiated components in
      the original framework available in the newly created 
      AbstractFramework. 
      @throws CCAException may be thrown when the following conditions occur:
        the AbstractFramework previously had shutdownFramework() called on it,
	the underlying framework implementation does not permit creation 
	of another instance.

   */
   AbstractFramework createEmptyFramework() ;

   /** start to share the CCA components with other CCA frameworks by
      1. broadcasting its own framework URL
      2. listening to other frameworks' broadcasting
      3. query the CCA components set availabe in other framewors.	 				
   */	
   void share(in gov.cca.Services svc);
 
   /** This one is in test for distributed computing
      
   */	 
   string createComponent(in string name, in string type);

}  // end interface AbstractFramework







/* # we're in cca core.  */















/** The CCA object model: the interface that all CCA components must implement. */
// abstract interface
interface Component  
{

  /** Obtain Services handle, through which the component and framework communicate.  
      This is the one method that every CCA Component must implement. 
      Every component must also implement a NULL constructor.
   */
   void setServices(in Services svc) ;

}  // end interface Component



/* $Source$ */



/* # we're in cca core.  */















/** An opaque reference to a Component. */
// abstract interface
interface ComponentID  
{

  /** Returns the instance name provided in 
      BuilderService.createInstance()
      or in
      AbstractFramework.getServices().
      @throws CCAException if ComponentID is invalid.
   */
   string getInstanceName() throws CCAException ;

  /** Returns a framework specific serialization of the ComponentID.
      @throws CCAException if ComponentID is invalid.
   */
   string getSerialization() throws CCAException ;

}  // end interface ComponentID



/* $Source$ */




/* # we're in cca core.  */














/**
  This interface describes a CCA connection between components.
  A connection is made at the users direction
  when one component provides a Port that another component
  advertises for and uses.  The components are referred to by their
  opaque ComponentID references and the Ports are referred to
  by their string instance names.
 */
// abstract interface
interface ConnectionID  
{

  /** Get the providing component (callee) ID.
      @return the ComponentID of the component that has 
        provided the Port for this connection. 
      @throws a CCAException if the underlying connection is no longer valid.
   */
   ComponentID getProvider() throws CCAException ;

  /** Get the using component (caller) ID.
     @return the ComponentID of the component that is using the provided Port.
     @throws a CCAException if the underlying connection is no longer valid.
   */
   ComponentID getUser() throws CCAException ; 

  /** Get the port name in the providing component of this connection.
      @return the instance name of the provided Port.
      @throws CCAException if the underlying connection is no longer valid.
    */
   string getProviderPortName() throws CCAException ; 

  /** Get the port name in the using component of this connection.
      @return the instance name of the Port registered for use in 
        this connection.
      @throws CCAException if the underlying connection is no longer valid.
   */
   string getUserPortName() throws CCAException ; 

}  // end interface ConnectionID



/* $Source$ */





/* # we're in cca core.  */














/** A tag interface to identify an interface capable of being exported to
    or imported from a CCA component.
    @see Services
 */
// abstract interface
interface Port  
{
}  // end interface Port



/* $Source$ */

    
  

  /** Mapping of sidl/java primitive types and arrays to
   occuring in the TypeMap interface to integers. 
   */
  enum Type {
    /** Undefined primitive type. includes things like
        long double, short, unsigned, char, etc that are C-isms.
     */
    None = -1,

    /** A signed, 32 bit int. */
    Int = 1,

    /** A signed, 64 bit int. */
    Long = 2,

    /** A 32 bit floating point number. */
    Float = 3,

    /** A 64 bit floating point number. */
    Double = 4,

    /** A 32x2 bit complex float number, a_f + b_f*i. */
    Fcomplex = 5,

    /** A 64x2 bit complex float number, a_d + b_d*i. */
    Dcomplex = 6,

    /** A string, in the language native representation. */
    String = 7,

    /** A boolean value in the language native representation. */
    Bool = 8,

    /** An array of Int */
    IntArray = 21,

    /** An array of Long */
    LongArray = 22,

    /** An array of Float */
    FloatArray = 23,

    /** An array of Double */
    DoubleArray = 24,

    /** An array of Fcomplex */
    FcomplexArray = 25,

    /** An array of Dcomplex */
    DcomplexArray = 26,

    /** An array of String  */
    StringArray = 27,

    /** An array of Bool */
    BoolArray = 28,

} // end enum Type



/* $Source$ */




/* # we're in cca core.  */














/** The CCA typemismatch definition.
    Not to be confused with a PortType mismatch or class mismatch.
 */
// Implementation Class
class TypeMismatchException  extends CCAException   {

  // new in this interface

  /** @return the enumerated value Type sought. */
   Type getRequestedType() ;

  /** @return the enumerated Type of the value actually found. */
   Type getActualType() ;


  // inherited from CCAExceptionType

  /** @return a member of the enumeration in CCAExceptionType. */
   CCAExceptionType getType() ;

  /** @return a (we hope) human parseable error. */
   string getMessage() ;

  /** Set the type of an exception. */
   void setType(in CCAExceptionType type) ;

  /** Set the string message in an exception. The method creates a copy
      for its own internal use. 
   */
   void setMessage(in string message) ;

}  // end interface TypeMismatchException



/* $Source$ */





/* # we're in cca core.  */














/** A CCA map.  Maps a string key to a particular value. Types are
    strictly enforced.  For example, values places into the map
    using putInt can be retrieved only using getInt.  Calls to
    getLong, getString, getIntArray and other get methods will
    fail (i.e. return the default value) if the value stored is of type Int.
 */
// abstract interface
interface TypeMap 
{

  /** Create an exact copy of this Map */
   TypeMap cloneData() ;

  /** Create a new Map with no key/value associations. */
   TypeMap cloneEmpty() ;

  /** Get the Int value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   int      getInt(in string key, in int defaultValue) throws TypeMismatchException ;

  /** Get the Long value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   long     getLong(in string key, in long defaultValue) throws TypeMismatchException ;

  /** Get the Float value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   float    getFloat(in string key, in float defaultValue) throws TypeMismatchException ;

  /** Get the Double value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   double   getDouble(in string key, in double defaultValue) throws TypeMismatchException ;

  /** Get the Fcomplex value associated with a given key.  If the key
      was not found, return complex the value defaultValue. */
   fcomplex getFcomplex(in string key, in fcomplex defaultValue) throws TypeMismatchException ;

  /** Get the Dcomplex value associated with a given key.  If the key
      was not found, return the complex value defaultValue. */
   dcomplex getDcomplex(in string key, in dcomplex defaultValue) throws TypeMismatchException ;

  /** Get the string value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   string  getString(in string key, in string defaultValue) throws TypeMismatchException ;

  /** Get the boolean value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   bool  getBool(in string key, in bool defaultValue) throws TypeMismatchException ;

    // ======================================================

  /** Get the value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   array<int> getIntArray(in string key, in array<int> defaultValue) throws TypeMismatchException ;

  /** Get the value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   array<long> getLongArray(in string key, in array<long> defaultValue) throws TypeMismatchException ;

  /** Get the value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   array<float>    getFloatArray(in string key, in array<float> defaultValue) throws TypeMismatchException ;

  /** Get the value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   array<double> getDoubleArray(in string key, in array<double> defaultValue) throws TypeMismatchException ;

  /** Get the complex value associated with a given key.  If the key
      was not found, return the complex value defaultValue. */
   array<fcomplex> getFcomplexArray(in string key, in array<fcomplex> defaultValue) throws TypeMismatchException ;

  /** Get the complex value associated with a given key.  If the key
      was not found, return the complex value defaultValue. */
   array<dcomplex> getDcomplexArray(in string key, in array<dcomplex> defaultValue) throws TypeMismatchException ;

  /** Get the value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   array<string> getStringArray(in string key, in array<string> defaultValue) throws TypeMismatchException ;

  /** Get the value associated with a given key.  If the key
      was not found, return the value defaultValue. */
   array<bool> getBoolArray(in string key, in array<bool> defaultValue) throws TypeMismatchException ;


    // ======================================================
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten.  */
   void putInt(in string key, in int value) ;
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten.  */
   void putLong(in string key, in long value) ;
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten.  */
   void putFloat(in string key, in float value) ;
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten.  */
   void putDouble(in string key, in double value) ;
    
  /** Assign a key and complex value.
      Any complex value previously assigned will be overwritten.  */
   void putFcomplex(in string key, in fcomplex value) ;
    
  /** Assign a key and complex value. 
      Any complex value previously assigned will be overwritten. */
   void putDcomplex(in string key, in dcomplex value) ;
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten.  */
   void putString(in string key, in string value) ;
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten.  */
   void putBool(in string key, in bool value) ;

    // ======================================================
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten. Arrays are stored
      by COPY, not by reference. */
   void putIntArray(in string key, in array<int> value ) ;
  
  
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten. Arrays are stored
      by COPY, not by reference. */
   void putLongArray(in string key, in array<long> value ) ;
  
  
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten. Arrays are stored
      by COPY, not by reference. */
   void putFloatArray(in string key, in array<float> value ) ;
  
  
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten. Arrays are stored
      by COPY, not by reference. */
   void putDoubleArray(in string key, in array<double> value ) ;
  
  
    
  /** Assign a key and complex array value. Any value previously assigned
      to the same key will be overwritten. complex arrays are stored by COPY.*/
   void putFcomplexArray(in string key, in array<fcomplex> value ) ;
  
  
    
  /** Assign a key and complex array value. Any value previously assigned
     to the same key will be overwritten. Complex arrays are stored by COPY. */
   void putDcomplexArray(in string key, in array<dcomplex> value ) ;
  
  
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten. Arrays are stored
      by COPY, not by reference. */
   void putStringArray(in string key, in array<string> value) ;
    
  /** Assign a key and value. Any value previously assigned
      to the same key will be overwritten. Arrays are stored
      by COPY, not by reference. */
   void putBoolArray(in string key, in array<bool> value ) ;
  
  

    // ======================================================

  /** Make the key and associated value disappear from the object. */
   void remove (in string key) ;

  /** Get all the names associated with a particular type
      without exposing the data implementation details.  The keys
      will be returned in an arbitrary order. If type specified is
      None (no specification) all keys of all types are returned.
  */
   array<string> getAllKeys(in Type t) ;

  /** Return true if the key exists in this map */
   bool hasKey(in string key) ;

  /** Return the type of the value associated with this key */
   Type typeOf(in string key) ;

}  // end interface TypeMap



/* $Source$ */





/* # we're in cca core.  */














/** The handle through which the component communicates with its
    containing context and (indirectly) other components. 
*/
// abstract interface
interface Services  
{
  /** Fetch a previously registered Port (defined by either 
      addProvidePort or (more typically) registerUsesPort).  
    @return Will return the Port (possibly waiting forever while
    attempting to acquire it) or throw an exception. Does not return
    NULL, even in the case where no connection has been made. 
    If a Port is returned,
    there is then a contract that the port will remain valid for use
    by the caller until the port is released via releasePort(), or a 
    Disconnect Event is successfully dispatched to the caller,
    or a runtime exception (such as network failure) occurs during 
    invocation of some function in the Port. 
    <p>
    Subtle interpretation: If the Component is not listening for
    Disconnect events, then the framework has no clean way to
    break the connection until after the component calls releasePort.
    </p>
    <p>The framework may go through some machinations to obtain
       the port, possibly involving an interactive user or network 
       queries, before giving up and throwing an exception.
    </p>

    @param name The previously registered or provide port which
           the component now wants to use.
    @exception CCAException with the following types: NotConnected, PortNotDefined, NetworkError, OutOfMemory.

   */
    Port getPort(in string portName) throws CCAException ;

  /** Get a previously registered Port (defined by
    either addProvide or registerUses) and return that
    Port if it is available immediately (already connected
    without further connection machinations).
    There is an contract that the
    port will remain valid per the description of getPort.
    @return The named port, if it exists and is connected or self-provided,
            or NULL if it is registered and is not yet connected. Does not
            return if the Port is neither registered nor provided, but rather
            throws an exception.
    @param name registered or provided port that
           the component now wants to use.
    @exception CCAException with the following types: PortNotDefined, OutOfMemory.
  */
    Port getPortNonblocking(in string name) throws CCAException ;

  /** Notifies the framework that this component is finished 
      using the previously fetched Port that is named.     
      The releasePort() method calls should be paired with 
      getPort() method calls; however, an extra call to releasePort()
      for the same name may (is not required to) generate an exception.
      Calls to release ports which are not defined or have never be fetched
      with one of the getPort functions generate exceptions.
      @param name The name of a port.
      @exception CCAException with the following types: PortNotDefined, PortNotInUse.
   */
   void releasePort(in string name) throws CCAException ;

  /** Creates a TypeMap, potentially to be used in subsequent
      calls to describe a Port. Initially, the map is empty.
  */
   TypeMap createTypeMap() throws CCAException ;

  /** Register a request for a Port that will be retrieved subsequently 
      with a call to getPort().
      @param name A string uniquely describing this port.  This string
      must be unique for this component, over both uses and provides ports.
      @param type A string desribing the type of this port.
      @param properties A TypeMap describing optional properties
      associated with this port. This can be a null pointer, which
      indicates an empty list of properties.  Properties may be
      obtained from createTypeMap or any other source.  The properties
      be copied into the framework, and subsequent changes to the
      properties object will have no effect on the properties
      associated with this port.
      In these properties, all frameworks recognize at least the
      following keys and values in implementing registerUsesPort:
      <pre>
      key:              standard values (in string form)     default
      "MAX_CONNECTIONS" any nonnegative integer, "unlimited".   1
      "MIN_CONNECTIONS" any integer > 0.                        0
      "ABLE_TO_PROXY"   "true", "false"                      "false"
      </pre>
      The component is not expected to work if the framework
      has not satisfied the connection requirements.
      The framework is allowed to return an error if it
      is incapable of meeting the connection requirements,
      e.g. it does not implement multiple uses ports.
      The caller of registerUsesPort is not obligated to define
      these properties. If left undefined, the default listed above is
            assumed.
      @exception CCAException with the following types: PortAlreadyDefined, OutOfMemory.
   */
   void registerUsesPort(in string name, in string type, in TypeMap properties) throws CCAException ;

  /** Notify the framework that a Port, previously registered by this
      component but currently not in use, is no longer desired. 
      Unregistering a port that is currently 
      in use (i.e. an unreleased getPort() being outstanding) 
      is an error.
      @param name The name of a registered Port.
      @exception CCAException with the following types: UsesPortNotReleased, PortNotDefined.
   */
   void unregisterUsesPort(in string name) throws CCAException ;

  /** Exposes a Port from this component to the framework.  
      This Port is now available for the framework to connect 
      to other components. 
      @param inPort An abstract interface (tagged with CCA-ness
              by inheriting from gov.cca.Port) the framework will
              make available to other components.

      @param name string uniquely describing this port.  This string
      must be unique for this component, over both uses and provides ports.

      @param type string describing the type (class) of this port.

      @param properties A TypeMap describing optional properties
      associated with this port. This can be a null pointer, which
      indicates an empty list of properties.  Properties may be
      obtained from createTypeMap or any other source.  The properties
      be copied into the framework, and subsequent changes to the
      properties object will have no effect on the properties
      associated with this port.
      In these properties, all frameworks recognize at least the
      following keys and values in implementing registerUsesPort:
      <pre>
      key:              standard values (in string form)     default
      "MAX_CONNECTIONS" any nonnegative integer, "unlimited".   1
      "MIN_CONNECTIONS" any integer > 0.                        0
      "ABLE_TO_PROXY"   "true", "false"                      "false"
      </pre>
      The component is not expected to work if the framework
      has not satisfied the connection requirements.
      The framework is allowed to return an error if it
      is incapable of meeting the connection requirements,
      e.g. it does not implement multiple uses ports.
      The caller of addProvidesPort is not obligated to define
      these properties. If left undefined, the default listed above is
      assumed.
      @exception CCAException with the following types: PortAlreadyDefined, OutOfMemory.
   */
   void addProvidesPort(in Port inPort, in string name, in string type, in TypeMap properties) throws CCAException ;

  /** Returns the public list of the properties for a Port.  This
      includes the properties defined when the port was registered
      (these properties can be modified by the framework), two special
      properties "cca.portName" and "cca.portType", and any other
      properties that the framework wishes to disclose to the component.
      The framework may also choose to provide only the subset of input
      properties (i.e. from addProvidesPort/registerUsesPort) that it
      will honor. 
      @throws CCAException if invalid portName.
  */
   TypeMap getPortProperties(in string portName)  throws CCAException ;


  /** Notifies the framework that a previously exposed Port is no longer 
      available for use. The Port being removed must exist
      until this call returns, or a CCAException may occur.
      @param name The name of a provided Port.
      @exception PortNotDefined. In general, the framework will not dictate 
      when the component chooses to stop offering services.
   */
   void removeProvidesPort(in string name) throws CCAException ;

  /** Get a reference interface for the component to which 
      this Services object belongs.
      @return The ComponentID uniquely paired with this component.
   */
   ComponentID getComponentID() ;

}  // end interface Services



/* $Source$ */

// BEGIN proposed sparker
interface ComponentClassDescription {
  string getClassName();
  string getModelName();
}
// END proposed sparker

#if 0
} // end package cca
} // end package gov

/* $Source$ */

/* SIDL BINDING - generated CCA file. do not edit. */
version gov 0.0.0;
version cca 0.5.5;
version ports 0.0.2;

package gov {
package cca {
#endif

package ports {



/* # cca */
/* # cca spec mappings */

/** 
 ComponentRepository is a Port implemented by a CCA compliant framework 
 or other component to expose in a standard way:<ol>
 <li>immediately instantiable component classes.
 <li>component class property maps. 
 <li>the operations used to obtain more component classes at runtime.
 </ol>

 */
    
// abstract interface
interface ComponentRepository  extends gov.cca.Port
{


  // ----------------------------------------------------
  // 1 available classes.

  /** Collect the currently obtainable class name strings from
      factories known to the builder and the from the
      already instantiated components.
      @return The list of class description, which may be empty, that are
       known a priori to contain valid values for the className
       argument of createInstance. 
      @throws CCAException in the event of error.
   */
   array<gov.cca.ComponentClassDescription> getAvailableComponentClasses() throws gov.cca.CCAException ;


//this section gone until further discussion
  // ----------------------------------------------------
  // 2 Class properties,as with port,component,connection.

  /** Get class properties, if any, stored by the framework.
      One key with a standard definition, if present, is 
      cca.classURI, a string value of the URI the class was loaded from.
      @return map of properties. possibly empty.
      @throws CCAException if className is unknown.
   */
   gov.cca.TypeMap getClassProperties(in string className) throws gov.cca.CCAException ;

  /** Set class properties.
      @throws CCAException if className is unknown or some property
      that is locked has a change attempted or map is invalid.
   */
   void setClassProperties(in string className, in gov.cca.TypeMap properties) throws gov.cca.CCAException ;

  // ------------------------------------------------------
  // 3 creating/destroying classes at runtime.

  /** Collect the string names of classes with known locations but not
      presently loaded. That is check "in-memory" repository data but do not
      invoke remote access interfaces to find more classes.
   */
   array<string> getLoadableComponentClasses() throws gov.cca.CCAException ;

  /** Load a class from the given URI.
      @param timeout the time to wait while attempting to obtain a class, or 0
             to use the loaders default wait.
      @param properties initial properties to assign to component, in 
             addition to any it may come with. Two properties in 
	     particular have standard meanings
	     if present (and supported by os and framework):
	     <pre>
	     name		type	default		meaning
	     cca.LoadLazy 	bool	false	Runtime link resolves as 
	                                        needed(lazy) or immediately.
	     cca.LoadGlobal 	bool	false	Runtime link adds loaded 
	                                        symbols to global table or 
						in private symbol table.
	     </pre>
      @throws CCAException if timeout exceeded or class not loadable 
      for any reason.
   */
   void loadClass(in string uri, in float timeout, in gov.cca.TypeMap componentProperties) throws gov.cca.CCAException ;


  /** Unload a class, if there are no instances of it in existence and
      the framework can be sure this is the case and the class 
      was dynamically loaded.
      @throws CCAException if named class not unloadable for any reason.
   */
   void unloadClass(in string className) throws gov.cca.CCAException ;


  /** Hunt for new classes, possibly remotely.
     @param repositoryURIs the locations in which to search.
     @param timeout the time after which to give up, or 0 to use the 
             framework's default. The timeout is per-repositoryURI-element.
     @return string uris of the classes found at the given repositories.
     @throws CCAException if any of numerous possible errors occur.
   */
   array<string> findComponentClasses(in array<string> repositoryURIs , in float timeout) throws gov.cca.CCAException ;

}  // end interface ComponentRepository



/* $Source$ */




/* # cca */
/* # cca spec mappings */

/** 
BuilderService is a Port implemented by a CCA compliant framework for
 the purpose of composing components into applications in a standard way.
 It is meant to expose the Component creation and composition functionality
 without the specific framework implementation. This interface is expected 
 to be useful for rapid application development in a scripting language. 
 Other uses are generic application development environments for CCA 
 applications. 
 <p>Each of the fundamental component architecture pieces
    (instances of Component, Port, and Connection) may have
    an associated TypeMap of properties managed by the framework.
    The standardized keys in the properties of a Port are documented
    in Services.getPortProperties().
    The standardized keys in the properties of a Component and Connection
    are documented below.
  </p>
  <p>For connection, thus far:
    <pre>
    Key		value		meaning
    cca.isInUse	boolean		true if there have been more successful
                                getPort than releasePort calls for the
				connection at the the time 
				properties were fetched.
   </pre>
   </p>
  <P>For component, thus far:
   <pre>
    Key			value		meaning
    cca.className	string		component type
   </pre>
  </p>
 */
// abstract interface
interface BuilderService  extends gov.cca.Port
{

  // ---------------------------------------------------------------
  // component instance creation/destruction/property configuration

  /**
      Creates an instance of a CCA component of the type defined by the 
      string className.  The string classname uniquely defines the
      "type" of the component, e.g.
          doe.cca.Library.GaussianElmination. 
      It has an instance name given by the string instanceName.
      The instanceName may be empty (zero length) in which case
      the instanceName will be assigned to the component automatically.
      @throws CCAException If the Component className is unknown, or if the
              instanceName has already been used, a CCAException is thrown.
      @return A ComponentID corresponding to the created component. Destroying
              the returned ID does not destroy the component; 
              see destroyInstance instead.
   */
   gov.cca.ComponentID createInstance(in string className, in string instanceName,
		 in gov.cca.TypeMap properties, in string frameworkURL) throws gov.cca.CCAException ; 

  /** Get component list.
      @return a ComponentID for each component currently created.
   */
   array<gov.cca.ComponentID> getComponentIDs() throws gov.cca.CCAException ; 

  /** Get property map for component.
    @return the public properties associated with the component referred to by
    ComponentID. 
    @throws a CCAException if the ComponentID is invalid.
   */
   gov.cca.TypeMap getComponentProperties(in gov.cca.ComponentID cid) throws gov.cca.CCAException ;

  /**
      Causes the framework implementation to associate the given properties 
      with the component designated by cid. 
      @throws CCAException if cid is invalid or if there is an attempted
      change to a property locked by the framework implementation.
   */
   void setComponentProperties(in gov.cca.ComponentID cid, in gov.cca.TypeMap map) throws gov.cca.CCAException ;

  /** Get component id from stringified reference.
      @return a ComponentID from the string produced by 
       ComponentID.getSerialization(). 
      @throws CCAException if the string does not represent the appropriate 
        serialization of a ComponentID for the underlying framework.
  */
   gov.cca.ComponentID getDeserialization(in string s) throws gov.cca.CCAException ;

  /** Get id from name by which it was created.
      @return a ComponentID from the instance name of the component
        produced by ComponentID.getInstanceName().
      @throws CCAException if there is no component matching the 
        given componentInstanceName.
  */
   gov.cca.ComponentID getComponentID(in string componentInstanceName) throws gov.cca.CCAException ;

   /** 
       Eliminate the Component instance, from the scope of the framework.
       @param toDie the component to be removed.
       @param timeout the allowable wait; 0 means up to the framework.
       @throws CCAException if toDie refers to an invalid component, or
              if the operation takes longer than timeout seconds.
    */
   void destroyInstance(in gov.cca.ComponentID toDie, in float timeout ) throws gov.cca.CCAException ;

  // ---------------------------------------------------------------
  // the following methods manipulate and obtain information about ports:

  /** Get the names of Port instances provided by the identified component.
       @param cid the component.
       @throws CCAException if cid refers to an invalid component.
   */
   array<string> getProvidedPortNames(in gov.cca.ComponentID cid) throws gov.cca.CCAException ; 

  /** Get the names of Port instances used by the identified component.
      @param cid the component.
      @throws CCAException if cid refers to an invalid component. 
   */
   array<string> getUsedPortNames(in gov.cca.ComponentID cid) throws gov.cca.CCAException ; 

  /** Fetch map of Port properties exposed by the framework.
    @return the public properties pertaining to the Port instance 
      portname on the component referred to by cid. 
    @throws CCAException when any one of the following conditions occur:<ul>
      <li>portname is not a registered Port on the component indicated by cid,
      <li>cid refers to an invalid component. </ul>
   */
   gov.cca.TypeMap getPortProperties(in gov.cca.ComponentID cid, in string portname) throws gov.cca.CCAException ;

  /** Associates the properties given in map with the Port indicated by 
      portname. The component must have a Port known by portname.
      @throws CCAException if either cid or portname are
        invalid, or if this a changed property is locked by 
        the underlying framework or component.
  */
   void setPortProperties(in gov.cca.ComponentID cid, in string portname, in gov.cca.TypeMap map) throws gov.cca.CCAException ;

  /**
     Creates a connection between ports on component user and 
     component provider. Destroying the ConnectionID does not
     cause a disconnection; for that, see disconnect().
     @throws CCAException when any one of the following conditions occur:<ul>
     <li>If either user or provider refer to an invalid component,
     <li>If either usingPortName or providingPortName refer to a 
       nonexistent Port on their respective component,
     <li>If other-- In reality there are a lot of things that can go wrong 
       with this operation, especially if the underlying connections 
       involve networking.</ul>
  */
   gov.cca.ConnectionID connect(in gov.cca.ComponentID user, in string usingPortName, in gov.cca.ComponentID provider, in string providingPortName) throws gov.cca.CCAException ; 

  /** Returns a list of connections as an array of 
      handles. This will return all connections involving components 
      in the given componentList of ComponentIDs. This
      means that ConnectionID's will be returned even if only one 
      of the participants in the connection appears in componentList.

      @throws CCAException if any component in componentList is invalid.
   */
   array<gov.cca.ConnectionID> getConnectionIDs(in array<gov.cca.ComponentID> componentList) throws gov.cca.CCAException ; 

  /**
      Fetch property map of a connection.
      @returns the properties for the given connection.
      @throws CCAException if connID is invalid.
    */
   gov.cca.TypeMap getConnectionProperties(in gov.cca.ConnectionID connID) throws gov.cca.CCAException ;

  /** Associates the properties with the connection.
      @param map the source of the properties.
      @param connID connection to receive property values.
      @throws CCAException if connID is invalid, or if this changes 
        a property locked by the underlying framework.
  */
   void setConnectionProperties(in gov.cca.ConnectionID connID, in gov.cca.TypeMap map) throws gov.cca.CCAException ;

  /** Disconnect the connection indicated by connID before the indicated
      timeout in secs. Upon successful completion, connID and the connection
      it represents become invalid. 
      @param timeout the time in seconds to wait for a connection to close; 0
      means to use the framework implementation default.
      @throws CCAException when any one of the following conditions occur: <ul>
        <li>id refers to an invalid ConnectionID,
        <li>timeout is exceeded, after which, if id was valid before 
        disconnect() was invoked, it remains valid
     </ul>
     .
  */
   void disconnect(in gov.cca.ConnectionID connID, in float timeout) throws gov.cca.CCAException ; 

  /** Remove all connections between components id1 and id2 within 
      the period of timeout secs. If id2 is null, then all connections 
      to id1 are removed (within the period of timeout secs).
      @throws CCAException when any one of the following conditions occur:<ul>
          <li>id1 or id2 refer to an invalid ComponentID (other than id2 == null),
          <li>The timeout period is exceeded before the disconnections can be made. 
	  </ul>
  */
   void disconnectAll(in gov.cca.ComponentID id1, in gov.cca.ComponentID id2, in float timeout) throws gov.cca.CCAException ; 

   // BEGIN proposed sparker/kzhang
   /* get available ports in c2 that can be connected to port1 of c1*/ 	
   array<string> getCompatiblePortList(in gov.cca.ComponentID c1,
				       in string port1,
				       in gov.cca.ComponentID c2);

   void registerFramework(in string frameworkURL); 	
   void registerServices(in gov.cca.Services svc);
   AbstractFramework getFramework();
   // END Proposed sparker


}  // end interface BuilderService



/* $Source$ */


/* # cca */
/* # cca spec mappings */

/** A do-it port.  Tremendously useful. Provided by components 
    to advertise that they can do some arbitrary thing. 
    A component may provide more than one of these under
    different names (via delegation). More detailed forms
    of this include TimeAdvance, etc.
 */
// abstract interface
interface GoPort  extends gov.cca.Port
{  


  /** Make the component do its thing.
   * @return
   * <ul>
   * <li> 0 if did ok</li>
   * <li> -1 if had problem,</li>
   * <li> -2 if had problem bad enough to shoot
   *  the component in the head or exit the framework.</li> 
   * </ul>
   */
   int go() ;

}  // end interface GoPort

//abstract interface 
interface UIPort extends gov.cca.Port
{
	//return 0 for success, -1 for fatal error, other values for others errors
	int ui();
}

//abstract interface 
interface BuilderPort extends gov.cca.Port
{
	/** The builder port is designed for the Builder only
	 *  There is only one port for convenience.
	 *  All final modification should be done through 
	 *  the BuilderService and the BuilderService will tranverse
	 *  each Builder
	 */
	void buildRemotePackageMenus(in gov.cca.ports.ComponentRepository reg, in string frameworkURL); 	

}


//abstract interface
interface ZListPort extends gov.cca.Port
{
	array<double> getList();
}
/* $Source$ */



//abstract interface 
interface Field2DPort extends gov.cca.Port
{
	//provides a interface to 
	array<double> getField();
}

//abstract interface 
interface PDEDescriptionPort extends gov.cca.Port
{
	//provides a interface to 
	array<double> getNodes();
	array<int> getBoundaries();
	array<int> getDirichletNodes();
	array<double> getDirichletValues();
}

//abstract interface 
interface MeshPort extends gov.cca.Port
{
	//provides a interface to 
	array<int> getTriangles();
	array<double> getNodes();
}


//abstract interface 
interface PDEMatrixPort extends gov.cca.Port
{
	//provides a interface to 
	Matrix getMatrix();
	array<double> getVector();
}


/* # cca */
/* # cca spec mappings */

  /** There are 4 basic events to do with connections. They form
     a subset of the events in the component lifecycle. */
  enum Type {
  /** never delivered to a listener, but used by listeners to subscribe broadly. */
  ALL = 0, 

  /** a connection may soon be made. */
  ConnectPending = 1, 

  /** a connection has been made. */
  Connected = 2,

  /** a connection will soon be broken. */
  DisconnectPending = 3,
 
  /** a connection has been broken. */
  Disconnected = 4,
  } // end enum 

/** Base event interface components wishing to know about their connectedness
(used or provided ports) must listen for. 
This interface represents a large simplification and callback
style imposed over the general EventService layer.
This interface contains only enough information to be useful
in the scope of the particular Component instance receiving
the event.
*/
// abstract interface
interface ConnectionEvent 
{


  /** Returns the integer from those defined above
      in Type that describes the connection event.
      At present there are 4 of these.
      <p>
      The semantics are noted before
      each member of the enum/static constant. We can add in different
      types of connect/disconnect as multiports and
      explicit local/global/sync/async semantics are agreed to in the future.
      </p>

      <p>
      At present we assume that:
      <ul>
      <li> all instances in a component cohort (often thought of as a single
        "parallel component") receive all the events
        and in the same order, but not necessarily globally synchronously.</li>
      <li> for disconnections, within a process the events are delivered first
        to the using component then to the providing component.</li>
      <li> for connections, within a process the events are delivered first
        to the providing component then to the using component.</li>
      </ul>

      Clearly some of the assumptions above may not suit a component
      instance in which multiple execution threads act on a
      single instance of the gov::cca::Services object (SMP). The Services
      specification is ambiguous as to whether such a component is even allowed.
      When this is clarified, additional members of the enum may arise,
      in which case the assumptions here apply only to
      ConnectPending, Connected, DisconnectPending, Disconnected types.

  */
   Type getEventType() ;

  /** Get the properties of the affected Port.
      Among the standard properties are the name and type info. */
   gov.cca.TypeMap getPortProperties() ;

}  // end interface ConnectionEvent





/* $Source$ */

/* # cca */
/* # cca spec mappings */
// requires import gov.cca.ports




/** This is the interface that a component must provide
in order to be notified of ConnectionEvents. */
// abstract interface
interface ConnectionEventListener 
{

  /** Delivered to listeners when a connection is made or broken. */
   void connectionActivity(in ConnectionEvent evt) ;

}  // end interface ConnectionEventListener



/* $Source$ */

/* # cca */
/* # cca spec mappings */
// requires import gov.cca.ports





/** A callback service to alert a component when connections are made 
    or broken; this service is to be 
    immediately available during a setServices call. This service 
    interface is compatible with a direct-connected or proxy framework.
    @see Component 
*/
// abstract interface
interface ConnectionEventService  extends gov.cca.Port
{
  /** Sign up to be told about connection activity.
      @param connectionEventType must be one of the integer values 
             ALL, ConnectPending, Connected, DisconnectPending, Disconnected
             as defined in @see ContainerEventType. 
             ALL means listening to all of the other four listed here.
      @param l, an object (this component or its delegate) that listens
             by implementing the ConnectionEventListener callback.
   */
   void addConnectionEventListener(in Type type, in ConnectionEventListener l) ;

  /** Ignore future ConnectionEvents of the given type.
      Removing a non-added listener is not an error. 
      @param connectionEventType must be one of the integer values defined in
             addConnectionEventListener.
      @param l, a previously added listener interface.
   */
   void removeConnectionEventListener(in Type type, in ConnectionEventListener l) ;

}  // end interface ConnectionEventService



/* $Source$ */


// BEGIN proposed sparker
// Builder events
// Component created
// Component destroyed
// Component moved
// Connection created
// Connection destroyed
// Connection moved
enum ComponentEventType {
  AllComponentEvents = 0,
  InstantiatePending=1,
  ComponentInstantiated=2,
  DestroyPending=3,
  ComponentDestroyed=4,
  ComponentMoved=5,
}
interface ComponentEventListener {
  void componentActivity(in ComponentEvent evt);
}
interface ComponentEvent {
  ComponentEventType getEventType() ;

  ComponentID getComponentID();

   /** Get the Properties of the affected Port. */
  TypeMap getComponentProperties() ;
}
interface ComponentEventService  extends Port
{
  /** Sign up to be told about connection activity.
      @param connectionEventType must be one of the integer values 
             ALL, ConnectPending, Connected, DisconnectPending, Disconnected
             as defined in @see ContainerEventType. 
             ALL means listening to all of the other four listed here.
      @param l, an object (this component or its delegate) that listens
             by implementing the ConnectionEventListener callback.
  */
   void addComponentEventListener(in ComponentEventType type, in ComponentEventListener l, in bool playInitalEvents);

  /** Ignore future ConnectionEvents of the given type.
      Removing a non-added listener is not an error. 
      @param connectionEventType must be one of the integer values defined in
             addConnectionEventListener.
      @param l, a previously added listener interface.
   */
   void removeComponentEventListener(in ComponentEventType type, in ComponentEventListener l) ;
 
   void moveComponent(in ComponentID component, in int x, in int y);
}

// END proposed - sparker


} // end package ports
} // end package cca
} // end package gov


/* $Source$ */
