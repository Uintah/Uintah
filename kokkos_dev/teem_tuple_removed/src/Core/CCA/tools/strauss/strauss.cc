/*
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
*/
 

#include <algorithm>
#include <iostream>
#include <map>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include <unistd.h>

#include <Dataflow/XMLUtil/StrX.h>
#include <Dataflow/XMLUtil/XMLUtil.h>

#include <Core/CCA/tools/strauss/strauss.h>

using namespace std;
using namespace SCIRun;

//**** CRCState
std::ostream& operator<<(CRCState& out, const Leader&) {
  out << out.leader;
  return out;
}
//**** End of CRCState

string absPath(string& file)
{
  if(file.substr(0,1) != "/") {
    char buf[100];
    string absfile = std::string(getcwd(buf,100))+"/"+file;
    return absfile;
  }
  else return file;
}

Strauss::Strauss(string plugin, string portspec, 
		 string header, string implementation)
  :header(header), implementation(implementation), plugin(plugin), 
   portSpec(portspec)
{
  emitted = false;

  //Create name the bridge component class
  ostringstream o;
  srand(time(NULL));
  o << "Bridge" << 1+(int)(100000.0*rand()/(RAND_MAX+1.0));
  bridgeComponent = o.str();

  //Make paths absolute for plugin and portSpec 
  plugin = absPath(plugin);
  portSpec = absPath(portSpec);

  //Init Ruby
  ruby = RubyEval::instance();

  cout << "Strauss constructor\n";
}

Strauss::~Strauss()
{
  fHeader.close();
  fImpl.close();
}

int Strauss::emit()
{
  int n;
  char* scratchfile = "scratchfile";
  int bufsize=512;
  char *buf=new char[bufsize];

  if(emitted) return -1;
 
  impl << "//This file was automatically generated by Strauss. Do not edit directly!!\n";
  impl << "\n";
  impl << "#include \"" << header << "\"\n";
 
  hdr << "//This file was automatically generated by Strauss. Do not edit directly!!\n";
  hdr << "\n";
  hdr << "#ifndef STRAUSS_GENERATED_" << bridgeComponent << "\n";
  hdr << "#define STRAUSS_GENERATED_" << bridgeComponent << "\n";

  //make component function
  string makename = header.substr(0,header.rfind("."));
  makename = makename.substr(header.rfind("/")+1);
  
  ofstream osfile(scratchfile);
  osfile << portSpec << "\n";
  osfile << plugin << "\n";
  osfile << makename << "\n"; 
  osfile << bridgeComponent << "\n";
  osfile.close();

  ruby->run_file("../src/Core/CCA/tools/strauss/ruby/erbrun.rb");

  bool once = false;
  ifstream isfile(scratchfile);
  while(!isfile.eof()) {
    isfile.getline(buf,bufsize-1);
    string sbuf(buf);
    if((!once)&&(sbuf=="START HEADER")) {
      string pbuf;
      while (pbuf!="END HEADER") {
        hdr << pbuf << "\n";
      	isfile.getline(buf,bufsize-1);
        pbuf = buf;
      } 
      once = true; 
      continue;
    }
    impl << sbuf << "\n";
  }
  isfile.close();
  delete buf;

  hdr << "#endif\n";

  impl.calcCRC(bridgeComponent); 
  hdr.calcCRC(bridgeComponent);
  emitted = true;

  return 0;
}

unsigned long Strauss::getImplCRC()
{
  return impl.crc;
}

unsigned long Strauss::getHdrCRC()
{
  return hdr.crc;
}

void Strauss::commitToFiles()
{
  if(emitted) {
    fHeader.open(header.c_str()); 
    fImpl.open(implementation.c_str());
    if((!fHeader)||(!fImpl)) {
      cerr << "ERROR in: ./strauss/main.cc: Couldn't open output file\n";
      exit(1);
    }

    fImpl << "//*****CRC=" << impl.crc << "\n";
    fImpl << impl.str();
    fHeader << "//*****CRC=" << hdr.crc << "\n";
    fHeader << hdr.str();
  }
}


