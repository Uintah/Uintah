%
%  For more information, please see: http://software.sci.utah.edu
% 
%  The MIT License
% 
%  Copyright (c) 2004 Scientific Computing and Imaging Institute,
%  University of Utah.
% 
%  License for the specific language governing rights and limitations under
%  Permission is hereby granted, free of charge, to any person obtaining a
%  copy of this software and associated documentation files (the "Software"),
%  to deal in the Software without restriction, including without limitation
%  the rights to use, copy, modify, merge, publish, distribute, sublicense,
%  and/or sell copies of the Software, and to permit persons to whom the
%  Software is furnished to do so, subject to the following conditions:
% 
%  The above copyright notice and this permission notice shall be included
%  in all copies or substantial portions of the Software.
% 
%  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
%  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
%  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
%  DEALINGS IN THE SOFTWARE.
%


\chapter{Concepts}
\label{ch:concepts} 
\index{concepts}

This section describes the general design philosophy and goals of
integrated problem solving environments \index{problem solving
  environment} and how \sr{} embodies some of these ideas.

\section{Traditional Problem Solving Methods}

Traditional methods for solving bioelectric field problems use
multiple, non-integrated computer programs.  For example, using
a computer simulation to examine the effect of electrode patch placement on
transcardiac current density in the design of a cardiac implant-able
defibrillator\cite{CRJ:Sch95b} requires geometric modeling, numerical
simulation, and scientific visualization tools to complete the task.  The
user might need one program to define the thoracic surfaces from medical
images and another to create a discrete mesh of the volume contained within
the surfaces\cite{CRJ:Sch93b}. An application such as Matlab computes a
finite element simulation of the electric current distribution from the
defibrillation electrodes through the thoracic volume\cite{RSM:And93}.
Another approach is to write a Fortran program using a public domain
numerical library such as LAPACK\@ \index{LAPACK}.  Viewing output
requires a scientific visualization package (such as those described
in\cite{RSM:All91}).  Between each of these steps, it is necessary to
save the output of one program in a format that the next in the sequence
can read. This process usually necessitates separate file format conversion
utilities.  To find the optimal location, shape, and size parameters for
the defibrillating electrode, the user has to go back to the
geometric modeling package, change the necessary parameters, manually
re-run all subsequent steps to see how the new electrode
configuration affects the current density distribution, then manually
iterate.  The manual intervention required to drive this process is
tedious and time consuming.

More efficient is a scenario in which the user can define an
appropriate set of parameters for a given simulation, then set up
a sequence of runs to examine each of them and save the results for
subsequent examinations.  The complete execution of the sequence might
require hours or even days, but the user is free during that
time to perform other tasks.  This process is similar to the ``what
if'' analysis modern spreadsheet programs offer for far simpler
problems.  

In the example of the defibrillation simulation, the user can
select various locations and orientations for the defibrillation
electrodes, choose values for other parameters of the simulation
(\eg{} the number of nodes in the finite element model, the boundary
conditions, the error tolerance for convergence, and the evaluation
criteria), and leave the simulations to run as long as necessary.
Viewing the results can be as simple as watching the animation
produced by the simulation, or scanning other defibrillation quality
indices such as maximum and minimum current density magnitude or
current density histograms from the heart.  This automated execution
process, whereby the user selects all parameters in advance and
does not control the intra- or inter-package execution, is called
\emph{batch processing}.  A benefit of batch processing is
that it allows the user to utilize computational resources
without intervention.  However, most scientific computer software
 requires some user intervention in order to
produce meaningful results .  This constraint makes it difficult or
impossible to run multiple computational jobs automatically, leaving
the user with the task of manually initiating and controlling each
step of the process.

\section{Integrated Problem Solving and Computational Steering} 
\label{sec:con-steering} 

The goal of integrated problem solving environments, specifically
\SR{}, is to integrate the steps
described in the previous example as components in a single, unified,
extensible problem solving environment\index{PSE}.  The resulting function
includes the ability to manage each step in a
sequential computing process, and to create batch processes that
execute repeated simulations. The functionality that sets
\SR{} apart from most integrated software environments
is the ability to intervene and control execution anywhere in the
chain at any time during its execution.  The ability to control a
computer program during execution is termed \emph{computational
  steering.}

To provide a non-technical analogy, adding computational steering to a
software environment is similar to adding the ability to 
switch tracks in train travel.  A train passenger can get on a train
and get to a new destination, leaving all the details of
the individual actions to the rail system machinery and staff. The route and the 
destination are fixed.  Steering would permit each
passenger, at any time during the trip,  to request that the train take a new route, with different
stops, and a different destination.  In the example
of the defibrillation simulation, computational steering allows users to interactively change parameters and settings as the
simulation executes, performing his or her work in batch and interactive
modes.  Steering interventions might include adjusting electrode
locations to stay within anatomically reasonable bounds, or refining
the geometric model resolution in order to balance accuracy and
execution time.

To achieve integration within the elements of \SR{},
data flows \index{dataflow} directly from one processing 
step to the next, without
being diverted to a disk file or leaving the program.  Output from
each step is available as input to dependent steps.  The underlying
paradigm of \SR{} is data flowing between modules that each perform
some operation.  Integration between modules guarantees, that upon
completion of their tasks, upstream modules pass their data to
downstream modules, thereby forcing the downstream modules to execute
in response.  In the computational steering example,  the user may alter
electrode locations at any time, initiating a sequence of all
necessary steps to recompute the simulation with the new
configuration.  The modification of the geometric model, finite
element calculation, and visualization all proceed automatically and
in the proper sequence, all managed by \SR{}.  The combination of
steering and component integration allows the user to
spontaneously explore a problem.

While computational steering is a young field in computer
science, there are a number of examples of such systems (in addition
to \SR{}) described in the literature.  Burnett\cite{MM:Bur94}, and
Vetter and Schwan\cite{MM:Vet96} give overviews of existing
computational steering systems. Notable examples include
CUMULVS\cite{MM:Gei96,MM:Koh97}, \index{CUMULVS}
Progress\cite{MM:Vet95}, \index{Progress} and Magellan\cite{MM:Vet97a}
\index{Magellan}.



\subsection{\SR{} and its Packages}
\label{sec:srversuspse}

%begin{latexonly}
\newcommand{\eabfig}{%
  \includegraphics[bb=0 0 1501 906,width=4in]{Figures/SCIRunSoftSys.eps.gz}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\eabfig}{%
    \htmladdimg[alt="SCIRun Software System Diagram"]{../Figures/SCIRunSoftSys.gif}
  }
\end{htmlonly}

\sr{} is more properly considered a problem solving environment (PSE)
framework upon which application specific PSEs are built.  Each
specific PSE, such as \BIOPSE{}, is a \dfn{package} with \sr{}.  PSEs
use and build upon data types, algorithms, and modules provided by the
the \sr{} framework.  PSEs provide application specific data types,
algorithms, and modules.

It is important to understand the place of the software included in
this package within the hierarchy of computational problem solving
environments developed at the \sci{} Institute.  From a historical
perspective, \SR{}, which began development in 1992, was the
original implementation of the computational
framework\cite{CRJ:Joh94c,RSM:Par95,RSM:Par95b,RSM:Par97,RSM:Par97b,CRJ:Parker99b}.
Since then, \SR{} and its computational workbench infrastructure has
been the basis of many significant application-specific projects. 
Examples are the DOE sponsored Uintah system \cite{RSM:Dav2000}
and the NIH sponsored \BIOPSE{} system.  The target applications of
the Uintah project are combustion, computational fluid dynamics, and
mechanical modeling implemented on large-scale, distributed, shared
memory architectures.  The goal of the \BIOPSE{} project is to create
software for geometric modeling, simulation, and visualization for
solving bioelectric field problems.  A secondary goal of
the \SR{} system is to make source code for  problem solving
environments available to the scientific community.

\begin{figure}[htb]
  \centering
  \begin{makeimage} \end{makeimage}
  \eabfig
  \caption{\label{fig:SCIRunSoftSys} \sr{} and its
    packages.  BioPSE, for example, consists of \sr{}
    the BioPSE package.}
\end{figure}

To support extensibility in \sr{}, its infrastructure has undergone
significant enhancement. \SR{} remains the core problem solving
environment and the name is used to refer to the entire ensemble of
software.  A user may now use the core \SR{} software and augment its
functionality with one or more packages such as \BIOPSE{} (as shown in
Figure~\ref{fig:SCIRunSoftSys}).  \sci{} anticipates the collection of
packages will grow as the \SR{} infrastructure becomes available to
scientists and engineers in varied disciplines.

In addition to major projects that have leveraged and
advanced \SR{}, there exist a number of smaller packages that extend
\SR{}'s utility.  Examples include the Teem package for raster data
processing, the NetSolve package for linear algebra subroutines
(developed by researchers at the University of Tennessee and
Knoxville), and a communications interface to the Matlab program.  \SCI{}
has developed various forms of software wrappers or interfaces that
allow \SR{} to leverage the strengths of these third party tools,
links referred to as "bridges."

There are instances when a tighter level of integration than a bridge
between \SR{} and third-party software is necessary.  One example is
the addition of MPEG support for capturing animations from the \SR{}
Viewer module, for which the Berkeley and Alex Knowles' MPEG encoding
tools are used.  To indicate whether or not such tools are available,
the configure scripts for \SR{} contain optional control flags.

\sci{} believes the combination of a robust infrastructure and modular
extensibility through packages and third-party libraries will allow \SR{}
to grow, and adapt to changing needs and opportunities. 



\section{\SR{} Modules, Networks, and Sub-Networks}
\label{sec:con-modules} 

%begin{latexonly}
\newcommand{\basicmodule}{%
  \centerline{\includegraphics[bb=0 0 768 208,width=\columnwidth]
    {Figures/biopse-modmap.eps.gz}}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\basicmodule}{%
  \htmladdimg[align=top,width=766,alt="module"]
  {../Figures/biopse-modmap.gif}}
\end{htmlonly}

The functional unit of a data-flow environment is the {\em\/module}
\index{module}.  Figure~\ref{fig:conc-module} contains a generic \SR{}
module, with a User Interface (UI) button for graphically accessing the
module's user interface, and input and output ports for receiving and sending
data, respectively.  On the right is a simple example of a data-flow
network.  Data passes through the output port of the top module, through
the data pipe, and into the input port of the bottom module.  The User
Interface enables the selection of a desired isochrone surface.

\begin{figure}[htb]
  \begin{makeimage}
  \end{makeimage}
  \basicmodule
  \caption{\label{fig:conc-module} Example of a \SR{} module}
\end{figure}

Modules may contain other elements, but all have at least one input or
one output port. Most modules have input and output ports connected to
other modules.  Data readers are modules with only an output port.
Their ``input'' is read from a file.  The
\module{Viewer} module provides input
ports only; scene data arrives on its input ports and a screen
visualization is its ``output''.  

A \dfn{subnet} is a collection of modules that behave as one.
Sub-Networks can be created, edited, and saved just like networks.
Sub-Networks can be reused in other networks, including other
sub-networks.  Sub-networks simplify the construction of complex
networks.  \sr{} ships with a  set of subnets.  See \secref{Creating a
  Sub-Network}{sec:crsubnet} for details.

It is important to understand the concepts of modules, connections,
networks and data-flow.  See \secref{Working with
  Networks}{ch:workwithnets} for more information on modules, subnets,
ports, connections, and networks.

\section{\sr{}'s Use of Third Party Software}
\label{sec:con-links} 

\SR{} works with software from third party sources in several ways.
The use of third party software is largely invisible to the user of
\SR{} or \BIOPSE{}.

For example, \sr{}'s user interface is written in Tcl language
using the Tk library.  In general, \sr{} modules use Tcl for their
user interface elements and C++ for their computations.  However, a
module may also interact with code written in other languages such as
FORTRAN or Matlab.

One goal of the \BIOPSE{} project is to provide
support for such external code, including FORTRAN, C, Matlab, and
IDL\@.

\subsection{Matlab Interface}
\label{sec:concept-matlab} 
\index{Matlab}

The Matlab interface package allows \sr{} to execute Matlab scripts
and to read and write Matlab matrix data files.

A sockets interface allows \sr{} to exchange a matlab script and matrix
data with a Matlab process.  Matlab executes the script with input
data from \sr{} and returns matrix data to \sr{}.  

The Matlab process can run on the same computer as does \sr{} or it
can run on a separate computer, helping to distribute the load and
resolving potential licensing conflicts with Matlab.

Via the Matlab package, \sr{} can read Matlab matrix files, converting
them to a SCIRun matrix type or a NRRD type.

\subsection{Insight Tool Kit}
\index{Insight Toolkit}

\sr{} provides modules for solving problems in a wide range of areas
such as performance analysis, geometric modeling, numerical analysis,
and scientific visualization.  \sr{}, however, lacks image processing
tools. This deficiency is most prominent in the area of medical
imaging.

The \htmladdnormallinkfoot{Insight Tool Kit}{http://www.itk.org} (ITK)
is open source software that complements \sr{} by providing
image-processing capabilities, ranging from fundamental algorithms to
advanced segmentation and registration tools.  The Insight Tool Kit
provides these capabilities as \dfn{filters}.  \sci{} has developed a
method of encapsulating ITK filters in \sr{} modules.

A simple XML-based language is used to describe the properties of an
ITK filter.  The ITK filter description is independent of the software
system using ITK.  Additional (one or two) \sr{}-specific, XML-based
files drive the module generation process.

If ITK is present (and \sr{} is appropriately configured) \sr{} will
build a default set of ITK filter-based modules.  Users can generate
additional modules by writing XML descriptions. The process of
generating modules based on ITK filters is described in
\chref{Wrapping ITK Filters in \sr Modules}{ch:itk_mods}.

\subsection{PETSc}
\index{PETSc}

\htmladdnormallinkfoot{The Portable, Extensible, Toolkit for
  Scientific Computation
  (PETSc)}{http://www-unix.mcs.anl.gov/petsc/petsc-2/} is a library of
data structures and functions for the parallel solution of partial
differential equations.

When PETSc is installed, and SCIRun is configured to use it, SCIRun's
\module{SolveMatrix} module enables the use of PETSc solvers.

Installation of PETSc is optional.  SolveMatrix provides built-in
solvers if PETSc is not installed.


\subsection{GENESIS (via SQL)}
\index{GENESIS}

\htmladdnormallink{GENESIS}{http://www.bbb.caltech.edu/GENESIS/genesis.html}
(short for GEneral NEural SImulation System) is a general purpose
simulation platform that was developed to support the simulation of neural
systems ranging from complex models of single neurons, to simulations of
large networks made up of more abstract neuronal components. GENESIS has
provided the basis for laboratory courses in neural simulation at
Caltech and the Marine Biological Laboratory in Woods Hole, MA, and 
many other institutions.   

\sci{} has made it possible to use the output of a GENESIS simulation
as the input for a visualization, or a subsequent simulation within
\BIOPSE{}.  The mechanism for this bridge is a database accessible via
SQL queries.  \sci{} created code for GENESIS that writes the output
of the simulation into the database, then the corresponding functions
for \SR{} read this information from the same database.  Contact Chris
Butson
\htmladdnormallink{butson@sci.utah.edu}{mailto:butson@sci.utah.edu}
for details about the implementation of the GENESIS module.


\section{Extensibility}
\label{sec:con-extend} 


\sr{} can be extended by creating new packages, modules, and subnets.
Modules can be coded from scratch, or with the assistance of the \sr's
\dfn{Module Maker} component.

\sci{} encourages users to contribute modules to the \BIOPSE{} web
site \index{BioPSE@\BIOPSE{}!web site}
(\htmladdnormallink{www.sci.utah.edu/ncrr/software/biopse.html}
{http://www.sci.utah.edu/ncrr/software/biopse.html}) where they will be
reviewed, and useful modules will be included in subsequent releases
of \sr{}.

To leverage investment in legacy code, future releases of \sr{} will
include additional tools for wrapping existing code within \SR{}
modules.

\section{Power Apps}
\label{sec:sec:con-apps}
\index{power apps}

SCI is developing problem specific applications called
\dfn{Power Apps}.  Power Apps use \sr{}'s data flow engine for
computation and application specific data flow networks for problem
solving.  However, Power Apps hide the complexity of the data flow
environment behind a simplified application specific graphical user
interface.

The following Power Apps are available:

\begin{description}
  \descitem{BioTensor} \index{BioTensor} An application for computing
  and visualizing diffusion tensor data.  See the
  \htmladdnormallinkfoot{BioTensor
  tutorial}{\latexhtml{http://software.sci.utah.edu/doc/User/Tutorials/BioTensor/BioTensor.html}{../../Tutorials/BioTensor/BioTensor.html}}
  for more information.
  
  \descitem{BioFEM} \index{BioFEM} A finite element simulation
  application. It is used, for example, to compute electric and
  potential fields from a discretized volume conductor and a current
  source.

  \descitem{BioImage} \index{BioImage} An application for exploring 3D
  volume data.  See the \htmladdnormallinkfoot{BioImage tutorial}
  {\latexhtml{http://software.sci.utah.edu/doc/User/Tutorials/BioImage/index.html}{../../Tutorials/BioImage/index.html}}
  for more information.

\end{description}

Commands \command{BioTensor}, \command{BioFem} and \command{BioImage}
invoke these applications.  If \sr{} is installed from source code,
commands \command{BioTensor}, \command{BioFem} and \command{BioImage}
are located in \sr{}'s build directory (alongside the \command{scirun}
command).  If \sr{} is installed from RPMs these commands are located in
\directory{/usr/local/SCIRun/bin}.

\section{\sr{} Objects}
\label{sec:sr-objects}

\sr{}'s \datatype{Field}, \datatype{Mesh}, \datatype{Matrix}, and
\datatype{ColorMap} objects are used frequently in networks.  These
objects are described in the following sections.

\subsection{Field}
\index{fields}

A \sr{} \datatype{Field} consists of a geometric \datatype{Mesh} and a
set of data values.  Data values can be located at the nodes, edges,
faces, or cells of a mesh.  A \datatype{Field} can consist of a
\datatype{Mesh} component only (no associated data).

\subsection{Field Data}

The following C++/SCI data types can be associated with a \datatype{Field}:

\begin{itemize}
\item \datatype{double}, \datatype{float}
\item \datatype{int}, \datatype{short}, \datatype{unsigned}, \datatype{unsigned short}
\item \datatype{char}, \datatype{unsigned char}
\item 2nd order \datatype{Tensor}
\item \datatype{Vector} of doubles
\end{itemize}

C++ data types are \datatype{double}, \datatype{float},
\datatype{int}, \datatype{short}, \datatype{unsigned},
\datatype{unsigned short}, \datatype{char}, and \datatype{unsigned
  char}.  \sr{} data types are \datatype{Tensor} and \datatype{Vector}.

\subsection{Meshes}
\index{meshes}

\sr{} meshes are classified as \dfn{unstructured}, \dfn{structured},
or \dfn{regular}.  A mesh consists of nodes and implicit or explicit
node connectivity information.

Node locations and connectivities for unstructured 
meshes\index{meshes!unstructured meshes} are specified
explicitly.  The unstructured mesh types are:
\datatype{PointCloudMesh}, \datatype{CurveMesh},
\datatype{TriSurfMesh}, \datatype{QuadSurfMesh},
\datatype{TetVolMesh}, and \datatype{HexVolMesh}.

Node locations are specified explicitly, and connectivities are known
implicitly for structured meshes\index{meshes!structured meshes}.  The 
structured meshes are
\datatype{StructCurveMesh}, \datatype{StructQuadSurfMesh}, and
\datatype{StructHexVolMesh}.

Node locations and connectivities are known implicitly for regular
meshes\index{meshes!regular meshes}.  The regular mesh types 
are \datatype{ScanlineMesh},
\datatype{ImageMesh}, \datatype{LatVolMesh}.

A regular mesh is more constrained than structured and unstructured
meshes.  Likewise, a structured mesh is more constrained that a
unstructured mesh.  A more constrained mesh can be trivially converted
to a less constrained mesh by explicitly enumerating implicit
properties.  For instance, a LatVol mesh is converted to a StructHexVol
by enumerating a LatVol mesh's node coordinates (connectivities are
still implied).  Also, a LatVol mesh is converted to a HexVol mesh by
enumerating a LatVol's node locations and connectivities.  Module
\module{ToStructured} performs this type of conversion.

It is not meaningful to convert a less constrained mesh to a more
constrained mesh.  It is possible, however, to sample an unstructured
field at regular intervals to create a regular field.  For example, a
HexVolField is interpolated onto a LatVol mesh using modules
\module{SampleLattice} and \module{DirectInterpolate}.

Below are figures of mesh types:

%begin{latexonly}
\newcommand{\meshdoc}[4]{%
  \includegraphics[bb=0 0 100 #1]{Figures/#2.eps.gz}
  {#4}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\meshdoc}[4]{%
    \htmladdimg[align=left,alt="#3"]
    {../../Tutorials/SCIRun_Intro/images/figures/#2.gif}
    #4 \begin{rawhtml}<br clear="all"/>\end{rawhtml}
  }
\end{htmlonly}

\meshdoc{100}{pointcloud}{Point Cloud Mesh}{A Point Cloud \index{meshes!Point Cloud mesh} mesh is a
  set of unconnected points.}

\meshdoc{60}{ScanlineField}{Scanline Mesh}{A Scanline Mesh \index{meshes!Scanline mesh} is a
  regularly segmented straight line (a regular 1D grid).}

\meshdoc{60}{ContourField}{Contour Field Mesh}{A Curve mesh \index{meshes!Curve mesh} is a 
  segmented curve.}

\meshdoc{100}{ImageField}{Image Mesh}{An Image mesh \index{meshes!Image
  mesh} is a regular 2D grid. Note that an Image mesh is not used for
  image processing.}

\meshdoc{253}{StructQuadSurf2}{Structured Quad Surface mesh}{Surface made of
connected quadrilaterals on a structured grid \index{meshes!Structured Quad Surface mesh}}

\meshdoc{253}{StructHexVol2}{Structured Hex Volume mesh}{Subdivision of
space into structured hexagonal elements\index{meshes!Structured Hex
Volume mesh}}

\meshdoc{65}{trisurf}{Tri Surface Mesh}{A Tri Surface mesh \index {meshes!Tri Surface mesh} is a
  surface made of connected triangles.}

\meshdoc{83}{quadsurf}{Quad Surface Mesh}{A Quad Surface \index{meshes!Quad Surface mesh} mesh is a surface made of connected quadrilaterals.}

\meshdoc{87}{latticevol}{Lat Vol Mesh}{A Lattice Volume mesh \index{meshes!Lattice Volume mesh} is a regular 3D grid.}

\meshdoc{60}{tetvol}{Tet Vol Mesh}{A Tet Volume mesh \index{meshes!Tet Volume mesh} is a subdivision of space into tetrahedral elements.}

\meshdoc{84}{hexvol}{Hex Vol Mesh}{A Hex Volume mesh \index{meshes!Hex Volume mesh} is a subdivision
  of space into hexagonal elements.}

\meshdoc{84}{prismvol}{Prism Volume Mesh}{A Prism Volume mesh
  \index{meshes!Prism Volume mesh} is a subdivision of space into
  prism elements.  Prism elements have five faces, two trangular faces
  connected by three quadrilateral faces.}



\subsection{Matrices}
\index{matrices}

\sr{} supports three matrix types: 

\begin{description}
\descitem{\datatype{ColumnMatrix}} An \(Mx1\) matrix using \(M\)
storage units.

\descitem{\datatype{DenseMatrix}} An \(MxN\) matrix using \(MxN\)
storage units.

\descitem{\datatype{SparseRowMatrix}} A \(MxN\) matrix where most
elements are zero and no storage is allocated for zero valued
elements.
\end{description}

\subsection{Color Map}
\index{color map}

\sr{} \datatype{ColorMap} type is a mapping of color values to data values.

\section{Bioelectric Field Quantities and Units}
\label{sec:units}
\index{quantities}\index{units}

The quantities of interest in bioelectric field problems are
conductivity, potentials, electric field, dipole source, current
density, and current source density. These quantities and their
associated units are listed in table \ref{tbl:units}.

\begin{table}[htbp]
 \begin{center}
  \begin{tabular}{|l|l|}
   \hline
   {\em Quantity}&{\em Unit} \\
   \hline
   Conductivity&$amps / volts / meter$  ($siemens / meter$) \\
   Potential&$volts$ \\
   Electric Field&$volts / meter$ \\
   Dipole Source&$amps / meter$ \\
   Current Density&$amps / meter^2$ \\
   Current Source Density&$amps / meter^3$ \\
   \hline
  \end{tabular}
  \caption{SCIRun bioelectric field quantities and units}
  \label{tbl:units}
 \end{center}
\end{table}

SCIRun doesn't keep track of unit scale factors (e.g. centi-, milli-,
etc).  SCIRun assumes a dipole source is in units of $amps / meter$,
conductivities are in $siemens / meter$, model geometry is in $meters$;
results are therefore in units of $volts$.  If this isn't true (e.g. you
know that the model is in $mm$), then you have to carry those scale
factors through your computation (e.g. know that the results you get out
are in $kv$).

The rule of thumb is that if we \emph{increase} the conductivity, then
we \emph{decrease} the potentials by that same scale factor.
Conversely, if we \emph{increase} the dipole source moment, then we
\emph{increase} the potentials by that same scale factor.  i.e. $V = I /
sigma$.  Similarly, if we hold everything else constant, but
\emph{increase} the size of the domain, then we \emph{decrease} the
potentials by that same scale factor.

For example, the SCIRun Utah Torso model has a length scale of
centimeters ($10^{-2} meters$) and conductivity units of $siemens /
meter$, so our output potentials are in $hectovolts$  ($10^2 volts$).

