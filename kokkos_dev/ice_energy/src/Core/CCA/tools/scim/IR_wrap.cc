/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.19
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(const T& t) { tt = new T(t); return *this; }
    inline operator T&() const { return *tt; }
    inline T *operator&() { return tt; }
};                                                    
#endif

/* ruby.swg */
/* Implementation : RUBY */
#define SWIGRUBY 1

#include "ruby.h"

#define NUM2USHRT(n) (\
    (0 <= NUM2UINT(n) && NUM2UINT(n) <= USHRT_MAX)\
    ? (unsigned short) NUM2UINT(n) \
    : (rb_raise(rb_eArgError, "integer %d out of range of `unsigned short'",\
               NUM2UINT(n)), (short)0)\
)

#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7 */
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

typedef struct {
  VALUE  klass;
  void  (*mark)(void *);
  void  (*destroy)(void *);
} swig_class;

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;  /**/
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;  /**/
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif

static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;

/* Initialize Ruby runtime support */
SWIGRUNTIME(void)
SWIG_InitRuntime(void)
{
    if (_mSWIG == Qnil) {
        _mSWIG = rb_define_module("SWIG");
    }
}

/* Define Ruby class for C type */
SWIGRUNTIME(void)
SWIG_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
    free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME(VALUE)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own)
{
    char *klass_name;
    swig_class *sklass;
    VALUE klass;
    VALUE obj;
    
    if (!ptr)
	return Qnil;
    
    if (type->clientdata) {
      sklass = (swig_class *) type->clientdata;
      obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
    } else {
      klass_name = (char *) malloc(4 + strlen(type->name) + 1);
      sprintf(klass_name, "TYPE%s", type->name);
      klass = rb_const_get(_mSWIG, rb_intern(klass_name));
      free((void *) klass_name);
      obj = Data_Wrap_Struct(klass, 0, 0, ptr);
    }
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME(VALUE)
SWIG_NewClassInstance(VALUE klass, swig_type_info *type)
{
    VALUE obj;
    swig_class *sklass = (swig_class *) type->clientdata;
    obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Get type mangle from class name */
SWIGRUNTIME(char *)
SWIG_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return STR2CSTR(stype);
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(VALUE obj, void **ptr, swig_type_info *ty, int flags)
{
  char *c;
  swig_type_info *tc;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return 0;
  } else
    Data_Get_Struct(obj, void, *ptr);
  
  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
        if (!rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
          if (flags)
	    rb_raise(rb_eTypeError, "wrong argument type (expected %s)", ty->str);
	  else
	    return -1;
	}
        if (*ptr == 0)
	  rb_raise(rb_eRuntimeError, "This %s already released", ty->str);
    } else {
      if ((c = SWIG_MangleStr(obj)) == NULL) {
        if (flags)
	  rb_raise(rb_eTypeError, "Expected %s", ty->str);
	else
	  return -1;
      }
      tc = SWIG_TypeCheck(c, ty);
      if (!tc) {
        if (flags)
	  rb_raise(rb_eTypeError, "Expected %s", ty->str);
	else
	  return -1;
      }
      *ptr = SWIG_TypeCast(tc, *ptr);
    }
  }
  return 0;
}

/* Check convert */
SWIGRUNTIME(int)
SWIG_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

SWIGRUNTIME(VALUE)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME(void)
SWIG_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = STR2CSTR(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return;

type_error:

  if (flags) {
    if (ty) {
      rb_raise(rb_eTypeError, "Type error. Expected %s", ty->name);
    } else {
      rb_raise(rb_eTypeError, "Expected a pointer");
    }
  }
}

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_IrPort swig_types[0] 
#define  SWIGTYPE_p_IrDefinition swig_types[1] 
#define  SWIGTYPE_p_IrMap swig_types[2] 
#define  SWIGTYPE_p_p_IrMap swig_types[3] 
#define  SWIGTYPE_p_IrMethodMap_p swig_types[4] 
#define  SWIGTYPE_p_IrArgumentList swig_types[5] 
#define  SWIGTYPE_p_IrArgument swig_types[6] 
#define  SWIGTYPE_p_std__vectorTIrArgument_p_t swig_types[7] 
#define  SWIGTYPE_p_IrNameMap swig_types[8] 
#define  SWIGTYPE_p_p_IrNameMap swig_types[9] 
#define  SWIGTYPE_p_IR swig_types[10] 
#define  SWIGTYPE_p_IrMethod swig_types[11] 
#define  SWIGTYPE_p_IrPackage swig_types[12] 
#define  SWIGTYPE_p_IrMethodMap swig_types[13] 
#define  SWIGTYPE_p_IrDefList swig_types[14] 
#define  SWIGTYPE_p_std__string swig_types[15] 
#define  SWIGTYPE_p_IrMap_p swig_types[16] 
#define  SWIGTYPE_p_IrNameMapList swig_types[17] 
#define  SWIGTYPE_p_std__vectorTIrMap_p_t swig_types[18] 
#define  SWIGTYPE_p_std__vectorTstd__string_t swig_types[19] 
#define  SWIGTYPE_p_std__vectorTIrMethodMap_p_t swig_types[20] 
#define  SWIGTYPE_p_std__vectorTIrNameMap_p_t swig_types[21] 
#define  SWIGTYPE_p_IrMethodList swig_types[22] 
#define  SWIGTYPE_p_std__vectorTIrMethod_p_t swig_types[23] 
static swig_type_info *swig_types[25];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_libCore_CCA_tools_scim 
#define SWIG_name    "Scim"

static VALUE mScim;

#include "IR.h"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void _SWIG_exception(int code, const char *msg) {
    switch (code) {
        case SWIG_MemoryError:
            rb_raise(rb_eNoMemError, msg);
            break;
        case SWIG_IOError:
            rb_raise(rb_eIOError, msg);
            break;
        case SWIG_RuntimeError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        case SWIG_IndexError:
            rb_raise(rb_eIndexError, msg);
            break;
        case SWIG_TypeError:
            rb_raise(rb_eTypeError, msg);
            break;
        case SWIG_DivisionByZero:
            rb_raise(rb_eZeroDivError, msg);
            break;
        case SWIG_OverflowError:
            rb_raise(rb_eRangeError, msg);
            break;
        case SWIG_SyntaxError:
            rb_raise(rb_eSyntaxError, msg);
            break;
        case SWIG_ValueError:
            rb_raise(rb_eArgError, msg);
            break;
        case SWIG_SystemError:
            rb_raise(rb_eFatal, msg);
            break;
        case SWIG_UnknownError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        default:
            break;
    }
}

#define SWIG_exception(a, b) _SWIG_exception((a), (b))


#include <string>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(STR2CSTR(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new2(s.c_str());
}


#include <vector>
#include <algorithm>
#include <stdexcept>

IrMap *std_vectorlIrMap_m_g_pop___(std::vector<IrMap * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                IrMap * x = self->back();
                self->pop_back();
                return x;
            }
IrMap *&std_vectorlIrMap_m_g___getitem_____(std::vector<IrMap * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlIrMap_m_g___setitem_____(std::vector<IrMap * > *self,int i,IrMap *const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlIrMap_m_g_each___(std::vector<IrMap * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    IrMap ** x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_p_IrMap, 0));
                }
            }

swig_class cMapVector;
static void free_std_vectorlIrMap_m_g___(std::vector<IrMap * > *);

typedef IrMap IrMap_p;

IrMap_p *new_IrMap_p(){
  return new IrMap();
}
void delete_IrMap_p(IrMap_p *self){
  if (self) delete self;
}
void IrMap_p_assign(IrMap_p *self,IrMap value){
  *self = value;
}
IrMap IrMap_p_value(IrMap_p *self){
  return *self;
}
IrMap *IrMap_p_cast(IrMap_p *self){
  return self;
}
IrMap_p *IrMap_p_frompointer(IrMap *t){
  return (IrMap_p *) t;
}

swig_class cIrMap_p;
static void free_IrMap_p(IrMap_p *);

typedef IrMethodMap IrMethodMap_p;

IrMethodMap_p *new_IrMethodMap_p(){
  return new IrMethodMap();
}
void delete_IrMethodMap_p(IrMethodMap_p *self){
  if (self) delete self;
}
void IrMethodMap_p_assign(IrMethodMap_p *self,IrMethodMap value){
  *self = value;
}
IrMethodMap IrMethodMap_p_value(IrMethodMap_p *self){
  return *self;
}
IrMethodMap *IrMethodMap_p_cast(IrMethodMap_p *self){
  return self;
}
IrMethodMap_p *IrMethodMap_p_frompointer(IrMethodMap *t){
  return (IrMethodMap_p *) t;
}

swig_class cIrMethodMap_p;
static void free_IrMethodMap_p(IrMethodMap_p *);

swig_class cIR;
static void free_IR(IR *);

swig_class cIrDefinition;
static void free_IrDefinition(IrDefinition *);

swig_class cIrPackage;
static void free_IrPackage(IrPackage *);

swig_class cIrDefList;
static void free_IrDefList(IrDefList *);

swig_class cIrPort;
static void free_IrPort(IrPort *);

swig_class cIrMethod;
static void free_IrMethod(IrMethod *);

swig_class cIrMethodList;
static void free_IrMethodList(IrMethodList *);

swig_class cIrArgument;
static void free_IrArgument(IrArgument *);

swig_class cIrArgumentList;
static void free_IrArgumentList(IrArgumentList *);

swig_class cIrMap;
static void free_IrMap(IrMap *);

swig_class cIrNameMapList;
static void free_IrNameMapList(IrNameMapList *);

swig_class cIrNameMap;
static void free_IrNameMap(IrNameMap *);

swig_class cIrMethodMap;
static void free_IrMethodMap(IrMethodMap *);
static VALUE
_wrap_new_MapVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<IrMap * > *result;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    if (argc > 0) {
        arg1 = NUM2UINT(argv[0]);
    }
    result = (std::vector<IrMap * > *)new std::vector<IrMap * >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_MapVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    IrMap **arg2 = 0 ;
    std::vector<IrMap * > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_IrMap, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<IrMap * > *)new std::vector<IrMap * >(arg1,(IrMap *const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_MapVector_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTIrMap_p_t);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_MapVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = 0 ;
    std::vector<IrMap * > *result;
    std::vector<IrMap * > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<IrMap * >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                IrMap ** x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_IrMap, 1);
                temp1[i] = *x;
            }
        }else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
        }
    }
    result = (std::vector<IrMap * > *)new std::vector<IrMap * >((std::vector<IrMap * > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_MapVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_MapVector__SWIG_0(nargs, args, self);
        }
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_MapVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    IrMap ** x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_p_IrMap,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            }else {
                /* wrapped vector? */
                std::vector<IrMap * >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTIrMap_p_t,1) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_MapVector__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_IrMap, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_MapVector__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_MapVector'");
    return Qnil;
}


static VALUE
_wrap_MapVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    unsigned int result;
    std::vector<IrMap * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<IrMap * >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                IrMap ** x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_IrMap, 1);
                temp1[i] = *x;
            }
        }else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
        }
    }
    result = (unsigned int)((std::vector<IrMap * > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_MapVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    bool result;
    std::vector<IrMap * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<IrMap * >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                IrMap ** x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_IrMap, 1);
                temp1[i] = *x;
            }
        }else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
        }
    }
    result = (bool)((std::vector<IrMap * > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_MapVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_MapVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    IrMap **arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_p_IrMap, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((IrMap *const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_MapVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    IrMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
    {
        try {
            result = (IrMap *)std_vectorlIrMap_m_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMap,0);
    return vresult;
}


static VALUE
_wrap_MapVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    int arg2 ;
    IrMap **result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                IrMap *&_result_ref = std_vectorlIrMap_m_g___getitem_____(arg1,arg2);
                result = (IrMap **) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_IrMap,0);
    return vresult;
}


static VALUE
_wrap_MapVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    int arg2 ;
    IrMap **arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_p_IrMap, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vectorlIrMap_m_g___setitem_____(arg1,arg2,(IrMap *const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_MapVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<IrMap * > *arg1 = (std::vector<IrMap * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTIrMap_p_t, 1);
    std_vectorlIrMap_m_g_each___(arg1);
    
    return Qnil;
}


static void
free_std_vectorlIrMap_m_g___(std::vector<IrMap * > *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrMap_p_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrMap_p);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrMap_p(int argc, VALUE *argv, VALUE self) {
    IrMap_p *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrMap_p *)new_IrMap_p();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrMap_p(IrMap_p *arg1) {
    delete_IrMap_p(arg1);
;
}
static VALUE
_wrap_IrMap_p_assign(int argc, VALUE *argv, VALUE self) {
    IrMap_p *arg1 = (IrMap_p *) 0 ;
    IrMap arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap_p, 1);
    {
        IrMap * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_IrMap, 1);
        if (ptr) arg2 = *ptr;
    }
    IrMap_p_assign(arg1,arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrMap_p_value(int argc, VALUE *argv, VALUE self) {
    IrMap_p *arg1 = (IrMap_p *) 0 ;
    IrMap result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap_p, 1);
    result = IrMap_p_value(arg1);
    
    {
        IrMap * resultptr;
        resultptr = new IrMap((IrMap &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_IrMap, 1);
    }
    return vresult;
}


static VALUE
_wrap_IrMap_p_cast(int argc, VALUE *argv, VALUE self) {
    IrMap_p *arg1 = (IrMap_p *) 0 ;
    IrMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap_p, 1);
    result = (IrMap *)IrMap_p_cast(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMap,0);
    return vresult;
}


static VALUE
_wrap_IrMap_p_frompointer(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrMap_p *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (IrMap_p *)IrMap_p_frompointer(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMap_p,0);
    return vresult;
}


static VALUE
_wrap_IrMethodMap_p_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrMethodMap_p);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrMethodMap_p(int argc, VALUE *argv, VALUE self) {
    IrMethodMap_p *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrMethodMap_p *)new_IrMethodMap_p();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrMethodMap_p(IrMethodMap_p *arg1) {
    delete_IrMethodMap_p(arg1);
;
}
static VALUE
_wrap_IrMethodMap_p_assign(int argc, VALUE *argv, VALUE self) {
    IrMethodMap_p *arg1 = (IrMethodMap_p *) 0 ;
    IrMethodMap arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap_p, 1);
    {
        IrMethodMap * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_IrMethodMap, 1);
        if (ptr) arg2 = *ptr;
    }
    IrMethodMap_p_assign(arg1,arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrMethodMap_p_value(int argc, VALUE *argv, VALUE self) {
    IrMethodMap_p *arg1 = (IrMethodMap_p *) 0 ;
    IrMethodMap result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap_p, 1);
    result = IrMethodMap_p_value(arg1);
    
    {
        IrMethodMap * resultptr;
        resultptr = new IrMethodMap((IrMethodMap &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_IrMethodMap, 1);
    }
    return vresult;
}


static VALUE
_wrap_IrMethodMap_p_cast(int argc, VALUE *argv, VALUE self) {
    IrMethodMap_p *arg1 = (IrMethodMap_p *) 0 ;
    IrMethodMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap_p, 1);
    result = (IrMethodMap *)IrMethodMap_p_cast(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMethodMap,0);
    return vresult;
}


static VALUE
_wrap_IrMethodMap_p_frompointer(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *arg1 = (IrMethodMap *) 0 ;
    IrMethodMap_p *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_IrMethodMap, 1);
    result = (IrMethodMap_p *)IrMethodMap_p_frompointer(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMethodMap_p,0);
    return vresult;
}


static VALUE
_wrap_IR_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IR);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IR(int argc, VALUE *argv, VALUE self) {
    IR *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IR *)new IR();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IR(IR *arg1) {
    delete arg1;
}
static VALUE
_wrap_IR_staticCheck(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    (arg1)->staticCheck();
    
    return Qnil;
}


static VALUE
_wrap_IR_setPackage(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrPackage *arg2 = (IrPackage *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrPackage, 1);
    (arg1)->setPackage(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_getPackage(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrPackage *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    result = (IrPackage *)(arg1)->getPackage();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPackage,0);
    return vresult;
}


static VALUE
_wrap_IR_addInDefList(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrDefList *arg2 = (IrDefList *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrDefList, 1);
    (arg1)->addInDefList(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_addOutDefList(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrDefList *arg2 = (IrDefList *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrDefList, 1);
    (arg1)->addOutDefList(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_addInOutDef(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrDefinition *arg2 = (IrDefinition *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrDefinition, 1);
    (arg1)->addInOutDef(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_addMap(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrMap *arg2 = (IrMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMap, 1);
    (arg1)->addMap(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_setForAllMap(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrMap *arg2 = (IrMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMap, 1);
    (arg1)->setForAllMap(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_getForAllMap(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    IrMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    result = (IrMap *)(arg1)->getForAllMap();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMap,0);
    return vresult;
}


static VALUE
_wrap_IR_omitInOut__SWIG_0(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->omitInOut(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_remapInOut(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->remapInOut(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_omitInOut__SWIG_1(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    (arg1)->omitInOut();
    
    return Qnil;
}


static VALUE _wrap_IR_omitInOut(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_IR, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_IR_omitInOut__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_IR, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_IR_omitInOut__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'IR_omitInOut'");
    return Qnil;
}


static VALUE
_wrap_IR_existsOmit(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    std::string arg2 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->existsOmit(arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IR_outFile(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->outFile(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IR_getMap(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    int arg2 ;
    IrMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    arg2 = NUM2INT(argv[0]);
    result = (IrMap *)(arg1)->getMap(arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMap,0);
    return vresult;
}


static VALUE
_wrap_IR_getMapSize(int argc, VALUE *argv, VALUE self) {
    IR *arg1 = (IR *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IR, 1);
    result = (int)(arg1)->getMapSize();
    
    vresult = INT2NUM(result);
    return vresult;
}


static void
free_IrDefinition(IrDefinition *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrDefinition_out(int argc, VALUE *argv, VALUE self) {
    IrDefinition *arg1 = (IrDefinition *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefinition, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrDefinition_findPort(int argc, VALUE *argv, VALUE self) {
    IrDefinition *arg1 = (IrDefinition *) 0 ;
    std::string arg2 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    IrPort *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefinition, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    result = (IrPort *)(arg1)->findPort(arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPort,0);
    return vresult;
}


static VALUE
_wrap_IrDefinition_selfMap(int argc, VALUE *argv, VALUE self) {
    IrDefinition *arg1 = (IrDefinition *) 0 ;
    IR *arg2 = (IR *) 0 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefinition, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    (arg1)->selfMap(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_IrDefinition_getPortNames(int argc, VALUE *argv, VALUE self) {
    IrDefinition *arg1 = (IrDefinition *) 0 ;
    std::vector<std::string > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefinition, 1);
    result = (arg1)->getPortNames();
    
    {
        std::vector<std::string > * resultptr;
        resultptr = new std::vector<std::string >((std::vector<std::string > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_IrDefinition_mode_set(int argc, VALUE *argv, VALUE self) {
    IrDefinition *arg1 = (IrDefinition *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefinition, 1);
    arg2 = (int) NUM2INT(argv[0]);
    if (arg1) (arg1)->mode = (mode_T )arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrDefinition_mode_get(int argc, VALUE *argv, VALUE self) {
    IrDefinition *arg1 = (IrDefinition *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefinition, 1);
    result = (int) ((arg1)->mode);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrPackage_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrPackage);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrPackage(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    IrDefList *arg2 = (IrDefList *) 0 ;
    IrPackage *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_IrDefList, 1);
    result = (IrPackage *)new IrPackage(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrPackage(IrPackage *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrPackage_out(int argc, VALUE *argv, VALUE self) {
    IrPackage *arg1 = (IrPackage *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPackage, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrPackage_findPort(int argc, VALUE *argv, VALUE self) {
    IrPackage *arg1 = (IrPackage *) 0 ;
    std::string arg2 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    IrPort *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPackage, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    result = (IrPort *)(arg1)->findPort(arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPort,0);
    return vresult;
}


static VALUE
_wrap_IrPackage_selfMap(int argc, VALUE *argv, VALUE self) {
    IrPackage *arg1 = (IrPackage *) 0 ;
    IR *arg2 = (IR *) 0 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPackage, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    (arg1)->selfMap(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_IrPackage_getPortNames(int argc, VALUE *argv, VALUE self) {
    IrPackage *arg1 = (IrPackage *) 0 ;
    std::vector<std::string > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPackage, 1);
    result = (arg1)->getPortNames();
    
    {
        std::vector<std::string > * resultptr;
        resultptr = new std::vector<std::string >((std::vector<std::string > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_IrPackage_getName(int argc, VALUE *argv, VALUE self) {
    IrPackage *arg1 = (IrPackage *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPackage, 1);
    result = (arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrDefList_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrDefList);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrDefList(int argc, VALUE *argv, VALUE self) {
    IrDefList *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrDefList *)new IrDefList();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrDefList(IrDefList *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrDefList_addDef(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    IrDefinition *arg2 = (IrDefinition *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrDefinition, 1);
    (arg1)->addDef(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrDefList_modeTag(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    arg2 = (int) NUM2INT(argv[0]);
    (arg1)->modeTag((mode_T )arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrDefList_findPort(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    std::string arg2 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    IrPort *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    result = (IrPort *)(arg1)->findPort(arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPort,0);
    return vresult;
}


static VALUE
_wrap_IrDefList_selfMap(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    IR *arg2 = (IR *) 0 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    (arg1)->selfMap(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_IrDefList_getPortNames(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    std::vector<std::string > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    result = (arg1)->getPortNames();
    
    {
        std::vector<std::string > * resultptr;
        resultptr = new std::vector<std::string >((std::vector<std::string > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_IrDefList_getSize(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    result = (int)(arg1)->getSize();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrDefList_getDef(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    int arg2 ;
    IrDefinition *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    arg2 = NUM2INT(argv[0]);
    result = (IrDefinition *)(arg1)->getDef(arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrDefinition,0);
    return vresult;
}


static VALUE
_wrap_IrDefList_out(int argc, VALUE *argv, VALUE self) {
    IrDefList *arg1 = (IrDefList *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrDefList, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrPort_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrPort);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrPort(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    IrMethodList *arg2 = (IrMethodList *) 0 ;
    IrPort *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_IrMethodList, 1);
    result = (IrPort *)new IrPort(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrPort(IrPort *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrPort_out(int argc, VALUE *argv, VALUE self) {
    IrPort *arg1 = (IrPort *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPort, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrPort_findPort(int argc, VALUE *argv, VALUE self) {
    IrPort *arg1 = (IrPort *) 0 ;
    std::string arg2 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    IrPort *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPort, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    result = (IrPort *)(arg1)->findPort(arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPort,0);
    return vresult;
}


static VALUE
_wrap_IrPort_selfMap(int argc, VALUE *argv, VALUE self) {
    IrPort *arg1 = (IrPort *) 0 ;
    IR *arg2 = (IR *) 0 ;
    IrPackage *arg3 = (IrPackage *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPort, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IR, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrPackage, 1);
    (arg1)->selfMap(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_IrPort_staticCheck(int argc, VALUE *argv, VALUE self) {
    IrPort *arg1 = (IrPort *) 0 ;
    IrPort *arg2 = (IrPort *) 0 ;
    IrMap *arg3 = (IrMap *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPort, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrPort, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrMap, 1);
    (arg1)->staticCheck(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_IrPort_getPackageName(int argc, VALUE *argv, VALUE self) {
    IrPort *arg1 = (IrPort *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPort, 1);
    result = (arg1)->getPackageName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrPort_getPortNames(int argc, VALUE *argv, VALUE self) {
    IrPort *arg1 = (IrPort *) 0 ;
    std::vector<std::string > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrPort, 1);
    result = (arg1)->getPortNames();
    
    {
        std::vector<std::string > * resultptr;
        resultptr = new std::vector<std::string >((std::vector<std::string > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_IrMethod_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrMethod);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrMethod(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    IrArgumentList *arg3 = (IrArgumentList *) 0 ;
    IrMethod *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_IrArgumentList, 1);
    result = (IrMethod *)new IrMethod(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrMethod(IrMethod *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrMethod_out(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMethod_getName(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMethod_getReturnType(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (arg1)->getReturnType();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMethod_getArgList(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    IrArgumentList *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (IrArgumentList *)(arg1)->getArgList();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrArgumentList,0);
    return vresult;
}


static VALUE
_wrap_IrMethod_compare(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    IrMethod *arg2 = (IrMethod *) 0 ;
    IrNameMap *arg3 = (IrNameMap *) 0 ;
    IrMap *arg4 = (IrMap *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMethod, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_IrMap, 1);
    result = (bool)(arg1)->compare(arg2,arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_IrMethod_name_set(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->name = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMethod_name_get(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (std::string *)& ((arg1)->name);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrMethod_retType_set(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->retType = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMethod_retType_get(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (std::string *)& ((arg1)->retType);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrMethod_irArgL_set(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    IrArgumentList *arg2 = (IrArgumentList *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrArgumentList, 1);
    if (arg1) (arg1)->irArgL = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMethod_irArgL_get(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    IrArgumentList *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    result = (IrArgumentList *) ((arg1)->irArgL);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrArgumentList,0);
    return vresult;
}


static VALUE
_wrap_IrMethodList_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrMethodList);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrMethodList(int argc, VALUE *argv, VALUE self) {
    IrMethodList *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrMethodList *)new IrMethodList();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrMethodList(IrMethodList *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrMethodList_addMethod(int argc, VALUE *argv, VALUE self) {
    IrMethodList *arg1 = (IrMethodList *) 0 ;
    IrMethod *arg2 = (IrMethod *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMethod, 1);
    (arg1)->addMethod(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrMethodList_out(int argc, VALUE *argv, VALUE self) {
    IrMethodList *arg1 = (IrMethodList *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodList, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMethodList_staticCheck(int argc, VALUE *argv, VALUE self) {
    IrMethodList *arg1 = (IrMethodList *) 0 ;
    IrMethodList *arg2 = (IrMethodList *) 0 ;
    IrMap *arg3 = (IrMap *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMethodList, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrMap, 1);
    (arg1)->staticCheck(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_IrMethodList_IrMethods_set(int argc, VALUE *argv, VALUE self) {
    IrMethodList *arg1 = (IrMethodList *) 0 ;
    std::vector<IrMethod * > *arg2 = (std::vector<IrMethod * > *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTIrMethod_p_t, 1);
    if (arg1) (arg1)->IrMethods = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMethodList_IrMethods_get(int argc, VALUE *argv, VALUE self) {
    IrMethodList *arg1 = (IrMethodList *) 0 ;
    std::vector<IrMethod * > *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodList, 1);
    result = (std::vector<IrMethod * > *)& ((arg1)->IrMethods);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTIrMethod_p_t,0);
    return vresult;
}


static VALUE
_wrap_IrArgument_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrArgument);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrArgument(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    std::string arg3 ;
    IrArgument *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[2]) == T_STRING) {
            arg3 = std::string(STR2CSTR(argv[2]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (IrArgument *)new IrArgument(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrArgument(IrArgument *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrArgument_out(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrArgument_getMode(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (arg1)->getMode();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrArgument_getType(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (arg1)->getType();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrArgument_getName(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrArgument_getMappedType(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (arg1)->getMappedType();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrArgument_compare(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    IrArgument *arg2 = (IrArgument *) 0 ;
    IrNameMap *arg3 = (IrNameMap *) 0 ;
    IrMap *arg4 = (IrMap *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrArgument, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_IrMap, 1);
    result = (bool)(arg1)->compare(arg2,arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_IrArgument_mode_set(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->mode = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrArgument_mode_get(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (std::string *)& ((arg1)->mode);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrArgument_type_set(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->type = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrArgument_type_get(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (std::string *)& ((arg1)->type);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrArgument_name_set(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->name = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrArgument_name_get(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (std::string *)& ((arg1)->name);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrArgument_mappedType_set(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->mappedType = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrArgument_mappedType_get(int argc, VALUE *argv, VALUE self) {
    IrArgument *arg1 = (IrArgument *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgument, 1);
    result = (std::string *)& ((arg1)->mappedType);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrArgumentList_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrArgumentList);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrArgumentList(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrArgumentList *)new IrArgumentList();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrArgumentList(IrArgumentList *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrArgumentList_addArg(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    IrArgument *arg2 = (IrArgument *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrArgument, 1);
    (arg1)->addArg(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrArgumentList_addArgToFront(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    IrArgument *arg2 = (IrArgument *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrArgument, 1);
    (arg1)->addArgToFront(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrArgumentList_out(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrArgumentList_getArgSize(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    result = (int)(arg1)->getArgSize();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrArgumentList_getArg(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    int arg2 ;
    IrArgument *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    arg2 = NUM2INT(argv[0]);
    result = (IrArgument *)(arg1)->getArg(arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrArgument,0);
    return vresult;
}


static VALUE
_wrap_IrArgumentList_compare(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    IrArgumentList *arg2 = (IrArgumentList *) 0 ;
    IrNameMap *arg3 = (IrNameMap *) 0 ;
    IrMap *arg4 = (IrMap *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrArgumentList, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_IrMap, 1);
    result = (bool)(arg1)->compare(arg2,arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_IrArgumentList_irArgs_set(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    std::vector<IrArgument * > *arg2 = (std::vector<IrArgument * > *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTIrArgument_p_t, 1);
    if (arg1) (arg1)->irArgs = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrArgumentList_irArgs_get(int argc, VALUE *argv, VALUE self) {
    IrArgumentList *arg1 = (IrArgumentList *) 0 ;
    std::vector<IrArgument * > *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrArgumentList, 1);
    result = (std::vector<IrArgument * > *)& ((arg1)->irArgs);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTIrArgument_p_t,0);
    return vresult;
}


static VALUE
_wrap_new_IrMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
    IrMap *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrMap *)new IrMap();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_IrMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    IrNameMapList *arg3 = (IrNameMapList *) 0 ;
    IR *arg4 = (IR *) 0 ;
    IrMap *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_IrNameMapList, 1);
    SWIG_ConvertPtr(argv[3], (void **) &arg4, SWIGTYPE_p_IR, 1);
    result = (IrMap *)new IrMap(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_IrMap_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrMap);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    IR *arg2 = (IR *) 0 ;
    IrMap *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_IR, 1);
    result = (IrMap *)new IrMap(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_IrMap(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_IrMap__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_IrNameMapList, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_IR, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_IrMap__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_IrNameMapList, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_IR, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_IrMap__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_IrMap'");
    return Qnil;
}


static void
free_IrMap(IrMap *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrMap_out(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMap_addMethodMap(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrMethodMap *arg2 = (IrMethodMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMethodMap, 1);
    (arg1)->addMethodMap(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrMap_getMethodMap(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    int arg2 ;
    IrMethodMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    arg2 = NUM2INT(argv[0]);
    result = (IrMethodMap *)(arg1)->getMethodMap(arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMethodMap,0);
    return vresult;
}


static VALUE
_wrap_IrMap_getMethodMapSize(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (int)(arg1)->getMethodMapSize();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrMap_staticCheck(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    (arg1)->staticCheck();
    
    return Qnil;
}


static VALUE
_wrap_IrMap_existsNameMap(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    IrNameMap **arg4 = (IrNameMap **) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg3 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_p_IrNameMap, 1);
    result = (int)(arg1)->existsNameMap(arg2,arg3,arg4);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrMap_getInSymbol(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (arg1)->getInSymbol();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMap_getOutSymbol(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (arg1)->getOutSymbol();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMap_getInPackage(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (arg1)->getInPackage();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMap_getOutPackage(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (arg1)->getOutPackage();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMap_inSymbol_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->inSymbol = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_inSymbol_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (std::string *)& ((arg1)->inSymbol);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrMap_outSymbol_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->outSymbol = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_outSymbol_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (std::string *)& ((arg1)->outSymbol);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrMap_inPort_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrPort *arg2 = (IrPort *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrPort, 1);
    if (arg1) (arg1)->inPort = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_inPort_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrPort *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (IrPort *) ((arg1)->inPort);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPort,0);
    return vresult;
}


static VALUE
_wrap_IrMap_outPort_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrPort *arg2 = (IrPort *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrPort, 1);
    if (arg1) (arg1)->outPort = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_outPort_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrPort *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (IrPort *) ((arg1)->outPort);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrPort,0);
    return vresult;
}


static VALUE
_wrap_IrMap_nameMapL_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrNameMapList *arg2 = (IrNameMapList *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrNameMapList, 1);
    if (arg1) (arg1)->nameMapL = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_nameMapL_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IrNameMapList *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (IrNameMapList *) ((arg1)->nameMapL);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrNameMapList,0);
    return vresult;
}


static VALUE
_wrap_IrMap_irptr_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IR *arg2 = (IR *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IR, 1);
    if (arg1) (arg1)->irptr = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_irptr_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    IR *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (IR *) ((arg1)->irptr);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IR,0);
    return vresult;
}


static VALUE
_wrap_IrMap_methodMaps_set(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::vector<IrMethodMap * > *arg2 = (std::vector<IrMethodMap * > *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTIrMethodMap_p_t, 1);
    if (arg1) (arg1)->methodMaps = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMap_methodMaps_get(int argc, VALUE *argv, VALUE self) {
    IrMap *arg1 = (IrMap *) 0 ;
    std::vector<IrMethodMap * > *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMap, 1);
    result = (std::vector<IrMethodMap * > *)& ((arg1)->methodMaps);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTIrMethodMap_p_t,0);
    return vresult;
}


static VALUE
_wrap_IrNameMapList_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrNameMapList);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrNameMapList(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrNameMapList *)new IrNameMapList();
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrNameMapList(IrNameMapList *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrNameMapList_addNameMap(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    IrNameMap *arg2 = (IrNameMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrNameMap, 1);
    (arg1)->addNameMap(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrNameMapList_existsNameMap(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    IrNameMap **arg4 = (IrNameMap **) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg3 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_p_IrNameMap, 1);
    result = (int)(arg1)->existsNameMap(arg2,arg3,arg4);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrNameMapList_parentmap_set(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    IrMap *arg2 = (IrMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMap, 1);
    if (arg1) (arg1)->parentmap = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrNameMapList_parentmap_get(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    IrMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    result = (IrMap *) ((arg1)->parentmap);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMap,0);
    return vresult;
}


static VALUE
_wrap_IrNameMapList_nameMaps_set(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    std::vector<IrNameMap * > *arg2 = (std::vector<IrNameMap * > *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTIrNameMap_p_t, 1);
    if (arg1) (arg1)->nameMaps = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrNameMapList_nameMaps_get(int argc, VALUE *argv, VALUE self) {
    IrNameMapList *arg1 = (IrNameMapList *) 0 ;
    std::vector<IrNameMap * > *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMapList, 1);
    result = (std::vector<IrNameMap * > *)& ((arg1)->nameMaps);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTIrNameMap_p_t,0);
    return vresult;
}


static VALUE
_wrap_IrNameMap_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrNameMap);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrNameMap(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    IrNameMap *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (IrNameMap *)new IrNameMap(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static void
free_IrNameMap(IrNameMap *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrNameMap_addSubList(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    IrNameMapList *arg2 = (IrNameMapList *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrNameMapList, 1);
    (arg1)->addSubList(arg2);
    
    return Qnil;
}


static VALUE
_wrap_IrNameMap_existsNameMap(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg3 = std::string(STR2CSTR(argv[1]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->existsNameMap(arg2,arg3);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_IrNameMap_nameOne_set(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->nameOne = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrNameMap_nameOne_get(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    result = (std::string *)& ((arg1)->nameOne);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrNameMap_nameTwo_set(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->nameTwo = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrNameMap_nameTwo_get(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    result = (std::string *)& ((arg1)->nameTwo);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_IrNameMap_subList_set(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    IrNameMapList *arg2 = (IrNameMapList *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrNameMapList, 1);
    if (arg1) (arg1)->subList = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrNameMap_subList_get(int argc, VALUE *argv, VALUE self) {
    IrNameMap *arg1 = (IrNameMap *) 0 ;
    IrNameMapList *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrNameMap, 1);
    result = (IrNameMapList *) ((arg1)->subList);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrNameMapList,0);
    return vresult;
}


static VALUE
_wrap_new_IrMethodMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IrMethodMap *)new IrMethodMap();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_IrMethodMap_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IrMethodMap);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_IrMethodMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
    IrMethod *arg1 = (IrMethod *) 0 ;
    IrMethod *arg2 = (IrMethod *) 0 ;
    IrMethodMap *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_IrMethod, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_IrMethod, 1);
    result = (IrMethodMap *)new IrMethodMap(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_IrMethodMap(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_IrMethodMap__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_IrMethod, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_IrMethod, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_IrMethodMap__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_IrMethodMap'");
    return Qnil;
}


static void
free_IrMethodMap(IrMethodMap *arg1) {
    delete arg1;
}
static VALUE
_wrap_IrMethodMap_out(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *arg1 = (IrMethodMap *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap, 1);
    result = (arg1)->out();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_IrMethodMap_inMethod_set(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *arg1 = (IrMethodMap *) 0 ;
    IrMethod *arg2 = (IrMethod *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMethod, 1);
    if (arg1) (arg1)->inMethod = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMethodMap_inMethod_get(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *arg1 = (IrMethodMap *) 0 ;
    IrMethod *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap, 1);
    result = (IrMethod *) ((arg1)->inMethod);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMethod,0);
    return vresult;
}


static VALUE
_wrap_IrMethodMap_outMethod_set(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *arg1 = (IrMethodMap *) 0 ;
    IrMethod *arg2 = (IrMethod *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_IrMethod, 1);
    if (arg1) (arg1)->outMethod = arg2;
    
    return Qnil;
}


static VALUE
_wrap_IrMethodMap_outMethod_get(int argc, VALUE *argv, VALUE self) {
    IrMethodMap *arg1 = (IrMethodMap *) 0 ;
    IrMethod *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_IrMethodMap, 1);
    result = (IrMethod *) ((arg1)->outMethod);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IrMethod,0);
    return vresult;
}


static VALUE
_wrap_errHandler(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    errHandler(arg1);
    
    return Qnil;
}


static VALUE
_wrap_frontEndIdl(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)frontEndIdl(arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_frontEndCpp(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(STR2CSTR(argv[0]));
        }else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)frontEndCpp(arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_allocateIR(int argc, VALUE *argv, VALUE self) {
    IR *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (IR *)allocateIR();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IR,0);
    return vresult;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_IrPackageTo_p_IrDefinition(void *x) {
    return (void *)((IrDefinition *)  ((IrPackage *) x));
}
static void *_p_IrPortTo_p_IrDefinition(void *x) {
    return (void *)((IrDefinition *)  ((IrPort *) x));
}
static void *_p_IrMethodMap_pTo_p_IrMethodMap(void *x) {
    return (void *)((IrMethodMap *)  ((IrMethodMap_p *) x));
}
static void *_p_IrMap_pTo_p_IrMap(void *x) {
    return (void *)((IrMap *)  ((IrMap_p *) x));
}
static void *_p_p_IrMap_pTo_p_p_IrMap(void *x) {
    return (void *)((IrMap **)  ((IrMap_p **) x));
}
static swig_type_info _swigt__p_IrPort[] = {{"_p_IrPort", 0, "IrPort *", 0},{"_p_IrPort"},{0}};
static swig_type_info _swigt__p_IrDefinition[] = {{"_p_IrDefinition", 0, "IrDefinition *", 0},{"_p_IrPackage", _p_IrPackageTo_p_IrDefinition},{"_p_IrDefinition"},{"_p_IrPort", _p_IrPortTo_p_IrDefinition},{0}};
static swig_type_info _swigt__p_IrMap[] = {{"_p_IrMap", 0, "IrMap *", 0},{"_p_IrMap"},{"_p_IrMap_p", _p_IrMap_pTo_p_IrMap},{0}};
static swig_type_info _swigt__p_p_IrMap[] = {{"_p_p_IrMap", 0, "IrMap **", 0},{"_p_p_IrMap"},{"_p_p_IrMap_p", _p_p_IrMap_pTo_p_p_IrMap},{0}};
static swig_type_info _swigt__p_IrMethodMap_p[] = {{"_p_IrMethodMap_p", 0, "IrMethodMap_p *", 0},{"_p_IrMethodMap_p"},{0}};
static swig_type_info _swigt__p_IrArgumentList[] = {{"_p_IrArgumentList", 0, "IrArgumentList *", 0},{"_p_IrArgumentList"},{0}};
static swig_type_info _swigt__p_IrArgument[] = {{"_p_IrArgument", 0, "IrArgument *", 0},{"_p_IrArgument"},{0}};
static swig_type_info _swigt__p_std__vectorTIrArgument_p_t[] = {{"_p_std__vectorTIrArgument_p_t", 0, "std::vector<IrArgument * > *", 0},{"_p_std__vectorTIrArgument_p_t"},{0}};
static swig_type_info _swigt__p_IrNameMap[] = {{"_p_IrNameMap", 0, "IrNameMap *", 0},{"_p_IrNameMap"},{0}};
static swig_type_info _swigt__p_p_IrNameMap[] = {{"_p_p_IrNameMap", 0, "IrNameMap **", 0},{"_p_p_IrNameMap"},{0}};
static swig_type_info _swigt__p_IR[] = {{"_p_IR", 0, "IR *", 0},{"_p_IR"},{0}};
static swig_type_info _swigt__p_IrMethod[] = {{"_p_IrMethod", 0, "IrMethod *", 0},{"_p_IrMethod"},{0}};
static swig_type_info _swigt__p_IrPackage[] = {{"_p_IrPackage", 0, "IrPackage *", 0},{"_p_IrPackage"},{0}};
static swig_type_info _swigt__p_IrMethodMap[] = {{"_p_IrMethodMap", 0, "IrMethodMap *", 0},{"_p_IrMethodMap_p", _p_IrMethodMap_pTo_p_IrMethodMap},{"_p_IrMethodMap"},{0}};
static swig_type_info _swigt__p_IrDefList[] = {{"_p_IrDefList", 0, "IrDefList *", 0},{"_p_IrDefList"},{0}};
static swig_type_info _swigt__p_std__string[] = {{"_p_std__string", 0, "std::string *", 0},{"_p_std__string"},{0}};
static swig_type_info _swigt__p_IrMap_p[] = {{"_p_IrMap_p", 0, "IrMap_p *", 0},{"_p_IrMap_p"},{0}};
static swig_type_info _swigt__p_IrNameMapList[] = {{"_p_IrNameMapList", 0, "IrNameMapList *", 0},{"_p_IrNameMapList"},{0}};
static swig_type_info _swigt__p_std__vectorTIrMap_p_t[] = {{"_p_std__vectorTIrMap_p_t", 0, "std::vector<IrMap * > *", 0},{"_p_std__vectorTIrMap_p_t"},{0}};
static swig_type_info _swigt__p_std__vectorTstd__string_t[] = {{"_p_std__vectorTstd__string_t", 0, "std::vector<std::string > *", 0},{"_p_std__vectorTstd__string_t"},{0}};
static swig_type_info _swigt__p_std__vectorTIrMethodMap_p_t[] = {{"_p_std__vectorTIrMethodMap_p_t", 0, "std::vector<IrMethodMap * > *", 0},{"_p_std__vectorTIrMethodMap_p_t"},{0}};
static swig_type_info _swigt__p_std__vectorTIrNameMap_p_t[] = {{"_p_std__vectorTIrNameMap_p_t", 0, "std::vector<IrNameMap * > *", 0},{"_p_std__vectorTIrNameMap_p_t"},{0}};
static swig_type_info _swigt__p_IrMethodList[] = {{"_p_IrMethodList", 0, "IrMethodList *", 0},{"_p_IrMethodList"},{0}};
static swig_type_info _swigt__p_std__vectorTIrMethod_p_t[] = {{"_p_std__vectorTIrMethod_p_t", 0, "std::vector<IrMethod * > *", 0},{"_p_std__vectorTIrMethod_p_t"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_IrPort, 
_swigt__p_IrDefinition, 
_swigt__p_IrMap, 
_swigt__p_p_IrMap, 
_swigt__p_IrMethodMap_p, 
_swigt__p_IrArgumentList, 
_swigt__p_IrArgument, 
_swigt__p_std__vectorTIrArgument_p_t, 
_swigt__p_IrNameMap, 
_swigt__p_p_IrNameMap, 
_swigt__p_IR, 
_swigt__p_IrMethod, 
_swigt__p_IrPackage, 
_swigt__p_IrMethodMap, 
_swigt__p_IrDefList, 
_swigt__p_std__string, 
_swigt__p_IrMap_p, 
_swigt__p_IrNameMapList, 
_swigt__p_std__vectorTIrMap_p_t, 
_swigt__p_std__vectorTstd__string_t, 
_swigt__p_std__vectorTIrMethodMap_p_t, 
_swigt__p_std__vectorTIrNameMap_p_t, 
_swigt__p_IrMethodList, 
_swigt__p_std__vectorTIrMethod_p_t, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) Init_libCore_CCA_tools_scim(void) {
    int i;
    
    SWIG_InitRuntime();
    mScim = rb_define_module("Scim");
    
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        SWIG_define_class(swig_types[i]);
    }
    
    
    cMapVector.klass = rb_define_class_under(mScim, "MapVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTIrMap_p_t, (void *) &cMapVector);
    rb_include_module(cMapVector.klass, rb_eval_string("Enumerable"));
    rb_define_singleton_method(cMapVector.klass, "new", VALUEFUNC(_wrap_MapVector_allocate), -1);
    rb_define_method(cMapVector.klass, "initialize", VALUEFUNC(_wrap_new_MapVector), -1);
    rb_define_method(cMapVector.klass, "length", VALUEFUNC(_wrap_MapVector___len__), -1);
    rb_define_method(cMapVector.klass, "empty?", VALUEFUNC(_wrap_MapVector_emptyq___), -1);
    rb_define_method(cMapVector.klass, "clear", VALUEFUNC(_wrap_MapVector_clear), -1);
    rb_define_method(cMapVector.klass, "push", VALUEFUNC(_wrap_MapVector_push), -1);
    rb_define_method(cMapVector.klass, "pop", VALUEFUNC(_wrap_MapVector_pop), -1);
    rb_define_method(cMapVector.klass, "[]", VALUEFUNC(_wrap_MapVector___getitem__), -1);
    rb_define_method(cMapVector.klass, "[]=", VALUEFUNC(_wrap_MapVector___setitem__), -1);
    rb_define_method(cMapVector.klass, "each", VALUEFUNC(_wrap_MapVector_each), -1);
    cMapVector.mark = 0;
    cMapVector.destroy = (void (*)(void *)) free_std_vectorlIrMap_m_g___;
    
    cIrMap_p.klass = rb_define_class_under(mScim, "IrMap_p", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrMap_p, (void *) &cIrMap_p);
    rb_define_singleton_method(cIrMap_p.klass, "new", VALUEFUNC(_wrap_IrMap_p_allocate), -1);
    rb_define_method(cIrMap_p.klass, "initialize", VALUEFUNC(_wrap_new_IrMap_p), -1);
    rb_define_method(cIrMap_p.klass, "assign", VALUEFUNC(_wrap_IrMap_p_assign), -1);
    rb_define_method(cIrMap_p.klass, "value", VALUEFUNC(_wrap_IrMap_p_value), -1);
    rb_define_method(cIrMap_p.klass, "cast", VALUEFUNC(_wrap_IrMap_p_cast), -1);
    rb_define_singleton_method(cIrMap_p.klass, "frompointer", VALUEFUNC(_wrap_IrMap_p_frompointer), -1);
    cIrMap_p.mark = 0;
    cIrMap_p.destroy = (void (*)(void *)) free_IrMap_p;
    
    cIrMethodMap_p.klass = rb_define_class_under(mScim, "IrMethodMap_p", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrMethodMap_p, (void *) &cIrMethodMap_p);
    rb_define_singleton_method(cIrMethodMap_p.klass, "new", VALUEFUNC(_wrap_IrMethodMap_p_allocate), -1);
    rb_define_method(cIrMethodMap_p.klass, "initialize", VALUEFUNC(_wrap_new_IrMethodMap_p), -1);
    rb_define_method(cIrMethodMap_p.klass, "assign", VALUEFUNC(_wrap_IrMethodMap_p_assign), -1);
    rb_define_method(cIrMethodMap_p.klass, "value", VALUEFUNC(_wrap_IrMethodMap_p_value), -1);
    rb_define_method(cIrMethodMap_p.klass, "cast", VALUEFUNC(_wrap_IrMethodMap_p_cast), -1);
    rb_define_singleton_method(cIrMethodMap_p.klass, "frompointer", VALUEFUNC(_wrap_IrMethodMap_p_frompointer), -1);
    cIrMethodMap_p.mark = 0;
    cIrMethodMap_p.destroy = (void (*)(void *)) free_IrMethodMap_p;
    rb_define_const(mScim,"MODEIN", INT2NUM(MODEIN));
    rb_define_const(mScim,"MODEOUT", INT2NUM(MODEOUT));
    rb_define_const(mScim,"MODEINOUT", INT2NUM(MODEINOUT));
    
    cIR.klass = rb_define_class_under(mScim, "IR", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IR, (void *) &cIR);
    rb_define_singleton_method(cIR.klass, "new", VALUEFUNC(_wrap_IR_allocate), -1);
    rb_define_method(cIR.klass, "initialize", VALUEFUNC(_wrap_new_IR), -1);
    rb_define_method(cIR.klass, "staticCheck", VALUEFUNC(_wrap_IR_staticCheck), -1);
    rb_define_method(cIR.klass, "setPackage", VALUEFUNC(_wrap_IR_setPackage), -1);
    rb_define_method(cIR.klass, "getPackage", VALUEFUNC(_wrap_IR_getPackage), -1);
    rb_define_method(cIR.klass, "addInDefList", VALUEFUNC(_wrap_IR_addInDefList), -1);
    rb_define_method(cIR.klass, "addOutDefList", VALUEFUNC(_wrap_IR_addOutDefList), -1);
    rb_define_method(cIR.klass, "addInOutDef", VALUEFUNC(_wrap_IR_addInOutDef), -1);
    rb_define_method(cIR.klass, "addMap", VALUEFUNC(_wrap_IR_addMap), -1);
    rb_define_method(cIR.klass, "setForAllMap", VALUEFUNC(_wrap_IR_setForAllMap), -1);
    rb_define_method(cIR.klass, "getForAllMap", VALUEFUNC(_wrap_IR_getForAllMap), -1);
    rb_define_method(cIR.klass, "remapInOut", VALUEFUNC(_wrap_IR_remapInOut), -1);
    rb_define_method(cIR.klass, "omitInOut", VALUEFUNC(_wrap_IR_omitInOut), -1);
    rb_define_method(cIR.klass, "existsOmit", VALUEFUNC(_wrap_IR_existsOmit), -1);
    rb_define_method(cIR.klass, "outFile", VALUEFUNC(_wrap_IR_outFile), -1);
    rb_define_method(cIR.klass, "getMap", VALUEFUNC(_wrap_IR_getMap), -1);
    rb_define_method(cIR.klass, "getMapSize", VALUEFUNC(_wrap_IR_getMapSize), -1);
    cIR.mark = 0;
    cIR.destroy = (void (*)(void *)) free_IR;
    
    cIrDefinition.klass = rb_define_class_under(mScim, "IrDefinition", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrDefinition, (void *) &cIrDefinition);
    rb_undef_method(CLASS_OF(cIrDefinition.klass), "new");
    rb_define_method(cIrDefinition.klass, "out", VALUEFUNC(_wrap_IrDefinition_out), -1);
    rb_define_method(cIrDefinition.klass, "findPort", VALUEFUNC(_wrap_IrDefinition_findPort), -1);
    rb_define_method(cIrDefinition.klass, "selfMap", VALUEFUNC(_wrap_IrDefinition_selfMap), -1);
    rb_define_method(cIrDefinition.klass, "getPortNames", VALUEFUNC(_wrap_IrDefinition_getPortNames), -1);
    rb_define_method(cIrDefinition.klass, "mode=", VALUEFUNC(_wrap_IrDefinition_mode_set), -1);
    rb_define_method(cIrDefinition.klass, "mode", VALUEFUNC(_wrap_IrDefinition_mode_get), -1);
    cIrDefinition.mark = 0;
    cIrDefinition.destroy = (void (*)(void *)) free_IrDefinition;
    
    cIrPackage.klass = rb_define_class_under(mScim, "IrPackage", ((swig_class *) SWIGTYPE_p_IrDefinition->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_IrPackage, (void *) &cIrPackage);
    rb_define_singleton_method(cIrPackage.klass, "new", VALUEFUNC(_wrap_IrPackage_allocate), -1);
    rb_define_method(cIrPackage.klass, "initialize", VALUEFUNC(_wrap_new_IrPackage), -1);
    rb_define_method(cIrPackage.klass, "out", VALUEFUNC(_wrap_IrPackage_out), -1);
    rb_define_method(cIrPackage.klass, "findPort", VALUEFUNC(_wrap_IrPackage_findPort), -1);
    rb_define_method(cIrPackage.klass, "selfMap", VALUEFUNC(_wrap_IrPackage_selfMap), -1);
    rb_define_method(cIrPackage.klass, "getPortNames", VALUEFUNC(_wrap_IrPackage_getPortNames), -1);
    rb_define_method(cIrPackage.klass, "getName", VALUEFUNC(_wrap_IrPackage_getName), -1);
    cIrPackage.mark = 0;
    cIrPackage.destroy = (void (*)(void *)) free_IrPackage;
    
    cIrDefList.klass = rb_define_class_under(mScim, "IrDefList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrDefList, (void *) &cIrDefList);
    rb_define_singleton_method(cIrDefList.klass, "new", VALUEFUNC(_wrap_IrDefList_allocate), -1);
    rb_define_method(cIrDefList.klass, "initialize", VALUEFUNC(_wrap_new_IrDefList), -1);
    rb_define_method(cIrDefList.klass, "addDef", VALUEFUNC(_wrap_IrDefList_addDef), -1);
    rb_define_method(cIrDefList.klass, "modeTag", VALUEFUNC(_wrap_IrDefList_modeTag), -1);
    rb_define_method(cIrDefList.klass, "findPort", VALUEFUNC(_wrap_IrDefList_findPort), -1);
    rb_define_method(cIrDefList.klass, "selfMap", VALUEFUNC(_wrap_IrDefList_selfMap), -1);
    rb_define_method(cIrDefList.klass, "getPortNames", VALUEFUNC(_wrap_IrDefList_getPortNames), -1);
    rb_define_method(cIrDefList.klass, "getSize", VALUEFUNC(_wrap_IrDefList_getSize), -1);
    rb_define_method(cIrDefList.klass, "getDef", VALUEFUNC(_wrap_IrDefList_getDef), -1);
    rb_define_method(cIrDefList.klass, "out", VALUEFUNC(_wrap_IrDefList_out), -1);
    cIrDefList.mark = 0;
    cIrDefList.destroy = (void (*)(void *)) free_IrDefList;
    
    cIrPort.klass = rb_define_class_under(mScim, "IrPort", ((swig_class *) SWIGTYPE_p_IrDefinition->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_IrPort, (void *) &cIrPort);
    rb_define_singleton_method(cIrPort.klass, "new", VALUEFUNC(_wrap_IrPort_allocate), -1);
    rb_define_method(cIrPort.klass, "initialize", VALUEFUNC(_wrap_new_IrPort), -1);
    rb_define_method(cIrPort.klass, "out", VALUEFUNC(_wrap_IrPort_out), -1);
    rb_define_method(cIrPort.klass, "findPort", VALUEFUNC(_wrap_IrPort_findPort), -1);
    rb_define_method(cIrPort.klass, "selfMap", VALUEFUNC(_wrap_IrPort_selfMap), -1);
    rb_define_method(cIrPort.klass, "staticCheck", VALUEFUNC(_wrap_IrPort_staticCheck), -1);
    rb_define_method(cIrPort.klass, "getPackageName", VALUEFUNC(_wrap_IrPort_getPackageName), -1);
    rb_define_method(cIrPort.klass, "getPortNames", VALUEFUNC(_wrap_IrPort_getPortNames), -1);
    cIrPort.mark = 0;
    cIrPort.destroy = (void (*)(void *)) free_IrPort;
    
    cIrMethod.klass = rb_define_class_under(mScim, "IrMethod", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrMethod, (void *) &cIrMethod);
    rb_define_singleton_method(cIrMethod.klass, "new", VALUEFUNC(_wrap_IrMethod_allocate), -1);
    rb_define_method(cIrMethod.klass, "initialize", VALUEFUNC(_wrap_new_IrMethod), -1);
    rb_define_method(cIrMethod.klass, "out", VALUEFUNC(_wrap_IrMethod_out), -1);
    rb_define_method(cIrMethod.klass, "getName", VALUEFUNC(_wrap_IrMethod_getName), -1);
    rb_define_method(cIrMethod.klass, "getReturnType", VALUEFUNC(_wrap_IrMethod_getReturnType), -1);
    rb_define_method(cIrMethod.klass, "getArgList", VALUEFUNC(_wrap_IrMethod_getArgList), -1);
    rb_define_method(cIrMethod.klass, "compare", VALUEFUNC(_wrap_IrMethod_compare), -1);
    rb_define_method(cIrMethod.klass, "name=", VALUEFUNC(_wrap_IrMethod_name_set), -1);
    rb_define_method(cIrMethod.klass, "name", VALUEFUNC(_wrap_IrMethod_name_get), -1);
    rb_define_method(cIrMethod.klass, "retType=", VALUEFUNC(_wrap_IrMethod_retType_set), -1);
    rb_define_method(cIrMethod.klass, "retType", VALUEFUNC(_wrap_IrMethod_retType_get), -1);
    rb_define_method(cIrMethod.klass, "irArgL=", VALUEFUNC(_wrap_IrMethod_irArgL_set), -1);
    rb_define_method(cIrMethod.klass, "irArgL", VALUEFUNC(_wrap_IrMethod_irArgL_get), -1);
    cIrMethod.mark = 0;
    cIrMethod.destroy = (void (*)(void *)) free_IrMethod;
    
    cIrMethodList.klass = rb_define_class_under(mScim, "IrMethodList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrMethodList, (void *) &cIrMethodList);
    rb_define_singleton_method(cIrMethodList.klass, "new", VALUEFUNC(_wrap_IrMethodList_allocate), -1);
    rb_define_method(cIrMethodList.klass, "initialize", VALUEFUNC(_wrap_new_IrMethodList), -1);
    rb_define_method(cIrMethodList.klass, "addMethod", VALUEFUNC(_wrap_IrMethodList_addMethod), -1);
    rb_define_method(cIrMethodList.klass, "out", VALUEFUNC(_wrap_IrMethodList_out), -1);
    rb_define_method(cIrMethodList.klass, "staticCheck", VALUEFUNC(_wrap_IrMethodList_staticCheck), -1);
    rb_define_method(cIrMethodList.klass, "IrMethods=", VALUEFUNC(_wrap_IrMethodList_IrMethods_set), -1);
    rb_define_method(cIrMethodList.klass, "IrMethods", VALUEFUNC(_wrap_IrMethodList_IrMethods_get), -1);
    cIrMethodList.mark = 0;
    cIrMethodList.destroy = (void (*)(void *)) free_IrMethodList;
    
    cIrArgument.klass = rb_define_class_under(mScim, "IrArgument", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrArgument, (void *) &cIrArgument);
    rb_define_singleton_method(cIrArgument.klass, "new", VALUEFUNC(_wrap_IrArgument_allocate), -1);
    rb_define_method(cIrArgument.klass, "initialize", VALUEFUNC(_wrap_new_IrArgument), -1);
    rb_define_method(cIrArgument.klass, "out", VALUEFUNC(_wrap_IrArgument_out), -1);
    rb_define_method(cIrArgument.klass, "getMode", VALUEFUNC(_wrap_IrArgument_getMode), -1);
    rb_define_method(cIrArgument.klass, "getType", VALUEFUNC(_wrap_IrArgument_getType), -1);
    rb_define_method(cIrArgument.klass, "getName", VALUEFUNC(_wrap_IrArgument_getName), -1);
    rb_define_method(cIrArgument.klass, "getMappedType", VALUEFUNC(_wrap_IrArgument_getMappedType), -1);
    rb_define_method(cIrArgument.klass, "compare", VALUEFUNC(_wrap_IrArgument_compare), -1);
    rb_define_method(cIrArgument.klass, "mode=", VALUEFUNC(_wrap_IrArgument_mode_set), -1);
    rb_define_method(cIrArgument.klass, "mode", VALUEFUNC(_wrap_IrArgument_mode_get), -1);
    rb_define_method(cIrArgument.klass, "type=", VALUEFUNC(_wrap_IrArgument_type_set), -1);
    rb_define_method(cIrArgument.klass, "type", VALUEFUNC(_wrap_IrArgument_type_get), -1);
    rb_define_method(cIrArgument.klass, "name=", VALUEFUNC(_wrap_IrArgument_name_set), -1);
    rb_define_method(cIrArgument.klass, "name", VALUEFUNC(_wrap_IrArgument_name_get), -1);
    rb_define_method(cIrArgument.klass, "mappedType=", VALUEFUNC(_wrap_IrArgument_mappedType_set), -1);
    rb_define_method(cIrArgument.klass, "mappedType", VALUEFUNC(_wrap_IrArgument_mappedType_get), -1);
    cIrArgument.mark = 0;
    cIrArgument.destroy = (void (*)(void *)) free_IrArgument;
    
    cIrArgumentList.klass = rb_define_class_under(mScim, "IrArgumentList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrArgumentList, (void *) &cIrArgumentList);
    rb_define_singleton_method(cIrArgumentList.klass, "new", VALUEFUNC(_wrap_IrArgumentList_allocate), -1);
    rb_define_method(cIrArgumentList.klass, "initialize", VALUEFUNC(_wrap_new_IrArgumentList), -1);
    rb_define_method(cIrArgumentList.klass, "addArg", VALUEFUNC(_wrap_IrArgumentList_addArg), -1);
    rb_define_method(cIrArgumentList.klass, "addArgToFront", VALUEFUNC(_wrap_IrArgumentList_addArgToFront), -1);
    rb_define_method(cIrArgumentList.klass, "out", VALUEFUNC(_wrap_IrArgumentList_out), -1);
    rb_define_method(cIrArgumentList.klass, "getArgSize", VALUEFUNC(_wrap_IrArgumentList_getArgSize), -1);
    rb_define_method(cIrArgumentList.klass, "getArg", VALUEFUNC(_wrap_IrArgumentList_getArg), -1);
    rb_define_method(cIrArgumentList.klass, "compare", VALUEFUNC(_wrap_IrArgumentList_compare), -1);
    rb_define_method(cIrArgumentList.klass, "irArgs=", VALUEFUNC(_wrap_IrArgumentList_irArgs_set), -1);
    rb_define_method(cIrArgumentList.klass, "irArgs", VALUEFUNC(_wrap_IrArgumentList_irArgs_get), -1);
    cIrArgumentList.mark = 0;
    cIrArgumentList.destroy = (void (*)(void *)) free_IrArgumentList;
    
    cIrMap.klass = rb_define_class_under(mScim, "IrMap", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrMap, (void *) &cIrMap);
    rb_define_singleton_method(cIrMap.klass, "new", VALUEFUNC(_wrap_IrMap_allocate), -1);
    rb_define_method(cIrMap.klass, "initialize", VALUEFUNC(_wrap_new_IrMap), -1);
    rb_define_method(cIrMap.klass, "out", VALUEFUNC(_wrap_IrMap_out), -1);
    rb_define_method(cIrMap.klass, "addMethodMap", VALUEFUNC(_wrap_IrMap_addMethodMap), -1);
    rb_define_method(cIrMap.klass, "getMethodMap", VALUEFUNC(_wrap_IrMap_getMethodMap), -1);
    rb_define_method(cIrMap.klass, "getMethodMapSize", VALUEFUNC(_wrap_IrMap_getMethodMapSize), -1);
    rb_define_method(cIrMap.klass, "staticCheck", VALUEFUNC(_wrap_IrMap_staticCheck), -1);
    rb_define_method(cIrMap.klass, "existsNameMap", VALUEFUNC(_wrap_IrMap_existsNameMap), -1);
    rb_define_method(cIrMap.klass, "getInSymbol", VALUEFUNC(_wrap_IrMap_getInSymbol), -1);
    rb_define_method(cIrMap.klass, "getOutSymbol", VALUEFUNC(_wrap_IrMap_getOutSymbol), -1);
    rb_define_method(cIrMap.klass, "getInPackage", VALUEFUNC(_wrap_IrMap_getInPackage), -1);
    rb_define_method(cIrMap.klass, "getOutPackage", VALUEFUNC(_wrap_IrMap_getOutPackage), -1);
    rb_define_method(cIrMap.klass, "inSymbol=", VALUEFUNC(_wrap_IrMap_inSymbol_set), -1);
    rb_define_method(cIrMap.klass, "inSymbol", VALUEFUNC(_wrap_IrMap_inSymbol_get), -1);
    rb_define_method(cIrMap.klass, "outSymbol=", VALUEFUNC(_wrap_IrMap_outSymbol_set), -1);
    rb_define_method(cIrMap.klass, "outSymbol", VALUEFUNC(_wrap_IrMap_outSymbol_get), -1);
    rb_define_method(cIrMap.klass, "inPort=", VALUEFUNC(_wrap_IrMap_inPort_set), -1);
    rb_define_method(cIrMap.klass, "inPort", VALUEFUNC(_wrap_IrMap_inPort_get), -1);
    rb_define_method(cIrMap.klass, "outPort=", VALUEFUNC(_wrap_IrMap_outPort_set), -1);
    rb_define_method(cIrMap.klass, "outPort", VALUEFUNC(_wrap_IrMap_outPort_get), -1);
    rb_define_method(cIrMap.klass, "nameMapL=", VALUEFUNC(_wrap_IrMap_nameMapL_set), -1);
    rb_define_method(cIrMap.klass, "nameMapL", VALUEFUNC(_wrap_IrMap_nameMapL_get), -1);
    rb_define_method(cIrMap.klass, "irptr=", VALUEFUNC(_wrap_IrMap_irptr_set), -1);
    rb_define_method(cIrMap.klass, "irptr", VALUEFUNC(_wrap_IrMap_irptr_get), -1);
    rb_define_method(cIrMap.klass, "methodMaps=", VALUEFUNC(_wrap_IrMap_methodMaps_set), -1);
    rb_define_method(cIrMap.klass, "methodMaps", VALUEFUNC(_wrap_IrMap_methodMaps_get), -1);
    cIrMap.mark = 0;
    cIrMap.destroy = (void (*)(void *)) free_IrMap;
    
    cIrNameMapList.klass = rb_define_class_under(mScim, "IrNameMapList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrNameMapList, (void *) &cIrNameMapList);
    rb_define_singleton_method(cIrNameMapList.klass, "new", VALUEFUNC(_wrap_IrNameMapList_allocate), -1);
    rb_define_method(cIrNameMapList.klass, "initialize", VALUEFUNC(_wrap_new_IrNameMapList), -1);
    rb_define_method(cIrNameMapList.klass, "addNameMap", VALUEFUNC(_wrap_IrNameMapList_addNameMap), -1);
    rb_define_method(cIrNameMapList.klass, "existsNameMap", VALUEFUNC(_wrap_IrNameMapList_existsNameMap), -1);
    rb_define_method(cIrNameMapList.klass, "parentmap=", VALUEFUNC(_wrap_IrNameMapList_parentmap_set), -1);
    rb_define_method(cIrNameMapList.klass, "parentmap", VALUEFUNC(_wrap_IrNameMapList_parentmap_get), -1);
    rb_define_method(cIrNameMapList.klass, "nameMaps=", VALUEFUNC(_wrap_IrNameMapList_nameMaps_set), -1);
    rb_define_method(cIrNameMapList.klass, "nameMaps", VALUEFUNC(_wrap_IrNameMapList_nameMaps_get), -1);
    cIrNameMapList.mark = 0;
    cIrNameMapList.destroy = (void (*)(void *)) free_IrNameMapList;
    
    cIrNameMap.klass = rb_define_class_under(mScim, "IrNameMap", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrNameMap, (void *) &cIrNameMap);
    rb_define_singleton_method(cIrNameMap.klass, "new", VALUEFUNC(_wrap_IrNameMap_allocate), -1);
    rb_define_method(cIrNameMap.klass, "initialize", VALUEFUNC(_wrap_new_IrNameMap), -1);
    rb_define_method(cIrNameMap.klass, "addSubList", VALUEFUNC(_wrap_IrNameMap_addSubList), -1);
    rb_define_method(cIrNameMap.klass, "existsNameMap", VALUEFUNC(_wrap_IrNameMap_existsNameMap), -1);
    rb_define_method(cIrNameMap.klass, "nameOne=", VALUEFUNC(_wrap_IrNameMap_nameOne_set), -1);
    rb_define_method(cIrNameMap.klass, "nameOne", VALUEFUNC(_wrap_IrNameMap_nameOne_get), -1);
    rb_define_method(cIrNameMap.klass, "nameTwo=", VALUEFUNC(_wrap_IrNameMap_nameTwo_set), -1);
    rb_define_method(cIrNameMap.klass, "nameTwo", VALUEFUNC(_wrap_IrNameMap_nameTwo_get), -1);
    rb_define_method(cIrNameMap.klass, "subList=", VALUEFUNC(_wrap_IrNameMap_subList_set), -1);
    rb_define_method(cIrNameMap.klass, "subList", VALUEFUNC(_wrap_IrNameMap_subList_get), -1);
    cIrNameMap.mark = 0;
    cIrNameMap.destroy = (void (*)(void *)) free_IrNameMap;
    
    cIrMethodMap.klass = rb_define_class_under(mScim, "IrMethodMap", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_IrMethodMap, (void *) &cIrMethodMap);
    rb_define_singleton_method(cIrMethodMap.klass, "new", VALUEFUNC(_wrap_IrMethodMap_allocate), -1);
    rb_define_method(cIrMethodMap.klass, "initialize", VALUEFUNC(_wrap_new_IrMethodMap), -1);
    rb_define_method(cIrMethodMap.klass, "out", VALUEFUNC(_wrap_IrMethodMap_out), -1);
    rb_define_method(cIrMethodMap.klass, "inMethod=", VALUEFUNC(_wrap_IrMethodMap_inMethod_set), -1);
    rb_define_method(cIrMethodMap.klass, "inMethod", VALUEFUNC(_wrap_IrMethodMap_inMethod_get), -1);
    rb_define_method(cIrMethodMap.klass, "outMethod=", VALUEFUNC(_wrap_IrMethodMap_outMethod_set), -1);
    rb_define_method(cIrMethodMap.klass, "outMethod", VALUEFUNC(_wrap_IrMethodMap_outMethod_get), -1);
    cIrMethodMap.mark = 0;
    cIrMethodMap.destroy = (void (*)(void *)) free_IrMethodMap;
    rb_define_module_function(mScim, "errHandler", VALUEFUNC(_wrap_errHandler), -1);
    rb_define_module_function(mScim, "frontEndIdl", VALUEFUNC(_wrap_frontEndIdl), -1);
    rb_define_module_function(mScim, "frontEndCpp", VALUEFUNC(_wrap_frontEndCpp), -1);
    rb_define_module_function(mScim, "allocateIR", VALUEFUNC(_wrap_allocateIR), -1);
}

