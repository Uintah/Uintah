%
%  For more information, please see: http://software.sci.utah.edu
% 
%  The MIT License
% 
%  Copyright (c) 2004 Scientific Computing and Imaging Institute,
%  University of Utah.
% 
%  License for the specific language governing rights and limitations under
%  Permission is hereby granted, free of charge, to any person obtaining a
%  copy of this software and associated documentation files (the "Software"),
%  to deal in the Software without restriction, including without limitation
%  the rights to use, copy, modify, merge, publish, distribute, sublicense,
%  and/or sell copies of the Software, and to permit persons to whom the
%  Software is furnished to do so, subject to the following conditions:
% 
%  The above copyright notice and this permission notice shall be included
%  in all copies or substantial portions of the Software.
% 
%  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
%  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
%  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
%  DEALINGS IN THE SOFTWARE.
%


\chapter{Importing and Exporting \sr{} Data}
\label{ch:import_export} 
\index{importing}
\index{exporting}

This chapter describes the format of text-based data files and the use
of \sr{}'s reader and writer modules to import/export \sr{} data
objects from/to text files. 

\sr{}'s reader and writer modules support two classes of data formats:
\sr{}'s persistent format and text-based formats.  This chapter
discusses text-based formats.

In general, it is best to save data in \sr{}'s persistent
format.  \sr{}'s persistent format loads faster, supports better
numerical precision, and is usually smaller than its text-based
counterpart.  \sr{}'s persistent data files are portable between machine
architectures.  Text-based data are used primarily to import data
generated by other software into \sr{} and to export \sr{} generated
data to other software.

\secrefalt{Using Readers}{sec:using_readers} and \secrefalt{Using
  Writers}{sec:using_writers} discuss the use of \sr{}'s reader and
writer modules to read and write text-based data.
\secrefalt{Text-based File Formats}{sec:text_based_formats} describes
the format of text-based data files.


\section{Using Readers}
\label{sec:using_readers}

%begin{latexonly}
\newcommand{\MatrixReaderGUI}{%
  \centerline{\includegraphics[bb=0 0 413 280,width=4in]{Figures/MatrixReaderGUI.eps.gz}}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\MatrixReaderGUI}{%
    \htmladdimg[alt="MatrixReader Dialog"]{../Figures/MatrixReaderGUI.gif}
  }
\end{htmlonly}

%begin{latexonly}
\newcommand{\ReadFieldNet}{%
  \centerline{\includegraphics[bb=0 0 358 227,height=2in]{Figures/ReadFieldNet.eps.gz}}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\ReadFieldNet}{%
    \htmladdimg[alt="Network that reads a text-based field"]{../Figures/ReadFieldNet.gif}
  }
\end{htmlonly}

This section describes the use of \sr{}'s reader modules to read
text-based data.

Control dialogs for all reader modules are similar.  They contain a
file type popup menu that selects the type (binary or text) of file to
read as input.  The dialog's file browser is used to choose a file.
Figure~\ref{fig:MatrixReaderGUI} shows the control dialog for module
\module{MatrixReader}.  When reading a SCIRun matrix file, item
\guimenuitem{SCIRun Matrix File (*.mat)} is selected from the file
type popup menu.  When reading a text-based matrix file then one of
\guimenuitem{TextDenseMatrix (*.*)} or
\guimenuitem{TextSparseRowMatrix (*.*)} is selected from the file type
popup menu depending on the type of matrix stored in the text file.

\begin{figure}[htb]
  \centering
  \begin{makeimage} \end{makeimage}
  \MatrixReaderGUI
  \caption{\label{fig:MatrixReaderGUI} MatrixReader's dialog}
\end{figure}


When reading unstructured field data from a text file, module
\module{FieldReader} reads data from a node coordinate file and a
separate node connectivity file.  However only one of the files is
chosen with the file browser.  \module{FieldReader} assumes the other
file's name differs only in its extension.

Module \module{FieldReader} can read only field geometry (node
coordinate and node connectivity) data from text files.  Module
\module{MatrixReader} is used to read field data values.  Module
\module{ManageFieldData} is used to merge field geometry data (from
module \module{FieldReader}) with field data values to form a complete
filed.  Figure~\ref{fig:ReadFieldNet} shows the arrangement of these
three modules.

\begin{figure}[htb]
  \centering
  \begin{makeimage} \end{makeimage}
  \ReadFieldNet
  \caption{\label{fig:ReadFieldNet} Network that reads text-based field data}
\end{figure}

\section{Using Writers}
\label{sec:using_writers}

%begin{latexonly}
\newcommand{\FieldWriterGUI}{%
  \centerline{\includegraphics[bb=0 0 434 483,height=4in]{Figures/FieldWriterGUI.eps.gz}}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\FieldWriterGUI}{%
    \htmladdimg[alt="FieldWriter dialog"]{../Figures/FieldWriterGUI.gif}
  }
\end{htmlonly}

%begin{latexonly}
\newcommand{\WriteFieldNet}{%
  \centerline{\includegraphics[bb=0 0 387 224,height=2in]{Figures/WriteFieldNet.eps.gz}}
}
%end{latexonly}
\begin{htmlonly}
  \newcommand{\WriteFieldNet}{%
    \htmladdimg[alt="Network that reads a text-based field"]{../Figures/WriteFieldNet.gif}
  }
\end{htmlonly}

This section describes the use of \sr{}'s writer modules to write
text-based data.

Control dialogs for all writer modules are similar.  They contain a
file type popup menu that selects the type (e.g. text or binary) of
file (or possibly files for text output) to write as output.  The
dialog's file browser is used to specify an output file.
Figure~\ref{fig:FieldWriterGUI} shows the control dialog for module
\module{FieldWriter}.

\begin{figure}[htb]
  \centering
  \begin{makeimage} \end{makeimage}
  \FieldWriterGUI
  \caption{\label{fig:FieldWriterGUI} FieldWriter's dialog}
\end{figure}

When writing unstructured field data to text files, module \module{FieldWriter}
writes data to a node coordinate file and a separate node connectivity
file.  However only one of the files is specified in the dialog.
\module{FieldWriter} assumes the other file's name differs only in its
extension.

When writing to text files, module \module{FieldWriter} can write only
field geometry (node coordinate and node connectivity) data.  Module
\module{FieldWriter} is used to write field data values.  Module
\module{ManageFieldData} is used to split field geometry data from
field data values, sending field geometry data to module
\module{FieldWriter} and field node data to module
\module{FieldWriter}.  Figure~\ref{fig:WriteFieldNet} shows the
arrangement of these three modules.

\begin{figure}[htb]
  \centering
  \begin{makeimage} \end{makeimage}
  \WriteFieldNet
  \caption{\label{fig:WriteFieldNet} Network that writes text-based field data}
\end{figure}


\section{Text-based File Formats}
\label{sec:text_based_formats}

\sr{}'s reader and writer modules read and write text files containing the
following data:

\begin{itemize}
\item Node coordinates
\item Node connectivities
\item Structured mesh parameters
\item Column matrices
\item Dense matrices
\item Sparse row matrices
\item Color map parameters
\end{itemize}

\sr{} unstructured field \index{meshes!unstructured meshes} types are stored in two or three text files.
Curve, hex volume, quad surface, tet volume, and tri surface fields
each require three files: a \secrefalt{node
  coordinate}{sec:node_loc_fmt}, a
\secrefalt{connectivity}{sec:node_conn_fmt}, and a \secrefalt{column
  matrix}{sec:colmat} file.  Point cloud fields require no
connectivity file.  

Note that field readers read node coordinate and connectivity files
only.  Therefore, to construct a complete field from text-based files
a \module{FieldReader} module is used to read node coordinate and
connectivity data and a \module{MatrixReader} module is used to read
field data from a matrix file.  Outputs from modules
\module{FieldReader} and \module{FieldReader} are sent to module
\module{ManageFieldData}, which combines their outputs to create
complete field object.  See \secref{Using Readers}{sec:using_readers}
for more information.

When writing a field, use module \module{ManageFieldData} to split a
field into a geometry stream and a data stream.  Send the geometry
stream to module \module{FieldWriter}, which writes node coordinate
and connectivity files, and send the data stream to module
\module{MatrixWriter}, which writes field data to a matrix file.  See
\secref{Using Writers}{sec:using_writers} for more information.

The structured (curve, quad surface, and hex volume) field types each
require only a \secrefalt{node coordinate}{sec:struct_meshes} file.

\sr{} column matrix, dense matrix, and sparse row matrix data are
stored in \secrefalt{column matrix}{sec:colmat}, \secrefalt{dense
  matrix}{sec:dense_matrix} and \secrefalt{sparse
  matrix}{sec:sparse_row_matrix} files respectively.

A Colormap is stored in a \secrefalt{colormap}{sec:colormap_fmt} file.

\subsection{Node Coordinate File}
\label{sec:node_loc_fmt}

Node coordinate files have the extension \filename{.pts}.  A node
coordinate file contains the coordinates of every node in a mesh.

Field reader and writer modules import/export pts files.

The format is as follows:

\begin{verbatim}
N
x0 y0 z0
x1 y1 z1
    .
    .
    .
xN yN zN
\end{verbatim}

\verb|N| is the number of nodes in the file.  Each remaining line
defines the coordinates of one mesh node.

\subsection{Connectivity Files}
\label{sec:node_conn_fmt}

\sr{} supports five unstructured mesh types.  Each mesh type is
described by a corresponding type of node connectivity file.  Curve
meshes are made up of edge elements contained in \dfn{edge} files.
Surface meshes composed of triangular elements are stored in \dfn{fac}
files.  Surface meshes composed of quadrilateral elements are stored
in \dfn{quad} files.  Volume meshes composed of tetrahedral elements
are stored in \dfn{tet} files.  Volume meshes composed of hexahedral
elements are stored in \dfn{hex} file.

Edge files have the file extension \filename{.edge}.  Fac files have
the extension \filename{.fac}.  Likewise for quad, tet, and hex files.

Field reader and writer modules import/export edge, fac, quad, tet,
and hex connectivity files.

Connectivity files are formatted as follows:

\begin{verbatim}
N
Node indicies of element 0
Node indicies of element 1
            .
            .
            .
Node indicies of element N
\end{verbatim}

\verb|N| specifies the number of elements in a file.

Each  remaining line specifies node indices of one element.
Node indices are assumed to be zero-based.

Edge files have two node indices per line, fac files have three, quad
and tet files have four, and hex files have eight node indices per
line.  For example, a fac file looks like the following:

\begin{verbatim}
N
i0 j0 k0
i1 j1 k0
    .
    .
    .
iN jN kN
\end{verbatim}


%% Needs work!
\subsection{Structured Meshes}
\label{sec:struct_meshes}
\index{meshes!structured meshes}

Structured meshes are stored in node coordinate (pts) files.  Only
node coordinates are needed.  Connectivities are implicit because node
coordinates are stored in \dfn{scan-line} order.

For example, in a structured hexahedral mesh, the list of nodes comprising
element \(e_{i,j,k}\) is \(\{n_{i,j,k}, n_{i,j,k+1}, n_{i,j+1,k+1}, n_{i,j+1,k}, n_{i+1,j,k}, n_{i+1,j,k+1}, n_{i+1,j+1,k+1}, n_{i+1,j+1,k}\}\)

% Verify the following paragraph.  See converter source code.
The formats of node coordinate files for structured meshes differ
slightly from node coordinate files described in \secref{Node
  Coordinate File Format}{sec:node_loc_fmt}.  Node coordinate files
for structured meshes specify the number of indices in each dimension
of the mesh.

A structured curve field node coordinate file looks like this:

\begin{verbatim}
NI
x0 y0 z0
x1 y1 z1
    .
    .
    .
xN yN zN
\end{verbatim}

The node coordinate file for a structured quadrilateral surface field
looks like this:

\begin{verbatim}
NI NJ
x0 y0 z0
x1 y1 z1
    .
    .
    .
xN yN zN
\end{verbatim}

The node coordinate file for a structured hexahedral volume field
looks like this:

\begin{verbatim}
NI NJ NK
x0 y0 z0
x1 y1 z1
    .
    .
    .
xN yN zN
\end{verbatim}


\subsection{Column Matrix}
\label{sec:colmat}
\index{matrices}

The column matrix file format is:

\begin{verbatim}
N
v0 
v1
.
.
.
vN
\end{verbatim}

\verb|N| specifies the number of matrix rows.  \verb|N| is followed by
a list of data values.

\subsection{Dense Matrix}
\label{sec:dense_matrix}

The dense matrix file format is:

\begin{verbatim}
N M
v(0,0) v(0,1)...v(0,M)
v(1,0) v(1,1)...v(1,M)
        .
        .
        .
v(N,0) v(N,1)...v(N,M)
\end{verbatim}

\verb|N|, \verb|M| are the number of matrix rows and columns
respectively.  Following \verb|N| and \verb|M| is a list of data
values given in row major order.


\subsection{Sparse Row Matrix}
\label{sec:sparse_row_matrix}

The sparse row matrix file format is:

\begin{verbatim}
NR NC NE
r0 c0 v0
r1 c1 v1
   .
   .
   .
rNE cNE vNE
\end{verbatim}

\verb|NR|, \verb|NC|, and \verb|NE| specify the number of rows, number
of columns, and number of matrix entries respectively.  

Remaining lines are matrix entries.  Each entry consists of a row
index, a column index, and a data value.  Entries must have ascending
row indices. Column indices must be in ascending order for rows with
multiple entries.

\subsection{Color Map}
\label{sec:colormap_fmt}
\index{color map}

The color map file format is:

\begin{verbatim}
N
r1 g1 b1 a1 v1
r2 g2 b2 a2 v2
      .
      .
      .
rN gN bN aN vN
\end{verbatim}


\verb|N| specifies the number of color map entries in the file.

Each line following \verb|N| is a color map entry consisting of an RGB
color entry, an alpha value, and a data value.  All RGB, alpha, and
data values are in the range 0.0 to 1.0 inclusive.


