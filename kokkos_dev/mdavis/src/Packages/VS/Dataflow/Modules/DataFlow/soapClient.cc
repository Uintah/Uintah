/* soapClient.cpp
   Generated by gSOAP 2.6.2 from OQAFMA/OQAFMAClient.h
   Copyright (C) 2001-2004 Genivia, Inc. All Rights Reserved.
   This software is released under the gSOAP public license and GPL.
   See README.txt for further details.
*/
#include "soapH.h"

SOAP_BEGIN_NAMESPACE(soap)

SOAP_SOURCE_STAMP("@(#) soapClient.cpp ver 2.6.2 2004-08-31 16:11:04 GMT")


SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__processStruQL(struct soap *soap, const char *URL, const char *action, std::string _query, struct ns1__processStruQLResponse &param_1)
{
	struct ns1__processStruQL soap_tmp_ns1__processStruQL;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	if (!URL)
		URL = "http://fme.biostr.washington.edu:8082/OQAFMA_Service/services/ServiceInterface";
	if (!action)
		action = "";
	soap_tmp_ns1__processStruQL._query=_query;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns1__processStruQL(soap, &soap_tmp_ns1__processStruQL);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_ns1__processStruQL(soap, &soap_tmp_ns1__processStruQL, "ns1:processStruQL", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__processStruQL(soap, &soap_tmp_ns1__processStruQL, "ns1:processStruQL", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
#ifndef WITH_LEANER
	 || soap_putattachments(soap)
#endif
	 || soap_end_send(soap))
		return soap_closesock(soap);
	soap_default_ns1__processStruQLResponse(soap, &param_1);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	soap_get_ns1__processStruQLResponse(soap, &param_1, "ns1:processStruQLResponse", "ns1:processStruQLResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			return soap_recv_fault(soap);
		return soap_closesock(soap);
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
#ifndef WITH_LEANER
	 || soap_getattachments(soap)
#endif
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getClosure(struct soap *soap, const char *URL, const char *action, std::string _root, std::string _relationship, struct ns1__getClosureResponse &param_2)
{
	struct ns1__getClosure soap_tmp_ns1__getClosure;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	if (!URL)
		URL = "http://fme.biostr.washington.edu:8082/OQAFMA_Service/services/ServiceInterface";
	if (!action)
		action = "";
	soap_tmp_ns1__getClosure._root=_root;
	soap_tmp_ns1__getClosure._relationship=_relationship;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns1__getClosure(soap, &soap_tmp_ns1__getClosure);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_ns1__getClosure(soap, &soap_tmp_ns1__getClosure, "ns1:getClosure", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__getClosure(soap, &soap_tmp_ns1__getClosure, "ns1:getClosure", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
#ifndef WITH_LEANER
	 || soap_putattachments(soap)
#endif
	 || soap_end_send(soap))
		return soap_closesock(soap);
	soap_default_ns1__getClosureResponse(soap, &param_2);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	soap_get_ns1__getClosureResponse(soap, &param_2, "ns1:getClosureResponse", "ns1:getClosureResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			return soap_recv_fault(soap);
		return soap_closesock(soap);
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
#ifndef WITH_LEANER
	 || soap_getattachments(soap)
#endif
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

SOAP_END_NAMESPACE(soap)

/* end of soapClient.cpp */
