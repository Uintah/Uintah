<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE component SYSTEM "../../../doc/component.dtd">
<?xml-stylesheet href="../../../doc/component.xsl" type="text/xsl"?>
<?cocoon-process type="xslt"?>

<!--
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
-->


<component name="ShowField" category="Visualization">
  <overview>
    <authors>
      <author>Martin Cole</author>
    </authors>
    <summary>
          ShowField is used to visualize the geometry that makes up a 
          Mesh inside a Field. The field takes its color from the Data 
          values that permeate the field where possible.
    </summary>
    <description>
      <p>
         The field in input port 1 holds the mesh and data that are 
         to be visualized. It only needs to have a mesh, in which case 
         it will be rendered in the default color, which is editable from
         the ui. If there is a color map attached to port 2, and there is
         valid data in field, then the data serves as an index into the
         color map, and the mesh is rendered with appropriate colors.
      </p>
      <p>
         Nodes can be rendered as spheres, axes, or as points. Edges can be
         rendered as lines or cylinders. All of which have editable size.
         Faces can be rendered or not.
      </p>
      <p>
         Vector and Tensor vis are forthcoming.
      </p>
      <developer>
	<p>
           ShowField uses the dynamic loader to compile and load a 
           RenderField Algorithm templated on field type. RenderField does 
           all the rendering work, it loads the scene graph to be rendered. 
        </p>
      </developer>
    </description>
  </overview>
  <io>
    <inputs lastportdynamic="no">
      <!-- one of (device port file) -->
      <port>
	<name>Field</name>
	<description>
	  <p>
             The only required input to function properly. This field need 
             only have a valid mesh. Its data is accessed only if the ColorMap 
             port has valid data.
          </p>
	</description>
	<datatype>SCIRun::Field</datatype>
	<componentname>FieldReader</componentname>
      </port>
      <port>
	<name>ColorMap</name>
	<description>
	  <p>
             Optional Input. This is the color indexed by the
             input field's data, and defines the colors the mesh is 
             rendered with.
          </p>
	</description>
	<datatype>SCIRun::ColorMap</datatype>
	<componentname>GenStandardColorMap</componentname>
      </port>
    </inputs>
    <outputs>
      <!-- one of (device port file) -->
      <port>
	<name>Scene Graph</name>
	<description>
	  <p>
             A scene graph is sent out through this port expecting to be 
             rendered by the downstream port.
          </p>
	</description>
	<datatype>SCIRun::Geometry</datatype>
	<componentname>Viewer</componentname>
      </port>
    </outputs>
  </io>
  <gui>
    <description>
      <p>
         The user can control wether or not to render nodes, edges, or 
         faces independently. Also some option for how to render them 
         are available.
      </p>
    </description>
    <parameter>
      <widget>checkbox</widget>
      <datatype>bool</datatype>
      <label>Show Nodes</label>
      <description>
	<p>Toggles display of nodes in the scene.</p>
	<developer>
	  <p>This toggles the state of a GeomSwitch on the C++ side.</p>
	</developer>
      </description>
    </parameter>
    <parameter>
      <widget>radiobutton</widget>
      <datatype>string</datatype>
      <label>Node Display Type</label>
      <description>
	<p>
           Choices are Spheres, Axes, Points. These are options for how to 
           draw the nodes. Spheres will draw spheres centered on the node, 
           Axes will draw a miniature coordinate frame centered on each 
           node, while Points will draw a single point at each node.
        </p>
      </description>
    </parameter>
    <parameter>
      <widget>expontial scale</widget>
      <datatype>double</datatype>
      <label>NodeScale</label>
      <description>
	<p>
           Effects the size of rendered nodes (Point rendered nodes, 
           are always a single point therefore not affected by this value)
        </p>
      </description>
    </parameter>
    <parameter>
      <widget>checkbox</widget>
      <datatype>bool</datatype>
      <label>Show Edges</label>
      <description>
	<p>Toggles display of edges in the scene.</p>
	<developer>
	  <p>This toggles the state of a GeomSwitch on the C++ side.</p>
	</developer>
      </description>
    </parameter>
    <parameter>
      <widget>radiobutton</widget>
      <datatype>string</datatype>
      <label>Edge Display Type</label>
      <description>
	<p>
           Choices are Cylinders or Lines. These are options for how to 
           draw the edges. Cylinders draw cylinders to represent edges, while 
           lines always draw lines.
        </p>
      </description>
    </parameter>
    <parameter>
      <widget>expontial scale</widget>
      <datatype>double</datatype>
      <label>CylinderScale</label>
      <description>
	<p>
           Effects the thickness of both cylinders and lines rendered for 
           edges.
        </p>
      </description>
    </parameter>
    <parameter>
      <widget>checkbox</widget>
      <datatype>bool</datatype>
      <label>Show Faces</label>
      <description>
	<p>Toggles display of faces in the scene.</p>
	<developer>
	  <p>This toggles the state of a GeomSwitch on the C++ side.</p>
	</developer>
      </description>
    </parameter>
    <parameter>
      <widget>slider</widget>
      <datatype>int</datatype>
      <label>Cylinder and Sphere Resolution</label>
      <description>
	<p>
           This effects how smooth spheres and cylinders appear when rendered.
           The greater the number the smoother they appear, but the longer 
           it takes to draw.
        </p>
      </description>
    </parameter>
    <parameter>
      <widget>button</widget>
      <datatype>Material</datatype>
      <label>Default Color</label>
      <description>
	<p>
           This button will pop up a color selector when activated. This 
           allows you to control the default color a mesh will render with.  
           Default color is ignored if a color map is attached to input port 2.
        </p>
      </description>
    </parameter>
    <parameter>
      <widget>button</widget>
      <datatype>none</datatype>
      <label>Excecute</label>
      <description>
	<p>Force the module to execute.</p>
      </description>
    </parameter>
    <parameter>
      <widget>button</widget>
      <datatype>none</datatype>
      <label>Dismiss</label>
      <description>
	<p>Closes the ui window for ShowField.</p>
      </description>
    </parameter>
    <img>../Modules/Visualization/doc/ShowFieldGUI.jpg</img>
  </gui>
  <testing>
    <plan>
      <description>
	<p>
           To test this module all of the steps below need to be attempted 
           with all types of valid fields. Render with/without nodes, 
           edges, and faces.  Also with and without color input.
        </p>
      </description>
      <step>
	<p>connect all inputs, and output to the viewer module.</p>
      </step>
      <step>
	<p>turn off/on faces</p>
      </step>
      <step>
	<p>turn off/on edges</p>
      </step>
      <step>
	<p>turn off/on nodes</p>
      </step>
      <step>
	<p>turn off both edges and faces</p>
      </step>
      <step>
	<p>change NodeScale</p>
      </step>
      <step>
	<p>select Axes</p>
      </step>
      <step>
	<p>change NodeScale</p>
      </step>
      <step>
	<p>select Points</p>
      </step>
      <step>
	<p>turn off nodes</p>
      </step>
      <step>
	<p>turn on edges</p>
      </step>
      <step>
	<p>turn on faces</p>
      </step>
      <step>
	<p>turn on nodes</p>
      </step>
      <step>
	<p>select Spheres</p>
      </step>
    </plan>
  </testing>
</component>
