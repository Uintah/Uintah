<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>2. Concepts</TITLE>
<META NAME="description" CONTENT="2. Concepts">
<META NAME="keywords" CONTENT="usersguide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="usersguide.css">
<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="usersguide.html">
<LINK REL="next" HREF="node4.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html119"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html115"
 HREF="usersguide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html109"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html117"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html118"
 HREF="node8.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html120"
 HREF="node4.html">3. Starting SCIRun</A>
<B> Up:</B> <A NAME="tex2html116"
 HREF="usersguide.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html110"
 HREF="node2.html">1. Introduction</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><strong>Subsections</strong></A>
<UL>
<LI><A NAME="tex2html121"
 HREF="node3.html#SECTION00031000000000000000">2.1 Traditional problem solving methods</A>
<LI><A NAME="tex2html122"
 HREF="node3.html#SECTION00032000000000000000">2.2 Integrated problem solving and computational
steering</A>
<LI><A NAME="tex2html123"
 HREF="node3.html#SECTION00033000000000000000">2.3 <EM>SCIRun</EM> modules and networks</A>
<LI><A NAME="tex2html124"
 HREF="node3.html#SECTION00034000000000000000">2.4 Links to third party software</A>
<LI><A NAME="tex2html125"
 HREF="node3.html#SECTION00035000000000000000">2.5 Extensibility</A>
<LI><A NAME="tex2html126"
 HREF="node3.html#SECTION00036000000000000000">2.6 Detachable interface</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00030000000000000000">&#160;</A>
<A NAME="sec:concepts">&#160;</A> 
<A NAME="524">&#160;</A>
<BR>
2. Concepts
</H1>

<P>
Read this section to learn about the design philosphy and goals of
integrated problem solving environments <A NAME="525">&#160;</A>
generally and how <EM>BioPSE</EM> embodies
some of these ideas.  

<P>

<H2><A NAME="SECTION00031000000000000000">
2.1 Traditional problem solving methods</A>
</H2>

<P>
The traditional method for solving bioelectric field problems uses
multiple, non-integrated computer programs.  For example, a scientist using
a computer simulation to examine the effect of electrode patch placement on
transcardiac current density in the design of a cardiac implantable
defibrillator[<A
 HREF="node7.html#CRJ:Sch95b">1</A>] would require geometric modeling, numerical
simulation, and scientific visualization tools to complete the task.  The
user might need one program to define the thoracic surfaces from medical
images and another to create a discrete mesh of the volume contained within
the surfaces[<A
 HREF="node7.html#CRJ:Sch93b">2</A>].  Another application like Matlab compute a
finite element simulation of the electric current distribution from the
defibrillation electrodes through the thoracic volume[<A
 HREF="node7.html#RSM:And93">3</A>].
Another approach might be to write a Fortran program using a public domain
numerical library such as LAPACK <A NAME="531">&#160;</A>.  To see the output would
require a scientific visualization package (such as those described
in[<A
 HREF="node7.html#RSM:All91">4</A>]).  Between each of these steps, it would be necessary to
save the output of one program in a format that the next in the sequence
could read--this might necessitate separate file format conversion
utilities.  To find the optimal location, shape, and size parameters for
the defibrillating electrode, the scientist would have to go back to the
geometric modeling package, change the necessary parameters, manually
re-run all of the subsequent steps to see how the new electrode
configuration affects the current density distribution, and then manually
iterate.  The manual intervention required to drive this process is both
tedious and time consuming.

<P>
Far more efficient is a scenario in which the user could define an
appropriate set of parameters for a given simulation, and then set up
a sequence of runs to examine each of them and save the results for
subsequent examinations.  The complete execution of the sequence might
require hours or even days, but the user would be free during that
time to perform other tasks.  This process is similar to the ``what
if?'' analysis that modern spreadsheet programs offer for much simpler
problems.  

<P>
In our example of the defibrillation simulation, the scientist could select
various locations and orientations for the defibrillation electrodes,
choose values for the other parameters of the simulation (<EM>e.g.,</EM> the number
of nodes in the finite element model, the boundary conditions, the error
tolerance for convergence, and the evaluation criteria), and leave the
simulations to run as long as necessary.  Viewing the results might be as
simple as watching the animation produced by the simulation or scanning
other defibrillation quality indices such as maximum and minimum current
density magnitude or current density histograms from the heart.  This
automated execution process, whereby the user selects all of the parameters
in advance and does not control the intra- or inter-package execution is
<EM>batch processing</EM>.  A primary benefit of batch processing it that it
allows the scientist to utilize computational resources without the need to
continuously guide the process.  However, with most available computer
programs execution cannot be automated.  That is, the package cannot be run
without regular user intervention during execution.  This constraint makes
it difficult or impossible to run multiple computational jobs
automatically, leaving the user with the task of manually initiating and
controlling each step of the process.

<P>

<H2><A NAME="SECTION00032000000000000000">&#160;</A> 
<A NAME="sec:con-steering">&#160;</A>
<BR>
2.2 Integrated problem solving and computational
steering
</H2> 

<P>
The goal of integrated problem solving environments--and specifically of
<EM>SCIRun</EM> and <EM>BioPSE</EM>--is to incorporate and integrate all the steps described
in the previous example as components in a single, unified, extensible
problem solving environment (PSE)<A NAME="539">&#160;</A>.  The functionality that will
result includes the ability to manage each step in a sequential computing
process, and to create batch processes that execute repeated simulations.
However, the functionality that sets <EM>SCIRun</EM> and <EM>BioPSE</EM> apart from most
integrated software environments is the ability to intervene and control
execution anywhere in the chain at any time during its execution.  This
ability to control a computer program during execution is termed
<EM>computational steering.</EM>

<P>
To provide a non-technical analogy, adding computational steering to a
software environment is similar to adding the ability to occasionally
switch tracks to train travel.  A train passenger can get on the train and
automatically get to a new destination, leaving all the details of the
individual actions to the rail system machinery and staff.  But the route
and the destination are fixed.  Steering would permit each passenger to
request that the train take a new route, with different stops, and even a
different destination, and be able to make these decisions at any time
during the trip.  In the more rigorous example of the defibrillation
simulation, computational steering allows a scientist to interactively
change parameters and settings as the simulation executes, both as a single
run or in batch mode.  Steering interventions might include adjusting
electrode locations to stay within anatomically reasonable bounds or
refining the geometric model resolution in order to balance accuracy and
execution time.

<P>
To achieve integration within the elements of <EM>SCIRun</EM> and <EM>BioPSE</EM>, data 
flows directly from one processing step to the next, without ever being
diverted to a disk file or leaving the program.  Output from any step 
are available as inputs to dependent steps.  The underlying paradigm of
<EM>SCIRun</EM> is of data flowing between modules that each perform some
operation.  Integration between modules guarantees that upon completion of
their tasks, upstream modules pass their data to downstream modules,
thereby forcing the downstream modules to execute in response.  In our
example, this means that the scientist may alter electrode locations at any
time, thus initiating a sequence of all the necessary steps to recompute
the simulation with the new configuration.  The modification of the
geometric model, finite element calculation, and visualization all proceed
automatically and in the proper sequence, all managed by <EM>SCIRun</EM>.  This
combination of steering and component integration allows the scientist
to spontaneously explore a problem.  

<P>
While computational steering is still a young field in computer science,
there are a number of examples of such systems (besides <EM>SCIRun</EM>) described in
the literature.  Burnett[<A
 HREF="node7.html#MM:Bur94">5</A>], and Vetter and
Schwan[<A
 HREF="node7.html#MM:Vet96">6</A>] give overviews of existing computational steering
system.  Several notable examples include CUMULVS[<A
 HREF="node7.html#MM:Gei96">7</A>,<A
 HREF="node7.html#MM:Koh97">8</A>],
<A NAME="551">&#160;</A> Progress[<A
 HREF="node7.html#MM:Vet95">9</A>], <A NAME="553">&#160;</A> and
Magellan[<A
 HREF="node7.html#MM:Vet97a">10</A>] <A NAME="555">&#160;</A>.

<P>

<H3><A NAME="SECTION00032100000000000000">
2.2.1 <EM>SCIRun</EM> versus <EM>BioPSE</EM></A>
</H3>

<P>
It is important to understand the hierarchy of the problem solving software
included in this package.  From a historical perspective, <EM>SCIRun</EM> was the
original implementation of the concept of dataflow in a computational
framework[<A
 HREF="node7.html#CRJ:Joh94c">11</A>,<A
 HREF="node7.html#RSM:Par95">12</A>,<A
 HREF="node7.html#RSM:Par95b">13</A>,<A
 HREF="node7.html#RSM:Par97">14</A>,<A
 HREF="node7.html#RSM:Par97b">15</A>,<A
 HREF="node7.html#CRJ:Parker99b">16</A>].
We have now generalized and greatly expanded the <EM>SCIRun</EM> software so that
now, <EM>SCIRun</EM> is the overarching term for any of the integrated problem
solving applications built on the same foundation.  <EM>BioPSE</EM> is then one of
these specific  applications, in this case for solving bioelectric field
problems.  Another example of a <EM>SCIRun</EM> applications package is
Uintah[<A
 HREF="node7.html#RSM:Dav2000">17</A>], which focuses on the simulation of fire and
combustion. 

<P>
In this manual, we will try and be consistent about the usage of the two
terms, <EM>SCIRun</EM> and <EM>BioPSE</EM>.  <EM>SCIRun</EM> will typically refer to some feature that
is common to the core functionality of the system and this is common to all
of the problem solving environment applications packages.  <EM>BioPSE</EM> will
refer to specific elements of the bioelectric field problem solving
environment.

<P>

<H2><A NAME="SECTION00033000000000000000">&#160;</A>
<A NAME="sec:con-modules">&#160;</A>
<BR>
2.3 <EM>SCIRun</EM> modules and networks
</H2> 

<P>
<BR>
<DIV ALIGN="CENTER"><A NAME="fig:conc-module">&#160;</A><A NAME="648">&#160;</A>
<TABLE WIDTH="50%">
<CAPTION><STRONG>Figure 1:</STRONG>
Example of a <EM>SCIRun</EM> module</CAPTION>
<TR><TD><IMG
  WIDTH="766" ALIGN="TOP"
 SRC="../figures/biopse-modmap.gif"
 ALT="module"></TD></TR>
</TABLE>
</DIV>
<BR>
<P>
The functional unit of a dataflow environment is the <EM>module</EM>
<A NAME="578">&#160;</A>.  Figure&nbsp;<A HREF="node3.html#fig:conc-module">1</A> contains a generic <EM>SCIRun</EM>
module, with a User Interface (UI) button for graphically accessing the
module's parameters, and input and output ports for receiving and sending
data, respectively.  On the right is a simple example of a dataflow
network.  Data passes through the output port of the top module, through
the data pipe, and into the input port of the bottom module.  The User
Interface enables the selection of a desired isochrone surface.

<P>
Modules may contain other elements, but they will all have at least one
input or one output port.  Examples of a module with only an output port
would be file readers.  The <A NAME="tex2html12"
 HREF="viewer.html"><EM>Viewer</EM></A>
module contains only input ports because it receives information and the
output is a visualization.  For a more detailed description of modules and
how to control them, see <A HREF="node5.html#sec:workwithnets"><EM>Working with Networks</EM></A>.
The most important goal at this stage is to appreciate the concept of a
module and the dataflow that links one module to another.

<P>
A network diagram <A NAME="585">&#160;</A> describes the way data flows
through <EM>SCIRun</EM> and is the main means of user interaction with the overall
action of the program.  The network essentially defines the basic function of
the program; without a network, <EM>SCIRun</EM> and <EM>BioPSE</EM> are just a set of tools
sitting in a chest.  By joining the modules into a network, the tools
become a functioning program that does whatever the network tells it to.
Once again, the important thing to appreciate is what the network is
conceptually; for the details, see <A HREF="node5.html#sec:workwithnets"><EM>Working with
Networks</EM></A>. 

<P>

<H2><A NAME="SECTION00034000000000000000">&#160;</A>
<A NAME="sec:con-links">&#160;</A>
<BR>
2.4 Links to third party software
</H2> 

<P>
<EM>SCIRun</EM> works together with software from third party sources in several
ways.  If you have installed <EM>SCIRun</EM> and <EM>BioPSE</EM> yourself, you will have seen
the need for some third party software libraries that are required for
basic functionality.  This type of third party software is largely
invisible to the user of <EM>SCIRun</EM> or <EM>BioPSE</EM>, at least until something
breaks... Perhaps the most evident is the
<A NAME="tex2html13"
 HREF="http://www.tcltk.com/">TCL/Tk</A>
<A NAME="601">&#160;</A> library,
which <EM>SCIRun</EM> uses to create the network editor and the icons for the modules
and data pipes.  In fact, <EM>SCIRun</EM> is actually a large TCL script that calls a
lot of specialized C++ code to do all the hard work.

<P>
Far more interesting is the interaction between programs you may have that
are written in FORTRAN <A NAME="604">&#160;</A> or
<A NAME="tex2html14"
 HREF="http://www.mathworks.com/products/matlab/">Matlab</A>
and
<EM>SCIRun</EM>.  One of the goals of the <EM>BioPSE</EM> project was to develop support for
such external code, including FORTRAN, C, Matlab, and IDL.  This first
version of <EM>BioPSE</EM> has support for Matlab and one example of wrapping
existing FORTRAN code into a <EM>SCIRun</EM> module. <A NAME="611">&#160;</A>

<P>

<H3><A NAME="SECTION00034100000000000000">&#160;</A>
<A NAME="sec:concept-matlab">&#160;</A>
<BR>
2.4.1 <EM>SCIRun</EM>/Matlab interface
</H3> 

<P>
The interface (based on Berkeley sockets) between <EM>SCIRun</EM> and Matlab provides
a pathway to send matrix data objects from <EM>SCIRun</EM> to Matlab and then accept
the result of some Matlab computations.  At present, this arrangement
requires that a Matlab script exist that will perform the desired
operations.  <EM>SCIRun</EM> sends the input data to an existing process running
Matlab, which serves as a compute engine, performs the steps
described in the script, and then returns data to <EM>SCIRun</EM> for further
processing or display.  The Matlab process can even run on a separate
computer connected via a network, which helps to distribute the load as
well as to resolve potential licensing conflicts with Matlab.

<P>
The underlying mechanism for this communication is a socket interface
consisting of two SCIRun Modules, <TT>MatrixSend</TT> and
<TT>MatrixReceive</TT>, and a Matlab ``transport'' routine.  Both the <EM>SCIRun</EM>
and the Matlab process know about each other's whereabouts (in the form
hostname:port) and use a client-to-client communication model, so that
synchronization between processes is manual.  For example, 
the <EM>SCIRun</EM> <TT>MatrixSend</TT> module sends the matrix to a socket at which a 
Matlab script is listening.  The script then receives the matrix, 
performs the calculations in Matlab and sends the results to a socket 
where <TT>MatrixReceive</TT> module is listening.  <EM>SCIRun</EM>then carries out
further calculations and display of the results.

<P>

<H2><A NAME="SECTION00035000000000000000">&#160;</A>
<A NAME="sec:con-extend">&#160;</A>
<BR>
2.5 Extensibility
</H2> 

<P>
<EM>SCIRun</EM> is an extensible <A NAME="627">&#160;</A> problem solving environment.
This is true in the sense that no one by the user really limits the
different ways of connecting modules and creating new applications.  Ii is
also more generally true in that <EM>SCIRun</EM> is designed to have users who can
program create their own new modules.  To support creating new modules, we
have developed the <EM>Module maker</EM> application, described in The
<A NAME="tex2html15"
 HREF="http://modulemaker">Module maker manual</A>.

<P>
With the release of <EM>SCIRun</EM>, we anticipate that users all over the world will
create new modules and we will encourage them to contribute modules to a
repository on the <EM>BioPSE</EM> web site <A NAME="651">&#160;</A>
(<A NAME="tex2html16"
 HREF="http://www.sci.utah.edu/ncrr/software/biopse.html">www.sci.utah.edu/ncrr/software/biopse.html</A>.  We will review
submissions to this collection of modules and adopt and then test generally
useful ones to include in subsequent releases of <EM>BioPSE</EM>.  Future releases
will also include more extensive tools for both building modules and
wrapping existing codes within <EM>SCIRun</EM> module wrappers to maximize your
intellectual investment in legacy code.

<P>

<H2><A NAME="SECTION00036000000000000000">&#160;</A>
<A NAME="sec:con-detach">&#160;</A> 
<A NAME="641">&#160;</A>
<BR>
2.6 Detachable interface
</H2>

<P>
A strategy seen in a few PSEs currently under development and an integral
part of <EM>SCIRun</EM> is the idea of a detachable interface.  Rather than having a
fixed link between a user interface and the underlying application, a
detachable interface can be separated from the application, in which case
the application becomes unsteerable.  The advantage, however, lies in the
ability to now re-attach an interface to a running application and thus
re-enable steering.  The re-attached interface need not be from the same
physical computer from which the application was started, instead it may
come from a remote computer via a network, or from another user on the same
computer.  An additional strength of this approach is that the re-attached
interface may not be an interactive widget at all, but a set of commands
executed from a script.  This permits complete remote control of the
application and thus is a flexible blend of interactive and almost
unlimited batch control.  CUMULVS <A NAME="643">&#160;</A> is one example of such a
system and uses its detachable interface to allow collaboration between
scientists working remotely, with viewing systems that can attach or detach
from the running simulation.

<P>
The first release of <EM>SCIRun</EM> will not include any of the detachable interface
support but we plan to add this within six months of the first release.

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html119"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html115"
 HREF="usersguide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html109"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html117"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html118"
 HREF="node8.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html120"
 HREF="node4.html">3. Starting SCIRun</A>
<B> Up:</B> <A NAME="tex2html116"
 HREF="usersguide.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html110"
 HREF="node2.html">1. Introduction</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Rob MacLeod</I>
<BR><I>2001-03-23</I>
</ADDRESS>
</BODY>
</HTML>
