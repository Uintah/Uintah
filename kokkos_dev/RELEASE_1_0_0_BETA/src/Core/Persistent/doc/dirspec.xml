<!--
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
-->

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE dir SYSTEM "dirspec.dtd">

<dir name="Core/Persistent">

<!-- ************** phase 1 content ************** -->

  <fit>
  <!-- describe how this directory fits into SCIRun - why does it 
       exist, how does SCIRun benefit from it, etc. -->
    <p>
how it fits

     To maximize their usefulness, all software systems must be able
     to store data to disk at the end of a run, and retrieve that data
     later for additional processing.  As the SW system becomes larger
     and more complex, especially if numerous different groups are
     contributing to it, there needs to be a consistent, powerful, and
     straight forward strategy for performing this data storage and
     retrieval.  Core/Persistent encapsulates the SCIRun data storage
     and retrieval philosophy which attempts to provide such a
     solution to this problem.

     Core/Persistent provides a direct and uniform method for saving
     to disk the complex data structures used by SCIRun.  Through its
     use, a user can save and later retrieve data that is distributed
     across a large number of classes and sub-classes, and need not
     worry about manually handling dynamically allocated (and possibly
     cross referenced) memory.  
    </p>
  </fit>

  <use>
    <why>
    <!-- Discuss why a developer would need or want to use the
         functions and/or classes in this directory. -->
      <p>
       Because most of the code added to SCIRun will use a large
       number of complex SCIRun data structures, it is necessary for
       the developer to be able to manage storing data in a consistent
       manner.  Core/Persistent provides this ability by specifying a
       set of routines that are implemented by each of the SCIRun data
       structures.  It also allows the user to implement these
       routines in his or her code and thus have a complete and
       consistent method of storing and retrieving data.
      </p>
    </why>

    <when>
    <!-- Discuss when or where to use the functions and classes in
         this directory: From within modules?, when a certain event
	 occurs? -->
      <p>
       Many module implementors will need to include routines in their
       module for saving to and retrieve data from disk. Software
       engineers who develop parts of the SCIRun core will also many
       times need to add routines to provide the IO for these Core
       codes.  By using Core/Persistent, programmers will be able to
       easily define routines to save the data specifically created by
       their codes as well as save the data stored in any of the
       SCIRun data structures that they use.
      </p>
    </when>
  </use>

<!-- ************** phase 2 content ************** -->

  <definition>
  <!-- Give the definition for a term, or concept, that is embodied
       by this directory.  Please provide feature length rather than
       short story definitions. -->
    <term>
      Module
    </term>
    <p>
      From the most abstract perspective, a module is considered to
      be a one or more algorithms that solves a single, specific and
      coarse grained, problem.  For example, suppose you have a large
      database of english words that you want to display in sorted
      order.  There are several algorithms that you may employ to
      to solve this problem such as bubble sort, quick sort, etc.
      A module that solves this problem, likely named Sort, would
      be a collection of one or more of these algorithms.
    </p>

    <p>
      On a slightly more concrete level, a module can be compared 
      to a function or procedure (of a high level text based
      programming language) that also implements one or more
      algorithms to solve a specific problem.  The prototype for
      such a function (in C like syntax) might look like this:
    </p>

    <p>
        int Sort(string *words_to_sort, int alg_to_use);
    </p>

    <p>
      Where words_to_sort is a random , possibly large, list of words
      to be sorted (the data), and alg_to_use is a single integer used
      to control which of the implemented algorithms to use.
    </p>

    <p>
      The Sort module is identical to the Sort function in many ways:
      They both have input (data and control), they both have output,
      they both have a single point of entry for execution, and they
      can both be used modularly in any program, provided that they are
      simultaneously specific and general enough to be used universally.
    </p>

    <p>
      Some important differences include: The Sort module seperates
      the mode for communicating inputs of different kinds (i.e. data
      is treated differently and seperately from control) and the sort
      module can have more than one output.
    </p>
    
    <p>
      On the lowest level a module is exactly like the function.  The
      module is actually implemented as a C++ class with one member
      function named execute().  The execute member function is
      similar to the C function in many ways.  In fact, it is possible
      to cut the contents out of the C function and paste them into
      the execute function of the module and achieve the same 
      functionality, with one exception: the module does not pass 
      data to the execute function through formal parameters, instead
      it passes them through the use of seperate member functions
      (pseudo code):
    </p>
    
    <p>
      void execute() {
        string *words_to_sort;
	int alg_to_use;

	words_to_sort = get_data_from_input_port() ;
	alg_to_use = get_chosen_algorithm_from_gui();

	/* paste contents of sort function here */
	
	send_data_to_output_port(words_to_sort);
      }
    </p>

    <p>
      Modules are often manifested as graphical boxes with ports, 
      a name, a timer and a progress bar.  Modules can exist outside
      this graphical representation as well.  Outside it's graphical
      manifestation, a module can be viewed as a node in an dataflow
      graph.
    </p>
  </definition>

  <definition>
    <term>
      Port
    </term>
    <p>
      Ports are the analog of formal paramaters of a C function.
      They are used to connect modules together and they enforce type
      matching.
    </p>
  </definition>

  <definition>
    <term>
      Connection
    </term>
    <p>
    </p>
  </definition>

  <definition>
    <term>
      Network
    </term>
    <p>
    </p>
  </definition>

  <definition>
    <term>
      Network Editor
    </term>
    <p>
    </p>
  </definition>

  <example>
  <!-- give an example of how to use the classes and/or functions
       here.  Again, more is better, however give only exactly 
       that which is being explained, no superfluous text (i.e.
       please don't cut and paste from existing code.) -->
    
    <p>
      To get data into and out of your module's execute function, you
      need to use the module's ports.  In order to use the ports, 
      you first need to get a pointer to a specific port.  Then, call
      that port's get() function with a handle to the type of data
      expected on the port.  On success, the handle passed to get()
      will represent the data that is on that input port:

      #include <Dataflow/Ports/MatrixPort.h>

      ...

      void SomeModule::execute() {

        //The input port for this module is of type Matrix, and is
        // named "Input Matrix"

        MatrixIPort *iport = get_iport("Input Matrix");

        MatrixHandle InputMatrix;

        int connected = iport->get(InputMatrix);

        if (!connected) {
          printf("There is no connection for 'Input Matrix'!");
	  return;
        }
        
	...
      }
    </p>
  </example>
</dir>

<!-- author comments: suggestions for new/better tags for this xml file

  Hey, I think this file should address known bugs, i.e. have a <bugs> tag.

-->