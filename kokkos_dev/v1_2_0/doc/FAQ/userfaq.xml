
<!-- 

  each faq is a collection of entries.  Entries are a paired question and
  answer, along with a set of keywords.  Questions and answers are delimited
  with <para> or <pre> tags.

  <entry>
    <keywords>SGI, endian</keywords>
    <question>
      <para>
        ...
      </para>
      ...
    </question>
    <answer>
      <para>
        ...
      </para>
      ...
    </answer>
  </entry>
          
  the guts of para's and pre's are "free form": you can use HTML
  inside them.

-->

<faq>
  <title>User FAQ</title>
  <description> 
    <para> The User FAQ addresses questions about the behavior of SCIRun, 
modules, messages issued, etc. The FAQ also addresses other high level issues 
such as: </para> 
  </description> 

  <entry> <keywords>unable to load module, can't find
 symbol</keywords>
    <question> 
      <para> When I run SCIRun, one or more 
messages appear in the message window indicating a problem with a package and/or 
module.</para>
      <para> The message(s) is/are 
similar to the following: 
      </para> 
      <pre>Loading package 'SCIRun'
Unable to load module 'CastField' :
- can't find symbol 'make_CastField'
      </pre>
      <para>
        or
      </para>
      <pre>Unable to load all of package 'Teem' (category 'DataIO' failed) :
- libPackages_Teem_Dataflow.so: cannot open shared object file: No
such file or directory
- libPackages_Teem_Dataflow_Modules_DataIO.so: cannot open shared
object file: No such file or directory
      </pre>
    </question> 
    <answer> 
      <para> Each module for a given package has its own .xml file 
that describes it. When SCIRun starts, it parses all the .xml files in the packages 
(under Dataflow/XML) and tries to find the matching code within the related .so 
files. If the .so files cannot be found the message "No such file or directory" 
is given. If the .so can be found, but the code for a particular module does not 
exist within the library, then the message "can't find symbol" is
    given. 
      </para> 
      <para> The message(s) may or may not indicate a problem with SCIRun. For some 
modules, the .xml file may be listed but the code has not yet been completed (this 
may be common for module developers). For others it may mean that the SCIRun installation 
is some how corrupt (.so files have been deleted, moved, etc.) 
      </para> 
      <para> 
The solution to this problem is to either a) build the libraries that the .xml 
files need, or b) remove the offending .xml files. 
      </para> 
    </answer>
</entry> 

<entry> <question> <para> What systems are compatible with SCIRun? </para> </question> 
<answer> <para> SCIRun should be generally compatible with any SGI or Linux machine. 
</para> <para> SCIRun has been tested on the following Linux distributions: </para> 
<para> 
<ul>
          <li>Mandrake 7.2 &amp; 8.0</li>
          <li>Redhat 6.2, 7.0 &amp; 7.1</li>
          <li>SuSE 6.4, 7.0 &amp; 7.2</li>
          <li>Debian testing</li>
        </ul> 
      </para>
      <para>
        SCIRun has been tested on the following PC processor configurations:
      </para>
      <para>
        <ul>
          <li>Dual Intel Pentium II</li>
          <li>Single Intel Pentium III</li>
          <li>Dual Intel Pentium III</li>
          <li>Single Intel Pentium 4</li>
          <li>Single AMD Athlon</li>
        </ul>
      </para>
      <para>
        SCIRun has been tested with the following PC graphics cards:
      </para>
      <para>
        <ul>
          <li>NVIDIA GeForce, GeForce II &amp; GeForce3</li>
        </ul>
      </para>
    </answer>
  </entry>

  <entry>
    <keywords>Design of BioPSE</keywords>
    <question>
      <para>
          What is the relationship between SCIRun, BioPSE, and the other
          SCI Institute software?
      </para>
    </question>
    <answer>
      <para>
      It is important to understand the place of the software included in
      this package within the hierarchy of computational problem solving
      environments developed at the SCI Institute.  From a historical
      perspective, <I>SCIRun</I>, which we started developing in 1992, was
      the original implementation of the computational framework.  Since
      then, <I>SCIRun</I> and its computational workbench infrastructure
      have been the origin of many significant application-specific
      projects.  Two major examples are the DOE sponsored Uintah system and
      the NIH sponsored <I>BioPSE</I> system (from the (<A NAME="tex2html3"
      HREF="http://www.ncrr.nih.gov/">National Center for Research
      Resources</A> (NCRR) Center at <A NAME="tex2html4"
      HREF="http://www.sci.utah.edu/ncrr/">Utah</A>).  The target
      applications of the Uintah project are combustion, computational
      fluid dynamics, and mechanical modeling implemented on large-scale,
      distributed, shared memory architectures.  The goal of the
      <I>BioPSE</I> project is to create software for geometric modeling,
      simulation, and visualization for solving bioelectric field problems.
      An important secondary goal of the <I>SCIRun</I> system is to make
      source code for these problem solving environments publicly available
      to the scientific community.</para>
 
      <para> To realize these two significant projects, the <I>SCIRun</I>
      infrastructure itself has required significant reorganization,
      extension, and enhancement.  Even with these recent changes,
      <I>SCIRun</I> remains both the core infrastructure for our problem
      solving environments and the name we use to refer to the entire
      ensemble of software.  Thus a user may install and operate the core
      <I>SCIRun</I> software and also augment its functionality with one or
      more of the ``packages'' such as <I>BioPSE</I>.  We anticipate that
      the collection of packages will grow as the advantages of the
      <I>SCIRun</I> infrastructure become available to scientists and
      engineers of all disciplines.</para>
 
      <para>
      <div ALIGN="CENTER"><A NAME="fig:biopsesr"></A><A NAME="193"></A>
      <table>
      <CAPTION ALIGN="BOTTOM"><strong>Figure 1:</strong>
      The relationship among <I>SCIRun</I> and the other
        packages that it uses.  <I>BioPSE</I> consists of the basic
      <I>SCIRun</I> software together with the <I>BioPSE</I> modules and
      support libraries</CAPTION>
      <tr><td><IMG WIDTH="645" ALIGN="TOP"
          SRC="http://ampano.cs.utah.edu/research/images/EAB-BioPSE.gif"
          ALT="biopsesr"></IMG></td>
       </tr>
       </table>
       </div>
      
</para> <para> In addition to the major projects that have both leveraged and 
advanced <I>SCIRun</I>, there exist a number of smaller packages that can extend 
<I>SCIRun</I>'s utility. Examples include the <I>Teem</I> package for raster data 
processing, the <I>NetSolve</I> package for linear algebra subroutines (developed 
by researchers at the University of Tennessee and Knoxville), and a communications 
interface we have recently introduced to the <I>Matlab</I> program. We have developed 
various forms of software wrappers or interfaces that allow <I>SCIRun</I> to leverage 
the strengths of these third party tools, links we refer to as "bridges."</para> 
<para> There are also instances in which a tighter level of integration than a 
bridge between <I>SCIRun</I> and third-party software is necessary. One example 
is the addition of mpeg support for capturing animations from the <I>SCIRun</I> 
Viewer module, for which we use the Berkeley and Alex Knowles' mpeg encoding tools. 
Another example is the set of image generation and manipulation tools from Paul 
Haeberli called <I>libimage</I>. To indicate whether or not such tools are available, 
the configure scripts for <I>SCIRun</I> contain optional control flags.</para> 
<para> We believe that this combination of a robust infrastructure and modular 
extensibility through packages and third-party libraries will allow <I>SCIRun</I> 
to grow and adapt to changing needs and opportunities.</para> </answer> </entry> 
<entry> <keywords>file conversion, import and export</keywords> <question> <para> 
How do I get my data into <I>SCIRun</I>? </para> </question> <answer> <para> Like 
all program, <I>SCIRun</I> has its own data file formats so conversion is required. 
At present, the pathway for converting data files is to use one of a set of stand-alone 
converter programs that are part of the regular <I>SCIRun</I> distribution. Here 
is the list of available converters: </para> <para> <strong>RawToTriSurf: </strong> 
converts simple ASCII files containing node locations, triangle connectivity, 
and optionally scalar data into <I>SCIRun</I> a field data file.</para> <para> 
Usage: RawToTriSurf pts-file tris-file [vals-file] fieldout.fld </para> <para> 
where: </para> <para> <strong><tt>pts-file</tt> </strong> is a file containing 
point locations for the geometry, a single triplet of x, y, z in each line of 
the file. </para> <para> <strong><tt>tris-file</tt> </strong> is a file containing 
connectivity for the triangles, with each row of the file pointing to three node 
numbers in the <tt>pts-file</tt>. The node numbering starts at 0 in these files. 
</para> <para> <strong><tt>vals-file</tt> </strong> is an optional file that contains 
scalar values to be associated with the nodes of the geometry. These files have 
the same number of values as the <tt>pts-file</tt> with one value per line of 
the file. </para> <para> <strong><tt>fieldout.fld</tt> </strong> is the output 
fields file containing the geometry and associated scalar data. </para> <para> 
The Cardiovascular Research and Training Institute (CVRTI) has developed a number 
of scalar and vector data and geometry file formats which required converters 
for <em>SCIRun</em>. The result is a set of stand-alone programs that read in 
one more more existing CVRTI files and generate a particular form of <em>SCIRun</em> 
file, the details of which depend on the particular combination of nodes, connectivities, 
and associated attributes.</para> <para> The programs and their parameters as 
as follows (go to the end of the list to see the definitions of the different 
parameter and file types): </para> <para> <strong>CVRTItoTriSurfGrad: </strong> 
converts nodes, triangle connectivities, and vector (grad) files into a field 
with associated vector attribute: </para> 
<pre>
        CVRTItoTriSurfGrad pts fac grad [channels] fieldout
        </pre>  

	<para>
        <strong>CVRTItoTriSurfPot: </strong>
        converts nodes, triangle connectivities, and
        scalar (pot) data files into a field with associated scalar
        attributes.
        </para>

        <pre>
        CVRTItoTriSurfPot pts fac pot [channels] fieldout
        </pre>
        <para>
	<strong>CVRTItoTetVolGrad: </strong>
        converts nodes, tetrahedral connectivities, and
        vector (grad) files into a field with associated vector
        attributes:
        </para>

        <pre>
        CVRTItoTetVolGrad pts tetras grad [channels] fieldout
        </pre> 
        <para>
        <strong>CVRTItoTetVolPot: </strong>
        converts nodes, tetrahedral connectivities, and
        scalar (pot) files into a field with associated scalar
        attributes:
        </para>

        <pre>
        CVRTItoTetVolPot pts tetras pot [channels] fieldout
        </pre>
 
	<para>
        <div ALIGN="CENTER">
        <table CELLPADDING="3" BORDER="1">
        <tr><td ALIGN="CENTER" COLSPAN="1">Argument</td>
        <td ALIGN="CENTER" COLSPAN="1">Purpose</td>
        </tr>
        <tr><td ALIGN="LEFT" COLSPAN="2">Geometry</td>
        </tr>
        <tr><td ALIGN="CENTER">pts</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI points file; ASCII
        file with one x,y,z triplet per line.*</td>
        </tr>
        <tr><td ALIGN="CENTER">fac</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI triangle connectivity
        (facet) file; ASCII file with one triangle defined per line.  Each
        value points to a node number in the associated .pts file, with 1
        (not 0) as the first node number.*</td>
        </tr>
        <tr><td ALIGN="CENTER">tetras</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI tetrahedra file;
        ASCII file with the nodes from one tetrahedron on each line,
        pointing to the nodes in the associated .pts
        file.  Pointers begin with 1 (not 0).*</td>
        </tr>
        <tr><td ALIGN="LEFT" COLSPAN="2">Data</td>
        </tr>
        <tr><td ALIGN="CENTER">grad</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI vector file; ASCII
        file with two x,y,z triplets per line; first triplet is origin of
        the vector and second is the endpoint.*</td>
        </tr>
        <tr><td ALIGN="CENTER">pot</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI scalar (potentials)
        data file; ASCII file,  each line contains one scalar value.
        Without .channels file, all programs assume a one-to-one mapping of
        scalar value to the  nodes in the associated .pts file.*</td>
        </tr>
        <tr><td ALIGN="LEFT" COLSPAN="2">Channel Mapping</td>
        </tr>
        <tr><td ALIGN="CENTER">channels</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI data channel mapping
        file; ASCII file that begins with the line ``N channels'', where N
        is the number of channels in the file. Subsequent lines contain two
        values, the first refers to a node number in the geometry and the
        second points to the associated channel of any scalar or vector
        data files.  Thus a .channels file must have an entry for each node
        of the associated .pts file but the associated .pot file can have
        more (or even fewer) entries.</td>
        </tr>
        <tr><td ALIGN="LEFT" COLSPAN="2">Field File</td>
        </tr>
        <tr><td ALIGN="CENTER">field</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">SCIRun fields file that
        contains both the geometry and associated scalar or vector data as
        attributes.</td>
        </tr>
        <tr><td ALIGN="CENTER">&nbsp;</td>
        <td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">*<B>Note</B>: to find the
        length of all CVRTI ASCII geometry, scalar, and vector files, count
        the number of lines in the file.</td>
        </tr>
        </table></div>
        </para>
 
        <para>All converter programs are normally available in the
        subdirectory of the <em>SCIRun</em> distribution called
        <tt>src/StandAlone/convert</tt>.  If they are not easily available,
        ask the local person who installed <em>SCIRun</em> for assistance.
      </para>
    </answer>
  </entry>

  <entry>
    <keywords>modules, granularity</keywords>
    <question>
      <para>
        What is the granularity of modules?
      </para>
    </question>
    <answer>
      <para>
        There is no simple answer to this question and modules that start
        at one level sometimes divide or merge to move to a different
        level.  When designing and writing the code, it is therefore
        important to think in terms of modularity even within a single
        module so that subsequent divisions or reorganization is possible.
        One approach we take within the group is to present the design for
        a new module or set of modules to the group and see if there are
        others interested in some part of the functionality or can provide
        existing modules for the new module.  In this way we at least
        benefit from the collective plans and knowledge of the group.
      </para>
    </answer>
  </entry>
 
  <entry>
    <keywords>coding standards, emacs</keywords>
    <question>
      <para>
        Are there Emacs tools for coding standard?
      </para>
    </question>
    <answer>
      <para>
      Yes, here is the code we use to support the coding standard:
      </para>
 
      <pre>
      ; Filename: sci-c++-style.el
      ; Author: Marty Cole
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (defun c-no-initializer-indent (langelem)
        ;; using in a statement block intro...
          (save-excursion
              (let* ((curpos (point))
           retval)
      (setq retval (if (search-forward "{" (c-point 'eol) t)
                       (* -1 c-basic-offset) c-basic-offset))
      (goto-char curpos)
      retval)))
 
      (defun my-c-mode-common-hook ()
      ;; my customizations for all of c-mode and related modes
      (c-set-style "gnu")
      (set 'c-label-minimum-indentation 0)
      (c-set-offset 'substatement-open 0)
      (c-set-offset 'innamespace 0)
      (c-set-offset 'statement-cont 'c-no-initializer-indent)
      )
 
      (add-hook 'c-mode-common-hook 'my-c-mode-common-hook)
      </pre>
 
      <para>
      Place this in a file that you load, or directly in your .emacs file.
      </para>
 
      <para>
      We are working on a <I>BioPSE</I> coding standard that will replace
      the one that we currently share with the C-SAFE/Uintah group.  As
      soon as it is ready, we will add it to the <A NAME="tex2html7"
      HREF="http://www.sci.utah.edu/scirun_docs/doc/">documentation</A>.
      </para>
    </answer>
  </entry>
  <entry>
    <keywords></keywords>
    <question>
      <para>
        Do we need to get accounts for your CVS? How do we handle checking
        out the latest version of <I>SCIRun</I> or <I>BioPSE</I>?
      </para>
    </question>
    <answer>
      <para>
      At present, remote access to the code repository does require an
      account on our server.  To get the most recent released version,
      visit our web site to download archives.  You may place the resulting
      files on your own code repository site and manage your own
      development.
      </para>
    </answer>
  </entry>
 
  <entry>
    <keywords></keywords>
    <question>
      <para>
         Are there guidelines for module testing? What is the testing
         strategy?
      </para>
    </question>
    <answer>
      <para>
      The nature of <I>SCIRun</I> as a very interactive, user driven
      program makes testing modules and their interactions very
      challenging.  Our approach to this is to develop a user interface the
      contains a state manager that will accept and manage input from all
      user interface elements.  One advantage of such a manager is that it
      will be possible to replace the interactive input with a program that
      supplies a script of interaction requests to which the state manager
      will respond, just as if a user had executed the requests manually.
      The development of this structure is in progress and we hope to have
      the essential elements in place soon.
      </para>
    </answer>
  </entry>
 
  <entry>
    <keywords>XML</keywords>
    <question>
      <para>
        What is XML?
      </para>
    </question>
    <answer>
      <para>
        The best place to find the answer to this in on one of the XML web
        sites such as <A NAME="tex2html9"
        HREF="http://faq.oreillynet.com/XML/index0.shtm">
        faq.oreillynet.com/XML/index0.shtm</A>
        or
        <A NAME="tex2html10"
           HREF="http://www.xml.com/pub/a/98/10/guide0.html">
        www.xml.com/pub/a/98/10/guide0.html</A>.
      </para>
    </answer>
  </entry>

  <entry>
    <keywords></keywords>
    <question>
      <para>
        What does XML have to do with <I>SCIRun</I>?
      </para>
    </question>
    <answer>
      <para>
        Each module in <I>BioPSE</I> requires an XML format description of
        its functionality.  The information in the XML specification
        provides information to assist the <A NAME="tex2html11"
        HREF="http://www.sci.utah.edu/scirun_docs/doc/ReferenceGuide/create_modules.html">
        module-maker</A> do its job and help create the template for a
        module.  It also forms the basis of a Reference Manual of all
        modules.  And it even provides information to <I>SCIRun</I> about
        the number of type of ports that the module needs when it appears
        in a network diagram.  There is addition <A NAME="tex2html12"
        HREF="http://www.sci.utah.edu/scirun_docs/doc/ReferenceGuide/component.html">        documentation</A> that describes the format and content of the XML
        spec.
      </para>
    </answer>
  </entry>
 
  <entry>
    <keywords></keywords>
    <question>
      <para>
        What does it mean to <I>validate</I> a design specification in
        XML?
      </para>
    </question>
    <answer>
      <para>
        One of the powerful elements of XML is that it requires adherence
        to the language standard, unlike HTML, which permits many implicit
        actions like environments that are never closed properly.  To
        ensure that an XML specification for <I>BioPSE</I> adheres to
        specifications, there is a document description that the <A
        NAME="tex2html13"
        HREF="http://www.stg.brown.edu/service/xmlvalid/">online validation
        tool</A> requires against which to test the XML file.  This
        document description describes all the legal tags and other
        elements of the document structure.
      </para>
    </answer>
  </entry>
</faq>
