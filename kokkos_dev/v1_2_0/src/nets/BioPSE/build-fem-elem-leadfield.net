#
# The contents of this file are subject to the University of Utah Public
# License (the "License"); you may not use this file except in compliance
# with the License.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations under
# the License.
# 
# The Original Source Code is SCIRun, released March 12, 2001.
# 
# The Original Source Code was developed by the University of Utah.
# Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
# University of Utah. All Rights Reserved.
#

# SCI Network 1.0

if {[llength [array get env SCIRUN_DATA]] == 0} {
   puts ""
   puts "*** Error: this net depends on the SCIRUN_DATA enviroment variable."
   puts "*** Please exit, set it in your shell, and rerun."
   puts "*** (e.g. setenv SCIRUN_DATA /local/data/SCIRunData/)"
   puts ""
   ::netedit scheduleok
   return
}
set DATADIR $env(SCIRUN_DATA)
puts "*** Using SCIRUN_DATA $DATADIR"

if {[llength [array get env SCIRUN_DATASET]] == 0} {
   puts ""
   puts "*** Environment variable 'SCIRUN_DATASET' was not set -- "
   puts "*** using 'sphere' as the default."
   puts ""
   set DATASET sphere
} else {
   set DATASET $env(SCIRUN_DATASET)
   puts "*** Using DATASET $DATASET"
}

source $DATADIR/$DATASET/$DATASET-settings.net

::netedit dontschedule

global userName
set userName "dmw"

global runDate
set runDate "Thu Mar  1 2001"

global runTime
set runTime " 21:53:29"

global notes
set notes "This net builds an element-centered finite element lead-field for an input finite element
mesh and set of electrodes.

"

set m0 [addModuleAtPosition "SCIRun" "DataIO" "FieldReader" 45 70]
set m1 [addModuleAtPosition "BioPSE" "Forward" "SetupFEMatrix" 45 179]
set m2 [addModuleAtPosition "SCIRun" "DataIO" "FieldReader" 387 14]
set m3 [addModuleAtPosition "BioPSE" "LeadField" "BuildElemLeadField" 262 179]
set m4 [addModuleAtPosition "SCIRun" "Math" "SolveMatrix" 244 263]
set m5 [addModuleAtPosition "SCIRun" "DataIO" "MatrixWriter" 393 279]
set m6 [addModuleAtPosition "SCIRun" "Fields" "ManageFieldData" 226 333]
set m7 [addModuleAtPosition "SCIRun" "Fields" "BuildInterpolant" 280 104]
set m8 [addModuleAtPosition "SCIRun" "Fields" "Gradient" 226 403]
set m9 [addModuleAtPosition "SCIRun" "Fields" "ManageFieldData" 226 472]
set m10 [addModuleAtPosition "SCIRun" "DataIO" "FieldReader" 226 15]

addConnection $m1 0 $m4 0
addConnection $m3 0 $m4 1
addConnection $m3 1 $m5 0
addConnection $m2 0 $m7 1
addConnection $m4 0 $m6 1
addConnection $m7 0 $m3 1
addConnection $m6 0 $m8 0
addConnection $m8 0 $m9 0
addConnection $m9 1 $m3 2
addConnection $m10 0 $m7 0
addConnection $m10 0 $m3 0
addConnection $m10 0 $m6 0
addConnection $m0 0 $m1 0

set $m0-notes {TetVolField input is the finite element mesh -- data values at the elements are conductivity tensors.

}
set $m0-filename $DATADIR/$DATASET/$DATASET-mesh.tvt.fld
set $m1-notes {Using the zero'th node as a ground reference, we build the finite element stiffness matrix
for the incoming TetVolField.  The TetVolField has a conductivity tensor at each element.

}
set $m1-UseCondTCL 1
set $m1-BCFlag {GroundZero}
set $m2-notes {TetVolField specifying the electrode positions (no cells).

}
set $m2-filename $DATADIR/$DATASET/$DATASET-electrodes.pcd.fld
set $m3-notes {Build the element-centered leadfield matrix for the input finite element mesh (port 1) and electrode
interpolant Field (port 2).  We set the last electrode to ground, and iteratively pair it with
each of the other electrodes.  For each pairing, we build a right-hand-side column matrix 
that specifies the source-sink pair to have unit current.  That right-hand-side is passed
to a solve matrix module, the system is solved, the gradient is computed, and the ouput
is passed back to us and stored as one column in our lead-field matrix.

}
set $m4-notes {Solve the: A x phi = flux
linear system.  A is the stiffness matrix, with node 0 pinned to ground, the flux vector is all
zeroes except for the TetVol source and sink node positions, which have a 1 and a -1 
respectively (unit current passed between them).  Solving for phi gives us the voltages
everywhere at the nodes in the TetVolMesh.

}
set $m4-target_error 0.000001
set $m4-orig_error 1
set $m4-current_error {8.45361e-07}
set $m4-method {Conjugate Gradient & Precond. (SCI)}
set $m4-precond {jacobi}
set $m4-iteration 176
set $m4-maxiter 2000
set $m4-use_previous_soln 1
set $m4-emit_partial 0
set $m4-np 16
set $m5-notes {Store the lead-field.  The size is nr=(# of electrodes - 1) x nc=(# of elements x 3).  Each
row is stored [ex1 ey1 ez1 ex2 ey2 ez2 ex3 ey3 ez3 ... exn eyn ezn] where [exi eyi ezi] is 
the electric field vector in element i.
 
}
set $m5-filename $DATADIR/$DATASET/generated/$DATASET-leadfield.mat
set $m5-filetype {ASCII}
set $m5-split 1
set $m6-notes {Having solving for the voltages at the nodes of the TetVolMesh, we combine those scalar
values with the TetVolMesh to produce a TetVolField of scalar double potentials at the
nodes.

}
set $m7-notes {Build the interpolant weights for the electrodes.  For each node in the electrode field (second input
field port), we record the single nearest node from the finite element mesh and assign it a weight of 1.

}
set $m10-filename $DATADIR/$DATASET/$DATASET-voltage.tvd.fld
$m4 ui

::netedit scheduleok
