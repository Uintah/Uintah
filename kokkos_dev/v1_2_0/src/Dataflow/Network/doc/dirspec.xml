
<!--
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
-->

<chapter>
  <title>Dataflow Programming</title>

  <sect1>
    <para>
      This chapter describes the elements of a SCIRun dataflow
      program.
    </para>
  </sect1>

  <sect1>
    <title>Introduction</title>

    <para>
      Dataflow/Network provides the basic functionality of the SCIRun
      dataflow paradigm.  The notions of Modules, Ports, Connections
      and Networks are defined here.  It also provides the
      implementation for the NetworkEditor, which is the tool used by
      a network designer to build Networks.
    </para>

  </sect1>

  <sect1>
    <title>Programming SCIRun Dataflow</title>

      <para>
        One of the useful features of SCIRun is that it can easily
	be extended by developing new modules (algorithms) and new 
	ports (datatypes) for it.  To do this, a developer would
	write code that inherits functionality from the classes
	in this directory.  By inheriting from these classes, a
	developer can focus on the code needed to quickly implement
	a new algorithm.
      </para>

      <para>
        Most of the code in this directory is meant to be used
	internally by the SCIRun PSE only.  There are three instances
	in which a developer would use code in this directory
	external to the PSE: When writing modules, When writing ports,
	and when a developer would like to post a message to the 
	NetworkEditor's message window.
      </para>

     <sect2>
       <title>Module</title>

    <para>
      From the most abstract perspective, a module is considered to
      be a one or more algorithms that solves a single, specific and
      coarse grained, problem.  For example, suppose you have a large
      database of english words that you want to display in sorted
      order.  There are several algorithms that you may employ to
      to solve this problem such as bubble sort, quick sort, etc.
      A module that solves this problem, likely named Sort, would
      be a collection of one or more of these algorithms.
    </para>

    <para>
      On a slightly more concrete level, a module can be compared 
      to a function or procedure (of a high level text based
      programming language) that also implements one or more
      algorithms to solve a specific problem.  The prototype for
      such a function (in C like syntax) might look like this:
    </para>

    <computeroutput>
        int Sort(string *words_to_sort, int alg_to_use);
    </computeroutput>

    <para>
      Where words_to_sort is a random , possibly large, list of words
      to be sorted (the data), and alg_to_use is a single integer used
      to control which of the implemented algorithms to use.
    </para>

    <para>
      The Sort module is identical to the Sort function in many ways:
      They both have input (data and control), they both have output,
      they both have a single point of entry for execution, and they
      can both be used modularly in any program, provided that they are
      simultaneously specific and general enough to be used universally.
    </para>

    <para>
      Some important differences include: The Sort module seperates
      the mode for communicating inputs of different kinds (i.e. data
      is treated differently and seperately from control) and the sort
      module can have more than one output.
    </para>
    
    <para>
      On the lowest level a module is exactly like the function.  The
      module is actually implemented as a C++ class with one member
      function named execute().  The execute member function is
      similar to the C function in many ways.  In fact, it is possible
      to cut the contents out of the C function and paste them into
      the execute function of the module and achieve the same 
      functionality, with one exception: the module does not pass 
      data to the execute function through formal parameters, instead
      it passes them through the use of seperate member functions
      (pseudo code):
    </para>
    
    <computeroutput>
      void execute() {
        string *words_to_sort;
	int alg_to_use;

	words_to_sort = get_data_from_input_port() ;
	alg_to_use = get_chosen_algorithm_from_gui();

	/* paste contents of sort function here */
	
	send_data_to_output_port(words_to_sort);
      }
    </computeroutput>

    <para>
      Modules are often manifested as graphical boxes with ports, 
      a name, a timer and a progress bar.  Modules can exist outside
      this graphical representation as well.  Outside it's graphical
      manifestation, a module can be viewed as a node in an dataflow
      graph.
    </para>
   </sect2>

   <sect2>
     <title>Port</title>
    <para>
      Ports are the analog of formal paramaters of a C function.
      They are used to connect modules together and they enforce type
      matching.
    </para>
   </sect2>

   <sect2>
     <title>Connection</title>
    <para>
    </para>
   </sect2>

   <sect2>
     <title>Network</title>
    <para>
    </para>
   </sect2>

   <sect2>
     <title>Network Editor</title>
    <para>
    </para>
   </sect2>

   <sect2>
     <title>Examples</title>
   
    
    <para>
      To get data into and out of your module's execute function, you
      need to use the module's ports.  In order to use the ports, 
      you first need to get a pointer to a specific port.  Then, call
      that port's get() function with a handle to the type of data
      expected on the port.  On success, the handle passed to get()
      will represent the data that is on that input port:
    </para>
    <computeroutput>
      #include &lt;Dataflow/Ports/MatrixPort.h&gt;

      ...

      void SomeModule::execute() {

        //The input port for this module is of type Matrix, and is
        // named "Input Matrix"

        MatrixIPort *iport = get_iport("Input Matrix");

        MatrixHandle InputMatrix;

        int connected = iport->get(InputMatrix);

        if (!connected) {
          printf("There is no connection for 'Input Matrix'!");
	  return;
        }
        
	...
      }
    </computeroutput>
   </sect2>
  </sect1>
</chapter>

