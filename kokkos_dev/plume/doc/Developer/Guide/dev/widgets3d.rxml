
<!--
   For more information, please see: http://software.sci.utah.edu

   The MIT License

   Copyright (c) 2004 Scientific Computing and Imaging Institute,
   University of Utah.

   License for the specific language governing rights and limitations under
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
-->


<chapter id="dev.widgets3d">
  <title>3D Widgets and Constraints in SCIRun</title>

  
    <para>
      This chapter introduces the concepts of 3D widgets and the
      Constraints used to make them functional.
    </para>
  

  <section>
    <title>Introduction</title>

    <para>
      SCIRun has  a set of 3D interaction widgets.
      These widgets have a graphical representation within the scene
      graph of the Viewer module, and can be directly manipulated within a
      visualization.  Furthermore, the module that creates a widget
      maintains access to and control of the widget, and is alerted
      through a callback when a widget is manipulated within a scence.
      Through this callback mechanism, the module can respond
      appropriately as the widget interaction is taking place -
      thereby allowing compuational feedback to be directly coupled
      with the visual feedback.
    </para>
    <para>
      Widgets are useful in any context where direct manipulation
      has clear advantages over indirect manipulation.
      For example,
      when specifying a cutting plane for a scene, it is possible to
      specify that plane by entering the A, B, C, and D of a plane
      equation (Ax + By + Cz + D = 0) with sliders or text-entry
      boxes; however, it is often much more natural to place a
      graphical representation of that plane (for example, a
      rectangular frame widget) into the scene and provide the user
      handles to translate and rotate the clipping plane directly.
      By manipulating the object directly, a greater sense of
      immersion is obtained, and the user has a more natural
      mechanism for setting parameters.
    </para>

    <para>
      One important aspect of 3D widgets in SCIRun is the notion of 
      <firstterm>Constraints</firstterm>.  Constraints are used to ensure that
      the user will not introduce degenerate situations when providing
      input to SCIRun.  For example, with the DistanceConstraint, two
      points are constrained to be a fixed distance apart.  If one
      point moves to a new location, the other point must be moved in
      order to maintain that constraint.  Some of the simpler
      constraints are solved using direct methods, while more complex
      constraints are solved using interative methods. 
    </para>

    <para>
      While the primary use for constraints within SCIRun is to
      provide robust 3D widgets, it doesn't preclude their use in
      other situations where constraints may be needed, such as in
      modeling particle interactions in a finite element simulation.
    </para>
  </section>

  <section>
    <title>Programming 3D Widgets</title>
    <para>
      Widgets should be constructed within the module that will be
      using them, and should be sent to a Viewer module through a
      Geom outport.  The developer should implement the virtual
      get_pick() method for their module if they want catch the
      callbacks when the widget is manipulated.
    </para>
  </section>

</chapter>



<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-default-dtd-file:"../../../Utilities/XML/docbook.ced"
sgml-omittag:nil
sgml-shorttag:nil
End:
-->
