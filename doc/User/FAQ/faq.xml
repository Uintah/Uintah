<!--
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
-->

<faq>
<title>User FAQ</title>
<description> 
<para> The User FAQ addresses questions about the behavior of SCIRun, 
its modules, and its networks.</para> 
</description>

<entry>
<keywords>Inverse Problems, Electrocardiography</keywords>
<question>
<para>I have a question regarding the way inverse problems in electrocardiography
 are solved in SCIRUN/BIOPSE. In papers, I read that the
so-called transfer matrix T is built and then a least-squares problem is
solved. This transfer matrix is expressed using inverses of submatrices. Is
this matrix T effectively computed ? Are inverses really computed ?  What
is the method really implemented ? In which modules can I see the source
code?</para>
</question>
<answer>
<para>There are two general solutions to the bioelectric inverse
problem, and they differ in terms of what one is seeking to recover.  In
one formulation, you try to recover equivalent dipole sources.In the
other, you try to recover the voltages on an interior surface that you
assume encompasses any sources (i.e. there are no sources located between
the measurement surface and the interior surface).</para>

<para>For the first formulation
(surface-to-source inversion), the inverse problem can be either
over-constrained (searching for a single dipole that accounts for the outer
surface measurements), or under-constrained (searching for a large number
of dipoles that are distributed through the domain).  The over-constrained
case is often refered to as parameterized inversion, whereas the
under-constrained case is non-parameterized.  For the parameterized case, a
search algorithm is used to locate the dipole that best reproduces the
measured data.For the non-parameterized case, we find the minimum-norm
solution that best fits some a-priori information we have about the data
(e.g. the solution should be spatially focused).</para>

<para>For the latter formulation
(surface-to-surface inversion), because of the poorly-specified boundary
conditions on the inner surface, the inverse problem is ill-conditioned.
This formulation does use the transfer matrix that is built from a
combination of sub-matrices from the stiffness matrix, as you described
below.To answer your more specific questions: we do solve the resulting
linear systems, but not by computing an explicit inverse; rather, we use an
iterative (conjugate-gradient) algorithm. And there is a preliminary
version of this code that I implemented a while ago when I was
investigating cortical mapping techniques.  Unfortuantely, we have not yet
released this code in BioPSE.  For the moment, the best I can offer is a
link to my web-page (http://www.cs.utah.edu/~dmw/) -- from there you can
download a postscript version of our SPIE `95 paper that describes this
technique in more detail.  This is one of the algorithms we intend to
integrate into BioPSE in the early Spring, though, so stay tuned...</para>
</answer>
</entry>


<entry> <keywords>unable to load module, can't find
 symbol</keywords>
<question> 

<para> When I run SCIRun, one or more messages appear in the message window
indicating a problem with a package and/or module.</para>

<para> The message(s) is/are similar to the following: </para>

<pre>Loading package 'SCIRun'
Unable to load module 'CastField' :
- can't find symbol 'make_CastField'
      </pre>
<para>
or
      </para>
<pre>Unable to load all of package 'Teem' (category 'DataIO' failed) :
- libPackages_Teem_Dataflow.so: cannot open shared object file: No
such file or directory
- libPackages_Teem_Dataflow_Modules_DataIO.so: cannot open shared
object file: No such file or directory
      </pre>
</question> 
<answer> 
<para> Each module for a given package has its own .xml file 
that describes it. When SCIRun starts, it parses all the .xml files in the packages 
(under Dataflow/XML) and tries to find the matching code within the related .so 
files. If the .so files cannot be found the message "No such file or directory" 
is given. If the .so can be found, but the code for a particular module does not 
exist within the library, then the message "can't find symbol" is
    given. 
      </para> 
<para> The message(s) may or may not indicate a problem with SCIRun. For some 
modules, the .xml file may be listed but the code has not yet been completed (this 
may be common for module developers). For others it may mean that the SCIRun installation 
is some how corrupt (.so files have been deleted, moved, etc.) 
      </para> 
<para> 
The solution to this problem is to either a) build the libraries that the .xml 
files need, or b) remove the offending .xml files. 
      </para> 
</answer>
</entry> 

<entry> <question> <para> What systems are compatible with SCIRun? </para> </question> 
<answer> <para> SCIRun should be generally compatible with any SGI or Linux machine. 
</para> <para> SCIRun has been tested on the following Linux distributions: </para> 
<para> 
<ul>
  <li>Mandrake 7.2 &amp; 8.0</li>
  <li>Redhat 6.2, 7.0 &amp; 7.1</li>
  <li>SuSE 6.4, 7.0 &amp; 7.2</li>
  <li>Debian testing</li>
</ul> 
      </para>
      <para>
SCIRun has been tested on the following PC processor configurations:
      </para>
      <para>
<ul>
  <li>Dual Intel Pentium II</li>
  <li>Single Intel Pentium III</li>
  <li>Dual Intel Pentium III</li>
  <li>Single Intel Pentium 4</li>
  <li>Single AMD Athlon</li>
</ul>
      </para>
      <para>
SCIRun has been tested with the following PC graphics cards:
      </para>
      <para>
<ul>
  <li>NVIDIA GeForce, GeForce II &amp; GeForce3</li>
</ul>
      </para>
    </answer>
  </entry>

  <entry>
<keywords>Design of BioPSE</keywords>
<question>
<para>
  What is the relationship between SCIRun, BioPSE, and the other
  SCI Institute software?
      </para>
</question>
<answer>
<para>
      It is important to understand the place of the software included in
      this package within the hierarchy of computational problem solving
      environments developed at the SCI Institute.  From a historical
      perspective, <I>SCIRun</I>, which we started developing in 1992, was
      the original implementation of the computational framework.  Since
      then, <I>SCIRun</I> and its computational workbench infrastructure
      have been the origin of many significant application-specific
      projects. Two major examples are the DOE sponsored Uintah system and
      the NIH sponsored <I>BioPSE</I> system (from the (<A NAME="tex2html3"
							   HREF="http://www.ncrr.nih.gov/">National Center for Research
      Resources</A> (NCRR) Center at <A NAME="tex2html4"
					HREF="http://www.sci.utah.edu/ncrr/">Utah</A>). The target
      applications of the Uintah project are combustion, computational
      fluid dynamics, and mechanical modeling implemented on large-scale,
      distributed, shared memory architectures. The goal of the
      <I>BioPSE</I> project is to create software for geometric modeling,
      simulation, and visualization for solving bioelectric field problems.
      An important secondary goal of the <I>SCIRun</I> system is to make
      source code for these problem solving environments publicly available
      to the scientific community.</para>
 
      <para> To realize these two significant projects, the <I>SCIRun</I>
      infrastructure itself has required significant reorganization,
      extension, and enhancement.  Even with these recent changes,
      <I>SCIRun</I> remains both the core infrastructure for our problem
      solving environments and the name we use to refer to the entire
      ensemble of software.  Thus a user may install and operate the core
      <I>SCIRun</I> software and also augment its functionality with one or
      more of the ``packages'' such as <I>BioPSE</I>.  We anticipate that
      the collection of packages will grow as the advantages of the
      <I>SCIRun</I> infrastructure become available to scientists and
      engineers of all disciplines.</para>
 
      <para>
      <div ALIGN="CENTER"><A NAME="fig:biopsesr"></A><A NAME="193"></A>
      <table>
      <CAPTION ALIGN="BOTTOM"><strong>Figure 1:</strong>
      The relationship among <I>SCIRun</I> and the other
packages that it uses.<I>BioPSE</I> consists of the basic
      <I>SCIRun</I> software together with the <I>BioPSE</I> modules and
      support libraries</CAPTION>
      <tr><td><IMG WIDTH="645" ALIGN="TOP"
		   SRC="http://ampano.cs.utah.edu/research/images/EAB-BioPSE.gif"
		   ALT="biopsesr"></IMG></td>
       </tr>
       </table>
       </div>
      
</para> 

<para> In addition to the major projects that have both leveraged and 
advanced <I>SCIRun</I>, there exist a number of smaller packages that can extend 
<I>SCIRun</I>'s utility. Examples include the <I>Teem</I> package for raster data 
processing, the <I>NetSolve</I> package for linear algebra subroutines (developed 
by researchers at the University of Tennessee and Knoxville), and a communications 
interface we have recently introduced to the <I>Matlab</I> program. We have developed 
various forms of software wrappers or interfaces that allow <I>SCIRun</I> to leverage 
the strengths of these third party tools, links we refer to as "bridges."</para> 
<para> There are also instances in which a tighter level of integration than a 
bridge between <I>SCIRun</I> and third-party software is necessary. One example 
is the addition of mpeg support for capturing animations from the <I>SCIRun</I> 
Viewer module, for which we use the Berkeley and Alex Knowles' mpeg encoding tools. 
Another example is the set of image generation and manipulation tools from Paul 
Haeberli called <I>libimage</I>. To indicate whether or not such tools are available, 
the configure scripts for <I>SCIRun</I> contain optional control flags.</para> 
<para> We believe that this combination of a robust infrastructure and modular 
extensibility through packages and third-party libraries will allow <I>SCIRun</I> 
to grow and adapt to changing needs and opportunities.</para> </answer> </entry> 
<entry> <keywords>file conversion, import and export</keywords> <question> <para> 
How do I get my data into <I>SCIRun</I>? </para> </question> <answer> <para> Like 
all program, <I>SCIRun</I> has its own data file formats so conversion is required. 
At present, the pathway for converting data files is to use one of a set of stand-alone 
converter programs that are part of the regular <I>SCIRun</I> distribution. Here 
is the list of available converters: </para> <para> <strong>RawToTriSurf: </strong> 
converts simple ASCII files containing node locations, triangle connectivity, 
and optionally scalar data into <I>SCIRun</I> a field data file.</para> <para> 
Usage: RawToTriSurf pts-file tris-file [vals-file] fieldout.fld </para> <para> 
where: </para> <para> <strong><tt>pts-file</tt> </strong> is a file containing 
point locations for the geometry, a single triplet of x, y, z in each line of 
the file. </para> <para> <strong><tt>tris-file</tt> </strong> is a file containing 
connectivity for the triangles, with each row of the file pointing to three node 
numbers in the <tt>pts-file</tt>. The node numbering starts at 0 in these files. 
</para> <para> <strong><tt>vals-file</tt> </strong> is an optional file that contains 
scalar values to be associated with the nodes of the geometry. These files have 
the same number of values as the <tt>pts-file</tt> with one value per line of 
the file. </para> <para> <strong><tt>fieldout.fld</tt> </strong> is the output 
fields file containing the geometry and associated scalar data. </para> <para> 
The Cardiovascular Research and Training Institute (CVRTI) has developed a number 
of scalar and vector data and geometry file formats which required converters 
for <em>SCIRun</em>. The result is a set of stand-alone programs that read in 
one more more existing CVRTI files and generate a particular form of <em>SCIRun</em> 
file, the details of which depend on the particular combination of nodes, connectivities, 
and associated attributes.</para> <para> The programs and their parameters as 
as follows (go to the end of the list to see the definitions of the different 
parameter and file types): </para> <para> <strong>CVRTItoTriSurfGrad: </strong> 
converts nodes, triangle connectivities, and vector (grad) files into a field 
with associated vector attribute: </para> 
<pre>
CVRTItoTriSurfGrad pts fac grad [channels] fieldout
</pre>

<para>
<strong>CVRTItoTriSurfPot: </strong>
converts nodes, triangle connectivities, and
scalar (pot) data files into a field with associated scalar
attributes.
</para>

<pre>
CVRTItoTriSurfPot pts fac pot [channels] fieldout
</pre>
<para>
<strong>CVRTItoTetVolGrad: </strong>
converts nodes, tetrahedral connectivities, and
vector (grad) files into a field with associated vector
attributes:
</para>

<pre>
CVRTItoTetVolGrad pts tetras grad [channels] fieldout
</pre> 
<para>
<strong>CVRTItoTetVolPot: </strong>
converts nodes, tetrahedral connectivities, and
scalar (pot) files into a field with associated scalar
attributes:
</para>

<pre>
CVRTItoTetVolPot pts tetras pot [channels] fieldout
</pre>
 
<para>
<div ALIGN="CENTER">
<table CELLPADDING="3" BORDER="1">
<tr><td ALIGN="CENTER" COLSPAN="1">Argument</td>
<td ALIGN="CENTER" COLSPAN="1">Purpose</td>
</tr>
<tr><td ALIGN="LEFT" COLSPAN="2">Geometry</td>
</tr>
<tr><td ALIGN="CENTER">pts</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI points file; ASCII
file with one x,y,z triplet per line.*</td>
</tr>
<tr><td ALIGN="CENTER">fac</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI triangle connectivity
(facet) file; ASCII file with one triangle defined per line.  Each
value points to a node number in the associated .pts file, with 1
(not 0) as the first node number.*</td>
</tr>
<tr><td ALIGN="CENTER">tetras</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI tetrahedra file;
ASCII file with the nodes from one tetrahedron on each line,
pointing to the nodes in the associated .pts
file.  Pointers begin with 1 (not 0).*</td>
</tr>
<tr><td ALIGN="LEFT" COLSPAN="2">Data</td>
</tr>
<tr><td ALIGN="CENTER">grad</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI vector file; ASCII
file with two x,y,z triplets per line; first triplet is origin of
the vector and second is the endpoint.*</td>
</tr>
<tr><td ALIGN="CENTER">pot</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI scalar (potentials)
data file; ASCII file,each line contains one scalar value.
Without .channels file, all programs assume a one-to-one mapping of
scalar value to the  nodes in the associated .pts file.*</td>
</tr>
<tr><td ALIGN="LEFT" COLSPAN="2">Channel Mapping</td>
</tr>
<tr><td ALIGN="CENTER">channels</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">CVRTI data channel mapping
file; ASCII file that begins with the line ``N channels'', where N
is the number of channels in the file. Subsequent lines contain two
values, the first refers to a node number in the geometry and the
second points to the associated channel of any scalar or vector
data files.  Thus a .channels file must have an entry for each node
of the associated .pts file but the associated .pot file can have
more (or even fewer) entries.</td>
</tr>
<tr><td ALIGN="LEFT" COLSPAN="2">Field File</td>
</tr>
<tr><td ALIGN="CENTER">field</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">SCIRun fields file that
contains both the geometry and associated scalar or vector data as
attributes.</td>
 </tr>
<tr><td ALIGN="CENTER">&#xa0;</td>
<td ALIGN="LEFT" VALIGN="TOP" WIDTH="288">*<B>Note</B>: to find the
length of all CVRTI ASCII geometry, scalar, and vector files, count
the number of lines in the file.</td>
</tr>
</table></div>
</para>
 
<para>All converter programs are normally available in the
subdirectory of the <em>SCIRun</em> distribution called
<tt>src/StandAlone/convert</tt>.  If they are not easily available,
ask the local person who installed <em>SCIRun</em> for assistance.
</para>
</answer>
</entry>

 
<entry>
<keywords>Viewer, axes orientation</keywords>
<question>
<para>
By default, what directions the positive x,y,z axis point to in the
viewer module?
</para>
</question>
<answer>
<para>
By default you're looking down the negative-z axis, positive-x
point to your right, and positive-y points up.If you have the
Axes turned on, you'll see arrows pointing in +/-{x,y,z}.  The way
to remember which is which is: (R,G,B) = (X,Y,Z).  And the arrows
pointing in the positive directions are brighter than the ones
pointing in the negative directions.  One last note, you can click
on the "Views" button at the botton-right of the ViewWindow, and
snap to a "canonical" view whenever you'd like (e.g. "Look down +Z
axis, Up vector +Y").
</para>
</answer>
</entry>

<entry>
<keywords>Viewer, axes orientation</keywords>
<question>
<para>
Does anyone know of a way to scale up the size of the axes in the
ViewWindow?  I'd like to make the size of the axes comparable to the size
of other objects.
</para>
</question>
<answer>
<para>
Currently you must scale everything else down to the size of unit-axes,
by using the Math::BuildTransform and Field::TransformField modules.
</para>
</answer>
</entry>
</faq>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-default-dtd-file:"../../../doc/Utilities/XML/faq.ced"
sgml-omittag:nil
sgml-shorttag:nil
End:
-->
