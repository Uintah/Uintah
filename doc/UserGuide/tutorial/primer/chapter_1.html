<html>
<head>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
<meta name="generator" content="Adobe GoLive 4">
<title>Geometry Visualization</title>
</head>

<body bgcolor="#a9a9a9">
<table align="center" border="0" cellpadding="0" cellspacing="0" width="306" bgcolor="#cccccc">
<tr>
<td><img height="92" width="600" src="images/sub-banner.jpg" border="0" usemap="#sub-banner8662a0c4"><map name="sub-banner8662a0c4"><area coords="581,65,598,84" shape="rect" title nohref><area href="chapter_7.html" coords="557,64,575,83" shape="rect" title="Feedback"><area href="chapter_6.html" coords="532,64,550,82" shape="rect" title="Putting Simulation and Visualization Together"><area href="chapter_5.html" coords="508,64,527,83" shape="rect" title="Bioelectric Field Simulation"><area href="chapter_4.html" coords="483,64,502,83" shape="rect" title="Multi-Vis"><area href="chapter_3.html" coords="460,64,478,83" shape="rect" title="Derived Fields"><area href="chapter_2.html" coords="436,64,454,83" shape="rect" title="Looking at the Data"><area href="chapter_1.html" coords="412,64,430,81" shape="rect" title="Geometry Visualization"><area href="Intro.html" coords="354,64,406,84" shape="rect" title="Introduction"><area href="http://software.sci.utah.edu/doc/index.html" coords="205,63,343,83" shape="rect" title="Documentation"><area href="http://software.sci.utah.edu/" coords="103,63,195,82" shape="rect" title="Software"><area href="index.html" coords="1,65,92,81" shape="rect" title="Tutorial Home"></map></td>
</tr>

<tr>
<td>
<center>
<table border="0" cellpadding="0" cellspacing="5" width="600">
        <tr>
	<td>
	<center>
	<p><br>
	<font size="4" face="Arial,Helvetica,Geneva,Swiss,SunSans-Regular"
	color="maroon">
        <b>Chapter 1: Geometry Visualization</b></font> </p>
        <p>&nbsp; </p>
        </center>
        <div align="left">
	<p><b><H4><A href="#section 1">FieldReader user interface</H4></b></A>
	<p><b><H4><A href="#section 2">Overview of field types</H4></b></A>
	<p><b><H4><A href="#section 3">ShowField module</H4></b></A>
	<p><b><H4><A href="#section 4">Hooking modules together</H4></b></A>
	<p><b><H4><A href="#section 5">Viewer module</H4></b></A>
	<p><b><H4><A href="#section 6">Navigating the ViewWindow</H4></b></A>
	<p><b><H4><A href="#section 7">Mouse controls</H4></b></A>
	<p><b><H4><A href="#section 8">Setting visualization parameters</H4></b></A>
	<p><b><H4><A href="#section 9">Controlling widgets</H4></b></A>
	<p><b><H4><A href="#section 10">Saving and reloading networks</H4></b></A>
	

        <p><b>Chapter Overview</b><br>

	<p>In this first chapter, we will construct a SCIRun network
        [link to 4.0 UG working with networks] to perform a visualization task: rendering of a
        tetrahedral mesh.  Our &quot;net&quot;, will consist of three
        modules: data reader, geometry converter, and renderer.<br> 

 
	<p>We will read in the datafile from disk, set some rendering
        properties for the nodes, edges, and faces (the
        nodes will be rendered as blue spheres), and render the
        geometry to the screen in an interactive viewing window.<br>  

	<p>To begin, we will construct a net from scratch (as shown,
        completed, in <b>Figure 1.1</b>). In the chapters that follow, we will
        expand on this network, adding more features and
        functionality as we progress.<br>

	</div>
	<center>
 	<p><img height="461" width="450" src="images/figures/1_1.gif"><br>
	<b>Figure 1.1</b></p>
 	</center>
	<div align="left">
	<p><br>

        <p><b><H4><A name="#section 1">FieldReader User Interface</A></b></H4><br>

<<<<<<< chapter_1.html
        <p>You should set several environment variables in your shell
        before we begin running SCIRun.  First, the SCIRUN_DATA
        variable should point to the location of the SCIRunData
        directory on your system.  Second, since many of our example
        networks can be run with a variety of inputs, the
        SCIRUN_DATASET variable indicates which dataset to load.

        <p>For example, in this chapter, we construct a network that
        loads a geometric mesh from disk and renders it to the screen.
        Such a network will work on a wide variety of inputs, and so
        the SCIRUN_DATASET variable indicates a selction for what the user
        would like to see.  To begin, in your Unix shell window, set your
        SCIRUN_DATA variable to point where you have installed the SCIRun
        data. Also set your SCIRUN_DATASET variable to utahtorso-lowres (as
        shown in <b>Figure 1.2.1.</b>)
=======
        <p>You should set the environment variables in your shell
        before we run SCIRun[link to 3.0 UG Starting SCIRun].  
	<ol>
	<li value="1.">The SCIRUN_DATA variable points to the location 
	of the SCIRunData directory on your system.  
	<li value="2.0">The SCIRUN_DATASET variable indicates which dataset to load
	since many of our example networks run with a variety of inputs.
	</ol> 

        <p>For example, we will construct a network that loads a geometric mesh from disk 
	and renders it to the screen. Such a network will work on a wide variety of inputs. 
	The SCIRUN_DATASET variable indicates what the user selects to view.<br>

	<p>To begin, in your Unix shell window:
	<ol>
	<li value="1.">Set your SCIRUN_DATA variable, pointing to the location of SCIRun data. 
	<li value="2.">Set your SCIRUN_DATASET variable to utahtorso-lowres (as
        shown in <b>Figure 1.2.</b>)</ol>
>>>>>>> 1.19

	</div>
	<center>
	<p><img height="240" width="450" src="images/figures/1_2.gif"><br>
	<b>Figure 1.2.1</b></p>
	</center>
	<div align="left">
	<p><br> 

      </div>
	<center>
	<p><img height="240" width="450" src="images/figures/1_2b.gif"><br>
	<b>Figure 1.2.2 Steup using Korn shell</b></p>
	</center>
	<div align="left">
	<p><br> 


	<p>Having set these environment variables, you are now ready to run SCIRun.  
	<ol>
	<li value="1.">Change into your SCIRun/src/ directory, and
        enter the command &quot;./scirun&quot;.  
	<li value="2.">The SCIRun NetworkEditor window appears on your screen, as shown in
        <b>Figure 1.3.</b></ol>

	</div>
	<center>
	<p><img height="410" width="400" src="images/figures/1_3a.gif"><br>
	<b>Figure 1.3</b></p>
	</center>
	<div align="left">
	<p><br>

        <p>We will first create a FieldReader module. Go to the pulldown the
        SCIRun menu and select DataIO/FieldReader, as shown in
        <b>Figure 1.3.1.</b><p>

	</div>
	<center>
	<p><img height="258" width="450" src="images/figures/1_3.gif"><br>
	<b>Figure 1.3.1</b></p>
	</center>
	<div align="left">
	<p><br>

        <p>The module appears as a box on the network map, 
	as seen in <b>Figure 1.4.</b><p>

	</div>
	<center>
	<p><img height="512" width="500" src="images/figures/1_4.gif"><br>
	<b>Figure 1.4</b></p>
	</center>
	<div align="left">
	<p><br>

        <p>To continue creating the module:
	<ol>
	<li value="1.">Press the user interface button to launch the file browser window.
	<li value+"2.">Type, or point-and-click navigate to the
        utahtorso-lowres/utahtorso-lowres-voltage.tvd.fld input file.
        (this dataset is a low resolution tetrahedral mesh of a human
        torso.)  
	<li>Select the filename in the file-browser
        window, press &quot;OK&quot;; the file-browser window
        disappears.
	<li>The FieldReader module begins to execute. 
	<li>The module finishes computing and the progress bar turns green. 
	<li>The module icon displays a number that indicates the amount of CPU time
        required to complete (<b>Figure 1.5</b>).</ol>

	</div>
	<center>
	<p><img height="63" width="161" src="images/figures/1_5.gif"><br>
	<b>Figure 1.5</b></p>
	</center>
	<div align="left">
	<p><br>

	<p> We have just finished reading-in the SCIRun
        &quot;Field&quot; dataset.  A Field contains a geometric mesh, and
        a collection of data values mapped onto that mesh.  In this case,
        we use a tetrahedral mesh with voltages defined at the nodes of the
        mesh.  The brief overview below describes the various types
        of geometric meshes, datavalues, and mappings that SCIRun
        supports.

        <p><A name="#section 2"><b>Overview of field types</A></b><br>

	<p>SCIRun has eight different geometric meshes
        available for Fields:
        <p> PointCloud: unconnected points.
        <p> ScanlineField: a regularly segmented straight
        line.  (a regular 1D grid).
	<p> ContourField: a segmented curve.
        <p> ImageField: a regular 2D grid.
        <p> TriSurf: a surface made of connected triangles.
        <p> QuadSurf: a surface make of connected quadrillaterals.
        <p> LatticeVol: a regular 3D grid.
        <p> TetVol: a subdivision of space into tetrahedral elements.
        <p> HexVol: a subdivision of space into hexagonal elements.
        <br>
        <br>

        <p>In a field, there are, at most, four different places in which data can
        be stored: nodes, edges, faces, and cells.  The dimensionality of the mesh type limits 
	the available storage locations. For instance, a TriSurf does not have three dimensional
        cell elements, thus, data cannot be stored in cells of that
        field type.

        <p>The following data types can be stored in a field:<br>
	</p>
	<ul>
	<li>Tensor
	<li>Vector
	<li>double
	<li>float
	<li>int
	<li>short
	<li>char
	<li>unsigned int
	<li>unsigned short
	<li>unsigned char<br>
	</ul>
	<p><br>

<<<<<<< chapter_1.html
        <p><b>Showfield module</b><br>
=======
        <p><b><A name="#section 3">ShowField module</b><br></A>
>>>>>>> 1.19

<<<<<<< chapter_1.html
        <p>We will now add a second module to our network.  Select
        ShowField from the SCIRun/Visualization menu.  This module is
        used for visualizing various field types.  ShowField has a User
        Interface (UI) option for rendering geometry
        from the field, and special options for rendering
        vector data.  ShowField can use color to represent data within
        the geometry if so desired.  For now, we will 
        render the nodes of the geometry as blue spheres.

        <p>Select the UI button on the ShowField module (<b>Figure 1.6</b>).

=======
        <p>We will now add a second module to our network.  
	<ol>
	<li value="1.">Select ShowField from the SCIRun/Visualization menu. 
	Use this module to visualize various field types).</ol><br>  
	<p>ShowField has a User Interface (UI) option for rendering geometry
        from the field, and special options for rendering vector data.  
	ShowField can use color to represent data within
        the geometry, if desired.  For now, we will 
        render blue spheres as the nodes of the geometry.<br>
	<ol>
	<li value="2.">Select the UI button on the ShowField module(<b>Figure 1.6</b>).</ol>
>>>>>>> 1.19
	</div>
	<center>
	<p><img height="512" width="500" src="images/figures/1_6.gif"><br>
	<b>Figure 1.6</b></p>
	</center>
	<div align="left">

        <p>The Nodes tab selects by default in addition to
        the Sphere Display Type.  However, the default color is grey.<br>

	<ol>
        <li value= "3.">Select the Default Color button
        near the bottom of the dialogue to change the default color.    
	<li value="4.">When a new dialogue with red, green, and blue sliders appears, 
	set red and green to 0.0, and blue to 1.00.  
	<li value="5.">Select the &quot;OK&quot; button in this color dialogue.  
	<li value="6.">Select &quot;Cancel&quot; to remove the dialogue from view.
        <li>Change the Node Scale to 2 and set the Sphere Resolution
        to 5. 
	<li>Turn off the display of edges and faces.  
	<li>Select the Edges tab in the ShowField dialogue.  
	<li>Turn off Show Edges.
        <li>Select the Faces tab.  
	<li>Turn off Show Faces.  
	<li>The ShowField module is now ready to render the nodes as blue spheres.
	</ol>
        <p><b><A name="#section 4">Hooking modules together</b><br></A>

        <p>You will now connect the two modules in your canvas so that data can 
	flow between them.  The Output port in SCIRun is always on the bottom of the module, 
	whereas the Input ports are always on top. Each datatype in SCIRun that can pass 
	through ports has a unique color. You may connect ports of the same color.
                  
	<p>To hook the modules together,
	<ol>       
	<li value="1.">With your middle mouse button, select the yellow output port on
        the FieldReader (<b>Figure 1.7.1</b>). You should see the name of the port and lines that indicate possible
        connections.
	<li value="2."> Drag your middle mouse toward the ShowField input
        Field port (yellow). 
	<li>When the line turns red (<b>Figure 1.7.2</b>), release the mouse
        button. 
	<li>You should see a yellow datapipe connection
        between FieldReader and ShowField (<b>Figure 1.7.3</b>).</ol>

	</div>
	<center>
	<p><img height="250" width="250" src="images/figures/1_7a.gif"><br>
	<b>Figure 1.7.1</b></p>
	</center>
	<div align="left">
	<p><br>
	</div>
	<center>
	<p><img height="250" width="250" src="images/figures/1_7b.gif"><br>
	<b>Figure 1.7.2</b></p>
	</center>
	<div align="left">
	<p><br>
	</div>
	<center>
	<p><img height="250" width="250" src="images/figures/1_7c.gif"><br>
	<b>Figure 1.7.3</b></p>
	</center>
	<div align="left">
	<p><br>
	<ol>
	<li value="5.">Next, press the "Execute" button on the ShowField UI that forces the
        module to execute its algorithm. </ol><br>

	<p>ShowField should work on any of our numerous Field types, each of which may contain 
	any data type. For example, ShowField should
        visualize TetVol with double data, or TetVol with Vector
        or Tensor data. This is also true for TriSurf and all of our Fields, 
	creating a combined explosion of accepted types. We have
        used the C++ template mechanism to achieve such versatility, which also requires 
	compiling all of the types we might ever use into our code base.<br>

        <p>Since we have compiled only algorithms with an
        exact field type, this information becomes known only after a module
        recieves its input data. We accomplish this by using <a
        href="http://www.sci.utah.edu/publications/mcole01/dyn.pdf">Dynamic
        Compilation</a>. <br>

	<p>You will notice a delay when ShowField executes for the first time. 
	This happens when the module compiles the algorithm specific to the field type, and loads it
        into SCIRun.  We cache away this compiled algorithm in a
        shared library, loading it without delay the next time you run
        SCIRun.

        <p>ShowField will then execute the newly loaded algorithm
        passing its results along downstream.

        <p><b><A name="#section 5">Viewer module</b><br></A>

	<p>The viewer module is the last that we will add to our
	network. 
	<ol>
	<li value="1.">Locate the viewer under the SCIRun/Render
	menu.  
	<li value="2.">Connect the output port from ShowField into the Viewer input port. 
	</ol> 

	<p>As a result, the Viewer module has generated a new input port. The Viewer provides an example 
	of SCIRun modules that have dynamic input ports. These dynamic ports always allow 
	the Viewer to accept additional data to render.<br>

	<p>To see the graphical rendering of the data (<b>Figure 1.10</b>)
	that passes into the Viewer module, press the Viewer UI button.<br>

		
	</div>
	<center>
	<p><img height="451" width="450" src="images/figures/1_10.gif"><br>
	<b>Figure 1.10</b></p>
	</center>
	<div align="left">
	<p><br>
	
	<p> For more information about executing a network, go to [link UG 4.5].

	<p><b><A name="#section 6">Navigating the ViewWindow</b><br></A>

	<p>Since the viewer is one of the most important elements of SCIRun,
	you may want to know more about its functionality.  The User's Guide 
	[link to UG 5.0 Viewer] provides a full description of the Viewer.  
 
	<p> <b>Figure 1.10</b> shows the Viewer window with the
	network you have built earlier in this chapter.  In the lower window panel,
	locate controls for setting the display.However, the controls you will 
	use most frequently are not visible.
 
	<p><b><A name="section 7">Mouse controls</b><br></A>
 
	<p>The mouse has great functionality that works with the Viewer. 
	<ol>
	<li value="1.">Move the mouse to the center of the Viewer window.
	<li value="2."> Click and hold the left mouse button. 
	<li>Slide the mouse and objects in the View window shift to follow the mouse movement.  
	<li>Slide the mouse with the middle mouse button and objects stop
	shifting and instead, begin to rotate.
 	<li>Let the buttons go and move the mouse to the edge of
	the object in the viewer window.  
	<li>Click, hold, and drag the middle mouse button. The object rotates in a
	different direction.</ol><br>
  
	<p>Up and down motions cause the objects to rotate counterclockwise and clockwise, 
	rather than around a horizontal axis by clicking on the middle of the
	objects.<br>
 
	<p>To picture the rotation action of the mouse, imagine the objects sitting 
	within a sphere. To grab a point on the sphere, click the middle mouse button,
	moving the point in the same direction as the mouse, rotating the
	sphere and all objects inside it.  The movement of the objects
	depends on the point moved by the mouse. To use an analogy, this is
	like placing a ball in a bowl full of water, touching the ball only
	at one point to move it around.<br>  
	
	<p>Using this type of mouse control, objects can rotate in three dimensions 
	while the mouse moves only in two.  With experimentation, you will
	be able to orient objects in whatever direction you
	wish through simple mouse manipulations.<br> For more information, 
	you may consult the User's Guide [link to UG 5.3] 
 
	<p>Pressing the right mouse button and moving the mouse
	cause the contents of the View window to get larger and
	smaller.  The creates the impression of moving closer in or
	farther away from the contents of the window <b>(Figure 1.10.1)</b>. 

      </div>
	<center>
	<p><img height="451" width="450" src="images/figures/1_10_1.gif"><br>
	<b>Figure 1.10.1</b></p>
	</center>
	<div align="left">
	<p><br>

      </div>
	<center>
	<p><img height="64" width="500" src="images/figures/1_10_2.gif"><br>
	<b>Figure 1.10.2</b></p>
	</center>
	<div align="left">
	<p><br>

 
 

	<p><b><A name="section 8">Setting Visualization Parameters</b><br></A>
 
	<p>Now we will use the controls in the Viewer
	window below the objects <b>(Figure 1.10.2)</b>. Here, you see buttons for the
	following functions:
	<br>
 	<ul>
        <li>Autoview:	restores the display back to its default
			condition; very useful when some combination of
			settings results in objects disappearing from the
			view window.  
	<li>Set Home View:	captures the setting of the current view so you
			can return to it later by clicking the ``Go home'' 
			button.
<<<<<<< chapter_1.html
	Go home:	restores the current home view.  
	Views:		lists a number of standard viewing angles and
			orientations for you to select.
 
	<p>See the User's Guide for more details on these functions.
 
	<p>The "+" button on the lower right corner of the viewer
	window provides access to a more complete set of display
	options <b>(Figure 1.10.3)</b>.  This "extended control window" provides a means to
	select features for either all objects, or for specific
	objects in the display.  Each object has its own entry in the
	list that appears in the extended control window.  There are
	settings that determine the rendering of each associated object, next to
	each entry in the object list. are settings that determine the
	rendering of the associated object--These settings may even turn
	the whole object on or off, i.e., make it appear or disappear.  The
	default settings apply to all objects that contain the
	"default" selection.  It is best to manipulate all of these
	settings to see the possible effects, and consult the
	User's Guide for a complete description.

      </div>
	<center>
	<p><img height="273" width="500" src="images/figures/1_10_3.gif"><br>
	<b>Figure 1.10.3</b></p>
	</center>
	<div align="left">
	<p><br>

 
	<p><b>Controlling Widgets</b><br>
 
	<p>Widgets are graphical elements---objects in the
	viewer.  Their main purpose is to allow interactive user
	control of the display.  SCIRun supports a family of widgets
	that have a similar look and feel, but manipulate different
	aspects of the display.
 
	<p>The associated widget module must be present in the network in
	order to include a widget in the display. 
 
	<p>You can control the widgets by shift-clicking and
	dragging on different parts of them.  Selecting some neutral
	spot on a widget allows the user to move it around the screen,
	which selects the region of the display where the widget
	should act.  Selecting spheres and cylinders on the widget
	usually provides a means by which to alter either the orientation
	of widget, or the parameters it controls, for example, density
	of streamlines.
=======
	<li>Go home:	restores the current home view.  
	<li>Views:	lists a number of standard viewing angles and
			orientations for you to select.</ul>
 
	<p>See the User's Guide [link UG 5.0]for more details on these functions.
 
	<p>For more display options:
	<ul>
	<li>Locate the "+" button in the lower right corner of the Viewer window.  
	This button provides access to a more complete set of display options.
	<li>Select features for all objects or for specific objects 
	in the display through the Extended Control Window[link to UG 5.4 ECW].</ul>
	
	<p>Each object has its own list entry in the extended control window.  
	Settings that determine the rendering of each associated object are located in the object list. These settings 
	may even turn the entire object on or off,(<i>i.e.</i>, make it appear or disappear).  
	
	<p>Default settings apply to all objects that contain the
	"default" selection.  We suggest that you manipulate all of these
	settings to see their possible effects, and consult the
	User's Guide for a more complete description.
 
	<p><b><A name="section 9">Controlling Widgets</b><br></A>
>>>>>>> 1.19
 
<<<<<<< chapter_1.html
	<p>Select and move the widget in your network by
=======
	<p>Widgets are graphical elements, objects in the Viewer that allow the interactive user
	to control the display.  SCIRun supports a family of widgets
	that have a similar look and feel, but manipulate different
	aspects of the display.<br>[link to UG 5.5 Control Widgets]
 
	<p>In order to include a widget in the display, its associated 
	widget module must be present in the network.<br> 
 
	<p>You can control widgets by:
	<ol>
 	<li value="1.">Shift-click and drag on different parts of a widget.  
	<li value="2.">Select a neutral spot on the widget.
	<li>Move the widget around the screen to choose the display region where it
	should act.
	<li>Select spheres and cylinders on the widget to alter either its 
	orientation, or parameters (<i>e.g.,</i>density of streamlines).
	<li>Select and move the widget in your network by
>>>>>>> 1.19
	making sure it is visible (via the extended control window).
	<li>Shift-click the left mouse button on any part of the widget.  
	<li>Move the mouse to move the widget around.  
	<li>Shift-click the widget's spheres (control points), and the widget 
	rotates around its center. </ol>
 
	<p> In order to greatly enhance your capabilities with SCIRun, learn more 
	about the Viewer's components in the User's Guide.[link to UG 5.0 Visualization with the Viewer]<br>
 
        <p><b><A name="section 10">Saving and reloading networks[link to Ug 4.13]</b><br></A>

        <p>The three-module network that we created earlier provides the foundation 
	for the nets we create through the rest of this tutorial.  As such, we will 
	examine how nets can be saved to disk and reloaded in a future SCIRun session.

        <p>To save a SCIRun network (<b>Figure 1.11</b>):
	<ol>
	<li value="1.">Pull down the File menu from the top of the SCIRun window.
	<li value="2.">Select &quot;Save&quot;.  
	<li>When the file browser appears, follow the prompt to choose a location and 
	filename for your net (by convention, we keep most nets in the SCIRun/src/nets/
        directory, but you can store them in whatever location you wish).
	<li>For this example,store the net as SCIRun/src/nets/show-torso-mesh.net 
	(we use the .net suffix for SCIRun network files).</ol><br>

	</div>
	<center>
	<p><img height="216" width="320" src="images/figures/1_11.gif"><br>
	<b>Figure 1.11</b></p>
	</center>
	<div align="left">
	<p><br>
	<ol>
	<li value="5.">Quit out of SCIRun and restart the program.  
	<li value="6.">To load the saved net (<b>Figure 1.12</b>), pulldown the
        &quot;Load...&quot; option from the File menu bar.
	<li>Select SCIRun/src/nets/show-torso-mesh.net 
	</ol><br>
	
	</div>
	<center>
	<p><img height="369" width="500" src="images/figures/1_12.gif"><br>
	<b>Figure 1.12</b></p>
	</center>
	<div align="left">
	<p><br>
        </div>

	<p>The net should reload into SCIRun, where it was when you saved it.  
	If we change something (<i>e.g.</i>, rotate your view in the ViewWindow or change
        the rendering color of the nodes in ShowField), then we have
        two options if we want to re-save our net:
	<ul>
	<li>Overwrite the existing show-torso-mesh.net file by simply
        pulling down File -&gt; Save.  
	<li>Alternatively, save it to a new file using File -&gt; Save As...  
	</ul><br>

	<p>For more information on the File menu options (such as Insert and
        Clear), please refer to the User's Guide.

	<p><b><H4>Summary</b></H4>
	<p> needs content


	</td>
	</tr>
</table>
</center>
</td>
</tr>
<tr>
<td><img height="35" width="600" src="images/sub-banner-bottom.jpg" border="0" usemap="#sub-banner-bottom8abfd9a4"><map name="sub-banner-bottom8abfd9a4"><area href="chapter_2.html" coords="564,3,589,18" shape="rect"><area href="Intro.html" coords="537,6,560,21" shape="rect"><area href="http://www.sci.utah.edu" coords="6,7,67,31" shape="rect" title="SCI Institute"></map></td>
</tr>
</table>
</body>
</html>
