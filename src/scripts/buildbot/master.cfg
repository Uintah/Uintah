# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# the 'slaves' list defines the set of allowable buildslaves. Each element is
# a tuple of bot-name and bot-password. These correspond to values given to
# the buildslave's mktap invocation.

from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("Lenny_64", "password"),
	       BuildSlave("Squeeze_64", "password",max_builds=1),
	       BuildSlave("Squeeze_32", "password",max_builds=1),
	       BuildSlave("Inferno", "password",max_builds=1)]

# to limit to two concurrent builds on a slave, use
#  c['slaves'] = [BuildSlave("bot1name", "bot1passwd", max_builds=2)]


# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)

c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. Any class which implements IChangeSource can be
# put here: there are several in buildbot/changes/*.py to choose from.

from buildbot.changes.svnpoller import SVNPoller
source_code_svn_url='https://gforge.sci.utah.edu/svn/uintah/trunk/src'
doc_svn_url='https://gforge.sci.utah.edu/svn/uintah/trunk/doc'
svn_poller = SVNPoller(svnurl=source_code_svn_url,
		       pollinterval=1*60, # seconds -- every 1 minute
                       )
doc_svn_poller = SVNPoller(svnurl=doc_svn_url,
		           pollinterval=10*60, # seconds -- every 10 minutes
                          )
c['change_source'] = [ svn_poller, doc_svn_poller]



####### SCHEDULERS

## configure the Schedulers

from buildbot import scheduler

quick = scheduler.Scheduler(name="quick-build", branch=None,
                            treeStableTimer=1*60, # wait 1 minutes
                            builderNames=["Linux-Debug-64bit"])

inferno = scheduler.Scheduler(name="inferno-build", branch=None,
                            treeStableTimer=1*60, # wait 1 minutes
                            builderNames=["inferno-linux"])

inferno_41 = scheduler.Dependent(name="inferno-build-4.1",
                                 upstream=inferno, 
                            	 builderNames=["inferno-linux-41"])

inferno_42 = scheduler.Dependent(name="inferno-build-4.2",
                                 upstream=inferno_41, 
                            	 builderNames=["inferno-linux-42"])

quick_32 = scheduler.Dependent(name="quick-build-32",
                               upstream=quick,
                               builderNames=["Linux-Debug-32bit-Static-Libraries"])
                               
quickWasatch = scheduler.Scheduler(name="quick-wasatch", branch=None,
                            treeStableTimer=1*60, # wait 1 minutes
                            builderNames=["Linux-dbg-static-Wasatch"])

full = scheduler.Dependent(name="full-build & test", 
			   upstream=quick_32,
			   builderNames=["Linux-Optimize-Test-64bit"])


night = scheduler.Nightly(name='nightly', 
			  builderNames=['Linux-Debug-Optimize-Test-64bit'],
             		  hour=2, minute=1)

doc = scheduler.Scheduler(name="doc-build",branch=None,
			  treeStableTimer=1*60,
			  builderNames=["Documentation-Builder"])

c['schedulers'] = []
c['schedulers'] = [ doc, quick, quick_32, quickWasatch, inferno,inferno_41, inferno_42,full, night ]
#c['schedulers'] = [ doc, quick, quick_32, full, night ]


####### BUILDERS

# the 'builders' list defines the Builders. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this bilder
#  slavename (required): which slave to use, must appear in c['bots']
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds

# buildbot/process/factory.py provides several BuildFactory classes you can
# start with, which implement build processes for common targets (GNU
# autoconf projects, CPAN perl modules, etc). The factory.BuildFactory is the
# base class, and is configured with a series of BuildSteps. When the build
# is run, the appropriate buildslave is told to execute each Step in turn.

# the first BuildStep is typically responsible for obtaining a copy of the
# sources. There are source-obtaining Steps in buildbot/steps/source.py for
# CVS, SVN, and others.

from buildbot.process import factory
from buildbot.steps import source, shell, transfer


compiler_env = {'CC' : '/usr/lib/ccache/gcc',
		'CXX' : '/usr/lib/ccache/g++',
		'F77' : 'gfortran',
		'SCI_MAKE_BE_QUIET' : 'true',
		'LANG' : ''
		}

compiler_env_32 = {'CC' : '/usr/lib/ccache/gcc',
		'CXX' : '/usr/lib/ccache/g++',
		'F77' : 'gfortran-4.4',
		'SCI_MAKE_BE_QUIET' : 'true',
		'LANG' : ''
		}

compiler_env_41 = {'CC' : 'gcc-4.1',
		'CXX' : 'g++-4.1',
		'F77' : 'g77',
		'SCI_MAKE_BE_QUIET' : 'true',
		'LANG' : ''
		}

compiler_env_42 = {'CC' : 'gcc-4.2',
		'CXX' : 'g++-4.2',
		'F77' : 'gfortran-4.2',
		'SCI_MAKE_BE_QUIET' : 'true',
		'LANG' : ''
		}

inferno_env =  {'SCI_MAKE_BE_QUIET' : 'true',
		'LANG' : ''
		}

rt_env = {'GOLD_STANDARD': '/usr/local/TestData'}

dbg_configure = ["../src/configure", "--enable-debug", "--enable-sci-malloc" ]

dbg_configure_command = dbg_configure + ["--enable-64bit"] 

dbg_configure_command_32 = dbg_configure + ["--enable-static"]

wasatch_configure_command = ["../src/configure", 
                             "--enable-debug", 
                             "--enable-64bit",
                             "--with-hdf5",
                             "--with-boost=/usr",
                             "--enable-wasatch_3p",
                             "--enable-static",
                             "--without-fortran",
                             "USE_MPM=no USE_ICE=no USE_MPMICE=no USE_ARCHES=no USE_MODELS_RADIATION=no",
                             "USE_WASATCH=yes" ]
                         


opt_configure_command = ["../src/configure", 
                         "--enable-optimize=-O3 -mfpmath=sse", 
                         "--enable-64bit", "--enable-assertion-level=0",
                         "--disable-sci-malloc"
			]

wasatch_configure = ["--enable-wasatch_3p",
#                     "--with-boost=/usr/local/boost",
                     "--with-boost=/usr",
                     "--with-hdf5" 
		    ]

opt_configure_command = opt_configure_command + wasatch_configure

malloc_trace = ["--with-MallocTrace=/usr/local/MallocTrace"]

opt_nightly_configure_command = opt_configure_command + malloc_trace

dbg_nightly_configure_command = dbg_configure_command + wasatch_configure


rt_command = ["../../src/scripts/regression_tester", "-exact", "-restart", "-nice"]

def AddTestStep(fac,test_case,build_type):
	fac.addStep(shell.ShellCommand,
	            description=["Running " + test_case.upper() + " " + build_type + " tests"],
		    command=rt_command + ["-" + test_case, "-" + build_type],
		    env=rt_env,
		    workdir= 'build/'+build_type+'/StandAlone',
                    warnOnWarnings=True,
		    timeout=60*60,  # timeout after 1 hour
                    name=test_case + "_test")

tests=["wasatch","arches","examples","models","ice","ice_amr","mpm","mpmice","mpmice_amr","impm","mpmarches"]

#tests=["mpmarches"]

doc_f = factory.BuildFactory()

doc_f.addStep(source.SVN, svnurl=doc_svn_url,directory='build/doc', 
		mode="update",retry=(10,2))

doc_f.addStep(shell.ShellCommand, 
              description=["Building documentation"],
              command=["./runLatex"],
              workdir='build/doc',
              warnOnWarnings=False,
              warnOnFailure=False,
	      name="build documentation")

debug_f = factory.BuildFactory()
 
debug_f.addStep(source.SVN, svnurl=source_code_svn_url,directory='build/src', 
	mode="update",retry=(10,2))

debug_f.addStep(shell.Configure,
                command=dbg_configure_command,
                env=compiler_env,
		workdir='build/dbg')

debug_f.addStep(shell.Compile,
           	command=["python", "../src/scripts/make.py", " 4"],
           	env=compiler_env,
		workdir='build/dbg')
		

inferno_f = factory.BuildFactory()
inferno_f.addStep(source.SVN, svnurl=source_code_svn_url,
	           directory='build/src', mode="update",retry=(10,2))

inferno_f.addStep(shell.Configure,
           	   command=dbg_configure,
                   env=inferno_env,
                   workdir='build/dbg')


inferno_f.addStep(shell.Compile, 
                   command=["../src/scripts/pump_make.sh"],
                   env=inferno_env,
                   workdir='build/dbg')

inferno_41_f = factory.BuildFactory()
inferno_41_f.addStep(source.SVN, svnurl=source_code_svn_url,
	           directory='build/src', mode="update",retry=(10,2))

inferno_41_f.addStep(shell.Configure,
           	   command=dbg_configure,
                   env=compiler_env_41,
                   workdir='build/dbg')


inferno_41_f.addStep(shell.Compile, 
                   command=["../src/scripts/pump_make.sh", " g++-4.1"],
                   env=compiler_env_41,
                   workdir='build/dbg')


inferno_42_f = factory.BuildFactory()
inferno_42_f.addStep(source.SVN, svnurl=source_code_svn_url,
	           directory='build/src', mode="update",retry=(10,2))

inferno_42_f.addStep(shell.Configure,
           	   command=dbg_configure,
                   env=compiler_env_42,
                   workdir='build/dbg')


inferno_42_f.addStep(shell.Compile, 
                   command=["../src/scripts/pump_make.sh", " g++-4.2"],
                   env=compiler_env_42,
                   workdir='build/dbg')


debug_f_32 = factory.BuildFactory()
debug_f_32.addStep(source.SVN, svnurl=source_code_svn_url,
	           directory='build/src', mode="update",retry=(10,2))

debug_f_32.addStep(shell.Configure,
           	   command=dbg_configure_command_32,
                   env=compiler_env_32,
                   workdir='build/dbg')

debug_f_32.addStep(shell.Compile, 
                   command=["python", "../src/scripts/make.py", " 4"],
                   env=compiler_env_32,
                   workdir='build/dbg')
                   
                   
                   
wasatchOnly_f = factory.BuildFactory()
wasatchOnly_f.addStep(source.SVN, svnurl=source_code_svn_url,
	           directory='build/src', mode="update",retry=(10,2))

wasatchOnly_f.addStep(shell.Configure,
           	     command=wasatch_configure_command,
                   env=compiler_env_42,
                   workdir='build/dbg')

wasatchOnly_f.addStep(shell.Compile, 
                   command=["python", "../src/scripts/make.py", " 4"],
                   env=compiler_env_42,
                   workdir='build/dbg')                   
                   
                   


optimize_f = factory.BuildFactory()
optimize_f.addStep(source.SVN, svnurl=source_code_svn_url, 
		   directory='build/src', mode="update",retry=(10,2))

optimize_f.addStep(shell.Configure,
                   env=compiler_env,
                   workdir='build/opt',
                   command=opt_configure_command)

optimize_f.addStep(shell.Compile, 
           	   command=["python", "../src/scripts/make.py", " 4"],
           	   env=compiler_env,
                   workdir='build/opt')

optimize_f.addStep(shell.ShellCommand, 
                   description=["Creating inputs symbolic link"],
                   command=["../../src/scripts/create_inputs_dir.sh"],
                   workdir='build/opt/StandAlone',
                   warnOnWarnings=False,
                   warnOnFailure=False,
		   name="input_symbolic_link")

for test in tests:
	AddTestStep(optimize_f,test,"opt")



import os, shutil, glob
from buildbot.process.properties import WithProperties

class TransferTestResults(transfer.DirectoryUpload):
	def __init__(self,extradir=None,**kwargs):
		self.extradir=extradir
		transfer.DirectoryUpload.__init__(self,**kwargs)
 	
	def finished(self, result):
		bname = self.getProperty("buildername")
		bnum = self.getProperty("buildnumber")
        	url = "http://buildbot.uintah.utah.edu:8010/TestResults/"+ bname+"/"+ str(bnum) +"/"
		print self.extradir
		if self.extradir != None:
			url = url + self.extradir
        	self.addURL("TestResults", url)
        	result = transfer.DirectoryUpload.finished(self, result)
        	self.step_status.setText(["uploaded results"])
        	return result


optimize_f.addStep(TransferTestResults(workdir='build/opt/StandAlone',
		   slavesrc="TestResults",
		   masterdest=WithProperties("~/master/public_html/TestResults/%(buildername)s/%(buildnumber)s/"))
		)




night_f = factory.BuildFactory()
night_f.addStep(source.SVN, svnurl=source_code_svn_url, directory='build/src',
	        mode="update",retry=(10,2))

night_f.addStep(shell.Configure,
                command=dbg_nightly_configure_command,
                env=compiler_env,
                workdir='build/dbg')

night_f.addStep(shell.Compile, 
                command=["python", "../src/scripts/make.py", " 4"],
                env=compiler_env,
                workdir='build/dbg')

night_f.addStep(shell.ShellCommand, 
                description=["Creating inputs symbolic link"],
                command=["../../src/scripts/create_inputs_dir.sh"],
                workdir='build/dbg/StandAlone',
                warnOnWarnings=False,
                warnOnFailure=False,
		name="input_symbolic_link")

for test in tests:
	AddTestStep(night_f,test,"dbg")

night_f.addStep(TransferTestResults(workdir='build/dbg/StandAlone',
		slavesrc="TestResults",
		masterdest=WithProperties("~/master/public_html/TestResults/%(buildername)s/%(buildnumber)s/dbg/"),
		extradir="dbg")
		)

night_f.addStep(shell.Configure,
                command=opt_configure_command,
                env=compiler_env,
                workdir='build/opt')

night_f.addStep(shell.Compile, 
                command=["python", "../src/scripts/make.py", " 4"],
                env=compiler_env,
                workdir='build/opt')

night_f.addStep(shell.ShellCommand, 
                description=["Creating inputs symbolic link"],
                command=["../../src/scripts/create_inputs_dir.sh"],
                workdir='build/opt/StandAlone',
                warnOnWarnings=False,
                warnOnFailure=False,
		name="input_symbolic_link")

for test in tests:
	AddTestStep(night_f,test,"opt")

night_f.addStep(TransferTestResults(workdir='build/opt/StandAlone',
		slavesrc="TestResults",
		masterdest=WithProperties("~/master/public_html/TestResults/%(buildername)s/%(buildnumber)s/opt/"),
		extradir="opt")
		)


#### BUILDERS #####

doc_squeeze = {'name': "Documentation-Builder",
               'slavenames':[ "Squeeze_64","Inferno"],
#               'slavename': "Squeeze_64",
               'builddir': "uintah_doc",
               'factory': doc_f,
               }

ql_squeeze_wasatch = {'name': "Linux-dbg-static-Wasatch",
      'slavename': "Squeeze_64",
      'builddir':  "wasatch_quick",
      'factory':    wasatchOnly_f,
      }
      
ql_squeeze = {'name': "Linux-Debug-64bit",
      'slavename': "Squeeze_64",
      'builddir': "uintah_quick",
      'factory': debug_f,
      }

inferno_builder = {'name': "inferno-linux",
      'slavename': "Inferno",
      'builddir': "uintah_inferno",
      'factory': inferno_f,
      }

inferno_41_builder = {'name': "inferno-linux-41",
      'slavename': "Inferno",
      'builddir': "uintah_inferno_41",
      'factory': inferno_41_f,
      }

inferno_42_builder = {'name': "inferno-linux-42",
      'slavename': "Inferno",
      'builddir': "uintah_inferno_42",
      'factory': inferno_42_f,
      }

ql_squeeze_32 = {'name': "Linux-Debug-32bit-Static-Libraries",
#                 'slavename': "Squeeze_32",
                 'slavenames': ["Squeeze_32","Inferno"],
                 'builddir': "uintah_quick_32",
                 'factory': debug_f_32,
                 }

fl_squeeze = {'name': "Linux-Optimize-Test-64bit",
      'slavename': "Squeeze_64",
      'builddir': "uintah_full",
      'factory': optimize_f,
      } 

nl_squeeze = {'name': "Linux-Debug-Optimize-Test-64bit",
      	      'slavename': "Squeeze_64",
      	      'builddir': "uintah_nightly",
      	      'factory': night_f,
      	     } 

c['builders'] = [doc_squeeze, ql_squeeze, ql_squeeze_wasatch, ql_squeeze_32, inferno_builder, inferno_41_builder,inferno_42_builder,fl_squeeze, nl_squeeze]
#c['builders'] = [doc_squeeze, ql_squeeze, ql_squeeze_32, fl_squeeze, nl_squeeze]


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.WebStatus(http_port="8010",allowForce=True))

from buildbot.status import mail
c['status'].append(mail.MailNotifier(fromaddr="uintah-developer@gforge.sci.utah.edu",
                                     extraRecipients=["uintah-developer@gforge.sci.utah.edu"],
                                     sendToInterestedUsers=True,
				     lookup="sci.utah.edu",
				     mode="failing"))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")


####### PROJECT IDENTITY

# the 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.

c['projectName'] = "Uintah"
c['projectURL'] = "http://www.uintah.utah.edu/"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://buildbot.uintah.utah.edu:8010/"
