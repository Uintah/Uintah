/*****************************************************************************
 *
 * Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
 * Produced at the Lawrence Livermore National Laboratory
 * LLNL-CODE-400142
 * All rights reserved.
 *
 * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
 * full copyright notice is contained in the file COPYRIGHT located at the root
 * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
 *
 * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of  source code must  retain the above  copyright notice,
 *    this list of conditions and the disclaimer below.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
 *    documentation and/or other materials provided with the distribution.
 *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
 * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
 * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
 * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
 * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
 * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
 * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 *****************************************************************************/

// ************************************************************************* //
//                            avtudaReaderMTMDFileFormat.C                           //
// ************************************************************************* //

#include <Packages/Uintah/VisIt/udaReaderMTMD/avtudaReaderMTMDFileFormat.h>

#include <stdio.h>
#include <cstring>
#include <dlfcn.h>
#include <string>

#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkFieldData.h>
#include <vtkFloatArray.h>
#include <vtkIntArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>

#include <avtDatabase.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtStructuredDomainNesting.h>
#include <avtVariableCache.h>
#include <avtMaterial.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

using     std::string;

#define PARTICLE_INTERVAL 1


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat constructor
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

avtudaReaderMTMDFileFormat::avtudaReaderMTMDFileFormat(const char *filename) :
  avtMTMDFileFormat(filename)
{
  cout << "\nIn avtudaReaderFileFormat\n";

  // INITIALIZE DATA MEMBERS
  bool fileOpened = false;

  // folder.assign("/home/collab/sshankar/csafe_data/jp8_tuna_can_Dmin_Pmax_rel_Wmax.uda"); 
  // folder.assign("/home/collab/sshankar/csafe_data/jp8_tuna_can_Dmax_Pmax.uda");
  // folder.assign("/home/sci/kuzimmer/work/SCIRunData/JP8_MR.uda.000");
  // folder.assign("/home/collab/sshankar/csafe_data/guni.2L.2C.uda.000");
  // folder.assign("/home/collab/sshankar/csafe_data/M2wedge.2L.uda.001");

  // Verify that it is a UDA index.xml file:
  //   The 2nd line should look like this <Uintah_DataArchive>.

  FILE * fp = fopen( filename, "r" );
  if( fp == NULL ) {

    string error = string( "Failed to open file: " ) + filename;
    EXCEPTION1( InvalidDBTypeException, error.c_str() );
  }

  char line[1024];
  char * result = fgets( line, 1024, fp );
  if( result ) { 
    result = fgets( line, 1024, fp );
  }

  string lineStr = line;
  if( !result || lineStr.find( "<Uintah_DataArchive>" ) == string::npos ) {
    string error = string( filename ) + " does not appear to be a <Uintah_DataArchive>.";
    printf("here: %s\n", error.c_str());
    EXCEPTION1( InvalidDBTypeException, error.c_str() );
  }
  fclose( fp );

  folder.assign(filename);
  size_t found = folder.find_last_of("/");
  folder = folder.substr(0, found);

  cout << folder << endl;

  const char * lib = "@UINTAH_UDA_TO_VIS_LIB@";

  libHandle = dlopen(lib, RTLD_NOW); // The dylib locn should be changed
  if (!libHandle) {
    char* errString = dlerror();
    cerr << "Error: " << string( errString ) << "\n"; 
    cerr << "The library libuda2vis could not be located!!!\n"; 
    cerr << "Tried to load: " << lib << "\n";
    EXCEPTION1(InvalidDBTypeException, errString);
  }

  // All possible function calls - check here

  *(void **)(&getTimeSteps) = dlsym(libHandle, "getTimeSteps");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getTimeSteps could not be located in the library!!!");
  }

  *(void **)(&getVarList) = dlsym(libHandle, "getVarList");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getVarList could not be located in the library!!!");
  }

  *(void **)(&getMaterials) = dlsym(libHandle, "getMaterials");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getMaterials could not be located in the library!!!");
  }

  *(void **)(&getBBox) = dlsym(libHandle, "getBBox");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getBBox could not be located in the library!!!");
  }

  *(void **)(&getPatchBBox) = dlsym(libHandle, "getPatchBBox");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getPatchBBox could not be located in the library!!!");
  }

  *(void **)(&processData) = dlsym(libHandle, "processData");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function processData could not be located in the library!!!");
  }

  *(void **)(&getTotalNumPatches) = dlsym(libHandle, "getTotalNumPatches");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getTotalNumPatches could not be located in the library!!!");
  }

  *(void **)(&getNumPatches) = dlsym(libHandle, "getNumPatches");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getNumPatches could not be located in the library!!!");
  }

  *(void **)(&getNumLevels) = dlsym(libHandle, "getNumLevels");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getNumLevels could not be located in the library!!!");
  }             

  *(void **)(&getPatchIndex) = dlsym(libHandle, "getPatchIndex");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getPatchIndex could not be located in the library!!!");
  }     

  *(void **)(&getPatchInfo) = dlsym(libHandle, "getPatchInfo");
  if((error = dlerror()) != NULL) {
    EXCEPTION1(InvalidDBTypeException, "The function getPatchInfo could not be located in the library!!!");
  }                                                                                                                                                                         

  // Check to see if the file could be opened should be here
  // fileOpened should be set if the file could be opened
  fileOpened = true;

  // No. of timesteps
  // timeSteps = *((*getTimeSteps)(folder));
  timeStepInfo = ((*getTimeSteps)(folder));

  currLevel = -1;
  currVar.assign("any_var");
  currMesh.assign("any_mesh");
  // callDomainNesting = false;
  // patchInfoReq = true;
  // levelInfoReq = true;
  
  currTimeStep = -1;
  lastTimeStep = -1;
  
  ccMesh = false;
  ncMesh = false;
  sfcxMesh = false;
  sfcyMesh = false;
  sfczMesh = false;

  cout << "Out avtudaReaderFileFormat\n";
}


// Destructor
avtudaReaderMTMDFileFormat::~avtudaReaderMTMDFileFormat()
{
  cout << "In destructor\n";

  dlclose(libHandle);

  if (levelPatchVecPtr !=  NULL) // just a pre-cautionary measure
    delete levelPatchVecPtr;

  if (patchInfoVecPtr !=  NULL) // just a pre-cautionary measure
    delete patchInfoVecPtr;     
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

  int
avtudaReaderMTMDFileFormat::GetNTimesteps(void)
{
  // return timeSteps;
  return timeStepInfo->size();
}


// ****************************************************************************
// Method: avtudaReaderMTMDFileForma::GetTime
//
// Purpose: 
//   Get the time.
//
// Programmer: sshankar 
// Creation:   Fri Feb 6 15:31 MST 2009 
//
// ****************************************************************************

double 
avtudaReaderMTMDFileFormat::GetTime(int ts)
{
    return (*timeStepInfo)[ts];
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

  void
avtudaReaderMTMDFileFormat::FreeUpResources(void)
{
  cout << "In Free up resources\n";
  currLevel = -1;
  currVar.assign("any_var");
  currMesh.assign("any_mesh");

  // ccMesh = false;
  // ncMesh = false;
  // sfcxMesh = false;
  // sfcyMesh = false;
  // sfczMesh = false;

  // callDomainNesting = false;

  // levelPatchVecPtr = NULL;
  // patchInfoVecPtr = NULL;

  // if (levelPatchVecPtr !=  NULL) // just a pre-cautionary measure
  // delete levelPatchVecPtr;

  // if (patchInfoVecPtr !=  NULL) // just a pre-cautionary measure
  // delete patchInfoVecPtr;    
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::ActivateTimestep
//
//  Purpose:
//      Tells the reader it can now do some initialization work.
//  
//  Programmer: sshankar
//  Creation:   Aug 4, 2008
//
// ****************************************************************************

#if 0
  void
avtudaReaderMTMDFileFormat::ActivateTimestep(int ts)
{
  // cout << "\n\nActivating timestep: " << ts << "\n\n";
  if (callDomainNesting) {
    cout << "Making the much required call to getPatchInfo\n";
    patchInfoVecPtr = (*getPatchInfo)(folder, ts, currMesh, true); // remove_boundary: true or false
    levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
    int numLevels = levelPatchVecObj.size();

    // if there is just a single level, there is no need to call this function
    if (numLevels > 1) {
      cout << "CalculateDomainNesting() called\n";
      CalculateDomainNesting(ts);
    }

    callDomainNesting = false;
  }
}
#endif

// ****************************************************************************
//  Method:  avtudaReaderMTMDFileFormat::RegisterVariableList
//
//  Purpose:
//    Records the active variable name so per-variable ghosting can be applied
//    during GetMesh calls.
//
//  Programmer:  Mark C. Miller 
//  Creation:    December 9, 2003 
//
// ****************************************************************************

#if 0
  void
avtudaReaderMTMDFileFormat::RegisterVariableList(const char *prim_var_name,
    const std::vector<CharStrRef> &)
{
  cout << "\n\n\nActive variable: " << string(prim_var_name) << "\n\n\n";

  if ((currMesh.compare(prim_var_name) != 0) 
      && (string(prim_var_name).find("mesh_particle") == string::npos)) { // no domain nesting for particles
    callDomainNesting = true;
    currMesh.assign(prim_var_name);
  }
}
#endif


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

  void
avtudaReaderMTMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  //
  // CODE TO ADD A MESH
  //
  cout << "\nIn PopulateDatabaseMetaData\n";

  // Prevent VisIt from sorting the variables.
  // md->SetMustAlphabetizeVariables(false);

  // currTimeStep = timeState;

  // if (levelPatchVecPtr !=  NULL) // just a pre-cautionary measure
  // delete levelPatchVecPtr;

  // if (patchInfoVecPtr !=  NULL) // just a pre-cautionary measure
  // delete patchInfoVecPtr;    
  
  lastTimeStep = currTimeStep;
  currTimeStep = timeState;

  levelPatchVecPtr = (*getTotalNumPatches)(folder, timeState);
  levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;

  int numLevels = levelPatchVecObj.size();
  int totalPatches = 0;

  for (int i = 0; i < numLevels; i++) {
    totalPatches +=  levelPatchVecObj[i].noPatches;
  }  

  cout << "Levels: " << numLevels << " Patches: " << totalPatches << endl;

  vector<int> groupIds(totalPatches);
  vector<string> pieceNames(totalPatches);

  for (int i = 0; i < totalPatches; i++) {
    char tmpName[64];
    int level, local_patch;

    GetLevelAndLocalPatchNumber(i, timeState, level, local_patch);
    sprintf(tmpName,"level%d, patch%d", level, local_patch);

    groupIds[i] = level;
    pieceNames[i] = tmpName;
  }

  int nblocks = 1;  
  int block_origin = 0;
  int spatial_dimension = 3;
  int topological_dimension;

  avtMeshType mt;
  avtCentering cent;

  double* minMaxArr = (*getBBox)(folder, timeState, 0); // level 0

  double extents[6];

  extents[0] = minMaxArr[0];
  extents[1] = minMaxArr[3];
  extents[2] = minMaxArr[1];
  extents[3] = minMaxArr[4];
  extents[4] = minMaxArr[2];
  extents[5] = minMaxArr[5];

  udaVars* udaVarsPtr = (*getVarList)(folder);
  udaVars& udaVarsObj = *(udaVarsPtr);

  cout << "Variables: " << udaVarsObj.size() << endl;

  for (int i = 0; i < udaVarsObj.size(); i++) {
    if (udaVarsObj[i].find("p.") == string::npos) {
      char tmpArray[128];
      string varname = udaVarsObj[i];
      size_t found = varname.find("/");

      string vartype = varname.substr(found + 1);
      varname = varname.substr(0, found);

      string mesh_for_this_var;

      if (vartype.find("NC") != string::npos) {
	cent = AVT_NODECENT;
	mesh_for_this_var.assign("NC_Mesh"); 
      }  
      else if (vartype.find("CC") != string::npos) {  
	cent = AVT_ZONECENT;
	mesh_for_this_var.assign("CC_Mesh"); 
      }
      else if (vartype.find("SFC") != string::npos) { 
	cent = AVT_ZONECENT;

	if (vartype.find("SFCX") != string::npos)		
	  mesh_for_this_var.assign("SFCX_Mesh");
	else if (vartype.find("SFCY") != string::npos)		
	  mesh_for_this_var.assign("SFCY_Mesh");
	else if (vartype.find("SFCZ") != string::npos)		
	  mesh_for_this_var.assign("SFCZ_Mesh");
      }  

      // mesh_for_this_var.append("mesh_");
      // mesh_for_this_var.append(newVarname);

      // cout << newVarname << " " << mesh_for_this_var << endl;

      bool addMeshToMetadata = false;

      if  ((vartype.find("NC") != string::npos) && ncMesh == false) {
        ncMesh = true;
	addMeshToMetadata = true;
      }	
      else if ((vartype.find("CC") != string::npos) && ccMesh == false) {
        ccMesh = true;
	addMeshToMetadata = true;
      }
      else if ((vartype.find("SFCX") != string::npos) && sfcxMesh == false) {
        sfcxMesh = true;
	addMeshToMetadata = true;
      }	
      else if ((vartype.find("SFCY") != string::npos) && sfcyMesh == false) {
        sfcyMesh = true;
	addMeshToMetadata = true;
      }	
      else if ((vartype.find("SFCZ") != string::npos) && sfczMesh == false) {
        sfczMesh = true;
        addMeshToMetadata = true;	   
      }	   

      if (addMeshToMetadata) {
        strcpy(tmpArray, mesh_for_this_var.c_str());
        avtMeshMetaData *mesh = new avtMeshMetaData;

        mesh->name = tmpArray;
        mesh->meshType = AVT_AMR_MESH;
        mesh->topologicalDimension = 3;
        mesh->spatialDimension = 3;

        mesh->numBlocks = totalPatches;
        mesh->blockTitle = "patches";
        mesh->blockPieceName = "patch";
        mesh->numGroups = numLevels;
        mesh->groupTitle = "levels";
        mesh->groupPieceName = "level";
        mesh->blockNames = pieceNames;

        mesh->hasSpatialExtents = true; 
        mesh->minSpatialExtents[0] = minMaxArr[0];
        mesh->maxSpatialExtents[0] = minMaxArr[3];
        mesh->minSpatialExtents[1] = minMaxArr[1];
        mesh->maxSpatialExtents[1] = minMaxArr[4];
        mesh->minSpatialExtents[2] = minMaxArr[2];
        mesh->maxSpatialExtents[2] = minMaxArr[5];

        md->Add(mesh); 
      }

      varMatls* varMatlsPtr = (*getMaterials)(folder, varname, timeState);
      varMatls& varMatlsObj = *(varMatlsPtr); 

      if (varMatlsObj.size() == 0)
	cout << varname << " has no materials\n";

      // cout << "Querying variable " << varname << " with " << varMatlsObj.size() << " materials" << endl;

      for (int j = 0; j < varMatlsObj.size(); j++) {
	char buffer[128];
	string newVarname = varname;
	sprintf(buffer, "%d", varMatlsObj[j]);
	newVarname.append("/");
	newVarname.append(buffer);

	// string mesh_for_this_var;

	// mt = AVT_AMR_MESH;
	// topological_dimension = 3;

	/*if (vartype.find("NC") != string::npos) {
	  cent = AVT_NODECENT;
	  mesh_for_this_var.assign("NC"); 
	}  
	else if (vartype.find("CC") != string::npos) {  
	  cent = AVT_ZONECENT;
	  mesh_for_this_var.assign("CC"); 
	}
	else if (vartype.find("SFC") != string::npos) { 
	  cent = AVT_ZONECENT;

	  if (vartype.find("SFCX") != string::npos)             
	    mesh_for_this_var.assign("SFCX");
	  else if (vartype.find("SFCY") != string::npos)                
	    mesh_for_this_var.assign("SFCY");
	  else if (vartype.find("SFCZ") != string::npos)                
	    mesh_for_this_var.assign("SFCZ");
	}  

	mesh_for_this_var.append("mesh_");
	mesh_for_this_var.append(newVarname);*/

	// cout << newVarname << " " << mesh_for_this_var << endl;

	/*AddMeshToMetaData(md, mesh_for_this_var, mt, extents, totalPatches, 1,
	  3, topological_dimension);*/

	// strcpy(buffer, mesh_for_this_var.c_str());

	/*avtMeshMetaData *mesh = new avtMeshMetaData;

	mesh->name = buffer;
	mesh->meshType = AVT_AMR_MESH;
	mesh->topologicalDimension = 3;
	mesh->spatialDimension = 3;
	mesh->blockOrigin = 0;

	mesh->numBlocks = totalPatches;
	mesh->blockTitle = "patches";
	mesh->blockPieceName = "patch";
	mesh->numGroups = numLevels;
	mesh->groupTitle = "levels";
	mesh->groupPieceName = "level";

	mesh->hasSpatialExtents = true; 
	mesh->minSpatialExtents[0] = minMaxArr[0];
	mesh->maxSpatialExtents[0] = minMaxArr[3];
	mesh->minSpatialExtents[1] = minMaxArr[1];
	mesh->maxSpatialExtents[1] = minMaxArr[4];
	mesh->minSpatialExtents[2] = minMaxArr[2];
	mesh->maxSpatialExtents[2] = minMaxArr[5];

	mesh->blockNames = pieceNames;

	md->Add(mesh); */

	if (vartype.find("Vector") != string::npos) 
	  AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
	else if (vartype.find("Matrix3") != string::npos)
	  AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
	else  
	  AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
      }
    }   
  }
  
  ccMesh = false;
  ncMesh = false;
  sfcxMesh = false;
  sfcyMesh = false;
  sfczMesh = false;

  md->AddGroupInformation(numLevels, totalPatches, groupIds);
  md->AddDefaultSILRestrictionDescription(std::string("!TurnOnAll"));

  // Nothing needs to be modifed for particle data, as they exist only on a single level
  for (int i = 0; i < udaVarsObj.size(); i++) {
    if (udaVarsObj[i].find("p.") != string::npos && udaVarsObj[i].find("p.x") == string::npos) {
      string varname = udaVarsObj[i];
      size_t found = varname.find("/");

      string vartype = varname.substr(found + 1);
      varname = varname.substr(0, found);

      varMatls* varMatlsPtr = (*getMaterials)(folder, varname, timeState);
      varMatls& varMatlsObj = *(varMatlsPtr);

      cout << "Querying variable " << varname << " with " << varMatlsObj.size() << " materials" << endl;

      bool addStar = false;
      int count =  varMatlsObj.size() + 1;
      for (int j = 0; j < count; j++) {
	char buffer[128];
	string newVarname = varname;
	if (j > 0)
	  sprintf(buffer, "%d", varMatlsObj[j-1]);
	newVarname.append("/");

	if (j == 0 && addStar == false) {
	  newVarname.append("*");
	  // j--;
	  addStar = true;
	}    
	else
	  newVarname.append(buffer);

	string mesh_for_this_var = string("mesh_particle_");
	mesh_for_this_var.append(newVarname);

	cout << newVarname << " " << mesh_for_this_var << endl;

	mt = AVT_POINT_MESH;
	topological_dimension = 0;
	AddMeshToMetaData(md, mesh_for_this_var, mt, extents, nblocks, block_origin,
	    spatial_dimension, topological_dimension);

	cent = AVT_NODECENT;

	if (vartype.find("Vector") != string::npos) 
	  AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
	else if (vartype.find("Matrix3") != string::npos)
	  AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
	else  
	  AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
      }
    }   
  }

  cout << "Out PopulateDatabaseMetaData\n";
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetLevelAndLocalPatchNumber
//
//  Purpose:
//      Translates the global patch identifier to a refinement level and patch
//      number local to that refinement level.
//  
//  Programmer: sshankar, taken from implementation of the plugin, CHOMBO
//  Creation:   May 20, 2008
//
// ****************************************************************************

  void
avtudaReaderMTMDFileFormat::GetLevelAndLocalPatchNumber(int global_patch, int timestate, 
    int &level, int &local_patch)
{
  levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
  int num_levels = levelPatchVecObj.size();
  // cout << "In GetLevelAndLocalPatchNumber, num_levels = " << num_levels << endl; 
  int num_patches = 0;
  int tmp = global_patch;
  level = 0;
  while (1 && level < num_levels)
  {
    num_patches = levelPatchVecObj[level].noPatches;
    if (tmp < num_patches)
    {
      break;
    }
    tmp -= num_patches;
    level++;
  }
  local_patch = tmp;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::CalculateDomainNesting
//
//  Purpose:
//      Calculates two important data structures.  One is the structure domain
//      nesting, which tells VisIt how the AMR patches are nested, which allows
//      VisIt to ghost out coarse zones that are refined by smaller zones.
//      The other structure is the rectilinear domain boundaries, which tells
//      VisIt which patches are next to each other, allowing VisIt to create
//      a layer of ghost zones around each patch.  Note that this only works
//      within a refinement level, not across refinement levels.
//  
//  Programmer: Hank Childs / Modified for re-use by sshankar
//  Creation:   January 22, 2006
//
// ****************************************************************************

  void
avtudaReaderMTMDFileFormat::CalculateDomainNesting(int timestate)
{
  levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
  int num_levels = levelPatchVecObj.size();

  // Call to store all patch information
  // Patch Info Vector
  // patchInfoVecPtr should be made global for use in GetMesh
  // patchInfoVec* patchInfoVecPtr = (*getPatchInfo)(folder, timestate);
  patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr);   

  //
  // Calculate some info we will need in the rest of the routine.
  //
  int totalPatches = 0;
  vector<int> levelStart;
  vector<int> levelEnd;
  for (int level = 0 ; level < num_levels ; level++) {
    levelStart.push_back(totalPatches);
    totalPatches += levelPatchVecObj[level].noPatches;
    levelEnd.push_back(totalPatches);
  }

  //
  // Now that we know the total number of patches, we can allocate the
  // data structure for the patch nesting.
  // 
  avtStructuredDomainNesting *dn = new avtStructuredDomainNesting(
      totalPatches, num_levels);

  //
  // Calculate what the refinement ratio is from one level to the next.
  //

  // vector<int> dim(3); 
  // vector<vector<int>> rr(3, dim);

  vector<int> rr(3); 
  for (int level = 0 ; level < num_levels ; level++) {
    int* refinement_ratio = levelPatchVecObj[level].rr;
    for (int j = 0 ; j < 3 ; j++) {
      rr[j] = refinement_ratio[j];
    }
    dn->SetLevelRefinementRatios(level, rr);
  }

  //
  // This multiplier will be needed to find out if patches are nested.
  //

  vector<int> dim(3); 
  vector< vector<int> > multiplier(num_levels, dim);
  multiplier[num_levels-1][0] = 1;
  multiplier[num_levels-1][1] = 1;
  multiplier[num_levels-1][2] = 1;
  for (int level = num_levels-2 ; level >= 0 ; level--) {
    int* refinement_ratio = levelPatchVecObj[level+1].rr;
    for (int i = 0; i < 3; i++) {
      multiplier[level][i] = multiplier[level+1][i] * refinement_ratio[i];
      cout << multiplier[level][i] << " ";
    }
    cout << endl;       
  }

  //
  // Now set up the data structure for patch boundaries.  The data 
  // does all the work ... it just needs to know the extents of each patch.
  //
  avtRectilinearDomainBoundaries *rdb 
    = new avtRectilinearDomainBoundaries(true);
  rdb->SetNumDomains(totalPatches);
  for (int patch = 0 ; patch < totalPatches ; patch++) {
    int my_level, local_patch;
    GetLevelAndLocalPatchNumber(patch, timestate, my_level, local_patch);

    // int* indexArr = (*getPatchLoIndex)(folder, timestate, my_level, local_patch); // this should be stored somewhere

    int e[6];
    e[0] = patchInfoVecObj[patch].indexArr[0];
    e[1] = patchInfoVecObj[patch].indexArr[3];
    e[2] = patchInfoVecObj[patch].indexArr[1];
    e[3] = patchInfoVecObj[patch].indexArr[4];
    e[4] = patchInfoVecObj[patch].indexArr[2];
    e[5] = patchInfoVecObj[patch].indexArr[5];

    rdb->SetIndicesForAMRPatch(patch, my_level, e);
  }
  rdb->CalculateBoundaries();
  void_ref_ptr vrdb = void_ref_ptr(rdb,
      avtStructuredDomainBoundaries::Destruct);
  cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION,
      timestate, -1, vrdb);

  //
  // Calculating the child patches really needs some better sorting than
  // what I am doing here.  This is likely to become a bottleneck in extreme
  // cases.  Although this routine has performed well for a previous 55K
  // patch run.
  //
  vector< vector<int> > childPatches(totalPatches);
  for (int level = num_levels-1 ; level > 0 ; level--) {
    int prev_level = level-1;
    int search_start  = levelStart[prev_level];
    int search_end    = levelEnd[prev_level];
    vector<int> mC = multiplier[prev_level];
    int patches_start = levelStart[level];
    int patches_end   = levelEnd[level];
    vector<int> mP = multiplier[level];
    for (int patch = patches_start ; patch < patches_end ; patch++) {
      for (int candidate = search_start ; candidate < search_end ; candidate++) {                       
	if (patchInfoVecObj[patch].indexArr[3]*mP[0] <  patchInfoVecObj[candidate].indexArr[0]*mC[0])
	  continue;
	if (patchInfoVecObj[patch].indexArr[0]*mP[0] >= patchInfoVecObj[candidate].indexArr[3]*mC[0])
	  continue;
	if (patchInfoVecObj[patch].indexArr[4]*mP[1] <  patchInfoVecObj[candidate].indexArr[1]*mC[1])
	  continue;
	if (patchInfoVecObj[patch].indexArr[1]*mP[1] >= patchInfoVecObj[candidate].indexArr[4]*mC[1])
	  continue;
	if (patchInfoVecObj[patch].indexArr[5]*mP[2] <  patchInfoVecObj[candidate].indexArr[2]*mC[2])
	  continue;
	if (patchInfoVecObj[patch].indexArr[2]*mP[2] >= patchInfoVecObj[candidate].indexArr[5]*mC[2])
	  continue;

	childPatches[candidate].push_back(patch);
      }
    }
  }

  //
  // Now that we know the extents for each patch and what its children are,
  // tell the structured domain boundary that information.
  //
  for (int i = 0 ; i < totalPatches ; i++) {
    int my_level, local_patch;
    GetLevelAndLocalPatchNumber(i, timestate, my_level, local_patch);

    // int* indexArr = (*getPatchLoIndex)(folder, timestate, my_level, local_patch); // this should be stored somewhere

    vector<int> logExts(6);

    logExts[0] = patchInfoVecObj[i].indexArr[0];
    logExts[3] = patchInfoVecObj[i].indexArr[3] - 1;
    logExts[1] = patchInfoVecObj[i].indexArr[1];
    logExts[4] = patchInfoVecObj[i].indexArr[4] - 1;
    logExts[2] = patchInfoVecObj[i].indexArr[2]; 
    logExts[5] = patchInfoVecObj[i].indexArr[5] - 1;

    if (childPatches[i].size() > 0) {
      cout << "Parent: " << i << " Child patches: ";
      for (int j = 0; j < childPatches[i].size(); j++) {
	cout << childPatches[i][j] << " ";
      }
      cout << endl;
    }   

    dn->SetNestingForDomain(i, my_level, childPatches[i], logExts);
  }

  //
  // Register this structure with the generic database so that it knows
  // to ghost out the right cells.
  //
  dn->SetNumDimensions(3);
  void_ref_ptr vr = void_ref_ptr(dn, avtStructuredDomainNesting::Destruct);
  cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
      timestate, -1, vr);
}


// ***************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

  vtkDataSet *
avtudaReaderMTMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
  if (currTimeStep != timestate) {
    levelPatchVecPtr = (*getTotalNumPatches)(folder, timestate);
    currTimeStep = timestate; 
  }

  string meshName(meshname);

  if (meshName.find("mesh_particle") == string::npos) { // volume data
    cout << "\nIn GetMesh, timestate: " << timestate << "\n";

    cout << "domain: " << domain << endl;

    cout << meshName << " ";

    size_t found1 = meshName.find("_");
    size_t found2 = meshName.find("/");

    string varName = meshName.substr(found1 + 1, found2 - (found1 + 1));
    string matlNo = meshName.substr(found2 + 1);

    cout << varName << endl;
    cout << matlNo << endl;

    if (currMesh.compare(varName) != 0) {
      cout << "Making the much required call to getPatchInfo\n";
      patchInfoVecPtr = (*getPatchInfo)(folder, timestate, meshname, true);
      levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
      int numLevels = levelPatchVecObj.size();

      // if there is just a single level, there is no need to call this function
      if (numLevels > 1) {
	cout << "CalculateDomainNesting() called\n";
	CalculateDomainNesting(timestate);
      }

      currMesh.assign(varName);
    }    

    patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr); 

    // int level, local_patch;

    // GetLevelAndLocalPatchNumber(domain, timestate, level, local_patch);
    // double* minMaxArr = (*getPatchBBox)(folder, timestate, level, local_patch);

    double* minMaxArr = patchInfoVecObj[domain].minMaxArr;
    int* indexArr = patchInfoVecObj[domain].indexArr;

    // cout << level << " " << local_patch << endl; 

    // char buffer[128];
    // sprintf(buffer, "%d", level);

    /*strcpy(arr2d[0], "uda2nrrd"); // anything will do
      strcpy(arr2d[1], "-uda");
      strcpy(arr2d[2], folder.c_str());
      strcpy(arr2d[3], "-v");
      strcpy(arr2d[4], varName.c_str());
      strcpy(arr2d[5], "-m");
      strcpy(arr2d[6], matlNo.c_str());
      strcpy(arr2d[7], "-l");
      strcpy(arr2d[8], buffer);
      strcpy(arr2d[9], "-o");
      strcpy(arr2d[10], "test"); // anything will do*/

    // timeStep *timeStepObjPtr = (*processData)(11, arr2d, timestate, false, 0, false, local_patch);
    // timeStep &timeStepObj = *timeStepObjPtr;

    // cellVals& cellValColln = *(timeStepObj.cellValColln);

    int cellValColln_x = indexArr[3] - indexArr[0];
    int cellValColln_y = indexArr[4] - indexArr[1];
    int cellValColln_z = indexArr[5] - indexArr[2];

    cout << cellValColln_x << " " << cellValColln_y << " " << cellValColln_z << endl;

    // cout << cellValColln_x << " " << cellValColln_y << " " << cellValColln_z << endl;
    /*for (int i = 0; i < 6; i++)
      cout << minMaxArr[i] <<  endl;*/

    int ndims = 3; 
    int dims[3] = {cellValColln_x + 1, cellValColln_y + 1, cellValColln_z + 1}; // for node centered -> remove +1
    vtkFloatArray *coords[3] = {0,0,0};

    double dx, dy, dz;
    dx = (minMaxArr[3] - minMaxArr[0]) / cellValColln_x; // for node centered -> -1
    dy = (minMaxArr[4] - minMaxArr[1]) / cellValColln_y;
    dz = (minMaxArr[5] - minMaxArr[2]) / cellValColln_z;

    double dtdx, dtdy, dtdz;
    dtdx = dtdy = dtdz = 0.;

    if (meshName.find("NC") != string::npos) {
      cout << "NC Mesh\n";
      dims[0] = cellValColln_x;
      dims[1] = cellValColln_y;
      dims[2] = cellValColln_z;

      dx = (minMaxArr[3] - minMaxArr[0]) / (cellValColln_x - 1);
      dy = (minMaxArr[4] - minMaxArr[1]) / (cellValColln_y - 1);
      dz = (minMaxArr[5] - minMaxArr[2]) / (cellValColln_z - 1);
    }  
    else if (meshName.find("SFC") != string::npos) {
      cout << "SFC Mesh\n";
      dims[0] = cellValColln_x + 1;
      dims[1] = cellValColln_y + 1;
      dims[2] = cellValColln_z + 1;

      dx = (minMaxArr[3] - minMaxArr[0]) / cellValColln_x;
      dy = (minMaxArr[4] - minMaxArr[1]) / cellValColln_y;
      dz = (minMaxArr[5] - minMaxArr[2]) / cellValColln_z;

      if (meshName.find("SFCX") != string::npos) {
	cout << "SFCX\n";
	dims[0] = dims[0] - 1;
	dx = (minMaxArr[3] - minMaxArr[0]) / (cellValColln_x - 1);
	// dtdy = dy / 2.;
	// dtdz = dz / 2.;
      }
      else if (meshName.find("SFCY") != string::npos) {
	cout << "SFCY\n";
	dims[1] = dims[1] - 1;
	dy = (minMaxArr[4] - minMaxArr[1]) / (cellValColln_y - 1);
	// dtdx = dx / 2.;
	// dtdz = dz / 2.;
      }
      else if (meshName.find("SFCZ") != string::npos) {
	cout << "SFCZ\n";
	dims[2] = dims[2] - 1;
	dz = (minMaxArr[5] - minMaxArr[2]) / (cellValColln_z - 1);
	// dtdx = dx / 2.;
	// dtdy = dy / 2.;
      }                 
    }

    // Read the X coordinates from the file. 
    coords[0] = vtkFloatArray::New(); 
    coords[0]->SetNumberOfTuples(dims[0]); 
    float *xarray = (float *)coords[0]->GetVoidPointer(0); 
    for (int i = 0; i < dims[0]; i++) {
      xarray[i] =  (minMaxArr[0] + dtdx) + i * dx;
    }

    // Read the Y coordinates from the file. 
    coords[1] = vtkFloatArray::New(); 
    coords[1]->SetNumberOfTuples(dims[1]); 
    float *yarray = (float *)coords[1]->GetVoidPointer(0); 
    for (int i = 0; i < dims[1]; i++) {
      yarray[i] =  (minMaxArr[1] + dtdy) + i * dy;
    }

    // Read the Z coordinates from the file. 
    coords[2] = vtkFloatArray::New(); 
    coords[2]->SetNumberOfTuples(dims[2]); 
    float *zarray = (float *)coords[2]->GetVoidPointer(0); 
    for (int i = 0; i < dims[2]; i++) {
      zarray[i] =  (minMaxArr[2] + dtdz) + i * dz;
    }

    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New(); 
    rgrid->SetDimensions(dims); 
    rgrid->SetXCoordinates(coords[0]); 
    coords[0]->Delete(); 
    rgrid->SetYCoordinates(coords[1]); 
    coords[1]->Delete();
    rgrid->SetZCoordinates(coords[2]); 
    coords[2]->Delete(); 

    //
    // Determine the indices of the mesh within its group.  Add that to the
    // VTK dataset as field data.
    //

    // int* indexArr = (*getPatchIndex)(folder, timestate, level, local_patch, meshName); // Add variable/ meshname

    vtkIntArray *arr = vtkIntArray::New();
    arr->SetNumberOfTuples(3);
    arr->SetValue(0, indexArr[0]);
    arr->SetValue(1, indexArr[1]);
    arr->SetValue(2, indexArr[2]);
    arr->SetName("base_index");
    rgrid->GetFieldData()->AddArray(arr);
    arr->Delete();

    // delete minMaxArr;
    // delete timeStepObjPtr;
    // delete indexArr;

    cout << "Out GetMesh\n";

    return rgrid;
  }
  else if (meshName.find("mesh_particle") != string::npos) { // particle data
    cout << "\nIn GetMesh\n";
    cout << meshName << endl;

    size_t found = meshName.find("/");
    string matl = meshName.substr(found + 1);

    int matlNo = 0;

    if (matl.compare("*") != 0)
      matlNo = atoi(matl.c_str());

    cout << matlNo << endl;

    strcpy(arr2d[0], "uda2nrrd"); // anything will do
    strcpy(arr2d[1], "-uda");
    strcpy(arr2d[2], folder.c_str());
    strcpy(arr2d[3], "-p");
    strcpy(arr2d[4], "-o");
    strcpy(arr2d[5], "test"); // anything will do

    timeStep *timeStepObjPtr;

    // not removing the boundary with particle data
    if (matl.compare("*") == 0) {
      timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false, 0); 
      cout << "All data\n";
    }
    else {
      timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true, 0);
      cout << "Some data\n";
    }  

    timeStep &timeStepObj = *timeStepObjPtr;

    variables& varCollnRef = *(timeStepObj.varColln);

    unsigned int i, ndims, nnodes, count = 0;

    ndims = 3;

    if ((varCollnRef.size() % PARTICLE_INTERVAL) != 0) 
      nnodes = (varCollnRef.size() / PARTICLE_INTERVAL) + 1;
    else
      nnodes = varCollnRef.size() / PARTICLE_INTERVAL;

    cout << nnodes << endl;

    float *xarray = new float[nnodes];
    float *yarray = new float[nnodes]; 
    float *zarray = new float[nnodes];

    float *xc = xarray; 
    float *yc = yarray; 
    float *zc = zarray; 

    for (i = 0; i < nnodes; ++i) {
      variable& varRef = varCollnRef[i * PARTICLE_INTERVAL];
      *xc++ = varRef.x;
      *yc++ = varRef.y;
      *zc++ = varRef.z;
      // cout << varRef.x << " " << varRef.y << " " << varRef.z << endl;
    }

    // 
    // Create the vtkPoints object and copy points into it. 
    // 

    vtkPoints *points = vtkPoints::New(); 
    points->SetNumberOfPoints(nnodes); 
    float *pts = (float *) points->GetVoidPointer(0); 

    xc = xarray; 
    yc = yarray; 
    zc = zarray; 

    if(ndims == 3) 
    { 
      for(i = 0; i < nnodes; ++i) 
      { 
	*pts++ = *xc++; 
	*pts++ = *yc++; 
	*pts++ = *zc++;
      }
    } 
    else if(ndims == 2) 
    { 
      for(i = 0; i < nnodes; ++i) 
      { 
	*pts++ = *xc++; 
	*pts++ = *yc++; 
	*pts++ = 0.; 
      } 
    } 

    // 
    // Create a vtkUnstructuredGrid to contain the point cells. 
    // 

    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
    ugrid->SetPoints(points); 
    points->Delete(); 
    ugrid->Allocate(nnodes); 
    vtkIdType onevertex; 

    for(int i = 0; i < nnodes; ++i) 
    { 
      onevertex = i; 
      ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex); 
    } 

    // Delete temporary arrays. 
    delete [] xarray; 
    delete [] yarray; 
    delete [] zarray;

    delete timeStepObjPtr;

    cout << "Out GetMesh\n";

    return ugrid;
  }
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

  vtkDataArray *
avtudaReaderMTMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
  //
  // If you have a file format where variables don't apply (for example a
  // strictly polygonal format like the STL (Stereo Lithography) format,
  // then uncomment the code below.
  //
  // EXCEPTION1(InvalidVariableException, varname);
  //

  cout << "\nIn GetVar, timestate: " << timestate << "\n";
  
  if (currTimeStep != timestate) {
    levelPatchVecPtr = (*getTotalNumPatches)(folder, timestate);
    currTimeStep = timestate; 
  }

  string varName(varname);

  vtkFloatArray *rv = vtkFloatArray::New();

  if (varName.find("p.") == string::npos) { // volume data
    size_t found = varName.find("/");
    string tmpVarName = varName;

    string matlNo = varName.substr(found + 1);
    varName = varName.substr(0, found);

    cout << varName << endl;
    cout << matlNo << endl;

    int level, local_patch;

    GetLevelAndLocalPatchNumber(domain, timestate, level, local_patch);
    // double* minMaxArr = (*getPatchBBox)(folder, timestate, level, local_patch);

    unsigned int count = 0;

    if ((currLevel != level) || (currVar.find(tmpVarName) == string::npos)) {
      /*if (currVar.find(tmpVarName) == string::npos) {
	levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
	int numLevels = levelPatchVecObj.size();

      // if there is just a single level, there is no need to call this function
      if (numLevels > 1) {
      cout << "CalculateDomainNesting() called\n";
      CalculateDomainNesting(timestate);
      }
      }*/

      cout << "Making the much required call to collect information at level " << level << "\n";
      currLevel = level;
      currVar.assign(tmpVarName);

      char buffer[128];
      sprintf(buffer, "%d", level);

      strcpy(arr2d[0], "uda2nrrd"); // anything will do
      strcpy(arr2d[1], "-uda");
      strcpy(arr2d[2], folder.c_str());
      strcpy(arr2d[3], "-v");
      strcpy(arr2d[4], varName.c_str());
      strcpy(arr2d[5], "-m");
      strcpy(arr2d[6], matlNo.c_str());
      strcpy(arr2d[7], "-l");
      strcpy(arr2d[8], buffer); 
      strcpy(arr2d[9], "-o");
      strcpy(arr2d[10], "test"); // anything will do
      strcpy(arr2d[11], "-nbc"); // boundary cells not required

      timeStep* timeStepObjPtr = (*processData)(12, arr2d, timestate, true, 0, false, local_patch);
      timeStep &timeStepObj = *timeStepObjPtr;

      cellVals& cellValColln = *(timeStepObj.cellValColln);
      typeDouble& cellValVec = *(cellValColln.cellValVec);

      cout << cellValColln.x << " " << cellValColln.y << " " << cellValColln.z << endl;

      // if (refMatrix != NULL)
      // delete [] refMatrix;

      // Allocating Matrix
      refMatrix = (double***)malloc(cellValColln.x * sizeof(double**));
      if (refMatrix == NULL) cout << "Error allocating refMatrix\n";
      for(int i = 0; i < cellValColln.x; i++) {
	refMatrix[i] = (double**)malloc(cellValColln.y * sizeof(double*));
	if (refMatrix[i] == NULL) cout << "Error allocating refMatrix[" << i << "]\n";
	for(int j = 0; j < cellValColln.y; j++) {
	  refMatrix[i][j] = (double*)malloc(cellValColln.z * sizeof(double));
	  if (refMatrix[i][j] == NULL) cout << "Error allocating refMatrix[" << i << "][" << j << "]\n";
	}
      }

      // Reference matrix
      for (int i = 0; i < cellValColln.z; i++) {
	for (int j = 0; j < cellValColln.y; j++) {
	  for (int k = 0; k < cellValColln.x; k++) {    
	    refMatrix[k][j][i] = cellValVec[count];
	    count++;  
	  }
	}
      }

      // Cleaning up
      delete timeStepObjPtr;
    }  

    patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr); 
    // int* indexArr = patchInfoVecObj[domain].indexArr;
    int indexArr[6];
    std::memcpy(indexArr, patchInfoVecObj[domain].indexArr, sizeof(int) * 6);
    int cellValColln_x = indexArr[3] - indexArr[0];
    int cellValColln_y = indexArr[4] - indexArr[1];
    int cellValColln_z = indexArr[5] - indexArr[2];

    int* hiLoArr = patchInfoVecObj[domain].hiLoArr;

    indexArr[0] = indexArr[0] - hiLoArr[0]; 
    indexArr[1] = indexArr[1] - hiLoArr[1]; 
    indexArr[2] = indexArr[2] - hiLoArr[2];
    indexArr[3] = indexArr[3] - hiLoArr[0]; 
    indexArr[4] = indexArr[4] - hiLoArr[1]; 
    indexArr[5] = indexArr[5] - hiLoArr[2];

    cout << "[ " << indexArr[0] << " " << indexArr[1] << " " << indexArr[2] << " ] " ;
    cout << "[ " << indexArr[3] << " " << indexArr[4] << " " << indexArr[5] << " ] "  << endl;

    rv->SetNumberOfTuples(cellValColln_x * cellValColln_y * cellValColln_z);
    count = 0;

    for (int i = indexArr[2]; i < indexArr[5]; i++) {
      for (int j = indexArr[1]; j < indexArr[4]; j++) {
	for (int k = indexArr[0]; k < indexArr[3]; k++) {
	  rv->SetTuple1(count++, refMatrix[k][j][i]);
	}
      }
    }

    /*for (unsigned int i = 0; i < cellValVec.size(); ++i) {
      rv->SetTuple1(i, cellValVec[i]);  // you must determine value for ith entry.
      }*/

    // delete timeStepObjPtr;
  }
  else {
    size_t found = varName.find("/");

    string matl = varName.substr(found + 1);
    varName = varName.substr(0, found);

    int matlNo = 0;

    if (matl.compare("*") != 0)
      matlNo = atoi(matl.c_str());

    cout << varName << endl;
    cout << matlNo << endl;

    strcpy(arr2d[0], "uda2nrrd"); // anything will do
    strcpy(arr2d[1], "-uda");
    strcpy(arr2d[2], folder.c_str());
    strcpy(arr2d[3], "-p");
    strcpy(arr2d[4], "-o");
    strcpy(arr2d[5], "test"); // anything will do

    timeStep *timeStepObjPtr;

    if (matl.compare("*") == 0) {
      timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false, 0); 
      cout << "All data\n";
    }  
    else { 
      timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true, 0);
      cout << "Some data\n";
    }  

    timeStep &timeStepObj = *timeStepObjPtr;

    variables& varColln = *(timeStepObj.varColln);

    int ntuples = 0;

    if ((varColln.size() % PARTICLE_INTERVAL) != 0) 
      ntuples = (varColln.size() / PARTICLE_INTERVAL) + 1;
    else
      ntuples = varColln.size() / PARTICLE_INTERVAL;

    cout << ntuples << endl;

    // int ntuples = varColln.size(); // this is the number of entries in the variable.
    rv->SetNumberOfTuples(ntuples);
    for (int i = 0 ; i < ntuples ; i++) {
      variable& varRef = varColln[i * PARTICLE_INTERVAL];
      unknownData& dataRef = varRef.data;

      for (int j = 0;  j < dataRef.size(); j++) {
	if (strcmp(varName.c_str(), dataRef[j].name.c_str()) == 0)
	  rv->SetTuple1(i, dataRef[j].value);  // you must determine value for ith entry.
      }
    }

    delete timeStepObjPtr;
  }

  cout << "Out GetVar\n";

  //
  return rv;
  //
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

  vtkDataArray *
avtudaReaderMTMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
  //
  // If you have a file format where variables don't apply (for example a
  // strictly polygonal format like the STL (Stereo Lithography) format,
  // then uncomment the code below.
  //
  // EXCEPTION1(InvalidVariableException, varname);
  //

  cout << "\nIn GetVectorVar, timestate: " << timestate << "\n";

  string varName(varname);

  vtkFloatArray *rv = vtkFloatArray::New();

  if (varName.find("p.") == string::npos) {
    size_t found = varName.find("/");
    string tmpVarName = varName;

    string matlNo = varName.substr(found + 1);
    varName = varName.substr(0, found);

    cout << varName << endl;
    cout << matlNo << endl;

    int level, local_patch;

    GetLevelAndLocalPatchNumber(domain, timestate, level, local_patch);
    // double* minMaxArr = (*getPatchBBox)(folder, timestate, level, local_patch);

    unsigned int count = 0;

    if ((currLevel != level) || (currVar.find(tmpVarName) == string::npos)) { 
      cout << "Making the much required call to collect information at level " << level << "\n";
      currLevel = level;
      currVar.assign(tmpVarName);

      char buffer[128];
      sprintf(buffer, "%d", level);

      strcpy(arr2d[0], "uda2nrrd"); // anything will do
      strcpy(arr2d[1], "-uda");
      strcpy(arr2d[2], folder.c_str());
      strcpy(arr2d[3], "-v");
      strcpy(arr2d[4], varName.c_str());
      strcpy(arr2d[5], "-m");
      strcpy(arr2d[6], matlNo.c_str());
      strcpy(arr2d[7], "-l");
      strcpy(arr2d[8], buffer);
      strcpy(arr2d[9], "-o"); // this is not required
      strcpy(arr2d[10], "test"); // this is not required
      strcpy(arr2d[11], "-nbc");

      timeStep *timeStepObjPtr = (*processData)(12, arr2d, timestate, true, 0, false, local_patch);
      timeStep &timeStepObj = *timeStepObjPtr;

      cellVals& cellValColln = *(timeStepObj.cellValColln);
      typeDouble& cellValVec = *(cellValColln.cellValVec);
      int dim = cellValColln.dim;

      if (dim == 5) // Tensors
	ncomps = 9;
      else if (dim == 4) // Vectors
	ncomps = 3;
      // else if (dim == 3) // Scalars + Tensors
      // ncomps = 1; // This case would lead to problem as it has not been added to meta data   

      // ntuples = cellValVec.size() / ncomps; // this is the number of entries in the variable.        

      if (ncomps == 3) { // Vectors
	// Allocating Matrix
	vecValMatrix = (vecVal***)malloc(cellValColln.x * sizeof(vecVal**));
	if (vecValMatrix == NULL) cout << "Error allocating vecValMatrix\n";
	for(int i = 0; i < cellValColln.x; i++) {
	  vecValMatrix[i] = (vecVal**)malloc(cellValColln.y * sizeof(vecVal*));
	  if (vecValMatrix[i] == NULL) cout << "Error allocating vecValMatrix[" << i << "]\n";
	  for(int j = 0; j < cellValColln.y; j++) {
	    vecValMatrix[i][j] = (vecVal*)malloc(cellValColln.z * sizeof(vecVal));
	    if (vecValMatrix[i][j] == NULL) cout << "Error allocating vecValMatrix[" << i << "][" << j << "]\n";
	  }
	}

	// Reference matrix
	for (int i = 0; i < cellValColln.z; i++) {
	  for (int j = 0; j < cellValColln.y; j++) {
	    for (int k = 0; k < cellValColln.x; k++) {  
	      vecVal& vecValRef = vecValMatrix[k][j][i];
	      vecValRef.x = cellValVec[count++];
	      vecValRef.y = cellValVec[count++];
	      vecValRef.z = cellValVec[count++];
	    }
	  }
	}
      }
      else if (ncomps == 9) { // Tensors
	// Allocating Matrix
	tenValMatrix = (tenVal***)malloc(cellValColln.x * sizeof(tenVal**));
	if (tenValMatrix == NULL) cout << "Error allocating tenValMatrix\n";
	for(int i = 0; i < cellValColln.x; i++) {
	  tenValMatrix[i] = (tenVal**)malloc(cellValColln.y * sizeof(tenVal*));
	  if (tenValMatrix[i] == NULL) cout << "Error allocating tenValMatrix[" << i << "]\n";
	  for(int j = 0; j < cellValColln.y; j++) {
	    tenValMatrix[i][j] = (tenVal*)malloc(cellValColln.z * sizeof(tenVal));
	    if (tenValMatrix[i][j] == NULL) cout << "Error allocating tenValMatrix[" << i << "][" << j << "]\n";
	  }
	}

	// Reference matrix
	for (int i = 0; i < cellValColln.z; i++) {
	  for (int j = 0; j < cellValColln.y; j++) {
	    for (int k = 0; k < cellValColln.x; k++) {  
	      tenVal& tenValRef = tenValMatrix[k][j][i];
	      // cout << "tenValMatrix[" << k << "][" << j << "][" << i << "]\n";
	      for (int p = 0; p < 3; p++) {
		for (int q = 0; q < 3; q++) {
		  tenValRef.mat[p][q] = cellValVec[count++];
		  if (k == 9 && j == 5 && i == 1) {
		    cout << tenValRef.mat[p][q] << " ";
		  }   
		}
	      }   
	    }
	  }
	}

      }

      // Cleaning up
      delete timeStepObjPtr;
    }  

    patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr); 
    // int* indexArr = patchInfoVecObj[domain].indexArr;
    int indexArr[6];
    std::memcpy(indexArr, patchInfoVecObj[domain].indexArr, sizeof(int) * 6);
    int cellValColln_x = indexArr[3] - indexArr[0];
    int cellValColln_y = indexArr[4] - indexArr[1];
    int cellValColln_z = indexArr[5] - indexArr[2];

    int* hiLoArr = patchInfoVecObj[domain].hiLoArr;

    indexArr[0] = indexArr[0] - hiLoArr[0]; 
    indexArr[1] = indexArr[1] - hiLoArr[1]; 
    indexArr[2] = indexArr[2] - hiLoArr[2];
    indexArr[3] = indexArr[3] - hiLoArr[0]; 
    indexArr[4] = indexArr[4] - hiLoArr[1]; 
    indexArr[5] = indexArr[5] - hiLoArr[2];

    cout << "[ " << indexArr[0] << " " << indexArr[1] << " " << indexArr[2] << " ] " ;
    cout << "[ " << indexArr[3] << " " << indexArr[4] << " " << indexArr[5] << " ] "  << endl;

    rv->SetNumberOfComponents(ncomps);
    rv->SetNumberOfTuples(cellValColln_x * cellValColln_y * cellValColln_z);

    double* one_entry = new double[ncomps];
    count = 0;

    if (ncomps == 3) {
      for (int i = indexArr[2]; i < indexArr[5]; i++) {
	for (int j = indexArr[1]; j < indexArr[4]; j++) {
	  for (int k = indexArr[0]; k < indexArr[3]; k++) {
	    vecVal& vecValRef = vecValMatrix[k][j][i];
	    one_entry[0] = vecValRef.x;
	    one_entry[1] = vecValRef.y;
	    one_entry[2] = vecValRef.z;
	    rv->SetTuple(count++, one_entry);
	  }
	}
      }
    }
    else if (ncomps == 9) {
      for (int i = indexArr[2]; i < indexArr[5]; i++) {
	for (int j = indexArr[1]; j < indexArr[4]; j++) {
	  for (int k = indexArr[0]; k < indexArr[3]; k++) {
	    tenVal& tenValRef = tenValMatrix[k][j][i];
	    one_entry[0] = tenValRef.mat[0][0];
	    one_entry[1] = tenValRef.mat[0][1];
	    one_entry[2] = tenValRef.mat[0][2];
	    one_entry[3] = tenValRef.mat[1][0];
	    one_entry[4] = tenValRef.mat[1][1];
	    one_entry[5] = tenValRef.mat[1][2];
	    one_entry[6] = tenValRef.mat[2][0];
	    one_entry[7] = tenValRef.mat[2][1];
	    one_entry[8] = tenValRef.mat[2][2];
	    rv->SetTuple(count++, one_entry);
	    if (k == 9 && j == 5 && i == 1) {
	      cout << one_entry[0] << " " << one_entry[1] << " " << one_entry[2] << endl;
	      cout << one_entry[3] << " " << one_entry[4] << " " << one_entry[5] << endl;
	      cout << one_entry[6] << " " << one_entry[7] << " " << one_entry[8] << endl;
	    }
	  }
	}
      }
    }

    delete [] one_entry;
  }
  else {
    size_t found = varName.find("/");

    string matl = varName.substr(found + 1);
    varName = varName.substr(0, found);

    int matlNo = 0;

    if (matl.compare("*") != 0)
      matlNo = atoi(matl.c_str());

    cout << varName << endl;
    cout << matlNo << endl;

    strcpy(arr2d[0], "uda2nrrd"); // anything will do
    strcpy(arr2d[1], "-uda");
    strcpy(arr2d[2], folder.c_str());
    strcpy(arr2d[3], "-p");
    strcpy(arr2d[4], "-o");
    strcpy(arr2d[5], "test"); // anything will do

    timeStep *timeStepObjPtr;

    if (matl.compare("*") == 0) {
      timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false, 0); 
      cout << "All data\n";
    }  
    else { 
      timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true, 0);
      cout << "Some data\n";
    }  

    timeStep &timeStepObj = *timeStepObjPtr;

    variables& varColln = *(timeStepObj.varColln);

    int ntuples = 0;
    int ncomps = 0;  // Vector -> 3, Tensor ->  9

    // Detemine whether we have a vector or a tensor

    udaVars* udaVarsPtr = (*getVarList)(folder);
    udaVars& udaVarsObj = *(udaVarsPtr);

    for (int k = 0; k < udaVarsObj.size(); k++) {
      if (udaVarsObj[k].find(varName) != string::npos) { // should be a vector or a tensor
	if (udaVarsObj[k].find("Vector") != string::npos)
	  ncomps = 3;
	else if (udaVarsObj[k].find("Matrix3") != string::npos)   
	  ncomps = 9;
      }
    }              

    if ((varColln.size() % PARTICLE_INTERVAL) != 0) 
      ntuples = (varColln.size() / PARTICLE_INTERVAL) + 1;
    else
      ntuples = varColln.size() / PARTICLE_INTERVAL;

    cout << ncomps << " " << ntuples << endl;

    rv->SetNumberOfComponents(ncomps);
    rv->SetNumberOfTuples(ntuples);

    float* one_entry = new float[ncomps];

    // int ntuples = varColln.size(); // this is the number of entries in the variable.

    if (ncomps == 3) { // Vectors
      for (int i = 0 ; i < ntuples ; i++) {
	variable& varRef = varColln[i * PARTICLE_INTERVAL];
	vecValData& vecDataRef = varRef.vecData;

	for (int j = 0;  j < vecDataRef.size(); j++) {
	  if (strcmp(varName.c_str(), vecDataRef[j].name.c_str()) == 0) {
	    one_entry[0] = vecDataRef[j].x; one_entry[1] = vecDataRef[j].y; one_entry[2] = vecDataRef[j].z; 
	    rv->SetTuple(i, one_entry);  // you must determine value for ith entry.
	  }     
	}
      }         
    }
    else if (ncomps == 9) { // Tensors
      for (int i = 0 ; i < ntuples ; i++) {
	variable& varRef = varColln[i * PARTICLE_INTERVAL];
	tenValData& tenDataRef = varRef.tenData;

	for (int j = 0;  j < tenDataRef.size(); j++) {
	  if (strcmp(varName.c_str(), tenDataRef[j].name.c_str()) == 0) {
	    one_entry[0] = (float)tenDataRef[j].mat[0][0];
	    one_entry[1] = (float)tenDataRef[j].mat[0][1];
	    one_entry[2] = (float)tenDataRef[j].mat[0][2];
	    one_entry[3] = (float)tenDataRef[j].mat[1][0];
	    one_entry[4] = (float)tenDataRef[j].mat[1][1];
	    one_entry[5] = (float)tenDataRef[j].mat[1][2];
	    one_entry[6] = (float)tenDataRef[j].mat[2][0];
	    one_entry[7] = (float)tenDataRef[j].mat[2][1];
	    one_entry[8] = (float)tenDataRef[j].mat[2][2];
	    rv->SetTuple(i, one_entry);  // you must determine value for ith entry.
	  }     
	}
      }         
    }

    delete [] one_entry;
    delete timeStepObjPtr;
  }

  cout << "Out GetVectorVar\n";

  return rv;
}
