/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtudaReaderMTMDFileFormat.C                           //
// ************************************************************************* //

#include <avtudaReaderMTMDFileFormat.h>

#include <stdio.h>
#include <dlfcn.h>
#include <string>

#include <vtkPoints.h>
#include <vtkFieldData.h>
#include <vtkFloatArray.h>
#include <vtkIntArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>

#include <avtDatabase.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtStructuredDomainNesting.h>
#include <avtVariableCache.h>
#include <avtMaterial.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

using     std::string;

#define PARTICLE_INTERVAL 1


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat constructor
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

avtudaReaderMTMDFileFormat::avtudaReaderMTMDFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    cout << "\nIn avtudaReaderFileFormat\n";

    // INITIALIZE DATA MEMBERS
	bool fileOpened = false;
	
	// folder.assign("/home/collab/sshankar/csafe_data/jp8_tuna_can_Dmin_Pmax_rel_Wmax.uda"); 
	// folder.assign("/home/collab/sshankar/csafe_data/jp8_tuna_can_Dmax_Pmax.uda");
	// folder.assign("/home/sci/kuzimmer/work/SCIRunData/JP8_MR.uda.000");
	// folder.assign("/home/collab/sshankar/csafe_data/guni.2L.2C.uda.000");
	// folder.assign("/home/collab/sshankar/csafe_data/M2wedge.2L.uda.001");
	
	folder.assign(filename);
	size_t found = folder.find_last_of("/");
	folder = folder.substr(0, found);

	cout << folder << endl;
	
	libHandle = dlopen("/home/collab/sshankar/svn_new/SCIRun/hex64opt/lib/libPackages_Uintah_StandAlone_tools_uda2nrrd.so", RTLD_NOW); // The dylib locn should be changed
	if (!libHandle) {
	    cerr << "The library libuda2nrrd could not be located!!!"; 
		EXCEPTION1(InvalidDBTypeException, "The library libuda2nrrd could not be located!!!");
	}

	// All possible function calls - check here

	*(void **)(&getTimeSteps) = dlsym(libHandle, "getTimeSteps");
	if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getTimeSteps could not be located in the library!!!");
	}

    *(void **)(&getVarList) = dlsym(libHandle, "getVarList");
	if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getVarList could not be located in the library!!!");
	}

	*(void **)(&getMaterials) = dlsym(libHandle, "getMaterials");
	if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getMaterials could not be located in the library!!!");
	}

	*(void **)(&getBBox) = dlsym(libHandle, "getBBox");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getBBox could not be located in the library!!!");
	}
	
	*(void **)(&getPatchBBox) = dlsym(libHandle, "getPatchBBox");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getPatchBBox could not be located in the library!!!");
	}

	*(void **)(&processData) = dlsym(libHandle, "processData");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function processData could not be located in the library!!!");
	}
	
	*(void **)(&getTotalNumPatches) = dlsym(libHandle, "getTotalNumPatches");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getTotalNumPatches could not be located in the library!!!");
	}
	
	*(void **)(&getNumPatches) = dlsym(libHandle, "getNumPatches");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getNumPatches could not be located in the library!!!");
	}
	
	*(void **)(&getNumLevels) = dlsym(libHandle, "getNumLevels");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getNumLevels could not be located in the library!!!");
	}		
	
	*(void **)(&getPatchIndex) = dlsym(libHandle, "getPatchIndex");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getPatchIndex could not be located in the library!!!");
	}	
	
	*(void **)(&getPatchInfo) = dlsym(libHandle, "getPatchInfo");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getPatchInfo could not be located in the library!!!");
	}																					    
	
	// Check to see if the file could be opened should be here
	// fileOpened should be set if the file could be opened
	fileOpened = true;
	
	// No. of timesteps
	timeSteps = *((*getTimeSteps)(folder));
	
	currLevel = -1;
	currVar.assign("any_var");
	currMesh.assign("any_mesh");
	// patchInfoReq = true;
	// levelInfoReq = true;
	
	cout << "Out avtudaReaderFileFormat\n";
}


// Destructor
avtudaReaderMTMDFileFormat::~avtudaReaderMTMDFileFormat() {
  cout << "In destructor\n";
  
  dlclose(libHandle);
  
  if (levelPatchVecPtr !=  NULL) // just a pre-cautionary measure
    delete levelPatchVecPtr;
	
  if (patchInfoVecPtr !=  NULL) // just a pre-cautionary measure
    delete patchInfoVecPtr;	
}

// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

int
avtudaReaderMTMDFileFormat::GetNTimesteps(void)
{
	return timeSteps;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

void
avtudaReaderMTMDFileFormat::FreeUpResources(void)
{
    cout << "In Free up resources\n";
	currLevel = -1;
	currVar.assign("any_var");
	currMesh.assign("any_mesh");
	
	// levelPatchVecPtr = NULL;
	// patchInfoVecPtr = NULL;
}


// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

void
avtudaReaderMTMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    //
    // CODE TO ADD A MESH
    //
    cout << "\nIn PopulateDatabaseMetaData\n";
	
	// Prevent VisIt from sorting the variables.
    // md->SetMustAlphabetizeVariables(false);

	levelPatchVecPtr = (*getTotalNumPatches)(folder, timeState);
	levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
	
	int numLevels = levelPatchVecObj.size();
	int totalPatches = 0;
	
	for (int i = 0; i < numLevels; i++) {
	  totalPatches +=  levelPatchVecObj[i].noPatches;
	}  
	
	cout << "Levels: " << numLevels << " Patches: " << totalPatches << endl;

	vector<int> groupIds(totalPatches);
	vector<string> pieceNames(totalPatches);
	
	for (int i = 0; i < totalPatches; i++) {
	  char tmpName[64];
	  int level, local_patch;
	  
	  GetLevelAndLocalPatchNumber(i, timeState, level, local_patch);
      sprintf(tmpName,"level%d, patch%d", level, local_patch);
	  
	  groupIds[i] = level;
	  pieceNames[i] = tmpName;
	}
	
	int nblocks = 1;  
    int block_origin = 0;
    int spatial_dimension = 3;
    int topological_dimension;
    
	avtMeshType mt;
    avtCentering cent;
    
	double* minMaxArr = (*getBBox)(folder, timeState, 0); // level 0
	
	double extents[6];
	
	extents[0] = minMaxArr[0];
	extents[1] = minMaxArr[3];
	extents[2] = minMaxArr[1];
	extents[3] = minMaxArr[4];
	extents[4] = minMaxArr[2];
	extents[5] = minMaxArr[5];
	
	udaVars* udaVarsPtr = (*getVarList)(folder);
	udaVars& udaVarsObj = *(udaVarsPtr);
	
	cout << "Variables: " << udaVarsObj.size() << endl;

	for (int i = 0; i < udaVarsObj.size(); i++) {
	  if (udaVarsObj[i].find("p.") == string::npos) {
	    string varname = udaVarsObj[i];
		size_t found = varname.find("/");
		
		string vartype = varname.substr(found + 1);
		varname = varname.substr(0, found);
  
        varMatls* varMatlsPtr = (*getMaterials)(folder, varname, timeState);
	    varMatls& varMatlsObj = *(varMatlsPtr); 

		if (varMatlsObj.size() == 0)
		  cout << varname << " has no materials\n";
		  
		// cout << "Querying variable " << varname << " with " << varMatlsObj.size() << " materials" << endl;
		  
	    for (int j = 0; j < varMatlsObj.size(); j++) {
			char buffer[128];
			string newVarname = varname;
			sprintf(buffer, "%d", varMatlsObj[j]);
			newVarname.append("/");
			newVarname.append(buffer);
			
			string mesh_for_this_var;
			
			mt = AVT_AMR_MESH;
			topological_dimension = 1;
			
			if (vartype.find("NC") != string::npos) {
			  cent = AVT_NODECENT;
			  mesh_for_this_var.assign("NC"); 
			}  
			else if (vartype.find("CC") != string::npos) {  
			  cent = AVT_ZONECENT;
			  mesh_for_this_var.assign("CC"); 
			}
			else if (vartype.find("SFC") != string::npos) { 
			  cent = AVT_ZONECENT;
			  
			  if (vartype.find("SFCX") != string::npos)		
			    mesh_for_this_var.assign("SFCX");
			  else if (vartype.find("SFCY") != string::npos)		
			    mesh_for_this_var.assign("SFCY");
			  else if (vartype.find("SFCZ") != string::npos)		
			    mesh_for_this_var.assign("SFCZ");
			}  
			
			mesh_for_this_var.append("mesh_");
			mesh_for_this_var.append(newVarname);

			cout << newVarname << " " << mesh_for_this_var << endl;
			
			/*AddMeshToMetaData(md, mesh_for_this_var, mt, extents, totalPatches, 1,
			 				    3, topological_dimension);*/
			
			strcpy(buffer, mesh_for_this_var.c_str());
			
			avtMeshMetaData *mesh = new avtMeshMetaData;
			
			mesh->name = buffer;
			mesh->meshType = AVT_AMR_MESH;
			mesh->topologicalDimension = 1;
			mesh->spatialDimension = 3;
			mesh->blockOrigin = 0;
			
			mesh->numBlocks = totalPatches;
			mesh->blockTitle = "patches";
			mesh->blockPieceName = "patch";
			mesh->numGroups = numLevels;
			mesh->groupTitle = "levels";
			mesh->groupPieceName = "level";

			mesh->hasSpatialExtents = true; 
			mesh->minSpatialExtents[0] = minMaxArr[0];
			mesh->maxSpatialExtents[0] = minMaxArr[3];
			mesh->minSpatialExtents[1] = minMaxArr[1];
			mesh->maxSpatialExtents[1] = minMaxArr[4];
			mesh->minSpatialExtents[2] = minMaxArr[2];
			mesh->maxSpatialExtents[2] = minMaxArr[5];
			
			mesh->blockNames = pieceNames;
			
			md->Add(mesh); 
			// md->AddGroupInformation(numLevels, totalPatches, groupIds);
			
			if (vartype.find("Vector") != string::npos) 
			  AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
            else if (vartype.find("Matrix3") != string::npos)
			  AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
			else  
			  AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
		}
	  }	
	}
	
	md->AddGroupInformation(numLevels, totalPatches, groupIds);
	
	// Nothing needs to be modifed for particle data, as they exist only on a single level
	for (int i = 0; i < udaVarsObj.size(); i++) {
	  if (udaVarsObj[i].find("p.") != string::npos && udaVarsObj[i].find("p.x") == string::npos) {
        string varname = udaVarsObj[i];
		size_t found = varname.find("/");
		
		string vartype = varname.substr(found + 1);
		varname = varname.substr(0, found);

		varMatls* varMatlsPtr = (*getMaterials)(folder, varname, timeState);
	    varMatls& varMatlsObj = *(varMatlsPtr);
		
		cout << "Querying variable " << varname << " with " << varMatlsObj.size() << " materials" << endl;
		  
        bool addStar = false;
		int count =  varMatlsObj.size() + 1;
	    for (int j = 0; j < count; j++) {
			char buffer[128];
			string newVarname = varname;
			if (j > 0)
			  sprintf(buffer, "%d", varMatlsObj[j-1]);
			newVarname.append("/");
			
			if (j == 0 && addStar == false) {
			  newVarname.append("*");
			  // j--;
			  addStar = true;
			}    
			else
			  newVarname.append(buffer);
			
			string mesh_for_this_var = string("mesh_particle_");
			mesh_for_this_var.append(newVarname);

			cout << newVarname << " " << mesh_for_this_var << endl;
			
			mt = AVT_POINT_MESH;
			topological_dimension = 0;
			AddMeshToMetaData(md, mesh_for_this_var, mt, extents, nblocks, block_origin,
							  spatial_dimension, topological_dimension);
			
			cent = AVT_NODECENT;

			if (vartype.find("Vector") != string::npos) 
			  AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
            else if (vartype.find("Matrix3") != string::npos)
			  AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
			else  
			  AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
		}
	  }	
	}
    
	cout << "Out PopulateDatabaseMetaData\n";
}

// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetLevelAndLocalPatchNumber
//
//  Purpose:
//      Translates the global patch identifier to a refinement level and patch
//      number local to that refinement level.
//  
//  Programmer: sshankar, taken from implementation of the plugin, CHOMBO
//  Creation:   May 20, 2008
//
// ****************************************************************************

void
avtudaReaderMTMDFileFormat::GetLevelAndLocalPatchNumber(int global_patch, int timestate, 
                                            int &level, int &local_patch)
{
	levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
	int num_levels = levelPatchVecObj.size();
	// cout << "In GetLevelAndLocalPatchNumber, num_levels = " << num_levels << endl; 
	int num_patches = 0;
    int tmp = global_patch;
    level = 0;
    while (1 && level < num_levels)
    {
		num_patches = levelPatchVecObj[level].noPatches;
        if (tmp < num_patches)
        {
            break;
        }
        tmp -= num_patches;
        level++;
    }
    local_patch = tmp;
}

// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::CalculateDomainNesting
//
//  Purpose:
//      Calculates two important data structures.  One is the structure domain
//      nesting, which tells VisIt how the AMR patches are nested, which allows
//      VisIt to ghost out coarse zones that are refined by smaller zones.
//      The other structure is the rectilinear domain boundaries, which tells
//      VisIt which patches are next to each other, allowing VisIt to create
//      a layer of ghost zones around each patch.  Note that this only works
//      within a refinement level, not across refinement levels.
//  
//  Programmer: Hank Childs / Modified for re-use by sshankar
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtudaReaderMTMDFileFormat::CalculateDomainNesting(int timestate)
{
    levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
    int num_levels = levelPatchVecObj.size();

	// Call to store all patch information
	// Patch Info Vector
	// patchInfoVecPtr should be made global for use in GetMesh
	// patchInfoVec* patchInfoVecPtr = (*getPatchInfo)(folder, timestate);
	patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr);	

    //
    // Calculate some info we will need in the rest of the routine.
    //
    int totalPatches = 0;
    vector<int> levelStart;
    vector<int> levelEnd;
    for (int level = 0 ; level < num_levels ; level++) {
      levelStart.push_back(totalPatches);
      totalPatches += levelPatchVecObj[level].noPatches;;
      levelEnd.push_back(totalPatches);
    }

    //
    // Now that we know the total number of patches, we can allocate the
    // data structure for the patch nesting.
    // 
    avtStructuredDomainNesting *dn = new avtStructuredDomainNesting(
                                          totalPatches, num_levels);

    //
    // Calculate what the refinement ratio is from one level to the next.
    //
	
	// vector<int> dim(3); 
    // vector<vector<int>> rr(3, dim);
	
	vector<int> rr(3); 
    for (int level = 0 ; level < num_levels ; level++) {
      int* refinement_ratio = levelPatchVecObj[level].rr;
      for (int j = 0 ; j < 3 ; j++) {
        rr[j] = refinement_ratio[j];
      }
      dn->SetLevelRefinementRatios(level, rr);
    }

    //
    // This multiplier will be needed to find out if patches are nested.
    //
	
	vector<int> dim(3); 
    vector< vector<int> > multiplier(num_levels, dim);
    multiplier[num_levels-1][0] = 1;
	multiplier[num_levels-1][1] = 1;
	multiplier[num_levels-1][2] = 1;
    for (int level = num_levels-2 ; level >= 0 ; level--) {
	  int* refinement_ratio = levelPatchVecObj[level].rr;
	  for (int i = 0; i < 3; i++) {
        multiplier[level][i] = multiplier[level+1][i] * refinement_ratio[i];
	  }	
    }

    //
    // Now set up the data structure for patch boundaries.  The data 
    // does all the work ... it just needs to know the extents of each patch.
    //
    avtRectilinearDomainBoundaries *rdb 
                                    = new avtRectilinearDomainBoundaries(true);
    rdb->SetNumDomains(totalPatches);
    for (int patch = 0 ; patch < totalPatches ; patch++) {
      int my_level, local_patch;
      GetLevelAndLocalPatchNumber(patch, my_level, local_patch, timestate);

	  // int* indexArr = (*getPatchLoIndex)(folder, timestate, my_level, local_patch); // this should be stored somewhere

      int e[6];
      e[0] = patchInfoVecObj[patch].indexArr[0];
      e[1] = patchInfoVecObj[patch].indexArr[3];
      e[2] = patchInfoVecObj[patch].indexArr[1];
      e[3] = patchInfoVecObj[patch].indexArr[4];
      e[4] = patchInfoVecObj[patch].indexArr[2];
      e[5] = patchInfoVecObj[patch].indexArr[5];

      rdb->SetIndicesForAMRPatch(patch, my_level, e);
    }
    rdb->CalculateBoundaries();
    void_ref_ptr vrdb = void_ref_ptr(rdb,
                                   avtStructuredDomainBoundaries::Destruct);
    cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION,
                        timestate, -1, vrdb);

    //
    // Calculating the child patches really needs some better sorting than
    // what I am doing here.  This is likely to become a bottleneck in extreme
    // cases.  Although this routine has performed well for a previous 55K
    // patch run.
    //
    vector< vector<int> > childPatches(totalPatches);
    for (int level = num_levels-1 ; level > 0 ; level--) {
      int prev_level = level-1;
      int search_start  = levelStart[prev_level];
      int search_end    = levelEnd[prev_level];
      vector<int> mC = multiplier[prev_level];
      int patches_start = levelStart[level];
      int patches_end   = levelEnd[level];
      vector<int> mP = multiplier[level];
	  for (int patch = patches_start ; patch < patches_end ; patch++) {
        for (int candidate = search_start ; candidate < search_end ; candidate++) {			
          if (patchInfoVecObj[patch].indexArr[3]*mP[0] <  patchInfoVecObj[candidate].indexArr[0]*mC[0])
            continue;
          if (patchInfoVecObj[patch].indexArr[0]*mP[0] >= patchInfoVecObj[candidate].indexArr[3]*mC[0])
            continue;
          if (patchInfoVecObj[patch].indexArr[4]*mP[1] <  patchInfoVecObj[candidate].indexArr[1]*mC[1])
            continue;
          if (patchInfoVecObj[patch].indexArr[1]*mP[1] >= patchInfoVecObj[candidate].indexArr[4]*mC[1])
            continue;
          if (patchInfoVecObj[patch].indexArr[5]*mP[2] <  patchInfoVecObj[candidate].indexArr[2]*mC[2])
            continue;
          if (patchInfoVecObj[patch].indexArr[2]*mP[2] >= patchInfoVecObj[candidate].indexArr[5]*mC[2])
            continue;
          
		  childPatches[candidate].push_back(patch);
        }
      }
    }

    //
    // Now that we know the extents for each patch and what its children are,
    // tell the structured domain boundary that information.
    //
    for (int i = 0 ; i < totalPatches ; i++) {
      int my_level, local_patch;
      GetLevelAndLocalPatchNumber(i, my_level, local_patch, timestate);

      // int* indexArr = (*getPatchLoIndex)(folder, timestate, my_level, local_patch); // this should be stored somewhere

      vector<int> logExts(6);
      logExts[0] = patchInfoVecObj[i].indexArr[0];
      logExts[3] = patchInfoVecObj[i].indexArr[3] - 1;
      logExts[1] = patchInfoVecObj[i].indexArr[1];
      logExts[4] = patchInfoVecObj[i].indexArr[4] - 1;
      logExts[2] = patchInfoVecObj[i].indexArr[2];
      logExts[5] = patchInfoVecObj[i].indexArr[5] - 1;

      cout << childPatches[i].size() << endl;

      dn->SetNestingForDomain(i, my_level, childPatches[i], logExts);
    }

    //
    // Register this structure with the generic database so that it knows
    // to ghost out the right cells.
    //
    dn->SetNumDimensions(3);
    void_ref_ptr vr = void_ref_ptr(dn, avtStructuredDomainNesting::Destruct);
    cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
                        timestate, -1, vr);
}

// ***************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

vtkDataSet *
avtudaReaderMTMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    string meshName(meshname);
	
	if (meshName.find("mesh_particle") == string::npos) { // volume data
		cout << "\nIn GetMesh, timestate: " << timestate << "\n";
		
		cout << meshName << " ";

        size_t found1 = meshName.find("_");
		size_t found2 = meshName.find("/");

		string varName = meshName.substr(found1 + 1, found2 - (found1 + 1));
		string matlNo = meshName.substr(found2 + 1);

		cout << varName << endl;
		cout << matlNo << endl;
		
		if (currMesh.compare(varName) != 0) {  // patchInfoReq may not be required
		  cout << "Making the much required call to getPatchInfo\n";
		  patchInfoVecPtr = (*getPatchInfo)(folder, timestate, meshname);
		  levelPatchVec& levelPatchVecObj = *levelPatchVecPtr;
		  int numLevels = levelPatchVecObj.size();
		  
		  // if there is just a single level, there is no need to call this function
		  if (numLevels > 1) {
			cout << "CalculateDomainNesting() called\n";
		    CalculateDomainNesting(timestate);
		  }
		  
		  currMesh.assign(varName);
		}    
	      
		patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr);	
		
		// int level, local_patch;
		
		// GetLevelAndLocalPatchNumber(domain, timestate, level, local_patch);
		// double* minMaxArr = (*getPatchBBox)(folder, timestate, level, local_patch);
		
		double* minMaxArr = patchInfoVecObj[domain].minMaxArr;
		int* indexArr = patchInfoVecObj[domain].indexArr;
		
		// cout << level << " " << local_patch << endl; 
		
		// char buffer[128];
		// sprintf(buffer, "%d", level);

		/*strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-v");
		strcpy(arr2d[4], varName.c_str());
		strcpy(arr2d[5], "-m");
		strcpy(arr2d[6], matlNo.c_str());
		strcpy(arr2d[7], "-l");
		strcpy(arr2d[8], buffer);
		strcpy(arr2d[9], "-o");
		strcpy(arr2d[10], "test"); // anything will do*/

		// timeStep *timeStepObjPtr = (*processData)(11, arr2d, timestate, false, 0, false, local_patch);
	    // timeStep &timeStepObj = *timeStepObjPtr;
		
		// cellVals& cellValColln = *(timeStepObj.cellValColln);
		
		int cellValColln_x = indexArr[3] - indexArr[0];
		int cellValColln_y = indexArr[4] - indexArr[1];
		int cellValColln_z = indexArr[5] - indexArr[2];
		
		// cout << cellValColln_x << " " << cellValColln_y << " " << cellValColln_z << endl;
		/*for (int i = 0; i < 6; i++)
		  cout << minMaxArr[i] <<  endl;*/
		
		int ndims = 3; 
		int dims[3] = {cellValColln_x + 1, cellValColln_y + 1, cellValColln_z + 1}; // for node centered -> remove +1
		vtkFloatArray *coords[3] = {0,0,0};
		
		double dx, dy, dz;
		dx = (minMaxArr[3] - minMaxArr[0]) / cellValColln_x; // for node centered -> -1
		dy = (minMaxArr[4] - minMaxArr[1]) / cellValColln_y;
		dz = (minMaxArr[5] - minMaxArr[2]) / cellValColln_z;
		
		double dtdx, dtdy, dtdz;
		dtdx = dtdy = dtdz = 0.;
		
		if (meshName.find("NC") != string::npos) {
		  cout << "NC Mesh\n";
		  dims[0] = cellValColln_x;
		  dims[1] = cellValColln_y;
		  dims[2] = cellValColln_z;
		  		
		  dx = (minMaxArr[3] - minMaxArr[0]) / (cellValColln_x - 1);
		  dy = (minMaxArr[4] - minMaxArr[1]) / (cellValColln_y - 1);
		  dz = (minMaxArr[5] - minMaxArr[2]) / (cellValColln_z - 1);
		}  
		else if (meshName.find("SFC") != string::npos) {
		  cout << "SFC Mesh\n";
		  dims[0] = cellValColln_x + 1;
		  dims[1] = cellValColln_y + 1;
		  dims[2] = cellValColln_z + 1;
		  		
		  dx = (minMaxArr[3] - minMaxArr[0]) / cellValColln_x;
		  dy = (minMaxArr[4] - minMaxArr[1]) / cellValColln_y;
		  dz = (minMaxArr[5] - minMaxArr[2]) / cellValColln_z;
		  
		  if (meshName.find("SFCX") != string::npos) {
		    cout << "SFCX\n";
		    dims[0] = dims[0] - 1;
		    dx = (minMaxArr[3] - minMaxArr[0]) / (cellValColln_x - 1);
		    // dtdy = dy / 2.;
		    // dtdz = dz / 2.;
		  }
		  else if (meshName.find("SFCY") != string::npos) {
		   cout << "SFCY\n";
		    dims[1] = dims[1] - 1;
		    dy = (minMaxArr[4] - minMaxArr[1]) / (cellValColln_y - 1);
		    // dtdx = dx / 2.;
		    // dtdz = dz / 2.;
	      }
		  else if (meshName.find("SFCZ") != string::npos) {
		    cout << "SFCZ\n";
		    dims[2] = dims[2] - 1;
		    dz = (minMaxArr[5] - minMaxArr[2]) / (cellValColln_z - 1);
		    // dtdx = dx / 2.;
		    // dtdy = dy / 2.;
	      }			
		}
		
		// Read the X coordinates from the file. 
		coords[0] = vtkFloatArray::New(); 
		coords[0]->SetNumberOfTuples(dims[0]); 
		float *xarray = (float *)coords[0]->GetVoidPointer(0); 
		for (int i = 0; i < dims[0]; i++) {
		  xarray[i] =  (minMaxArr[0] + dtdx) + i * dx;
		}
		
		// Read the Y coordinates from the file. 
		coords[1] = vtkFloatArray::New(); 
		coords[1]->SetNumberOfTuples(dims[1]); 
		float *yarray = (float *)coords[1]->GetVoidPointer(0); 
		for (int i = 0; i < dims[1]; i++) {
		  yarray[i] =  (minMaxArr[1] + dtdy) + i * dy;
		}
		
		// Read the Z coordinates from the file. 
		coords[2] = vtkFloatArray::New(); 
		coords[2]->SetNumberOfTuples(dims[2]); 
		float *zarray = (float *)coords[2]->GetVoidPointer(0); 
		for (int i = 0; i < dims[2]; i++) {
		  zarray[i] =  (minMaxArr[2] + dtdz) + i * dz;
		}
		
		vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New(); 
		rgrid->SetDimensions(dims); 
		rgrid->SetXCoordinates(coords[0]); 
		coords[0]->Delete(); 
		rgrid->SetYCoordinates(coords[1]); 
		coords[1]->Delete();
		rgrid->SetZCoordinates(coords[2]); 
		coords[2]->Delete(); 
		
		//
		// Determine the indices of the mesh within its group.  Add that to the
		// VTK dataset as field data.
		//
		
		// int* indexArr = (*getPatchIndex)(folder, timestate, level, local_patch, meshName); // Add variable/ meshname
		
		vtkIntArray *arr = vtkIntArray::New();
		arr->SetNumberOfTuples(3);
		arr->SetValue(0, indexArr[0]);
		arr->SetValue(1, indexArr[1]);
		arr->SetValue(2, indexArr[2]);
		arr->SetName("base_index");
		rgrid->GetFieldData()->AddArray(arr);
		arr->Delete();
		
		// delete minMaxArr;
		// delete timeStepObjPtr;
		// delete indexArr;

		cout << "Out GetMesh\n";

		return rgrid;
	}
	else if (meshName.find("mesh_particle") != string::npos) { // particle data
		cout << "\nIn GetMesh\n";
		cout << meshName << endl;

		size_t found = meshName.find("/");
		string matl = meshName.substr(found + 1);
		
		int matlNo = 0;
		
		if (matl.compare("*") != 0)
		  matlNo = atoi(matl.c_str());

		cout << matlNo << endl;

		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-p");
		strcpy(arr2d[4], "-o");
		strcpy(arr2d[5], "test"); // anything will do

		timeStep *timeStepObjPtr;
		
		if (matl.compare("*") == 0) {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false, 0); 
		  cout << "All data\n";
        }
        else {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true, 0);
		  cout << "Some data\n";
		}  

		timeStep &timeStepObj = *timeStepObjPtr;

		variables& varCollnRef = *(timeStepObj.varColln);

		unsigned int i, ndims, nnodes, count = 0;
		
		ndims = 3;
		
		if ((varCollnRef.size() % PARTICLE_INTERVAL) != 0) 
		  nnodes = (varCollnRef.size() / PARTICLE_INTERVAL) + 1;
		else
		  nnodes = varCollnRef.size() / PARTICLE_INTERVAL;

		cout << nnodes << endl;

		float *xarray = new float[nnodes];
		float *yarray = new float[nnodes]; 
		float *zarray = new float[nnodes];

		float *xc = xarray; 
		float *yc = yarray; 
		float *zc = zarray; 

		for (i = 0; i < nnodes; ++i) {
		  variable& varRef = varCollnRef[i * PARTICLE_INTERVAL];
		  *xc++ = varRef.x;
		  *yc++ = varRef.y;
		  *zc++ = varRef.z;
          // cout << varRef.x << " " << varRef.y << " " << varRef.z << endl;
		}

		// 
		// Create the vtkPoints object and copy points into it. 
		// 
		
		vtkPoints *points = vtkPoints::New(); 
		points->SetNumberOfPoints(nnodes); 
		float *pts = (float *) points->GetVoidPointer(0); 
		
		xc = xarray; 
		yc = yarray; 
		zc = zarray; 
		
		if(ndims == 3) 
		{ 
			for(i = 0; i < nnodes; ++i) 
			{ 
				*pts++ = *xc++; 
				*pts++ = *yc++; 
				*pts++ = *zc++;
			}
		} 
		else if(ndims == 2) 
		{ 
			for(i = 0; i < nnodes; ++i) 
			{ 
				*pts++ = *xc++; 
				*pts++ = *yc++; 
				*pts++ = 0.; 
			} 
		}	

		// 
		// Create a vtkUnstructuredGrid to contain the point cells. 
		// 
		
		vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
		ugrid->SetPoints(points); 
		points->Delete(); 
		ugrid->Allocate(nnodes); 
		vtkIdType onevertex; 
		
		for(int i = 0; i < nnodes; ++i) 
		{ 
			onevertex = i; 
			ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex); 
		} 

		// Delete temporary arrays. 
		delete [] xarray; 
		delete [] yarray; 
		delete [] zarray;
		
		delete timeStepObjPtr;

		cout << "Out GetMesh\n";

		return ugrid;
	}
}

// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

vtkDataArray *
avtudaReaderMTMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

	cout << "\nIn GetVar, timestate: " << timestate << "\n";
	
	string varName(varname);
	
	vtkFloatArray *rv = vtkFloatArray::New();

	if (varName.find("p.") == string::npos) {
		size_t found = varName.find("/");
		string tmpVarName = varName;
		
		string matlNo = varName.substr(found + 1);
		varName = varName.substr(0, found);

		cout << varName << endl;
		cout << matlNo << endl;
		
		int level, local_patch;
		
		GetLevelAndLocalPatchNumber(domain, timestate, level, local_patch);
		// double* minMaxArr = (*getPatchBBox)(folder, timestate, level, local_patch);
		
		unsigned int count = 0;
		
		if ((currLevel != level) || (currVar.find(tmpVarName) == string::npos)) { 
		  cout << "Making the much required call to collect information at level " << level << "\n";
		  currLevel = level;
		  currVar.assign(tmpVarName);
		  
		  char buffer[128];
		  sprintf(buffer, "%d", level);
	
		  strcpy(arr2d[0], "uda2nrrd"); // anything will do
		  strcpy(arr2d[1], "-uda");
		  strcpy(arr2d[2], folder.c_str());
		  strcpy(arr2d[3], "-v");
		  strcpy(arr2d[4], varName.c_str());
		  strcpy(arr2d[5], "-m");
		  strcpy(arr2d[6], matlNo.c_str());
		  strcpy(arr2d[7], "-l");
		  strcpy(arr2d[8], buffer); 
		  strcpy(arr2d[9], "-o");
		  strcpy(arr2d[10], "test"); // anything will do

		  timeStep* timeStepObjPtr = (*processData)(11, arr2d, timestate, true, 0, false, local_patch);
		  timeStep &timeStepObj = *timeStepObjPtr;
		
		  cellVals& cellValColln = *(timeStepObj.cellValColln);
		  typeDouble& cellValVec = *(cellValColln.cellValVec);
		  
		  cout << cellValColln.x << " " << cellValColln.y << " " << cellValColln.z << endl;
		  
		  // if (refMatrix != NULL)
		    // delete [] refMatrix;
		  
		  // Allocating Matrix
		  refMatrix = (double***)malloc(cellValColln.x * sizeof(double**));
		  if (refMatrix == NULL) cout << "Error allocating refMatrix\n";
		  for(int i = 0; i < cellValColln.x; i++) {
		    refMatrix[i] = (double**)malloc(cellValColln.y * sizeof(double*));
		    if (refMatrix[i] == NULL) cout << "Error allocating refMatrix[" << i << "]\n";
		    for(int j = 0; j < cellValColln.y; j++) {
			  refMatrix[i][j] = (double*)malloc(cellValColln.z * sizeof(double));
			  if (refMatrix[i][j] == NULL) cout << "Error allocating refMatrix[" << i << "][" << j << "]\n";
		    }
		  }
		  
		  // Reference matrix
		  for (int i = 0; i < cellValColln.z; i++) {
			for (int j = 0; j < cellValColln.y; j++) {
			  for (int k = 0; k < cellValColln.x; k++) {	
			    refMatrix[k][j][i] = cellValVec[count];
				count++;  
			  }
			}
		  }
		  
		  // Cleaning up
		  delete timeStepObjPtr;
		}  
		
		patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr);	
		int* indexArr = patchInfoVecObj[domain].indexArr;
		int cellValColln_x = indexArr[3] - indexArr[0];
		int cellValColln_y = indexArr[4] - indexArr[1];
		int cellValColln_z = indexArr[5] - indexArr[2];
		
		cout << "[ " << indexArr[0] << " " << indexArr[1] << " " << indexArr[2] << " ] " ;
		cout << "[ " << indexArr[3] << " " << indexArr[4] << " " << indexArr[5] << " ] "  << endl;
		
		rv->SetNumberOfTuples(cellValColln_x * cellValColln_y * cellValColln_z);
		count = 0;
		
		for (int i = indexArr[2]; i < indexArr[5]; i++) {
		  for (int j = indexArr[1]; j < indexArr[4]; j++) {
		    for (int k = indexArr[0]; k < indexArr[3]; k++) {
			  rv->SetTuple1(count++, refMatrix[k][j][i]);
			}
		  }
		}
		
		/*for (unsigned int i = 0; i < cellValVec.size(); ++i) {
		  rv->SetTuple1(i, cellValVec[i]);  // you must determine value for ith entry.
		}*/
		
		// delete timeStepObjPtr;
	}
	else {
		size_t found = varName.find("/");
		
		string matl = varName.substr(found + 1);
		varName = varName.substr(0, found);

		int matlNo = 0;
		
		if (matl.compare("*") != 0)
		  matlNo = atoi(matl.c_str());

		cout << varName << endl;
		cout << matlNo << endl;
		
		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-p");
		strcpy(arr2d[4], "-o");
		strcpy(arr2d[5], "test"); // anything will do

		timeStep *timeStepObjPtr;
		
		if (matl.compare("*") == 0) {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false, 0); 
		  cout << "All data\n";
		}  
        else { 
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true, 0);
		  cout << "Some data\n";
		}  
	    
		timeStep &timeStepObj = *timeStepObjPtr;

		variables& varColln = *(timeStepObj.varColln);

		int ntuples = 0;

		if ((varColln.size() % PARTICLE_INTERVAL) != 0) 
		  ntuples = (varColln.size() / PARTICLE_INTERVAL) + 1;
		else
		  ntuples = varColln.size() / PARTICLE_INTERVAL;

		cout << ntuples << endl;
		
		// int ntuples = varColln.size(); // this is the number of entries in the variable.
		rv->SetNumberOfTuples(ntuples);
		for (int i = 0 ; i < ntuples ; i++) {
			variable& varRef = varColln[i * PARTICLE_INTERVAL];
			unknownData& dataRef = varRef.data;
			
			for (int j = 0;  j < dataRef.size(); j++) {
				if (strcmp(varName.c_str(), dataRef[j].name.c_str()) == 0)
					rv->SetTuple1(i, dataRef[j].value);  // you must determine value for ith entry.
			}
		}
		
		delete timeStepObjPtr;
	}

	cout << "Out GetVar\n";

    //
    return rv;
    //
}

// ****************************************************************************
//  Method: avtudaReaderMTMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Tue May 13 19:02:26 PST 2008
//
// ****************************************************************************

vtkDataArray *
avtudaReaderMTMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //
	
	cout << "\nIn GetVectorVar, timestate: " << timestate << "\n";
	
	string varName(varname);
	
	vtkFloatArray *rv = vtkFloatArray::New();

	if (varName.find("p.") == string::npos) {
	    size_t found = varName.find("/");
		string tmpVarName = varName;
		
		string matlNo = varName.substr(found + 1);
		varName = varName.substr(0, found);

		cout << varName << endl;
		cout << matlNo << endl;
	
		int level, local_patch;
		
		GetLevelAndLocalPatchNumber(domain, timestate, level, local_patch);
		// double* minMaxArr = (*getPatchBBox)(folder, timestate, level, local_patch);
		
		unsigned int count = 0;
		
		if ((currLevel != level) || (currVar.find(tmpVarName) == string::npos)) { 
		  cout << "Making the much required call to collect information at level " << level << "\n";
		  currLevel = level;
		  currVar.assign(tmpVarName);
		
		  char buffer[128];
		  sprintf(buffer, "%d", level);
	
		  strcpy(arr2d[0], "uda2nrrd"); // anything will do
		  strcpy(arr2d[1], "-uda");
		  strcpy(arr2d[2], folder.c_str());
		  strcpy(arr2d[3], "-v");
		  strcpy(arr2d[4], varName.c_str());
		  strcpy(arr2d[5], "-m");
		  strcpy(arr2d[6], matlNo.c_str());
		  strcpy(arr2d[7], "-l");
		  strcpy(arr2d[8], buffer);
		  strcpy(arr2d[9], "-o");
		  strcpy(arr2d[10], "test"); // anything will do

		  timeStep *timeStepObjPtr = (*processData)(9, arr2d, timestate, true, 0, false, local_patch);
	      timeStep &timeStepObj = *timeStepObjPtr;
		
		  cellVals& cellValColln = *(timeStepObj.cellValColln);
		  typeDouble& cellValVec = *(cellValColln.cellValVec);
          int dim = cellValColln.dim;
		  
		  if (dim == 5) // Tensors
		    ncomps = 9;
		  else if (dim == 4) // Vectors
		    ncomps = 3;
		  // else if (dim == 3) // Scalars + Tensors
		    // ncomps = 1; // This case would lead to problem as it has not been added to meta data	
			
		  // ntuples = cellValVec.size() / ncomps; // this is the number of entries in the variable.	
		
		  if (ncomps == 3) { // Vectors
		    // Allocating Matrix
		    vecValMatrix = (vecVal***)malloc(cellValColln.x * sizeof(vecVal**));
		    if (vecValMatrix == NULL) cout << "Error allocating vecValMatrix\n";
		    for(int i = 0; i < cellValColln.x; i++) {
		      vecValMatrix[i] = (vecVal**)malloc(cellValColln.y * sizeof(vecVal*));
		      if (vecValMatrix[i] == NULL) cout << "Error allocating vecValMatrix[" << i << "]\n";
		      for(int j = 0; j < cellValColln.y; j++) {
			    vecValMatrix[i][j] = (vecVal*)malloc(cellValColln.z * sizeof(vecVal));
			    if (vecValMatrix[i][j] == NULL) cout << "Error allocating vecValMatrix[" << i << "][" << j << "]\n";
		      }
		    }
		  
		    // Reference matrix
		    for (int i = 0; i < cellValColln.z; i++) {
			  for (int j = 0; j < cellValColln.y; j++) {
			    for (int k = 0; k < cellValColln.x; k++) {	
			      vecVal& vecValRef = vecValMatrix[k][j][i];
				  vecValRef.x = cellValVec[count++];
				  vecValRef.y = cellValVec[count++];
				  vecValRef.z = cellValVec[count++];
			    }
			  }
		    }
		  }
		  else if (ncomps == 9) { // Tensors
		    // Allocating Matrix
		    tenValMatrix = (tenVal***)malloc(cellValColln.x * sizeof(tenVal**));
		    if (tenValMatrix == NULL) cout << "Error allocating tenValMatrix\n";
		    for(int i = 0; i < cellValColln.x; i++) {
		      tenValMatrix[i] = (tenVal**)malloc(cellValColln.y * sizeof(tenVal*));
		      if (tenValMatrix[i] == NULL) cout << "Error allocating tenValMatrix[" << i << "]\n";
		      for(int j = 0; j < cellValColln.y; j++) {
			    tenValMatrix[i][j] = (tenVal*)malloc(cellValColln.z * sizeof(tenVal));
			    if (tenValMatrix[i][j] == NULL) cout << "Error allocating tenValMatrix[" << i << "][" << j << "]\n";
		      }
		    }
		  
		    // Reference matrix
		    for (int i = 0; i < cellValColln.z; i++) {
			  for (int j = 0; j < cellValColln.y; j++) {
			    for (int k = 0; k < cellValColln.x; k++) {	
			      tenVal& tenValRef = tenValMatrix[k][j][i];
				  // cout << "tenValMatrix[" << k << "][" << j << "][" << i << "]\n";
				  for (int p = 0; p < 3; p++) {
				    for (int q = 0; q < 3; q++) {
				      tenValRef.mat[p][q] = cellValVec[count++];
					  if (k == 9 && j == 5 && i == 1) {
					    cout << tenValRef.mat[p][q] << " ";
					  }   
					}
				  }	  
			    }
			  }
		    }
			
		  }
		  
		  // Cleaning up
		  delete timeStepObjPtr;
		}  
		  
		patchInfoVec& patchInfoVecObj = *(patchInfoVecPtr);	
		int* indexArr = patchInfoVecObj[domain].indexArr;
		int cellValColln_x = indexArr[3] - indexArr[0];
		int cellValColln_y = indexArr[4] - indexArr[1];
		int cellValColln_z = indexArr[5] - indexArr[2];
		
		cout << "[ " << indexArr[0] << " " << indexArr[1] << " " << indexArr[2] << " ] " ;
		cout << "[ " << indexArr[3] << " " << indexArr[4] << " " << indexArr[5] << " ] "  << endl;
		
		rv->SetNumberOfComponents(ncomps);
		rv->SetNumberOfTuples(cellValColln_x * cellValColln_y * cellValColln_z);
		
		double* one_entry = new double[ncomps];
		count = 0;
		
		if (ncomps == 3) {
		  for (int i = indexArr[2]; i < indexArr[5]; i++) {
		    for (int j = indexArr[1]; j < indexArr[4]; j++) {
		      for (int k = indexArr[0]; k < indexArr[3]; k++) {
			    vecVal& vecValRef = vecValMatrix[k][j][i];
			    one_entry[0] = vecValRef.x;
			    one_entry[1] = vecValRef.y;
			    one_entry[2] = vecValRef.z;
			    rv->SetTuple(count++, one_entry);
			  }
		    }
		  }
		}
		else if (ncomps == 9) {
		  for (int i = indexArr[2]; i < indexArr[5]; i++) {
		    for (int j = indexArr[1]; j < indexArr[4]; j++) {
		      for (int k = indexArr[0]; k < indexArr[3]; k++) {
			    tenVal& tenValRef = tenValMatrix[k][j][i];
			    one_entry[0] = tenValRef.mat[0][0];
			    one_entry[1] = tenValRef.mat[0][1];
			    one_entry[2] = tenValRef.mat[0][2];
				one_entry[3] = tenValRef.mat[1][0];
			    one_entry[4] = tenValRef.mat[1][1];
			    one_entry[5] = tenValRef.mat[1][2];
				one_entry[6] = tenValRef.mat[2][0];
			    one_entry[7] = tenValRef.mat[2][1];
			    one_entry[8] = tenValRef.mat[2][2];
				rv->SetTuple(count++, one_entry);
				if (k == 9 && j == 5 && i == 1) {
				  cout << one_entry[0] << " " << one_entry[1] << " " << one_entry[2] << endl;
				  cout << one_entry[3] << " " << one_entry[4] << " " << one_entry[5] << endl;
				  cout << one_entry[6] << " " << one_entry[7] << " " << one_entry[8] << endl;
				}
			  }
		    }
		  }
		}

		delete [] one_entry;
	}
    else {
		size_t found = varName.find("/");
		
		string matl = varName.substr(found + 1);
		varName = varName.substr(0, found);

		int matlNo = 0;
		
		if (matl.compare("*") != 0)
		  matlNo = atoi(matl.c_str());

		cout << varName << endl;
		cout << matlNo << endl;
		
		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-p");
		strcpy(arr2d[4], "-o");
		strcpy(arr2d[5], "test"); // anything will do

		timeStep *timeStepObjPtr;
		
		if (matl.compare("*") == 0) {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false, 0); 
		  cout << "All data\n";
		}  
        else { 
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true, 0);
		  cout << "Some data\n";
		}  
	    
		timeStep &timeStepObj = *timeStepObjPtr;

		variables& varColln = *(timeStepObj.varColln);
		
		int ntuples = 0;
        int ncomps = 0;  // Vector -> 3, Tensor ->  9
		
		// Detemine whether we have a vector or a tensor
		
		udaVars* udaVarsPtr = (*getVarList)(folder);
	    udaVars& udaVarsObj = *(udaVarsPtr);
		
		for (int k = 0; k < udaVarsObj.size(); k++) {
		  if (udaVarsObj[k].find(varName) != string::npos) { // should be a vector or a tensor
		    if (udaVarsObj[k].find("Vector") != string::npos)
			  ncomps = 3;
			else if (udaVarsObj[k].find("Matrix3") != string::npos)   
			  ncomps = 9;
		  }
	    }	  	   

		if ((varColln.size() % PARTICLE_INTERVAL) != 0) 
		  ntuples = (varColln.size() / PARTICLE_INTERVAL) + 1;
		else
		  ntuples = varColln.size() / PARTICLE_INTERVAL;
		
		cout << ncomps << " " << ntuples << endl;

		rv->SetNumberOfComponents(ncomps);
		rv->SetNumberOfTuples(ntuples);
		
		float* one_entry = new float[ncomps];
		
		// int ntuples = varColln.size(); // this is the number of entries in the variable.
			
		if (ncomps == 3) { // Vectors
			for (int i = 0 ; i < ntuples ; i++) {
				variable& varRef = varColln[i * PARTICLE_INTERVAL];
				vecValData& vecDataRef = varRef.vecData;
				
				for (int j = 0;  j < vecDataRef.size(); j++) {
					if (strcmp(varName.c_str(), vecDataRef[j].name.c_str()) == 0) {
					  one_entry[0] = vecDataRef[j].x; one_entry[1] = vecDataRef[j].y; one_entry[2] = vecDataRef[j].z; 
					  rv->SetTuple(i, one_entry);  // you must determine value for ith entry.
					}	
				}
			}		
		}
		else if (ncomps == 9) { // Tensors
			for (int i = 0 ; i < ntuples ; i++) {
				variable& varRef = varColln[i * PARTICLE_INTERVAL];
				tenValData& tenDataRef = varRef.tenData;

				for (int j = 0;  j < tenDataRef.size(); j++) {
				    if (strcmp(varName.c_str(), tenDataRef[j].name.c_str()) == 0) {
					  one_entry[0] = (float)tenDataRef[j].mat[0][0];
					  one_entry[1] = (float)tenDataRef[j].mat[0][1];
					  one_entry[2] = (float)tenDataRef[j].mat[0][2];
					  one_entry[3] = (float)tenDataRef[j].mat[1][0];
					  one_entry[4] = (float)tenDataRef[j].mat[1][1];
					  one_entry[5] = (float)tenDataRef[j].mat[1][2];
					  one_entry[6] = (float)tenDataRef[j].mat[2][0];
					  one_entry[7] = (float)tenDataRef[j].mat[2][1];
					  one_entry[8] = (float)tenDataRef[j].mat[2][2];
					  rv->SetTuple(i, one_entry);  // you must determine value for ith entry.
					}	
				}
			}		
		}

		delete [] one_entry;
		delete timeStepObjPtr;
	}

	cout << "Out GetVectorVar\n";

	return rv;
}
