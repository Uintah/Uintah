<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE component SYSTEM "../../../../Dataflow/XML/component.dtd">
<?xml-stylesheet href="../../../../../doc/package-component.xsl" type="text/xsl"?>
<?cocoon-process type="xslt"?>

<!--
   For more information, please see: http://software.sci.utah.edu

   The MIT License

   Copyright (c) 2004 Scientific Computing and Imaging Institute,
   University of Utah.

   License for the specific language governing rights and limitations under
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
-->

<component name="MatlabBundle" category="DataIO">
  <overview>
    <authors>
      <author>Jeroen Stinstra</author>
    </authors>
    <summary>
      Interactive Matlab Interface: This module accomplishes a number
of steps to integrate MATLAB code into SCIRun, (1) it translates a
SCIRun object (field/matrix/nrrd) into a matlabarray and puts the
object in the current workspace of matlab, (2) it executes MATLAB code
that can be provided within the interface, (3) it translates back the
matlabarrays in MATLAB's workspace into SCIRun objects. The difference
with the normal Matlab module is that this one uses bundles as input
and output to allow for a more flexible interface. Since the use of
bundles is more complicated, the Matlab module should be used if
fields or matrices need to be adjusted. But for more complicated
projects, this module allows for more flexibility.
    </summary>
    <description>

      <section>
	<title>Overview</title>

	<p>
    This module is an extension of the Matlab module. Please review
the documentation of this module for a more detailed description of
the inner workings of the matlab interface. The main difference with
the Matlab module is the way data is imported into MATLAB. This module
uses the module concepts for transporting data. In short a bundle is a
collection of SCIRun objects bundled into one stream. As the number of
elements in a stream is only limited by the amount of memory that can
be used, far more variables can be transported into and out of the
module. However this comes with the price of a less straight forward
representation of data in matlab. In this case all input and output
matlab arrays are structures whose field can represent any of the
SCIRun objects currently supported by the Matlab package. Note the
currently colormaps and path streams are not supported, although they
can be fit into a bundled stream, it is not available in a matlab
representation. Converters for those classes will be implemented if
they are needed. 
    </p>
	<p>
    The bundle to matlab converter has some specific options as well.
For matrices and nrrds the default behaviour is to convert them
directly into a numeric dense or sparse matrix and all the other
properties of the SCIRun object are stripped away, whereas fields are
represented by a sub structure, with fields as defined by the
MatlabFieldWriter. The options 'numeric array' and 'struct array'
control how matrices and nrrds are converted. In case of 'numeric
array' all nrrds and matrices will be dense or sparse matrices and the
additional fields within the SCIRun object will be stripped away, such
as axis names etc. This is the default behavior. In case of 'struct
array' all the SCIRun Matrix and Nrrd objects will be translated into
sub structures with all the additional SCIRun data put in the fields
of this sub matrix. This module will always convert a field into a
structure.
    </p>
	<p>
    The matlab to bundle converter is a little bit more complicated
since there are more options for conversion. The first parameter
controlling the conversion process is 'prefer matrices' or 'prefer
nrrds'. This option controls whether a matrix is converted into a nrrd
or a matrix. Of course, some objects like sparse matrices can only be
represented by a SCIRun Matrix object and will hence be translated so.
The same is true for matrices with a dimension higher than two, these
can only become nrrds. For the others there are two representations
possible, this option just specifies the preference the user has. Note
that matrices and nrrds in the Bundled Stream can be inserted as nrrds
and read out matrices. One thing one should keep in mind that in the
matlab converter the first dimension of a nrrd is assumed to be the
rows space and secondly the column space. Some functions expect the
opposite order. Unfortunately the order is not specified in the nrrd
object. In case you run into unexpected transposed matrices, use the
built in function of the BundleGetMatrix and BundleGetNrrd to do these
transpose operations.
    </p>
	<p>
    A second choice is whether the substructure represent bundles or
scirun objects like fields, nrrds, and matrices. When a field in
matlab is a dense, sparse or a string the conversion is obvious.
However when it is a structure it can be split into a sub bundle with
all the fields being separate objects or they can represent more
complicate objects such as fields. The default option is 'prefer
sciobjects', which will first try to see if the fields correspond to
any of the object defined in SCIRun. For example when a subarray has a
field called 'node' it will be translated into a field. If no suitable
conversion can be found it will be translated into a bundle. In case
of 'prefer bundles' all substructures will be bundles again. This
means sno fields will be generated and the translation will be a
bundle with subbundles that contain only nrrds and matrices.
    </p>
    
      </section> 

      <section>
	<title>Overview Matlab/MatlabBundle module mechanism</title>

	<p>
    This module launches MATLAB as a separate process under control of
SCIRun. The process can be on a remote machine or a local machine. In
case the module is running on a remote machine the communication with
matlab will be through sockets. In the latter case the entry fields in
the middle panel of the GUI will need to be filled out with the IP
address (it will automatically do a DNS lookup), the port number and a
password. A password is only necessary for a remote MATLAB engine that
is configured to require a password when launching MATLAB. The current
implementation has an optional password in the matlabegine.rc, if this
field is left empty no password check is done. The current
implementation does not make use of secure sockets, this
implementation is still under development. In order to run multiple
MATLAB processes simultaneously different sessions can be launched.
Each session on the same machine will share the global workspace in
MATLAB and code is being executed sequentially for all modules making
use of that session. Hence variables declared in the global workspace
can be shared between these matlab modules.
    </p>

	<p>
    Once matlab is launched the intro message will appear in the
MATLAB OUTPUT window. The module needs to be executed in order to
launch matlab, but will then remain active until the module is
destroyed. Alternatively MATLAB can be launched from the MatlabEngine
Status panel in the right lower corner. It can be disconnected using
the 'disconnect' button in the same panel. That the MATLAB process is
kept alive between executions is done to smoothen the executing of
matlab networks and as well to be able to store variables in matlab's
workspace for later usage. However before the module is executed the
translation table of SCIRun objects to matlab objects needs to be
setup. This is accomplished by connecting the SCIRun object to one of
the input ports on the module. Note that there are ports for Matrices,
Fields and Nrrds. In the translation menu the Field section deals with
the translation of fields, the Matrix section with the translation of
Matrices and the Nrrd section with the translation of the nrrds. Each
line in this translation table refers to one set of input and output
ports. First of all the module will need to know how the object should
be called in MATLAB, it is going to be a matlab array and thus needs
to have a name. Then depending on the SCIRun object the object can be
translated into structured arrays or numeric arrays, whose numeric
format can be set as well. See the sections below for more details.
Then at the end of the line the name of the matlab array that needs to
be translated back into a SCIRun object. Here a name is sufficient as
the translation process will do the rest. The name can be the same as
the input array, but it might refer to another array as well.
    </p>

	<p>
    The process of running code in MATLAB is accomplished as follows:
SCIRun will translate the SCIRun objects into matlab compatible
objects and write them in a file and then instructs matlab to read
this file. Since all communication is through the stdin of matlab,
using files makes sure that the data does not have to be written out
in ASCII readable code. The module is smart enough to recognize that
it translated objects before. If this is the case it will not do the
translation again and it will use the file already generated. When
loading data into matlab the objects that were already there with the
same name will be overwritten. Subsequently the module will take the
code the user entered in the GUI and wrap it in a 'try/catch'
environment and execute it in matlab. All output generated on the
stdout will be displayed in the module. It will write a tag of when
the code starts executing as well one on when the code finished
executing. These are markers for the module to keep track of when
matlab finishes executing code. Please make sure that your progam does
NOT generate output that resembles these markers as it will confuse
the Matlab Interface. Once the end marker is encountered, the module
will instruct matlab to save the variables in the workspace so they
can be read in by SCIRun.
    </p>

	<p>
    The third window on the bottom will show the current status of the
matlab engine. Note: when session 0 is requested a new session number
will be assigned to the matlab process, which has not been used
before. The new session number will appear in this status window. This
option can be used to give each MatlabInterface Module its own matlab
process running in the background. 
    </p>  
      </section>

      <section>
	<title>Local configuration</title>

	<p>
    Before the module can be used, SCIRun needs to know how to run
matlab on the local machine. This is accomplished by the configuration
file 'matlabengine.rc', which will be created in the SCIRun/services
directory in your local HOME directory. This file is copied out of the
src tree the first time SCIRun is run. This file configures how matlab
should be run. Edit the line 'startmatlab=' to instruct SCIRun how
matlab should be started from an 'sh'-compatible shell. If matlab can
already be found using the PATH settings in the shell launching
SCIRun, this line probably does not need to be altered. All other
fields in this file refer to running matlab on a remote machine. In
case SCIRun will not be able to launch matlab a message will be
displayed asking to check the configuration file.
    </p>

	<p>
    To open a matlab process on the local machine the 'MATLAB ENIGNE
ADDRESS' in the GUI needs to have an empty Address and does not
require a port. SCIRun will in this case automatically launch matlab
locally. In the latter case no password checks are done. The local
manager does support multiple sessions. To clarify the word session: a
session is a matlab process. When multiple Matlab modules make use of
the same session the workspace in matlab is shared. Hence one module
can be used to load a large matrix into matlab, whereas another one
can be used to iterate over a process with small matrices, while using
the big matrix stored by the first one. This will allow for some
efficiency improvements.
    </p>    

      </section>

      <section>
	<title>Remote configuration</title>
    
	<p> In order to run matlab on a different machine then SCIRun,
a small server program needs to be run on the remote machine. The
latter is called 'scirunremote', this program sets up a socket for
listening and launches matlab when a request is made on its socket.
This program uses the same 'matlabengine.rc' file as the module
(though it will look in the local HOME directory of the remote
machine). This configuration file can be used to set a password,
restrict login to only certain machines in a certain domain. Currently
the communication is over an open socket in the future an openssl
implementation will be used for secure connections. In order to launch
the scirunremote program, type 'scirunremote -port 5678', or which
ever port you want to use. The latter program must be run on the
remote system and serves as a daemon for starting all kinds of
external programs. When launching this application a list of services
will be displayed. For the matlab engine to work properly two services
need to be switched on: matlabengine and matlabenginefiletransfer. The
currently implementation requires the last one even if there is a
shared home directory. In the latter case no files are transfered, and
only the names of the directories in which temporary files are stored
are exchanged. The latter mechanism will reduce the amount of network
traffic and hopefully speed up the function of this module.
    </p>
      </section>

      <section>
	<title>Configuration file</title>	
	<p>
    This section shortly lists the different options that can be set
in the configuration file 'SCIRun/services/matlabengine.rc'
    </p>
	<p>
    START MATLAB: This line describes how a sh-shell should start
matlab. This instruction is executed to launch matlab
    </p>
	<p>
    DISABLE: This will disable the matlabengine in scirunremote. The
service cannot be launched and any request for starting the
matlabengine will be denied.
    </p>
	<p>
    PASSWORD: A simple password, as a first line of defense. Better
ways will follow.
    </p>
	<p>
    RHOSTS: A list of machines that are allowed to log into
scirunremote to request the matlabengine service. This list should
contain all the machines you want to use for running SCIRun. Any
machine not on the list will be denied access. If no machine is listed
all machines are welcome to log in.
    </p>
	<p>
    MATLABTIMEOUT: How long should we wait before giving up. Note that
matlab often needs a couple of minutes to startup. The time entered
here is in seconds.
    </p>
      </section>



      <section>
	<title>See Also </title>
	<p>
	<modref package="MatlabInterface" name="Matlab" />, <modref
package="MatlabInterface" name="MatlabBundleReader" />, <modref
package="MatlabInterface" name="MatlabBundleWriter" />, <modref
package="MatlabInterface" name="MatlabDataReader" />, <modref
package="MatlabInterface" name="MatlabDataWriter" />, <modref
package="MatlabInterface" name="MatlabFieldsReader" />, <modref
package="MatlabInterface" name="MatlabFieldsWriter" />, <modref
package="MatlabInterface" name="MatlabMatricesReader" />, <modref
package="MatlabInterface" name="MatlabFieldsReader" />, <modref
package="MatlabInterface" name="MatlabMatricesWriter" />, <modref
package="MatlabInterface" name="MatlabMatricesWriter" />	
	</p>
      </section>  


    </description>
  </overview>
  <io>
    <inputs lastportdynamic="no">
      <port>
        <name>bundle1</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle2</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle3</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle4</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle5</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
    </inputs>
    <outputs>
      <port>
        <name>bundle1</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle2</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle3</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle4</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
      <port>
        <name>bundle5</name>
        <datatype>SCIRun::Bundle</datatype>
      </port>
    </outputs>
  </io>
</component>












