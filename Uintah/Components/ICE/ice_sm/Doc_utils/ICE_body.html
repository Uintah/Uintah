<HTML>
<HEAD><TITLE>UINTAH-ICE CFD FUNCTION DESCRIPTIONS</TITLE></HEAD>
<BODY BGCOLOR="#F5DEB3">
<FONT SIZE="3">

<A NAME="topofpage"></A>
<PRE>
<H1>Uintah ICE Function descriptions</H1>

<H2>Introduction</H2>

The following contains a list of the functions that are currently being
used in the Uintah-ICE CFD code.
<H2>General Coding Conventions:</H2>
To be filled in.



<EM>Version 1.0</EM><P>

<EM>If you have any suggestions regarding the font
size or the colors that are used in this page please let me know.  
Thanks,
Todd</EM><P>

Tue May 23 08:54:28 MDT 2000


<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="main">main</A>  Main program</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: main.c 
 Filename: main.c 
 Purpose:    This is the main program for the Uintah ICE cfd code. 

History: 
Version   Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       02/22/99                               
                                                                    
    Programming Conventions
        i, j, k         Loop indices for the x, y, z directions respectively
        f               is a loop index for face-centered values.
        m               Loop index for the different materials

                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face

 STEPS:
    - Set some eviromnental variables required for PGPLOT
    - Initialize some variables that are mainly used in testing
    - MEMORY SECTION: Allocate the memory needed for all of the arrays
      For all of the face-centered arrays set equate the common face addresses
      [i][j][k][RIGHT][m] = [i-1][j][k][LEFT][m]
    - PROBLEM INITIALIZATION SECTION: Read in the input file, test the inputs,
      set the boundary condtions, generate the grid
    - MAIN LOOP
        to be filled in
_____________________________________________________________________*/</FONT> 
<A href="#main">main</A>)
{
    int i, j, k, m, 
        xLoLimit,                       <FONT COLOR="570BA3">/* x array lower limits             */</FONT>
        yLoLimit,                       <FONT COLOR="570BA3">/* y array lower limits             */</FONT>
        zLoLimit,
        xHiLimit,
        yHiLimit,
        zHiLimit,
        printSwitch,
        should_I_write_output,          <FONT COLOR="570BA3">/* flag for dumping output          */</FONT>
        fileNum,                        <FONT COLOR="570BA3">/* tecplot file number              */</FONT>
        stat,                           <FONT COLOR="570BA3">/* status of putenv and getenv      */</FONT>
        **BC_inputs,                    <FONT COLOR="570BA3">/* BC_types[wall][m] that contains  */</FONT>
                                        <FONT COLOR="570BA3">/* the users boundary condition     */</FONT>
                                        <FONT COLOR="570BA3">/* selection for each wall          */</FONT>
        ***BC_types,                    <FONT COLOR="570BA3">/* each variable can have a Neuman, */</FONT>
                                        <FONT COLOR="570BA3">/* or Dirichlet type BC             */</FONT>
                                        <FONT COLOR="570BA3">/* BC_types[wall][variable][m]=type */</FONT>
        ***BC_float_or_fixed,           <FONT COLOR="570BA3">/* BC_float_or_fixed[wall][variable][m]*/</FONT>
                                        <FONT COLOR="570BA3">/* Variable on boundary is either   */</FONT>
                                        <FONT COLOR="570BA3">/* fixed or it floats during the    */</FONT>
                                        <FONT COLOR="570BA3">/* compuation                       */</FONT>
        nMaterials;                     <FONT COLOR="570BA3">/* Number of materials              */</FONT>

                                        
<FONT COLOR="570BA3">/* ______________________________   
*  Geometry                        
* ______________________________   */</FONT>     
     double  delX,                      <FONT COLOR="570BA3">/* Cell width                       */</FONT>
             delY,                      <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
             delZ,                      <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
             delt,                      <FONT COLOR="570BA3">/* time step                        */</FONT>
             CFL,                       <FONT COLOR="570BA3">/* Courant-Friedrichs and Lewy      */</FONT>
             t_final,                   <FONT COLOR="570BA3">/* final problem time               */</FONT>
            *t_output_vars,             <FONT COLOR="570BA3">/* array holding output timing info */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[1] = t_initial     */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[2] = t final       */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[3] = delta t       */</FONT>
            *delt_limits,               <FONT COLOR="570BA3">/* delt_limits[1]   = delt_minimum  */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[2]   = delt_maximum  */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[3]   = delt_initial  */</FONT>
             t,                         <FONT COLOR="570BA3">/* current time                     */</FONT>
             ***x_CC,                   <FONT COLOR="570BA3">/* x-coordinate of cell center      */</FONT>
             ***y_CC,                   <FONT COLOR="570BA3">/* y-coordinate of cell center      */</FONT>
             ***z_CC,                   <FONT COLOR="570BA3">/* z-coordinate of cell center      */</FONT>
             ***Vol_CC,                 <FONT COLOR="570BA3">/* vol of the cell at the cellcenter*/</FONT>
                                        <FONT COLOR="570BA3">/* (x, y, z)                        */</FONT>
            <FONT COLOR="570BA3">/*------to be treated as pointers---*/</FONT>
             *****x_FC,                 <FONT COLOR="570BA3">/* x-coordinate of face center      */</FONT>
                                        <FONT COLOR="570BA3">/* x_FC(i,j,k,face)                 */</FONT>
                                        <FONT COLOR="570BA3">/* cell i,j,k                       */</FONT>
             *****y_FC,                 <FONT COLOR="570BA3">/* y-coordinate of face center      */</FONT>
                                        <FONT COLOR="570BA3">/* y_FC(i,j,k,face)                 */</FONT>
                                        <FONT COLOR="570BA3">/* of cell i,j,k                    */</FONT>
             *****z_FC;                 <FONT COLOR="570BA3">/* z-coordinate of face center      */</FONT>
                                        <FONT COLOR="570BA3">/* z_FC(i,j,k,face)                 */</FONT>
                                        <FONT COLOR="570BA3">/* of cell i,j,k                    */</FONT>
            <FONT COLOR="570BA3">/*----------------------------------*/</FONT> 

<FONT COLOR="570BA3">/* ______________________________   
*  Cell-centered and Face centered                      
* ______________________________   */</FONT> 
    double                              <FONT COLOR="570BA3">/* (x,y,z,material                  */</FONT>
            ****uvel_CC,                <FONT COLOR="570BA3">/* u-cell-centered velocity         */</FONT>
            ****vvel_CC,                <FONT COLOR="570BA3">/*  v-cell-centered velocity        */</FONT>
            ****wvel_CC,                <FONT COLOR="570BA3">/* w cell-centered velocity         */</FONT>
            ****delPress_CC,            <FONT COLOR="570BA3">/* cell-centered change in pressure */</FONT>                                                                                       
            ****press_CC,               <FONT COLOR="570BA3">/* Cell-centered pressure           */</FONT>
            ****Temp_CC,                <FONT COLOR="570BA3">/* Cell-centered Temperature        */</FONT>
            ****rho_CC,                 <FONT COLOR="570BA3">/* Cell-centered density            */</FONT>
            ****viscosity_CC,           <FONT COLOR="570BA3">/* Cell-centered Viscosity          */</FONT> 
            ****thermalCond_CC,         <FONT COLOR="570BA3">/* Cell-centered thermal conductivity*/</FONT>
            ****cv_CC,                  <FONT COLOR="570BA3">/* Cell-centered specific heat      */</FONT> 
            ****mass_CC,                <FONT COLOR="570BA3">/* total mass, cell-centered        */</FONT>
            ****xmom_CC,                <FONT COLOR="570BA3">/* x-dir momentum cell-centered     */</FONT>
            ****ymom_CC,                <FONT COLOR="570BA3">/* y-dir momentum cell-centered     */</FONT>
            ****zmom_CC,                <FONT COLOR="570BA3">/* z-dir momentum cell-centered     */</FONT>
            ****int_eng_CC,             <FONT COLOR="570BA3">/* Internal energy cell-centered    */</FONT>
            ****total_eng_CC,           <FONT COLOR="570BA3">/* Total energy cell-centered       */</FONT>
            ****div_velFC_CC,           <FONT COLOR="570BA3">/* Divergence of the face centered  */</FONT>
                                        <FONT COLOR="570BA3">/* velocity that lives at CC        */</FONT>    
            ****scalar1_CC,             <FONT COLOR="570BA3">/* Cell-centered scalars            */</FONT>   
            ****scalar2_CC,             <FONT COLOR="570BA3">/* (x, y, z, material)              */</FONT>
            ****scalar3_CC,
            <FONT COLOR="570BA3">/*------to be treated as pointers---*/</FONT>
                                        <FONT COLOR="570BA3">/*______(x,y,z,face, material)______*/</FONT>
            ******uvel_FC,              <FONT COLOR="570BA3">/* u-face-centered velocity         */</FONT>
            ******vvel_FC,              <FONT COLOR="570BA3">/* *v-face-centered velocity        */</FONT>
            ******wvel_FC,              <FONT COLOR="570BA3">/* w face-centered velocity         */</FONT>
            ******press_FC,             <FONT COLOR="570BA3">/* face-centered pressure           */</FONT>
            ******tau_X_FC,             <FONT COLOR="570BA3">/* *x-stress component at each face */</FONT>
            ******tau_Y_FC,             <FONT COLOR="570BA3">/* *y-stress component at each face */</FONT>
            ******tau_Z_FC,             <FONT COLOR="570BA3">/* *z-stress component at each face */</FONT>
            <FONT COLOR="570BA3">/*----------------------------------*/</FONT>                                              
           *grav,                       <FONT COLOR="570BA3">/* gravity (dir)                    */</FONT>
                                        <FONT COLOR="570BA3">/* x-dir = 1, y-dir = 2, z-dir = 3  */</FONT>
            *gamma,
            ****speedSound;             <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) */</FONT>    
             
<FONT COLOR="570BA3">/* ______________________________   
*  Lagrangian Variables            
* ______________________________   */</FONT> 
    double                              <FONT COLOR="570BA3">/*_________(x,y,z,material)_________*/</FONT>
            ****rho_L_CC,               <FONT COLOR="570BA3">/* Lagrangian cell-centered density */</FONT>
            ****mass_L_CC,              <FONT COLOR="570BA3">/* Lagrangian cell-centered mass    */</FONT>
            ****Temp_L_CC,              <FONT COLOR="570BA3">/* Lagrangian cell-centered Temperature */</FONT>
            ****press_L_CC,             <FONT COLOR="570BA3">/* Lagrangian cell-centered pressure*/</FONT>            
            ****xmom_L_CC,              <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum*/</FONT>
            ****ymom_L_CC,              <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum*/</FONT>
            ****zmom_L_CC,              <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum*/</FONT>
            ****int_eng_L_CC,           <FONT COLOR="570BA3">/* Lagrangian cc internal energy    */</FONT>
            ****Vol_L_CC,               <FONT COLOR="570BA3">/* Lagrangian cell-centered volume  */</FONT>
<FONT COLOR="570BA3">/*__________________________________
* source terms
*___________________________________*/</FONT>
            ****mass_source,            <FONT COLOR="570BA3">/* Mass source term (x,y,z, material */</FONT>
            ****xmom_source,            <FONT COLOR="570BA3">/* momentum source terms            */</FONT>
                                        <FONT COLOR="570BA3">/* (x, y, z, material)              */</FONT>
            ****ymom_source,
            ****zmom_source,
            ****int_eng_source,         <FONT COLOR="570BA3">/* internal energy source           */</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   MISC Variables
*___________________________________*/</FONT>            
            ***BC_Values,                <FONT COLOR="570BA3">/* BC values BC_values[wall][variable][m]*/</FONT>  
            *R;                         <FONT COLOR="570BA3">/* gas constant R[material]          */</FONT> 
                             
    double  residual,                   <FONT COLOR="570BA3">/* testing*/</FONT>            
            x1, x2,
            temp1,
            temp2,
            u0,
            u1,
            u2,
            uL,
            uR;
            
    char    output_file_basename[30],   <FONT COLOR="570BA3">/* Tecplot filename description     */</FONT>
            output_file_desc[50];       <FONT COLOR="570BA3">/* Title used in tecplot stuff      */</FONT>



<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if (switchDebug_main == 1|| switchDebug_main == 2 || switchDebug_main_input == 1)
    #include "plot_declare_vars.h"   
#endif
    stat = putenv("PGPLOT_DIR=/usr/people/harman/Csafe/Uintah_cfd_code/Libraries");
    stat = putenv("PGPLOT_I_AM_HERE=0");              
                                        <FONT COLOR="570BA3">/* tell the plotting routine that  */</FONT>
                                        <FONT COLOR="570BA3">/* you're at the top of main       */</FONT>      

    stat = putenv("PGPLOT_PLOTTING_ON_OFF=1");
    stat = putenv("PGPLOT_OPEN_NEW_WINDOWS=1");  

<FONT COLOR="570BA3">/*______________________________________________________________________
*   Initialize variables
*_______________________________________________________________________*/</FONT> 
    printSwitch = 1;    
    t           = 0.0;  
    m           = 1;
    fileNum     = 1;

<FONT COLOR="570BA3">/*______________________________________________________________________ 
*                       MEMORY SECTION
*  Allocate memory for the arrays                                          
*_______________________________________________________________________*/</FONT>

#include "allocate_memory.i"
 <FONT COLOR="570BA3">/*__________________________________
* Needed by Steve Parkers Malloc library
*___________________________________*/</FONT>    
    <FONT COLOR="570BA3">/* fpsetmask(FP_X_UFL|FP_X_OFL|FP_X_DZ|FP_X_INV); */</FONT>
    <FONT COLOR="570BA3">/* audit(); */</FONT>                      <FONT COLOR="570BA3">/* Steve Parkers memory tool        */</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*
*                       PROBLEM INITIALIZATION SECTION
*   Initializing routines                                                  
*   First read the problem input then test the inputs.                     
* -----------------------------------------------------------------------  */</FONT>
                                        
       <A href="#readInputFile">readInputFile</A>   &amp;xLoLimit,      &amp;yLoLimit,      &amp;zLoLimit,     
                        &amp;xHiLimit,      &amp;yHiLimit,      &amp;zHiLimit,
                        &amp;delX,          &amp;delY,          &amp;delZ,
                        uvel_CC,        vvel_CC,        wvel_CC, 
                        Temp_CC,        press_CC,       rho_CC,
                        scalar1_CC,     scalar2_CC,     scalar3_CC,
                        viscosity_CC,   thermalCond_CC, cv_CC,
                        R,              gamma,
                        &amp;t_final,       t_output_vars,  delt_limits,
                        output_file_basename,           output_file_desc,       
                        grav,           speedSound,
                        BC_inputs,      BC_Values,      &amp;CFL,
                        &amp;nMaterials);      
    
    <A href="#testInputFile">testInputFile</A>      xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        Temp_CC,        press_CC,       rho_CC,
                        viscosity_CC,   thermalCond_CC, cv_CC,
                        speedSound,      
                        t_final,        t_output_vars,  delt_limits,
                        BC_inputs,      printSwitch,    CFL,
                        nMaterials); 
                   
    <A href="#definition_of_different_physical_boundary_conditions">definition_of_different_physical_boundary_conditions</A>              
                        BC_inputs,      BC_types,       BC_float_or_fixed,
                        BC_Values,      nMaterials  );  
                        
<FONT COLOR="570BA3">/*__________________________________
* Now make sure that the face centered
* values know about each other.
* for example 
* [i][j][k][RIGHT][m] = [i-1][j][k][LEFT][m]
*___________________________________*/</FONT>  

    <A href="#equate_ptr_addresses_adjacent_cell_faces">equate_ptr_addresses_adjacent_cell_faces</A>              
                        x_FC,           y_FC,           z_FC,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        press_FC,
                        tau_X_FC,       tau_Y_FC,       tau_Z_FC,
                        nMaterials);   

    <FONT COLOR="570BA3">/*__________________________________
    * Generate a grid
    *___________________________________*/</FONT> 
    <A href="#generateGrid">generateGrid</A>       xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        x_CC,           y_CC,           z_CC,   Vol_CC,  
                        x_FC,           y_FC,           z_FC );
    <FONT COLOR="570BA3">/*__________________________________
    *   zero the face-centered arrays
    *___________________________________*/</FONT>
    <A href="#zero_arrays_6d">zero_arrays_6d</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,
                        1,              N_CELL_FACES,
                        1,              nMaterials,     
                        7,             
                        uvel_FC,        vvel_FC,        wvel_FC,
                        press_FC,
                        tau_X_FC,       tau_Y_FC,       tau_Z_FC);                         
    stat = putenv("PGPLOT_PLOTTING_ON_OFF=1");
                            
    <FONT COLOR="570BA3">/*  audit();  */</FONT>                    <FONT COLOR="570BA3">/* Steve Parkers memory tool    */</FONT>   
<FONT COLOR="570BA3">/*______________________________________________________________________
*  TESTING: HARDWIRE SOME OF THE INPUTS
*       HARDWIRE FOR NOW
*   Comment this out 
*_______________________________________________________________________*/</FONT>
#if switchOveride_Initial_Conditions                               
  #include "overide_initial_conds.i"
#endif 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Plot the inputs (MUST HARDWIRE WHAT YOU WANT TO VIEW)
*   To keep the code clean I moved the code to another file
*_______________________________________________________________________*/</FONT>
#if switchDebug_main_input
    #define switchInclude_main_1 1
    #include "debugcode.i"
    #undef switchInclude_main_1
#endif     
<FONT COLOR="570BA3">/*__________________________________
*   For the first time through
*   set some variables
*___________________________________*/</FONT>
    delt    = delt_limits[3];              
    t       = delt;
    fprintf(stderr,"\nInitial time %f, timestep is %f\n",t,delt);
<FONT COLOR="570BA3">/*______________________________________________________________________
*                        MAIN ADVANCE LOOP
*_______________________________________________________________________*/</FONT>                       
    while( t &lt;= t_final)
    {
         should_I_write_output = <A href="#Is_it_time_to_write_output">Is_it_time_to_write_output</A> t, t_output_vars  );
        <FONT COLOR="570BA3">/* fprintf(stderr, "should _ I write_output %i\n",should_I_write_output); */</FONT>




<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
<FONT COLOR="570BA3">/*      initialize_darray_4d(
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        press_CC,        m,
                        1.0,            1,              0);
                          
   <A href="#initialize_darray_4d">initialize_darray_4d</A>
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        Temp_CC,        m,
                        1.0,            1,              0);  
                         
    <A href="#initialize_darray_4d">initialize_darray_4d</A>
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        rho_CC,        m,
                        1.0,            1,              0);  */</FONT>     
                        
                        
<FONT COLOR="570BA3">/*  initialize_darray_4d(
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        uvel_CC,        m,
                        1.0,            1,              0); 
                       
     <A href="#initialize_darray_4d">initialize_darray_4d</A>
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        vvel_CC,        m,
                        1.0,            2,              0);     */</FONT> 
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>         



    <FONT COLOR="570BA3">/*__________________________________
    * update the physical boundary conditions
    * and initialize some arrays
    *___________________________________*/</FONT>                        
    <A href="#update_CC_FC_physical_boundary_conditions">update_CC_FC_physical_boundary_conditions</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        BC_types,       BC_float_or_fixed,
                        BC_Values, 
                        nMaterials,     3,                 
                        uvel_CC,        UVEL,           uvel_FC,
                        vvel_CC,        VVEL,           vvel_FC,
                        wvel_CC,        WVEL,           wvel_FC);
                        
    <A href="#update_CC_physical_boundary_conditions">update_CC_physical_boundary_conditions</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        BC_types,       BC_float_or_fixed,
                        BC_Values, 
                        nMaterials,     3,                 
                        Temp_CC,TEMP,   rho_CC,DENSITY, press_CC,PRESS);
                        
    <A href="#zero_arrays_4d">zero_arrays_4d</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,
                        1,              nMaterials,     8,             
                        mass_source,    delPress_CC,    int_eng_source,  
                        xmom_source,    ymom_source,    zmom_source,
                        Vol_L_CC,       mass_CC);


<FONT COLOR="570BA3">/*__________________________________
*   Find the new time step based on the
*   Courant condition
*___________________________________*/</FONT>        
        <A href="#find_delta_time_based_on_CC_vel">find_delta_time_based_on_CC_vel</A>
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        &amp;delt,           delt_limits,
                        delX,            delY,          delZ,
                        uvel_CC,         vvel_CC,       wvel_CC,
                        speedSound,      CFL,           nMaterials );
 <FONT COLOR="570BA3">/*__________________________________
 *  STEP 1
 *  Use the equation of state to get
 *  P at the cell center
 *___________________________________*/</FONT>
#if switch_step1_OnOff
        <A href="#equation_of_state">equation_of_state</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        R,
                        press_CC,       rho_CC,         Temp_CC,
                        cv_CC,          nMaterials   );
                        
        <A href="#speed_of_sound">speed_of_sound</A>
                        xLoLimit,       yLoLimit,       zLoLimit,       
                        xHiLimit,       yHiLimit,       zHiLimit,       
                        gamma,          R,              Temp_CC,     
                        speedSound,     nMaterials   );
#endif

<FONT COLOR="570BA3">/*__________________________________
*   STEP 2
*   Use Euler's equation thingy to solve
*   for the n+1 Lagrangian press (CC)
*   and the n+1 face centered fluxing
*   velocity
*___________________________________*/</FONT> 
 <FONT COLOR="570BA3">/*__________________________________
*   Take (*)vel_CC and interpolate it to the 
*   face-center.  Advection operator needs
*   uvel_FC and so does the pressure solver
*___________________________________*/</FONT> 
        stat = putenv("PGPLOT_PLOTTING_ON_OFF=1"); 
        <A href="#compute_face_centered_velocities">compute_face_centered_velocities</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        delt,           
                        BC_types,       BC_float_or_fixed,
                        BC_Values,
                        rho_CC,         grav,           press_CC,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        nMaterials ); 
                        
                        
        <A href="#divergence_of_face_centered_velocity">divergence_of_face_centered_velocity</A>  
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        div_velFC_CC,   nMaterials); 
        stat = putenv("PGPLOT_PLOTTING_ON_OFF=1");


#if switch_step2_OnOff                        
  
    explicit_delPress
             (  
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        div_velFC_CC,
                        delPress_CC,    press_CC,
                        rho_CC,         delt,           speedSound,
                        nMaterials );
                
    <A href="#update_CC_physical_boundary_conditions">update_CC_physical_boundary_conditions</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        BC_types,       BC_float_or_fixed,
                        BC_Values, 
                        nMaterials,     1,                 
                        delPress_CC,    DELPRESS);
                                            
    <FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT>                                           
    #if switch_explicit_implicit                        
        <A href="#compute_delta_Press_Using_PCGMG">compute_delta_Press_Using_PCGMG</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        delt,           rho_CC,         speedSound,     
                        uvel_FC,        vvel_FC,        wvel_FC,
                        delPress_CC,    press_CC,       BC_types,
                        nMaterials ) ;  

                            
    <FONT COLOR="570BA3">/*__________________________________
    *   Now update the face centered velocity
    *   using the linear approximation to the
    *   time advance pressure
    *___________________________________*/</FONT>
        fprintf(stderr, "I've computed delpress_CC\n");
       <A href="#compute_face_centered_velocities">compute_face_centered_velocities</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        delt, 
                        BC_types,       BC_float_or_fixed,
                        BC_Values,
                        rho_CC,         grav,           press_CC,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        nMaterials );
    
                  
        <A href="#update_CC_FC_physical_boundary_conditions">update_CC_FC_physical_boundary_conditions</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        BC_types,       BC_float_or_fixed,
                        BC_Values, 
                        nMaterials,     1,                 
                        press_CC,       PRESS,          press_FC);               
    #endif  
    <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>                      

   
         <A href="#press_eq_residual">press_eq_residual</A>
                        xLoLimit,       yLoLimit,       zLoLimit,            
                        xHiLimit,       yHiLimit,       zHiLimit,            
                        delX,           delY,           delZ,
                        delt,           rho_CC,         speedSound,      
                        uvel_FC,        vvel_FC,        wvel_FC,       
                        delPress_CC,    press_CC,       &amp;residual,
                        nMaterials); 
                        
                            
#endif 
    <FONT COLOR="570BA3">/* audit(); */</FONT> 
    
   
<FONT COLOR="570BA3">/* ______________________________   
*   STEP 3 
*   Compute the face-centered pressure
*   using the "continuity of acceleration"
*   principle                     
* ______________________________   */</FONT>
#if switch_step3_OnOff                                  
        <A href="#press_face">press_face</A>         
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        press_CC,       press_FC,       rho_CC, 
                        nMaterials );
#endif
    <FONT COLOR="570BA3">/*__________________________________
    *
    *___________________________________*/</FONT>
    <A href="#update_CC_FC_physical_boundary_conditions">update_CC_FC_physical_boundary_conditions</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        BC_types,       BC_float_or_fixed,
                        BC_Values, 
                        nMaterials,     1,                 
                        press_CC,       PRESS,          press_FC);


<FONT COLOR="570BA3">/* ______________________________  
*   STEP 4                          
*   Compute ssources of mass, momentum and energy
*   For momentum, there are sources
*   due to mass conversion, gravity
*   pressure, divergence of the stress
*   and momentum exchange
* ______________________________   */</FONT>
#if (switch_step4_OnOff == 1 &amp;&amp; switch_Compute_burgers_eq == 0) 
    <A href="#accumulate_momentum_source_sinks">accumulate_momentum_source_sinks</A>
                        xLoLimit,       yLoLimit,       zLoLimit,                  
                        xHiLimit,       yHiLimit,       zHiLimit,                  
                        delt,                      
                        delX,           delY,           delZ,                      
                        grav,                  
                        mass_CC,        rho_CC,         press_FC,            
                        Temp_CC,        cv_CC,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        tau_X_FC,       tau_Y_FC,       tau_Z_FC,               
                        viscosity_CC,              
                        xmom_source,    ymom_source,    zmom_source,           
                        nMaterials   ); 

 
   <A href="#accumulate_energy_source_sinks">accumulate_energy_source_sinks</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delt,            
                        delX,           delY,           delZ,    
                        grav,           mass_CC,        rho_CC,          
                        press_CC,       delPress_CC,    Temp_CC,         
                        cv_CC,          speedSound,     
                        uvel_CC,        vvel_CC,        wvel_CC,
                        div_velFC_CC,         
                        int_eng_source,  
                        nMaterials   );

#endif


<FONT COLOR="570BA3">/*__________________________________
*   STEP 5                     
*   Compute Lagrangian values for the volume 
*   mass, momentum and energy.
*   Lagrangian values are the sum of the time n
*   values and the sources computed in 4
*___________________________________*/</FONT>
#if switch_step5_OnOff 
    <A href="#lagrangian_vol">lagrangian_vol</A>     xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        delt,           
                        Vol_L_CC,       Vol_CC,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        nMaterials);
                        
    <A href="#calc_flux_or_primitive_vars">calc_flux_or_primitive_vars</A>    -1,           
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        rho_CC,         Vol_CC,         
                        uvel_CC,        vvel_CC,        wvel_CC,        
                        xmom_CC,        ymom_CC,        zmom_CC,
                        cv_CC,          int_eng_CC,     Temp_CC,
                        nMaterials );                       
                        
    <A href="#lagrangian_values">lagrangian_values</A>  
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        Vol_L_CC,       Vol_CC,         rho_CC,
                        rho_L_CC,
                        xmom_CC,        ymom_CC,        zmom_CC,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        xmom_L_CC,      ymom_L_CC,      zmom_L_CC,
                        mass_L_CC,      mass_source,    
                        xmom_source,    ymom_source,    zmom_source,
                        int_eng_CC,     int_eng_L_CC,   int_eng_source,
                        nMaterials);
#endif  
                                     
<FONT COLOR="570BA3">/*_________________________________   
*   STEP 6                           
*   Compute the advection of mass,
*   momentum and energy.  These
*   quantities are advected using the face
*   centered velocities velocities from 2
*                  
*   STEP 7
*   Compute the time advanced values for
*   mass, momentum and energy.  "Time advanced"
*   means the sum of the "Lagrangian" values,
*   found in 5 and the advection contribution
*   from 6                      
*______________________________ */</FONT>  
#if (switch_step7_OnOff== 1 || switch_step6_OnOff == 1)
     <A href="#advect_and_advance_in_time">advect_and_advance_in_time</A>   
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        Vol_CC,         rho_CC,
                        xmom_CC,        ymom_CC,        zmom_CC,
                        Vol_L_CC,       rho_L_CC,       mass_L_CC,
                        xmom_L_CC,      ymom_L_CC,      zmom_L_CC,
                        int_eng_CC,     int_eng_L_CC,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        delt,           nMaterials);

         
    <FONT COLOR="570BA3">/*__________________________________
    *   Backout the velocities from the 
    *   the momentum
    *___________________________________*/</FONT>                        
    <A href="#calc_flux_or_primitive_vars">calc_flux_or_primitive_vars</A>    1,           
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        rho_CC,         Vol_CC,         
                        uvel_CC,        vvel_CC,        wvel_CC,        
                        xmom_CC,        ymom_CC,        zmom_CC,
                        cv_CC,          int_eng_CC,     Temp_CC,
                        nMaterials ); 
#endif
    
     <FONT COLOR="570BA3">/* audit(); */</FONT>                     <FONT COLOR="570BA3">/* Steve Parkers memory tool        */</FONT>

<FONT COLOR="570BA3">/*__________________________________
*   Write to tecplot files
*___________________________________*/</FONT>     
     
#if tecplot
    if ( should_I_write_output == YES)
    {                     
        <A href="#tecplot_CC">tecplot_CC</A>         
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        x_CC,           y_CC,           z_CC,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        press_CC,       Temp_CC,        rho_CC,
                        scalar1_CC,     scalar2_CC,     scalar3_CC,
                        fileNum,        output_file_basename,       output_file_desc,
                        nMaterials);

        <A href="#tecplot_FC">tecplot_FC</A>         
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        x_FC,           y_FC,           z_FC,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        fileNum,        output_file_basename,       output_file_desc,
                        nMaterials );
                            
        fileNum ++;
    } 
#endif 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION
*_______________________________________________________________________*/</FONT>
#if switchDebug_main
    if ( should_I_write_output == YES)
    {
         #define switchInclude_main 1
         #include "debugcode.i"
         #undef switchInclude_main
         
      <FONT COLOR="570BA3">/*   fprintf(stderr,"\npress return to continue\n"); 
        getchar();  */</FONT> 
    }
#endif
         <FONT COLOR="570BA3">/*__________________________________
         *  Clean up the plotting windows 
         *___________________________________*/</FONT>
         putenv("PGPLOT_I_AM_HERE=1");              
                                         <FONT COLOR="570BA3">/* tell the plotting routine that   */</FONT>
                                         <FONT COLOR="570BA3">/* you're at the bottom of main     */</FONT>
         putenv("PGPLOT_OPEN_NEW_WINDOWS=1"); 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now advance in time
*_______________________________________________________________________*/</FONT>
      
<FONT COLOR="570BA3">/*         find_delta_time_based_on_FC_vel(
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        &amp;delt,           delt_limits,
                        delX,            delY,          delZ,
                        uvel_FC,         vvel_FC,       wvel_FC,
                        speedSound,      CFL,           nMaterials ); */</FONT>
                        
        <A href="#find_delta_time_based_on_CC_vel">find_delta_time_based_on_CC_vel</A>
                        xLoLimit,        yLoLimit,      zLoLimit,
                        xHiLimit,        yHiLimit,      zHiLimit,
                        &amp;delt,           delt_limits,
                        delX,            delY,          delZ,
                        uvel_CC,         vvel_CC,       wvel_CC,
                        speedSound,      CFL,           nMaterials );
           
        t = t + delt;
        fprintf(stderr,"\nTime is %f, timestep is %f\n",t,delt);
 
 }
<FONT COLOR="570BA3">/* -----------------------------------------------------------------------  
*  Free the memory  and Finalize petsc                                                  
* -----------------------------------------------------------------------  */</FONT>
    fprintf(stderr,"Now deallocating memory");
    #include "free_memory.i"

    #if switch_explicit_implicit 
        PetscFinalize();
    #endif    
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn compiler remarks
*___________________________________*/</FONT>
    i = i;      j = j;      k = k;    
    residual    = residual;
    temp1       = temp1;
    temp2       = temp2;
    QUITE_FULLWARN(stat);                       
    QUITE_FULLWARN(fileNum); 

    return(1);
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="readInputFile">readInputFile</A>  INPUT: Controller for reading in the input file.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: input.c
 Filename: input.c
 Purpose:
   Read the problem input file   

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   

 ---------------------------------------------------------------------- */</FONT>

    void <A href="#readInputFile">readInputFile</A>    
           int     *xLoLimit,
           int     *yLoLimit,
           int     *zLoLimit,
           int     *xHiLimit,
           int     *yHiLimit,
           int     *zHiLimit,
           double  *delX,
           double  *delY,
           double  *delZ,               <FONT COLOR="570BA3">/* (*)_CC (i, j, k, material)       */</FONT>
           double  ****uvel_CC,         <FONT COLOR="570BA3">/* u-cell-centered velocity         */</FONT>
           double  ****vvel_CC,         <FONT COLOR="570BA3">/* v-cell-centered velocity         */</FONT>
           double  ****wvel_CC,         <FONT COLOR="570BA3">/* w-cell-centered velocity         */</FONT>
           double  ****Temp_CC,         <FONT COLOR="570BA3">/* Cell-centered temperature        */</FONT>
           double  ****Press_CC,        <FONT COLOR="570BA3">/* Cell-centered pressure           */</FONT>
           double  ****rho_CC,          <FONT COLOR="570BA3">/* Cell-centered density            */</FONT>
           double  ****scalar1_CC,
           double  ****scalar2_CC,
           double  ****scalar3_CC,
           double  ****viscosity_CC,    <FONT COLOR="570BA3">/* Cell-centered Viscosity          */</FONT>
           double  ****thermalCond_CC,  <FONT COLOR="570BA3">/* Cell-centered thermal conductivity*/</FONT>
           double  ****cv_CC,           <FONT COLOR="570BA3">/* Cell-centered constant cp        */</FONT>
           double  *R,                  <FONT COLOR="570BA3">/* Gas constant R[m]                */</FONT>
           double  *gamma,              <FONT COLOR="570BA3">/* ratio of specific heats          */</FONT>
           double  *t_final,            <FONT COLOR="570BA3">/* Time final                       */</FONT>
           double  *t_output_vars,      <FONT COLOR="570BA3">/* array holding output timing info */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[1] = t_initial     */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[2] = t final       */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[3] = delta t       */</FONT>
           double  *delt_limits,        <FONT COLOR="570BA3">/* delt_limits[1] = delt_min        */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[2] = delt_max        */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[3] = delt_initial interation*/</FONT>
           char    output_file_basename[],
           char    output_file_desc[],
           double  *grav,               <FONT COLOR="570BA3">/* gravity (dir)                    */</FONT>
           double  ****speedSound,      <FONT COLOR="570BA3">/* speed of sound (x, y, z, material*/</FONT>
           int     **BC_inputs,         <FONT COLOR="570BA3">/* array containing the different   */</FONT>
                                        <FONT COLOR="570BA3">/* types of boundary conditions     */</FONT>   
                                        <FONT COLOR="570BA3">/* at each wall [wall][m]           */</FONT>
           double  ***BC_Values,        <FONT COLOR="570BA3">/* BC values BC_values[wall][variable][m]*/</FONT>
           double  *CFL,
            int    *nMaterials         )
            
{

    int     i,j,k,m,
            counter;                    <FONT COLOR="570BA3">/* used in debugging code           */</FONT>      

    char    filename[]="if";      
    FILE    *fp;
<FONT COLOR="570BA3">/*______________________________________________________________________
* Initialize local variables
*_______________________________________________________________________*/</FONT>
    counter =0;
<FONT COLOR="570BA3">/*__________________________________
* Open the file
*___________________________________*/</FONT>
<FONT COLOR="570BA3">/*      printf("Input the input file name\n");
    scanf("%s",filename);  */</FONT>
    
    
    
    fp = fopen(filename,"r");
    if(fp == NULL)
        <A href="#Message">Message</A>1,"File: input.c","Subroutine: input","Error: Couldn't open the input data file");
<FONT COLOR="570BA3">/*__________________________________
* Now read the file description
* 
*___________________________________*/</FONT>
       
    <A href="#readstring">readstring</A>fp,output_file_basename," output file basename",switchDebug_readInputFile);
    <A href="#readstring">readstring</A>fp,output_file_desc," output file desc",switchDebug_readInputFile);  
<FONT COLOR="570BA3">/*__________________________________
* Geometry Section
*___________________________________*/</FONT>           
   *delX                                            = <A href="#readdouble">readdouble</A>fp," Delta_X",switchDebug_readInputFile);
   *delY                                            = <A href="#readdouble">readdouble</A>fp," Delta_Y",switchDebug_readInputFile);
   *delZ                                            = <A href="#readdouble">readdouble</A>fp," Delta_Z",switchDebug_readInputFile);
 
   *xLoLimit                                        = <A href="#readint">readint</A>fp," Initial index x-dir",switchDebug_readInputFile);
   *yLoLimit                                        = <A href="#readint">readint</A>fp," Initial index y-dir",switchDebug_readInputFile);
   *zLoLimit                                        = <A href="#readint">readint</A>fp," Initial index z-dir",switchDebug_readInputFile);
 
   *xHiLimit                                        = <A href="#readint">readint</A>fp," n _cells x-dir.",switchDebug_readInputFile);
   *yHiLimit                                        = <A href="#readint">readint</A>fp," n _cells y-dir.",switchDebug_readInputFile);
   *zHiLimit                                        = <A href="#readint">readint</A>fp," n _cells z-dir.",switchDebug_readInputFile);
   *nMaterials                                      = <A href="#readint">readint</A>fp," Number of Materials",switchDebug_readInputFile);
   *CFL                                             = <A href="#readdouble">readdouble</A>fp," CFL",switchDebug_readInputFile);

<FONT COLOR="570BA3">/*__________________________________
* Time variables
*___________________________________*/</FONT>
    *t_final                                        = <A href="#readdouble">readdouble</A>fp," Final time",switchDebug_readInputFile);
    t_output_vars[1]                                = <A href="#readdouble">readdouble</A>fp," t_initial_output",switchDebug_readInputFile);
    t_output_vars[2]                                = <A href="#readdouble">readdouble</A>fp," t_final_output",switchDebug_readInputFile);
    t_output_vars[3]                                = <A href="#readdouble">readdouble</A>fp," t_delta_output",switchDebug_readInputFile);
    delt_limits[1]                                  = <A href="#readdouble">readdouble</A>fp," delt_minimum",switchDebug_readInputFile);
    delt_limits[2]                                  = <A href="#readdouble">readdouble</A>fp," delt_maximum",switchDebug_readInputFile);
    delt_limits[3]                                  = <A href="#readdouble">readdouble</A>fp," delt_initial_iter",switchDebug_readInputFile);

<FONT COLOR="570BA3">/*__________________________________
*   Body Force  
*___________________________________*/</FONT>
    grav[1]                                         = <A href="#readdouble">readdouble</A>fp," gravity x-dir",switchDebug_readInputFile);  
    grav[2]                                         = <A href="#readdouble">readdouble</A>fp," gravity y-dir",switchDebug_readInputFile);
    grav[3]                                         = <A href="#readdouble">readdouble</A>fp," gravity z-dir",switchDebug_readInputFile);
    
<FONT COLOR="570BA3">/*__________________________________
*  Do some preliminary bullet proofing
*  but save the majority of bullet proofing
*   to testInputFile function
*___________________________________*/</FONT>
    if( (*xLoLimit - N_GHOSTCELLS) &lt; 0 || (*yLoLimit - N_GHOSTCELLS) &lt; 0 || (*zLoLimit - N_GHOSTCELLS) &lt; 0)
        <A href="#Message">Message</A>1, "Input File error:", "The lower array limits are invalid", "(*)LoLimit - N_GHOSTCELLS &lt;0 ");
    if( *xLoLimit &lt; 0 || *xLoLimit &gt; X_MAX_LIM)
        <A href="#Message">Message</A>1, "Input File Error:", "x Array limits are invalid", "xLoLimit &lt; 0 || xLoLimit &gt; X_MIN_LIM");      
    if( *xHiLimit &lt; 0 || *xHiLimit &gt; X_MAX_LIM)
        <A href="#Message">Message</A>1, "Input File Error:", "x Array limits are invalid", "xHiLimit &lt; 0 || xHiLimit &gt; X_MAX_LIM");
    if( *yLoLimit &lt; 0 || *yLoLimit &gt; Y_MAX_LIM)
        <A href="#Message">Message</A>1, "Input File Error:", "y Array limits are invalid", "yLoLimit &lt; 0 || yLoLimit &gt; Y_MIN_LIM");      
    if( *yHiLimit &lt; 0 || *yHiLimit &gt; Y_MAX_LIM)
        <A href="#Message">Message</A>1, "Input File Error:", "y Array limits are invalid", "yHiLimit &lt; 0 || yHiLimit &gt; Y_MAX_LIM");
    if( *zLoLimit &lt; 0 || *zLoLimit &gt; Z_MAX_LIM)
        <A href="#Message">Message</A>1, "Input File Error:", "z Array limits are invalid", "zLoLimit &lt; 0 || zLoLimit &gt; Z_MIN_LIM");      
    if( *zHiLimit &lt; 0 || *zHiLimit &gt; Z_MAX_LIM)
        <A href="#Message">Message</A>1, "Input File Error:", "z Array limits are invalid", "zHiLimit &lt; 0 || zHiLimit &gt; Z_MAX_LIM");
    if( *nMaterials &lt; 0 || *nMaterials &gt; N_MATERIAL)
        <A href="#Message">Message</A>1, "Input File Error:", "Number of material spec is invalid", "*nMaterials &lt; 0 || *nMaterials &gt; N_MATERIAL");
        
<FONT COLOR="570BA3">/*______________________________________________________________________
*   MATERIAL PROPERTIES
*_______________________________________________________________________*/</FONT>
    for (m = 1; m &lt;= *nMaterials; m++)
    {
    <FONT COLOR="570BA3">/*__________________________________
    * Initial primitive variables
    *___________________________________*/</FONT>
       uvel_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]      = <A href="#readdouble">readdouble</A>fp," U velocity",switchDebug_readInputFile);
       vvel_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]      = <A href="#readdouble">readdouble</A>fp," V velocity",switchDebug_readInputFile);
       wvel_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]      = <A href="#readdouble">readdouble</A>fp," W velocity",switchDebug_readInputFile);

       rho_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]       = <A href="#readdouble">readdouble</A>fp," Density",switchDebug_readInputFile);               
       Temp_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]      = <A href="#readdouble">readdouble</A>fp," Temperature",switchDebug_readInputFile);
       Press_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]     = <A href="#readdouble">readdouble</A>fp," Pressure",switchDebug_readInputFile);

       scalar1_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]   = <A href="#readdouble">readdouble</A>fp," Scalar 1",switchDebug_readInputFile);
       scalar2_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]   = <A href="#readdouble">readdouble</A>fp," Scalar 2",switchDebug_readInputFile);
       scalar3_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]   = <A href="#readdouble">readdouble</A>fp," Scalar 3",switchDebug_readInputFile);
    <FONT COLOR="570BA3">/*__________________________________
    * Material properties
    * Thermodynamic and transport properties
    *___________________________________*/</FONT> 
       viscosity_CC[*xLoLimit][*yLoLimit][*zLoLimit][m] = <A href="#readdouble">readdouble</A>fp," Viscosity",switchDebug_readInputFile);
       thermalCond_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]= <A href="#readdouble">readdouble</A>fp," Thermal conductivity",switchDebug_readInputFile);
       cv_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]        = <A href="#readdouble">readdouble</A>fp," Constant Specific heat",switchDebug_readInputFile);
       speedSound[*xLoLimit][*yLoLimit][*zLoLimit][m]   = <A href="#readdouble">readdouble</A>fp," Speed of sound",switchDebug_readInputFile);
       R[m]                                             = <A href="#readdouble">readdouble</A>fp," Ideal Gas constant",switchDebug_readInputFile);  
       gamma[m]                                         = <A href="#readdouble">readdouble</A>fp," Ratio of specific heats",switchDebug_readInputFile);  
    <FONT COLOR="570BA3">/*__________________________________
    *   Top face boundary conditions
    *___________________________________*/</FONT>
        BC_inputs[TOP][m]                               = <A href="#readint">readint</A>fp," BC_inputs[TOP] ",switchDebug_readInputFile);
        BC_Values[TOP][UVEL][m]                         = <A href="#readdouble">readdouble</A>fp," BC_Values[TOP][UVEL][m]",switchDebug_readInputFile);
        BC_Values[TOP][VVEL][m]                         = <A href="#readdouble">readdouble</A>fp," BC_Values[TOP][VVEL][m]",switchDebug_readInputFile);
        BC_Values[TOP][WVEL][m]                         = <A href="#readdouble">readdouble</A>fp," BC_Values[TOP][WVEL][m]",switchDebug_readInputFile);
        BC_Values[TOP][PRESS][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[TOP][PRESS_BC][m]",switchDebug_readInputFile);
        BC_Values[TOP][TEMP][m]                         = <A href="#readdouble">readdouble</A>fp," BC_Values[TOP][TEMP_BC][m]",switchDebug_readInputFile);
        BC_Values[TOP][DENSITY][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[TOP][DENSITY][m]",switchDebug_readInputFile);

    <FONT COLOR="570BA3">/*__________________________________
    * left and right face BC
    *___________________________________*/</FONT>
        BC_inputs[LEFT][m]                              = <A href="#readint">readint</A>fp," BC_inputs[LEFT]",switchDebug_readInputFile);
        BC_inputs[RIGHT][m]                             = <A href="#readint">readint</A>fp," BC_inputs[RIGHT]",switchDebug_readInputFile);
        BC_Values[LEFT][UVEL][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[LEFT][UVEL][m]",switchDebug_readInputFile);
        BC_Values[RIGHT][UVEL][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[RIGHT][UVEL][m]",switchDebug_readInputFile);
        BC_Values[LEFT][VVEL][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[LEFT][VVEL][m]",switchDebug_readInputFile);
        BC_Values[RIGHT][VVEL][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[RIGHT][VVEL][m]",switchDebug_readInputFile);
        BC_Values[LEFT][WVEL][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[LEFT][WVEL][m]",switchDebug_readInputFile);
        BC_Values[RIGHT][WVEL][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[RIGHT][WVEL][m]",switchDebug_readInputFile);
        BC_Values[LEFT][PRESS][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[LEFT][PRESS][m]",switchDebug_readInputFile);
        BC_Values[RIGHT][PRESS][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[RIGHT][PRESS][m]",switchDebug_readInputFile);     
        BC_Values[LEFT][TEMP][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[LEFT][TEMP][m]",switchDebug_readInputFile);
        BC_Values[RIGHT][TEMP][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[RIGHT][TEMP][m]",switchDebug_readInputFile);
        BC_Values[LEFT][DENSITY][m]                     = <A href="#readdouble">readdouble</A>fp," BC_Values[LEFT][DENSITY][m]",switchDebug_readInputFile);
        BC_Values[RIGHT][DENSITY][m]                    = <A href="#readdouble">readdouble</A>fp," BC_Values[RIGHT][DENSITY][m]",switchDebug_readInputFile);

    <FONT COLOR="570BA3">/*__________________________________
    *   BOTTOM FACE
    *___________________________________*/</FONT>
        BC_inputs[BOTTOM][m]                            = <A href="#readint">readint</A>fp," BC_inputs[BOTTOM]",switchDebug_readInputFile);
        BC_Values[BOTTOM][UVEL][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[BOTTOM][UVEL][m]",switchDebug_readInputFile);
        BC_Values[BOTTOM][VVEL][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[BOTTOM][VVEL][m]",switchDebug_readInputFile);
        BC_Values[BOTTOM][WVEL][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[BOTTOM][WVEL][m]",switchDebug_readInputFile);
        BC_Values[BOTTOM][PRESS][m]                     = <A href="#readdouble">readdouble</A>fp," BC_Values[BOTTOM][PRESS][m]",switchDebug_readInputFile);
        BC_Values[BOTTOM][TEMP][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[BOTTOM][TEMP][m]",switchDebug_readInputFile);
        BC_Values[BOTTOM][DENSITY][m]                   = <A href="#readdouble">readdouble</A>fp," BC_Values[BOTTOM][DENSITY][m]",switchDebug_readInputFile);

    <FONT COLOR="570BA3">/*__________________________________
    * 3D
    *___________________________________*/</FONT>
        BC_inputs[FRONT][m]                             = <A href="#readint">readint</A>fp," BC_inputs[FRONT][m]",switchDebug_readInputFile);
        BC_inputs[BACK][m]                              = <A href="#readint">readint</A>fp," BC_inputs[BACK][m]",switchDebug_readInputFile);

        BC_Values[FRONT][UVEL][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[FRONT][UVEL][m]",switchDebug_readInputFile);
        BC_Values[BACK][UVEL][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[BACK][UVEL][m]",switchDebug_readInputFile);

        BC_Values[FRONT][VVEL][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[FRONT][VVEL][m]",switchDebug_readInputFile);
        BC_Values[BACK][VVEL][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[BACK][VVEL][m]",switchDebug_readInputFile);

        BC_Values[FRONT][WVEL][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[FRONT][WVEL][m]",switchDebug_readInputFile);
        BC_Values[BACK][WVEL][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[BACK][WVEL][m]",switchDebug_readInputFile);

        BC_Values[FRONT][PRESS][m]                      = <A href="#readdouble">readdouble</A>fp," BC_Values[FRONT][PRESS][m]",switchDebug_readInputFile);
        BC_Values[BACK][PRESS][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[BACK][PRESS][m]",switchDebug_readInputFile);

        BC_Values[FRONT][TEMP][m]                       = <A href="#readdouble">readdouble</A>fp," BC_Values[FRONT][TEMP][m]",switchDebug_readInputFile);
        BC_Values[BACK][TEMP][m]                        = <A href="#readdouble">readdouble</A>fp," BC_Values[BACK][TEMP][m]",switchDebug_readInputFile);
        
        BC_Values[FRONT][DENSITY][m]                    = <A href="#readdouble">readdouble</A>fp," BC_Values[FRONT][DENSITY][m]",switchDebug_readInputFile);
        BC_Values[BACK][DENSITY][m]                     = <A href="#readdouble">readdouble</A>fp," BC_Values[BACK][DENSITY][m]",switchDebug_readInputFile); 
     }
    fclose(fp);

<FONT COLOR="570BA3">/*__________________________________
*  Fill the array with the inputs
*___________________________________*/</FONT>
    for (m = 1; m &lt;= *nMaterials; m++)
    { 
        for(k = GC_LO(*zLoLimit); k &lt;= GC_HI(*zHiLimit); k++)
        {
             for(j = GC_LO(*yLoLimit); j &lt;= GC_HI(*yHiLimit); j++)
             {
                 for(i = GC_LO(*xLoLimit); i &lt;= GC_HI(*xHiLimit); i++)
                 { 

                     counter = counter +1;
                     uvel_CC[i][j][k][m]        = uvel_CC[*xLoLimit][*yLoLimit][*zLoLimit][m];
                     vvel_CC[i][j][k][m]        = vvel_CC[*xLoLimit][*yLoLimit][*zLoLimit][m];
                     wvel_CC[i][j][k][m]        = wvel_CC[*xLoLimit][*yLoLimit][*zLoLimit][m];
                     rho_CC[i][j][k][m]         = rho_CC[*xLoLimit][*yLoLimit][*zLoLimit][m];
                     Temp_CC[i][j][k][m]        = Temp_CC[*xLoLimit][*yLoLimit][*zLoLimit][m];                
                     Press_CC[i][j][k][m]       = Press_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     scalar1_CC[i][j][k][m]     = scalar1_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     scalar2_CC[i][j][k][m]     = scalar2_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     scalar3_CC[i][j][k][m]     = scalar3_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     viscosity_CC[i][j][k][m]   = viscosity_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     thermalCond_CC[i][j][k][m] = thermalCond_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     cv_CC[i][j][k][m]          = cv_CC[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                     speedSound[i][j][k][m]     = speedSound[*xLoLimit][*yLoLimit][*zLoLimit][m]; 
                 }
             }
         }
    }
    
#if switchDebug_readInputFile                 
        fprintf(stderr,"\n\n Now leaving readInputFile\n");
#endif        
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="testInputFile">testInputFile</A>  INPUT: Tests the inputs to insure that they are reasonable.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: input.c
 Filename: input.c
 
 Purpose:
   Bullet proof the data that is entered in the readInputFile 
   
 Called by:    Main
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#testInputFile">testInputFile</A> 
         int     xLoLimit,
        int     yLoLimit,
        int     zLoLimit,
        int     xHiLimit,
        int     yHiLimit,
        int     zHiLimit,    
        double  delX,
        double  delY,
        double  delZ,
        double  ****Temp_CC,            <FONT COLOR="570BA3">/*Cell-centered temperature        */</FONT>
        double  ****Press_CC,           <FONT COLOR="570BA3">/* Cell-centered pressure           */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            */</FONT>
        double  ****viscosity_CC,       <FONT COLOR="570BA3">/* Cell-centered Viscosity          */</FONT>
        double  ****thermalCond_CC,     <FONT COLOR="570BA3">/* Cell-centered thermal conductivity*/</FONT>
        double  ****cv_CC,              <FONT COLOR="570BA3">/* Cell-centered constant cp        */</FONT>
        double  ****speedSound,         <FONT COLOR="570BA3">/* speed of sound (x, y, z, material*/</FONT>
        double  t_final,
        double  *t_output_vars,         <FONT COLOR="570BA3">/* array holding output timing info */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[1] = t_initial     */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[2] = t final       */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[3] = delta t       */</FONT>
        double  *delt_limits,           <FONT COLOR="570BA3">/* delt_limits[1] = delt_minimum    */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[2] = delt_maximum    */</FONT>
        int     **BC_inputs,            <FONT COLOR="570BA3">/* array containing the different   */</FONT>
                                        <FONT COLOR="570BA3">/* types of boundary conditions     */</FONT>   
                                        <FONT COLOR="570BA3">/* at each wall [wall][m]           */</FONT>
        int     printSwitch,
        double  CFL,
        int     nMaterials     )
{   
   int     m,
            wall,       
            wallLo,     wallHi;
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1) 
        wallLo = LEFT;  wallHi = RIGHT;
#endif
#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif
      
<FONT COLOR="570BA3">/*______________________________________________________________________
 Check grid quantites
_______________________________________________________________________*/</FONT>
    if ((xLoLimit - N_GHOSTCELLS &lt; 0) || 
        (yLoLimit - N_GHOSTCELLS &lt; 0) || 
        (zLoLimit - N_GHOSTCELLS &lt; 0) ) 
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: testInputFile",
        "Error: x,y or z LoLimit - N_GHOSTCELLS &lt; 0");

    if ( (xHiLimit &lt; xLoLimit) || (yHiLimit &lt; yLoLimit) 
         || (zHiLimit &lt; zLoLimit))  
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: testInputFile",
        "Error: (x,y,z)HiLimit &lt; (x,y,z)LoLimit");

    if ( (delX &lt;= 0.0) || (delY &lt;= 0.0) )  
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: testInputFile",
       "Error: delX or delY &lt;= 0.0");
<FONT COLOR="570BA3">/*__________________________________
*   Test CFL
*___________________________________*/</FONT>       
    if ( (CFL &lt;= 0.0) || (CFL &gt; 1.0) )  
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: testInputFile",
       "Error: (CFL &lt;= 0.0) || (CFL &gt; 1.0)");
<FONT COLOR="570BA3">/*__________________________________
*   Test time related inputs
*___________________________________*/</FONT>
    if (t_final&lt;= 0.0)  
        <A href="#Message">Message</A>1,"File: if","Subroutine: testInputFile",
       "Error: t_final &lt;= 0.0");
       
    if (t_output_vars[1]&lt; 0.0)  
        <A href="#Message">Message</A>1,"File: if","You've specified a negative initial ouput time",
       "Error: t_output_vars[1]&lt; 0.0");
       
    if (t_output_vars[2]&lt; t_output_vars[1])  
        <A href="#Message">Message</A>1,"File: if","The final output time is &lt; the initial output time",
       "Error: t_output_vars[2]&lt; t_output_vars[1]");
       
    if (t_output_vars[3]&lt; 0.0)  
        <A href="#Message">Message</A>1,"File: if","You've specified a negative delta ouput time",
       "Error: t_output_vars[3]&lt; 0.0");
       
    if (delt_limits[1] &lt;0.0)
        <A href="#Message">Message</A>1,"File: if","You've specified a negative delt_minimum",
       "Error: delt_limits[1]&lt; 0.0");
       
    if (delt_limits[2] &lt;0.0)
        <A href="#Message">Message</A>1,"File: if","You've specified a negative delt_max",
       "Error: delt_limits[2]&lt; 0.0");
       
    if (delt_limits[2] &lt;SMALL_NUM)
        <A href="#Message">Message</A>1,"File: if","You've specified delt_max = 0.0",
       "Error: delt_limits[2] =  0.0");    
       
    if (delt_limits[2] &lt;delt_limits[1])
        <A href="#Message">Message</A>1,"File: if","The max. allowable time step is less than the min. allowable time step",
       "Error: delt_limits[2]&lt; delt_limits[1]");  
       
    if (delt_limits[3] &lt;SMALL_NUM)
        <A href="#Message">Message</A>1,"File: if","You've specified delt_initial &lt;=0.0",
       "Error: delt_limits[3] &lt;=  0.0");    
       
<FONT COLOR="570BA3">/*__________________________________
*   Test material properties
*___________________________________*/</FONT>   
    for( m = 1; m&lt;= nMaterials; m++)
    {
    
        if( rho_CC[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || rho_CC[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","rho_CC has been set to either &lt; 0 or &gt; BIG_NUM","now Exiting");
            
        if( Temp_CC[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || Temp_CC[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","Temp_CC has been set to either &lt; 0 or &gt; BIG_NUM","now Exiting");
            
        if( Press_CC[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || Press_CC[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","Press_CC has been set to either &lt; 0 or &gt; BIG_NUM","now Exiting");
         
        if( speedSound[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || speedSound[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","Speed of Sound has been set to either &lt; 0 or &gt; BIG_NUM","now Exiting");
        
        if( cv_CC[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || cv_CC[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","Specific Heat cv has been set to either &lt; 0 or &gt; BIG_NUM","now Exiting");
         
        if( thermalCond_CC[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || thermalCond_CC[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","Thermal Conductivity has been set to either &lt; 0 or &gt; BIG_NUM","now Exiting"); 
            
            
        if( viscosity_CC[xLoLimit][yLoLimit][zLoLimit][m] &lt; 0.0 || viscosity_CC[xLoLimit][yLoLimit][zLoLimit][m] &gt; BIG_NUM)
            <A href="#Message">Message</A>1,"File: if","Viscosity has been set to either &lt; 0 or &gt; BIG_NUM", "now Exiting"); 
    }          
<FONT COLOR="570BA3">/*__________________________________
*   Test that at least one boundary
*   condition is set on every wall
*___________________________________*/</FONT>  
    for( m = 1; m&lt;= nMaterials; m++)
    {  
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        { 
            if (BC_inputs[wall][m] &lt; 1 || BC_inputs[wall][m] &gt; N_DIFFERENT_BCS)
                <A href="#Message">Message</A>1,"File: if","One wall doesn't have a valid boundary condition set",
                "now Exiting");               
        }
    }
    
    if(printSwitch == 1)
    { 
        fprintf(stderr,"****************************************************************************\n");
        fprintf(stderr,"                       NOW LEAVING TESTINPUTFILE\n");
        fprintf(stderr,"****************************************************************************\n");
    } 
<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    QUITE_FULLWARN(delZ);                       
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="readdouble">readdouble</A>  INPUT: Reads in a variable of type (double).</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: Input.c
 Filename: Input.c
 
 Purpose:
   Read a double value from the input file and returns it
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

 Alogrithm:  search for the character ~ and then read in the double  
 
 ---------------------------------------------------------------------  */</FONT>      

    double <A href="#readdouble">readdouble</A>
            FILE    *fp,
            char    var_name[],  <FONT COLOR="570BA3">/* Name of the variable to be read     */</FONT>
            int     printSwitch) <FONT COLOR="570BA3">/* switch for printing                 */</FONT>
    
                    
    
{
    int     num;                <FONT COLOR="570BA3">/* used for error checking              */</FONT>
            fpos_t  pos;        <FONT COLOR="570BA3">/* file position pointer                */</FONT>
    char    c,
                                <FONT COLOR="570BA3">/* error err if something goes wrong    */</FONT>
            err[1024]="Error: Read error";
    double  number=-999;        <FONT COLOR="570BA3">/* number read from input file          */</FONT>
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*
*_______________________________________________________________________*/</FONT>                  
    strcat(err,var_name);
   
    fgetpos(fp,&amp;pos);
                                <FONT COLOR="570BA3">/* search line until "~" is found       */</FONT>
    while ( (c = fgetc(fp) ) != '~'){
        if(printSwitch ==1)
            fprintf(stderr,"%c",c);
    }
                               
    num = fscanf(fp,"%lg",&amp;number);
    
<FONT COLOR="570BA3">/*__________________________________
* Bullet proofing
*___________________________________*/</FONT>    
    if (num!=1)
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: readdouble",err);
        
    if(printSwitch ==1)     
        fprintf(stderr,"%lg ",number);              
 return number;                    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="readfloat">readfloat</A>  INPUT: Reads in a variable of type (float).</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: Input.c
 Filename: Input.c
 
 Purpose:
   Read in a float value from the input file and returns it
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

 Alogrithm:  search for the character ~ and then read in the double  
 
 ---------------------------------------------------------------------  */</FONT>      

    float <A href="#readfloat">readfloat</A>   
            FILE    *fp,
            char    var_name[], <FONT COLOR="570BA3">/* Name of the variable to be read     */</FONT>
            int     printSwitch)<FONT COLOR="570BA3">/* switch for printing                 */</FONT>
    
{
    int     num;                <FONT COLOR="570BA3">/* used for error checking              */</FONT>
            fpos_t  pos;        <FONT COLOR="570BA3">/* file position pointer                */</FONT>
    char    c,
                                <FONT COLOR="570BA3">/* error err if something goes wrong    */</FONT>
            err[1024]="Error: Read error";

    float  number;              <FONT COLOR="570BA3">/* number read from input file          */</FONT>
           number = -999;
<FONT COLOR="570BA3">/*______________________________________________________________________
*
*_______________________________________________________________________*/</FONT>                  

    strcat(err,var_name);
   
    fgetpos(fp,&amp;pos);
                                <FONT COLOR="570BA3">/* search line until "~" is found       */</FONT>
    while ( (c = fgetc(fp) ) != '~'){
      if(printSwitch ==1)
            fprintf(stderr,"%c",c);
    }
                               
    if(printSwitch ==1)
        num = fscanf(fp,"%f",&amp;number);
    
<FONT COLOR="570BA3">/*__________________________________
* Bullet proofing
*___________________________________*/</FONT>    
    if (num!=1)
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: readfloat", err); 
        
    fprintf(stderr,"%f \n",number);             
 return number;                    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="readint">readint</A>  INPUT: Reads in a variable of type (int).</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: Input.c
 Filename: Input.c

 Purpose:
   Read in a integer value from the input file and returns it
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
       
 Alogrithm:  search for the character ~ and then read in the double  
 
 ---------------------------------------------------------------------  */</FONT>      
 
    int <A href="#readint">readint</A> 
            FILE    *fp,
            char    var_name[], <FONT COLOR="570BA3">/* Name of the variable to be read     */</FONT>
            int     printSwitch)<FONT COLOR="570BA3">/* switch for printing                 */</FONT>                
    
{
    int     num,number;         <FONT COLOR="570BA3">/* used for error checking              */</FONT>
            fpos_t  pos;        <FONT COLOR="570BA3">/* file position pointer                */</FONT>
    char    c,
                                <FONT COLOR="570BA3">/* error err if something goes wrong    */</FONT>
            err[1024]="Error: Read error";        
            
<FONT COLOR="570BA3">/*______________________________________________________________________
*
*_______________________________________________________________________*/</FONT>                  
    strcat(err,var_name); 
    
    fgetpos(fp,&amp;pos);
                                 <FONT COLOR="570BA3">/*  search line until "~" is found     */</FONT>      
    while ( (c = fgetc(fp) ) != '~'){
    
     if(printSwitch ==1)
        fprintf(stderr,"%c",c);
    } 
                                                 
    num = fscanf(fp,"%d",&amp;number);   
     
<FONT COLOR="570BA3">/*__________________________________
* Bullet proofing
*___________________________________*/</FONT>  
   
      if (num!=1)
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: readint",err); 
        
      if(printSwitch ==1)    
        fprintf(stderr,"%d ",number);
                        
 return number;                    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="readstring">readstring</A>  INPUT: Reads in a variable of type (char[]).</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: Input.c
 Filename: Input.c

 Purpose:
   Read in a string from the input file and returns it
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       10/12/99    

 Alogrithm:  search for the character ~ and then read in the string  
 
 ---------------------------------------------------------------------  */</FONT>      
 
    void <A href="#readstring">readstring</A> 
            FILE    *fp,
            char    string[],
            char    var_name[], <FONT COLOR="570BA3">/* Name of the variable to be read     */</FONT>
            int     printSwitch)<FONT COLOR="570BA3">/* switch for printing                 */</FONT>                
    
{
    int     num;                <FONT COLOR="570BA3">/* used for error checking              */</FONT>
            fpos_t  pos;        <FONT COLOR="570BA3">/* file position pointer                */</FONT>
    char    c,
                                <FONT COLOR="570BA3">/* error err if something goes wrong    */</FONT>
            err[1024]="Error: Read error";      
            
<FONT COLOR="570BA3">/*______________________________________________________________________
*
*_______________________________________________________________________*/</FONT>                  
    strcat(err,var_name); 
    
    fgetpos(fp,&amp;pos);
                                 <FONT COLOR="570BA3">/*  search line until "~" is found     */</FONT>      
    while ( (c = fgetc(fp) ) != '~')
    {
    
     if(printSwitch ==1)
        fprintf(stderr,"%c",c);
    } 
                                                 
    num = fscanf(fp,"%s",string);   
     
<FONT COLOR="570BA3">/*__________________________________
* Bullet proofing
*___________________________________*/</FONT>  
   
      if (num!=1)
        <A href="#Message">Message</A>1,"File: input.f","Subroutine: readint",err); 
        
      if(printSwitch ==1)    
        fprintf(stderr,"%s",string);                                          
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_vector">plot_vector</A>  VISUALIZATION: Generates a 2D vector plot of input data.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_vector.c
 Filename: plot_vector.c

 Purpose:  Plot a vector plot of the input field

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       09/2/99   Written   
_______________________________________________________________________ */</FONT>
void    plot_vector_2D(
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     max_len,                <FONT COLOR="570BA3">/* max length of data arrays        */</FONT>
  const float   *data_array1,           <FONT COLOR="570BA3">/* data vector                      */</FONT>
  const float   *data_array2)           <FONT COLOR="570BA3">/* second set of data used for      */</FONT>
                                        <FONT COLOR="570BA3">/* vector plots                     */</FONT>
{
    int     i,
            unit = 2;                   <FONT COLOR="570BA3">/* units of measure 2 = mm          */</FONT>
    static float    TR[6] = {-0.5, 1.0, 0.0, -0.5, 0.0, 1.0};
    
    float   vector_scale,               <FONT COLOR="570BA3">/* scale for the vector             */</FONT>
            vel_vector,
            max_vector_len,             <FONT COLOR="570BA3">/* length of longest vector         */</FONT>
            max_velocity,               <FONT COLOR="570BA3">/* maximum velocity                 */</FONT>
            A, B,                       <FONT COLOR="570BA3">/* Temp varables                    */</FONT>
            char_size_text,             <FONT COLOR="570BA3">/*scale text according to win size  */</FONT>
            delx, dely,                 <FONT COLOR="570BA3">/* window width and height          */</FONT>
            x1, x2, y1, y2,             <FONT COLOR="570BA3">/* window corners                   */</FONT>
            c_x, c_y;                   <FONT COLOR="570BA3">/* char size in x and y dirs        */</FONT>
    char    label[10]; 
       
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Hardwire some vector plot parameters
*_______________________________________________________________________*/</FONT>
    vector_scale    = 1;
    max_velocity    = 0.0;
    max_vector_len  = 2.0;

<FONT COLOR="570BA3">/*__________________________________
*   Find the max velocity, and the 
*   vector scale
*___________________________________*/</FONT>
    for ( i = 1; i &lt;= max_len; i++)
    {
        
        A               = pow(data_array1[i], 2);
        B               = pow(data_array2[i], 2);
        vel_vector      = sqrt( A + B );
        max_velocity    = FMAX(max_velocity, vel_vector);   
    }
<FONT COLOR="570BA3">/*__________________________________
*   Change the shape of the arrows and the
* size of the plot data
*___________________________________*/</FONT>  
    cpgsch(0.7);
    cpgsah(1,40.0, 0.0);    
    
    vector_scale = max_vector_len/max_velocity;    

<FONT COLOR="570BA3">/*__________________________________
*   Generate the vector field
*___________________________________*/</FONT>
    cpgvect(        &amp;data_array1[1],&amp;data_array2[1], 
                    xHiLimit,       yHiLimit,
                    1,       xHiLimit,
                    1,       yHiLimit,
                    vector_scale,   1, 
                    TR,             0.0);                     
<FONT COLOR="570BA3">/*__________________________________
* Determine the size of the text
*___________________________________*/</FONT>
    cpgqvp(unit,&amp;x1, &amp;x2, &amp;y1, &amp;y2);

    delx            = x2 - x1;
    dely            = y2 - y1;
    
    c_x             = 70.0/delx;
    c_y             = 70.0/dely;

    c_x             = 80.0/delx;
    c_y             = 80.0/dely;    
    char_size_text  = FMAX(1.0, c_x);
    char_size_text  = FMAX(char_size_text, c_y);
<FONT COLOR="570BA3">/*__________________________________
*   Add labels
*___________________________________*/</FONT>    
    cpgsch(char_size_text);
    cpgmtxt("L\0", 2.5, 0.0, 0.0, "Max.velocity\0");
    sprintf(label, "%5.5g",max_velocity);
    cpgmtxt("L\0", 1.5, 0.0, 0.0, label);
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_control">plot_control</A>  VISUALZATION: Main controller for the plotting routines.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose:  main plot controlling program

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   
_______________________________________________________________________ */</FONT>
   void    plot(  
    const float   *data,                <FONT COLOR="570BA3">/* data vector                  */</FONT>
    const float   *data2,               <FONT COLOR="570BA3">/* second set of data used for  */</FONT>
                                        <FONT COLOR="570BA3">/* vector plots and the x-axis  */</FONT>
                                        <FONT COLOR="570BA3">/* for scatter plots            */</FONT> 
    int     max_len, 
    double  delX,                       <FONT COLOR="570BA3">/* delta x                      */</FONT>
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x_axis origin                */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x_axis limit                 */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y_axis origin                */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y_axis limit                 */</FONT>
    char    x_label[],                  <FONT COLOR="570BA3">/* label along the x axis       */</FONT>
    char    y_label[],                  <FONT COLOR="570BA3">/* label along the y axis       */</FONT>
    char    graph_label[],              <FONT COLOR="570BA3">/* label at top of plot         */</FONT>
    int     plot_type,                  <FONT COLOR="570BA3">/* switch to determine which type of*/</FONT>
                                        <FONT COLOR="570BA3">/* plot to generate                 */</FONT>
    int     outline_ghostcells,         <FONT COLOR="570BA3">/* 1= outline the ghostcells    */</FONT>
    int     max_sub_win,                <FONT COLOR="570BA3">/* max number of sub windows to */</FONT>
                                        <FONT COLOR="570BA3">/* generate                     */</FONT>
    char    file_basename[],            <FONT COLOR="570BA3">/* basename of the output file  */</FONT>
    int     filetype)                   <FONT COLOR="570BA3">/* type of file to select       */</FONT>
                                        <FONT COLOR="570BA3">/* 1 = gif, 2 = ps, 3 = xwd     */</FONT>
{

    int     i,  
            color,
            symbol,                                                       
            error,          
            error_x, 
            error_data;                 <FONT COLOR="570BA3">/* error flag for NAN or INF    */</FONT>

static int
            n_sub_win,                  <FONT COLOR="570BA3">/* counter for the number of sub*/</FONT>
            n_sub_win_cursor,           <FONT COLOR="570BA3">/* windows                      */</FONT>
            n_sub_win_file;             <FONT COLOR="570BA3">/* number of subwins for file   */</FONT>
                 
    float   xLo,          xHi,          <FONT COLOR="570BA3">/* max and min values           */</FONT>
            yHi,          yLo,
            data_min,       data_max;
    float   *x_data,
            symbol_size; 
            
    char    stay_or_go;
    
   
<FONT COLOR="570BA3">/*__________________________________
*   Should I plot during this pass
*___________________________________*/</FONT>
    stay_or_go = *getenv("PGPLOT_PLOTTING_ON_OFF");
<FONT COLOR="570BA3">/*     printf ("PGPLOT_PLOTTING: %c \n",stay_or_go); */</FONT>
    if (stay_or_go == '0') return;
<FONT COLOR="570BA3">/*__________________________________
*   Bulletproofing
*___________________________________*/</FONT>
    if(max_len &lt;=0)
    {
        <A href="#Message">Message</A>1,"File: Plot_Control.c","Function Plot",
        "The length of the input data array is &lt;=zero, now exitig");
    }     
                    
    <FONT COLOR="570BA3">/*__________________________________
    *  Find data_min, data_max
    *___________________________________*/</FONT>                                
    error_data  = <A href="#plot_scaling">plot_scaling</A> data,       max_len,        &amp;data_min, &amp;data_max);  
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   When dumping to the screen
*_______________________________________________________________________*/</FONT>    
    if (filetype == 0)
    {
    
        
        <A href="#plot_open_window_screen">plot_open_window_screen</A>max_sub_win, &amp;n_sub_win);

        <FONT COLOR="570BA3">/*__________________________________
        *   Generate the color spectrum
        *___________________________________*/</FONT>       
        <A href="#plot_color_spectrum">plot_color_spectrum</A>); 
                                                               
        <FONT COLOR="570BA3">/*__________________________________
        *  Contour plot
        *___________________________________*/</FONT>  
        if(plot_type == 1)
        { 
            cpgbbuf();
            xHi       = (float)xHiLimit;
            yHi       = (float)yHiLimit;
            xLo       = (float)xLoLimit;
            yLo       = (float)yLoLimit;
            
            <A href="#plot_generate_axis">plot_generate_axis</A> x_label,        y_label,        graph_label,
                                &amp;xLo,           &amp;xHi,         
                                &amp;yLo,           &amp;yHi, 
                                &amp;error_data);
                                
        #if (contourplot_type  == 1)                              
            <A href="#plot_contour">plot_contour</A>       xLo,            xHi,       
                                yLo,            yHi,
                                data_min,       data_max,       data);
        #endif
        #if (contourplot_type  == 2)                                    
            <A href="#plot_contour_checkerboard">plot_contour_checkerboard</A>       
                                xLo,            xHi,       
                                yLo,            yHi,
                                data_min,       data_max,       data);
        #endif
            
            <A href="#plot_legend">plot_legend</A>        data_max,       data_min, 
                                xHi,            yHi);
            cpgebuf();
            
        }
       <FONT COLOR="570BA3">/*__________________________________
       * Line plot
       *___________________________________*/</FONT>
        if((plot_type == 2) || (plot_type == 4))
        {
                                                      
            color           = NUM_COLORS;
            symbol          = -9;
            symbol_size     = 0.75;
            <FONT COLOR="570BA3">/*__________________________________
            *   Generate x data
            *___________________________________*/</FONT>
            x_data      = vector(1,  (max_len));
            x_data[0]   = (float)xLoLimit - 1;   
            x_data[1]   = (float)xLoLimit;

            for( i =2; i&lt;=max_len; i++)
            {
                x_data[i] = x_data[i-1] + 1;
            }
            <FONT COLOR="570BA3">/*__________________________________
            *   search for NAN or INF numbers
            *___________________________________*/</FONT>
            error_x     = <A href="#plot_scaling">plot_scaling</A> x_data,     max_len,     &amp;xLo,    &amp;xHi);
            error_data  = <A href="#plot_scaling">plot_scaling</A>   data,     max_len,     &amp;yLo,    &amp;yHi); 
            error       = IMAX(error_x, error_data);
            
            <A href="#plot_generate_axis">plot_generate_axis</A> 
                                x_label,        y_label,        graph_label,
                                &amp;xLo,           &amp;xHi,         
                                &amp;yLo,           &amp;yHi, 
                                &amp;error_data );
            cpgbox("G\0",0.0, 0, "G\0", 0.0, 0);
            <A href="#plot_2d_scatter">plot_2d_scatter</A>    x_data,         data,           max_len, 
                                color,          symbol,         symbol_size);
            <FONT COLOR="570BA3">/*__________________________________
            *   To overlay a second set of data
            *___________________________________*/</FONT>
            if (plot_type == 4)
            { 
                symbol      = -9;
                color = (int)color/2;                   
                <A href="#plot_2d_scatter">plot_2d_scatter</A>x_data,         data2,          max_len,     
                                color,          symbol,         symbol_size);
            }
            
            free_vector(x_data, 1, max_len);
            
        }
        <FONT COLOR="570BA3">/*__________________________________
        *   Vector Plot
        *___________________________________*/</FONT>
        if( plot_type == 3 )
        {
            cpgbbuf();
            
<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
            xHi       = (float)xHiLimit + 1;
            yHi       = (float)yHiLimit + 1;
            
            xHi       = (float)xHiLimit;
            yHi       = (float)yHiLimit;
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
            
            xLo       = (float)xLoLimit;
            yLo       = (float)yLoLimit;
            
            <A href="#plot_generate_axis">plot_generate_axis</A> x_label,        y_label,        graph_label,
                                &amp;xLo,          &amp;xHi,         
                                &amp;yLo,          &amp;yHi, 
                                &amp;error_data);            
            plot_vector_2D(      
                                xHi,            yHi,
                                max_len,
                                data,           data2); 
            cpgebuf();     
         }
    
          
        <FONT COLOR="570BA3">/*__________________________________
        *  Plot_cursor_position
        *___________________________________*/</FONT>
         plot_cursor_position(max_sub_win, &amp;n_sub_win_cursor); 
 
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
* If dumping to a file then
*
*                                   FILE DUMP
*_______________________________________________________________________*/</FONT>
    if (filetype &gt; 0)
    { 
        <A href="#plot_open_window_file">plot_open_window_file</A>max_sub_win, &amp;n_sub_win_file, file_basename, filetype);
        <FONT COLOR="570BA3">/*__________________________________
        *   Generate the color spectrum
        *___________________________________*/</FONT>       
        <A href="#plot_color_spectrum">plot_color_spectrum</A>);                                                                        
        <FONT COLOR="570BA3">/*__________________________________
        *  Contour plot
        *___________________________________*/</FONT>  
        if(plot_type == 1)
        { 
            xHi       = (float)xHiLimit;
            yHi      = (float)yHiLimit;
            xLo       = (float)xLoLimit;
            yLo       = (float)yLoLimit;
            
            <A href="#plot_generate_axis">plot_generate_axis</A> 
                                x_label,        y_label,        graph_label,
                                &amp;xLo,           &amp;xHi,         
                                &amp;yLo,           &amp;yHi, 
                                &amp;error_data);
        #if (contourplot_type  == 1)                              
            <A href="#plot_contour">plot_contour</A>       xLo,            xHi,       
                                yLo,            yHi,
                                data_min,       data_max,       data);
        #endif
        #if (contourplot_type  == 2)                                    
            <A href="#plot_contour_checkerboard">plot_contour_checkerboard</A>       
                                xLo,            xHi,       
                                yLo,            yHi,
                                data_min,       data_max,       data);
        #endif
            
            <A href="#plot_legend">plot_legend</A>        data_max,       data_min, 
                                xHi,            yHi);
                            
        }
        <FONT COLOR="570BA3">/*__________________________________
        * Line plot
        *___________________________________*/</FONT>
         if((plot_type == 2) || (plot_type == 4))
        {                                                
            color           = NUM_COLORS;
            symbol          = -9;
            symbol_size     = 0.75;
            <FONT COLOR="570BA3">/*__________________________________
            *   Generate x data
            *___________________________________*/</FONT>
            x_data      = vector(1,  (max_len));
            x_data[0]   = (float)xLoLimit - (float)delX;   
            x_data[1]   = (float)xLoLimit;

            for( i =2; i&lt;=max_len; i++)
            {
                x_data[i] = x_data[i-1] + (float)delX;
            }
            <FONT COLOR="570BA3">/*__________________________________
            *   search for NAN or INF numbers
            *___________________________________*/</FONT>
            error_x     = <A href="#plot_scaling">plot_scaling</A> x_data,     max_len,     &amp;xLo,    &amp;xHi);
            error_data  = <A href="#plot_scaling">plot_scaling</A>   data,     max_len,     &amp;yLo,    &amp;yHi); 
            error       = IMAX(error_x, error_data);
            
            <A href="#plot_generate_axis">plot_generate_axis</A> 
                                x_label,        y_label,        graph_label,
                                &amp;xLo,           &amp;xHi,         
                                &amp;yLo,           &amp;yHi, 
                                &amp;error_data );
            
            <A href="#plot_2d_scatter">plot_2d_scatter</A>    x_data,         data,           max_len, 
                                color,          symbol,         symbol_size);
            <FONT COLOR="570BA3">/*__________________________________
            *   To overlay a second set of data
            *___________________________________*/</FONT>
            if (plot_type == 4)
            { 
                color = (int)color/2;                   
                <A href="#plot_2d_scatter">plot_2d_scatter</A>x_data,         data2,          max_len,     
                                color,          symbol,         symbol_size);
            }
            
            free_vector(x_data, 1, max_len);
        }
        

    }
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now write a discription and outline the ghostcells and 
*   if it's time then close the file
*_______________________________________________________________________*/</FONT>    
    <FONT COLOR="570BA3">/*__________________________________
    *       MISC
    * Graph description
    *___________________________________*/</FONT>
    if(n_sub_win == 1 || n_sub_win_file == 1 )
    {
        cpgsclp(0);                                      <FONT COLOR="570BA3">/* turn off clipping*/</FONT>
        cpgsci(1);
        cpgsch(1.0);
        cpgmtxt("T\0", 3.0, 0.0, 0.0, GRAPHDESC);
        cpgmtxt("T\0", 2.0, 0.0, 0.0, GRAPHDESC2);
        cpgmtxt("B\0", 3.5, 0.5, 0.5, GRAPHDESC3);
        cpgmtxt("B\0", 4.5, 0.5, 0.5, GRAPHDESC4);
        cpgscf(1);
        cpgsclp(1);                                      <FONT COLOR="570BA3">/* turn on clipping*/</FONT>
    }
    <FONT COLOR="570BA3">/*__________________________________
    *   Outline Ghostcells
    *___________________________________*/</FONT>
    if(outline_ghostcells == 1)
    {        
        cpgmove(xLo+N_GHOSTCELLS,yLo+N_GHOSTCELLS);
        cpgdraw(xHi-N_GHOSTCELLS,yLo+N_GHOSTCELLS);
        cpgdraw(xHi-N_GHOSTCELLS,yHi-N_GHOSTCELLS);
        cpgdraw(xLo+N_GHOSTCELLS,yHi-N_GHOSTCELLS);
        cpgdraw(xLo+N_GHOSTCELLS,yLo+N_GHOSTCELLS);
    }
          
    <FONT COLOR="570BA3">/*__________________________________
    *Close the windows
    *___________________________________*/</FONT>

    if(n_sub_win == max_sub_win &amp;&amp; filetype == 0)
    {
        cpgclos();
        n_sub_win           = 0;
        n_sub_win_cursor    = 0;
    }
    if(n_sub_win_file == max_sub_win &amp;&amp; filetype &gt; 0)
    {
        cpgclos();
        n_sub_win_file      = 0;
    }
    
<FONT COLOR="570BA3">/*     getchar(); */</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    error = error;
     
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_face_centered_data">plot_face_centered_data</A>  VISUALIZATION: generates the face-centered contour plots.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_face_center.c
 Filename: plot_face_center.c

 Purpose:  This routine draws a cell grid pattern with the color of the 
 line on a particular face corresponding to a particular value
 
 This

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       10/06/99   Written 
         

_______________________________________________________________________ */</FONT>

   void    <A href="#plot_face_centered_data">plot_face_centered_data</A>  
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x_axis origin                */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x_axis limit                 */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y_axis origin                */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y_axis limit                 */</FONT>
    int     zLoLimit,
    int     zHiLimit,                                                   
    double  delX,                       <FONT COLOR="570BA3">/* delta X                      */</FONT>
    double  delY,                       <FONT COLOR="570BA3">/* delta Y                      */</FONT>
    double  ******data,                 <FONT COLOR="570BA3">/* *data(x,y,z,face,material)   */</FONT>
    char    x_label[],                  <FONT COLOR="570BA3">/* label along the x axis       */</FONT>
    char    y_label[],                  <FONT COLOR="570BA3">/* label along the y axis       */</FONT>
    char    graph_label[],              <FONT COLOR="570BA3">/* label at top of plot         */</FONT>
    int     outline_ghostcells,          <FONT COLOR="570BA3">/* 1= outline the ghostcells    */</FONT>            
    int     max_sub_win,                <FONT COLOR="570BA3">/* max number of sub windows to */</FONT>
                                        <FONT COLOR="570BA3">/* generate                     */</FONT>
    char    file_basename[],            <FONT COLOR="570BA3">/* basename of the output file  */</FONT>
    int     filetype,                   <FONT COLOR="570BA3">/* type of file to select       */</FONT>
                                        <FONT COLOR="570BA3">/* 1 = gif, 2 = ps, 3 = xwd     */</FONT>
    int     m)
{
    int     i,j,k, 
            color,
            error_data;                 <FONT COLOR="570BA3">/* error flag for NAN or INF    */</FONT>
static int
            n_sub_win;                  <FONT COLOR="570BA3">/* counter for the number of sub*/</FONT>
                                        <FONT COLOR="570BA3">/* windows                      */</FONT>
    float   xLo,        xHi,        <FONT COLOR="570BA3">/* max and min values           */</FONT>
            yHi,        yLo,
            data_max,   data_min,
            x,          y,
            offset; 
    char    stay_or_go;

<FONT COLOR="570BA3">/*__________________________________
*   Initialize Variables
*___________________________________*/</FONT>
    offset  = 0.25;
<FONT COLOR="570BA3">/*__________________________________
*   Should I plot during this pass
*___________________________________*/</FONT>
    stay_or_go = *getenv("PGPLOT_PLOTTING_ON_OFF");
    if (stay_or_go == '0') return;


<FONT COLOR="570BA3">/*__________________________________
*   FRAGMENT FOR TESTING
*___________________________________*/</FONT>
<FONT COLOR="570BA3">/*     for ( k = zLoLimit; k &lt;= zHiLimit; k++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( i = xLoLimit; i &lt;= xHiLimit; i++)
            {
                
                *data[i][j][k][LEFT][m]     = (float)xHiLimit - i;
                *data[i][j][k][RIGHT][m]    = (float)xHiLimit - i - 1;
                *data[i][j][k][BOTTOM][m]   = (float)yHiLimit - j;
                *data[i][j][k][TOP][m]      = (float)yHiLimit - j - 1;
                  
            }
        }
    } */</FONT>

<FONT COLOR="570BA3">/*______________________________________________________________________
*   When dumping to the screen
*_______________________________________________________________________*/</FONT>    
    if (filetype == 0)
    {
    
        
        <A href="#plot_open_window_screen">plot_open_window_screen</A>max_sub_win, &amp;n_sub_win);
        
        <FONT COLOR="570BA3">/*__________________________________
        *   Generate the color spectrum
        *___________________________________*/</FONT>       
        <A href="#plot_color_spectrum">plot_color_spectrum</A>); 

        <FONT COLOR="570BA3">/*__________________________________
        * Begin buffering the output
        *___________________________________*/</FONT>
        cpgbbuf();
        
        
        xHi = (float)xHiLimit+1;
        yHi = (float)yHiLimit+1;
        xLo = (float)xLoLimit;
        yLo = (float)yLoLimit;

        <A href="#plot_generate_axis">plot_generate_axis</A> x_label,        y_label,        graph_label,
                            &amp;xLo,           &amp;xHi,         
                            &amp;yLo,           &amp;yHi, 
                            &amp;error_data);
                            
        <A href="#plot_scaling_FC">plot_scaling_FC</A> 
                            xLoLimit,       yLoLimit,       zLoLimit,                  
                            xHiLimit,       yHiLimit,       zHiLimit,                  
                            data,           m,                         
                            &amp;data_min,      &amp;data_max );
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Draw the face centered values in all of the cells except the 
*   top and right face of the domain
*_______________________________________________________________________*/</FONT>
        for ( k = zLoLimit; k &lt;= zHiLimit; k++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            { 
                for ( i = xLoLimit; i &lt;= xHiLimit; i++)
                {  
                    x       = (float) i;    
                    y       = (float) j;
                    cpgmove(x,y);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Draw horizontal line
                    *___________________________________*/</FONT>
                    x       = (float) i+1;
                    y       = (float) j;
                    color   = (int)(NUM_COLORS)*(*data[i][j][k][BOTTOM][m] - data_min)/
                                (data_max - data_min + SMALL_NUM);
                    cpgsci(color);                          <FONT COLOR="570BA3">/* Define the color         */</FONT>
                    cpgdraw(x,y);                           <FONT COLOR="570BA3">/* Draw a horiziontal line  */</FONT>
                    x       = (float) i;    
                    y       = (float) j;
                    cpgmove(x,y);                           <FONT COLOR="570BA3">/* Move back                */</FONT>
                    
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Draw vertical line
                    *___________________________________*/</FONT>
                    x       = (float) i;    
                    y       = (float) j+1;
                    color   = (int)(NUM_COLORS) *(*data[i][j][k][LEFT][m] - data_min)/
                                (data_max - data_min + SMALL_NUM);
                    cpgsci(color);                          <FONT COLOR="570BA3">/* Define the color         */</FONT>
                    cpgdraw(x,y);                            <FONT COLOR="570BA3">/* Draw a vertical line     */</FONT>
                           <FONT COLOR="570BA3">/* move back down to i,j    */</FONT>  
                }
            }
        }


<FONT COLOR="570BA3">/*______________________________________________________________________
*   Draw the face centered values on the top and right face of the domain
*_______________________________________________________________________*/</FONT>
        
        for ( k = zLoLimit; k &lt;= zHiLimit; k++)
        {
            for ( j = yHiLimit; j &lt;= yHiLimit; j++)
            { 
                for ( i = xLoLimit; i &lt;= xHiLimit; i++)
                {  
                    x       = (float) i;    
                    y       = (float) j + 1;
                    cpgmove(x,y); 
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Top Face
                    *___________________________________*/</FONT>
                    x       = (float) i+1;
                    y       = (float) j+1;
                    color   = (int)(NUM_COLORS)*(*data[i][j][k][TOP][m] - data_min)/
                                (data_max - data_min + SMALL_NUM);
                    cpgsci(color);                          <FONT COLOR="570BA3">/* Define the color         */</FONT>
                    cpgdraw(x,y);                           <FONT COLOR="570BA3">/* Draw a horiziontal line  */</FONT>
                }
            }
        }
        for ( k = zLoLimit; k &lt;= zHiLimit; k++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            { 
                for ( i = xHiLimit; i &lt;= xHiLimit; i++)
                { 
                    x       = (float) i + 1;    
                    y       = (float) j;
                    cpgmove(x,y);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Right Face
                    *___________________________________*/</FONT>
                    x       = (float) i + 1;    
                    y       = (float) j+1;
                    color   = (int)(NUM_COLORS) *(*data[i][j][k][RIGHT][m] - data_min)/
                                (data_max - data_min + SMALL_NUM);
                    cpgsci(color);                          <FONT COLOR="570BA3">/* Define the color         */</FONT>
                    cpgdraw(x,y);                           <FONT COLOR="570BA3">/* Draw a vertical line     */</FONT>

                }
            }
        }

        <FONT COLOR="570BA3">/*__________________________________
        *   Generate a legend
        *___________________________________*/</FONT>
        <A href="#plot_legend">plot_legend</A>        data_max,       data_min, 
                            xHi,          yHi);
        <FONT COLOR="570BA3">/*__________________________________
        *   Draw lines around the ghost cells
        *___________________________________*/</FONT>
        cpgsci(1);
        if(outline_ghostcells == 1)
        {       
            cpgmove(xLoLimit+N_GHOSTCELLS   + offset,yLoLimit+N_GHOSTCELLS      + offset);
            cpgdraw(xHiLimit+1-N_GHOSTCELLS - offset,yLoLimit+N_GHOSTCELLS      + offset);
            cpgdraw(xHiLimit+1-N_GHOSTCELLS - offset,yHiLimit+1-N_GHOSTCELLS    - offset);
            cpgdraw(xLoLimit+N_GHOSTCELLS   + offset,yHiLimit+1-N_GHOSTCELLS    - offset);
            cpgdraw(xLoLimit+N_GHOSTCELLS   + offset,yLoLimit+N_GHOSTCELLS      + offset);
        }
        
        <FONT COLOR="570BA3">/*__________________________________
        * End buffering the output
        *___________________________________*/</FONT>
        cpgebuf();
        <FONT COLOR="570BA3">/*__________________________________
        *Close the windows
        *___________________________________*/</FONT>
        
        if(n_sub_win == max_sub_win)
        {
            cpgclos();
            n_sub_win = 0;
        }
        

                                                               
    }
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(delX);                       QUITE_FULLWARN(delY);
    QUITE_FULLWARN(file_basename);
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_open_window_screen">plot_open_window_screen</A>  VISUALIZATION: Window manager for plot windows.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose: Window manager, opens the number of window and makes sure
 that the output goes to the right window.
 Steps:
 ------
    1) If it is the first time through the main loop then count the max. 
    number of main windows that are opened (max_main_win).
    2) Open an window and select select it
    3) If there are subwindows for a main window then don't open a new 
    window.
    4) For subsequent passes through the routine select the correct window
    using win_index so that the figures don't bounce around.
    
Note that the windows will be closed outside of this routine

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   

       
SPECIAL CASE
     When the plotting routines is called inside of an iterative routine and it 
     is the first time through the main loop then only increment the 
     max_main_win once.  You don't want to add 1 to max_main_win
     every time it passes through the iteration or you'll open up 
     n_interation windows.
     
     Also when selecting the proper window with win_index you don't
     need to change the window on each pass throught the iteration
       
WARNING 
    Don't call any of the plotting routine inside of an iterative loop
       
_______________________________________________________________________ */</FONT>

    void <A href="#plot_open_window_screen">plot_open_window_screen</A>
    int        max_sub_win,             <FONT COLOR="570BA3">/* max number of sub_windows    */</FONT>
    int        *n_sub_win )             <FONT COLOR="570BA3">/* counter for the number of sub*/</FONT>
                                        <FONT COLOR="570BA3">/* windows                      */</FONT>

{
    int     i,
            open_new_windows_2,         <FONT COLOR="570BA3">/* flag for opening new windows */</FONT>
            open_new_windows_1;         <FONT COLOR="570BA3">/* flag for opening new windows */</FONT>
                                        
   static  int 
            first_time_through,         <FONT COLOR="570BA3">/* if this is the first time    */</FONT> 
            n_windows,                  <FONT COLOR="570BA3">/* counter for the number of open*/</FONT>
                                        <FONT COLOR="570BA3">/* windows                      */</FONT>
            max_main_win,               <FONT COLOR="570BA3">/* max number of windows opened */</FONT>
            win_indx,                   <FONT COLOR="570BA3">/* window index                 */</FONT>
            ID;                         <FONT COLOR="570BA3">/* ID of device                 */</FONT>
    char    am_I_here;            
<FONT COLOR="570BA3">/*______________________________________________________________________
*   MAIN CODE
*_______________________________________________________________________*/</FONT>
    open_new_windows_1 = 0;
    open_new_windows_2 = 0;
 
<FONT COLOR="570BA3">/*__________________________________
*   determine if this is the first time through
*___________________________________*/</FONT> 
    am_I_here= *getenv("PGPLOT_I_AM_HERE");        
    if ( am_I_here== '0' )  first_time_through = 1;
    if ( am_I_here== '1' )  first_time_through = 2;
<FONT COLOR="570BA3">/*__________________________________
*   For subsequent passes through this routine
*   Find out if I should open a new
*   series of windows
*___________________________________*/</FONT> 
    am_I_here= *getenv("PGPLOT_OPEN_NEW_WINDOWS"); 
    if ( am_I_here== '1' )  open_new_windows_1 = 1;  
    putenv("PGPLOT_OPEN_NEW_WINDOWS=0"); 
    
     
<FONT COLOR="570BA3">/*__________________________________
*   First pass through 
*___________________________________*/</FONT> 
    if ( first_time_through == 1 )
    {
        <FONT COLOR="570BA3">/*__________________________________
        * No subwindows then just open a new window
        *___________________________________*/</FONT>
        if ( max_sub_win == 0 ) 
        {
            max_main_win ++;        
            ID = cpgopen("/XSERVE\0");
            cpgslct(ID);
            cpgeras();   
        }   
        <FONT COLOR="570BA3">/*__________________________________
        * If there are sub windows then set
        * the sub window layout and open a new
        * window.
        *___________________________________*/</FONT>
         if( max_sub_win &gt; 0)
         {
            *n_sub_win = *n_sub_win + 1;
            if (*n_sub_win == 1 )
            {
                max_main_win ++;
                ID = cpgopen("/XSERVE\0");
                cpgslct(ID);
                cpgeras();
                if (max_sub_win ==2) cpgsubp(1,2);
                if (max_sub_win &gt;=3) cpgsubp(2,2);    
            }
        } 
    
   }    
 
<FONT COLOR="570BA3">/*__________________________________
*   All subsequent passes through
*   this routine
*___________________________________*/</FONT>       
    if ( first_time_through &gt;1 )
    {
    
       <FONT COLOR="570BA3">/*__________________________________
        *  After we've been through the entire
        * algorithm once check to see if we
        * are at the first window
        *___________________________________*/</FONT>

        if ( open_new_windows_1 == 1 &amp;&amp; max_sub_win == 0) 
        {
            open_new_windows_2 = 1;
        }

        if ( open_new_windows_1 == 1 &amp;&amp; max_sub_win &gt; 0 &amp;&amp; *n_sub_win == 0) 
        {
            open_new_windows_2 = 1;
        }

        <FONT COLOR="570BA3">/*__________________________________
        *   reset some counters
        *   and open a new set of windows
        *___________________________________*/</FONT>
        if( open_new_windows_2 == 1 )
        {           
            n_windows   =   0;
            *n_sub_win  =   0;

           for (i = 1; i&lt;= max_main_win; i++) 
            {
               ID = cpgopen("/XSERVE\0");
               if (ID &lt;= 0)
                 <A href="#Message">Message</A>1, "plot_common.c", "plot_open_window_screen", "couldn't open a window");
            }   
        }
         
        <FONT COLOR="570BA3">/*__________________________________
        *   If there are no subwindows then 
        *   we need to find the right window
        *   to dump the graphics in so that
        *   the plots stay in one window
        *___________________________________*/</FONT>
        if ( max_sub_win == 0 ) 
        {
            n_windows   ++;
            win_indx = max_main_win - n_windows + 1;    
            cpgslct(win_indx);
        } 
                     
        <FONT COLOR="570BA3">/*__________________________________
        *   If there are sub windows then set
        *   the sub window layout adn 
        *   find the right window to dump the 
        *   graphics in .
        *___________________________________*/</FONT>
         if( max_sub_win &gt; 0)
         {
            *n_sub_win = *n_sub_win + 1;

            if (*n_sub_win == 1 )
            {
                n_windows   ++; 
                win_indx = max_main_win - n_windows + 1; 
                cpgslct(win_indx); 
                    
                if (max_sub_win ==2) cpgsubp(1,2);
                if (max_sub_win &gt;=3) cpgsubp(2,2);
            }
        }
    }
   <FONT COLOR="570BA3">/*  fprintf(stderr, "win_indx %i max_main_win %i \n", win_indx, max_main_win);    */</FONT>   
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_open_window_file">plot_open_window_file</A>  VISUALIZATION: Opens a gif, ps or xwd file to dump plots to.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose: Window manager, opens a file
 Steps:
 ------
    1) If it is the first time through the main loop then count the max. 
    number of main windows that are opened (max_main_win).
    2) Open an window and select
    3) If there are subwindows for a main window then don't open a new 
    window.

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   
_______________________________________________________________________ */</FONT>

    void <A href="#plot_open_window_file">plot_open_window_file</A>
    
    int     max_sub_win,                <FONT COLOR="570BA3">/* max number of sub_windows    */</FONT>

    int     *n_sub_win,                 <FONT COLOR="570BA3">/* counter for the number of sub*/</FONT>
                                        <FONT COLOR="570BA3">/* windows                      */</FONT>              
    char    basename[],                 <FONT COLOR="570BA3">/* basename of the file         */</FONT>
    int     filetype            )       <FONT COLOR="570BA3">/* type of file to select       */</FONT>
                                        <FONT COLOR="570BA3">/* 1 = gif, 2 = ps, 3 = xwd     */</FONT>

{
   static  int 
            first_time_through,         <FONT COLOR="570BA3">/* if this is the first time    */</FONT> 
            max_main_file,              <FONT COLOR="570BA3">/* max number of windows opened */</FONT>
            counter,                    <FONT COLOR="570BA3">/* file name counter            */</FONT>
            ID;                         <FONT COLOR="570BA3">/* device identifier            */</FONT>
            
    char    filename[100],
            indx[3],                    <FONT COLOR="570BA3">/* index of the file name      */</FONT>
            type[10];                   <FONT COLOR="570BA3">/* typ of plot                  */</FONT>
    char    am_I_here;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   
*_______________________________________________________________________*/</FONT>

    if (filetype == 1 )
        strcpy(type,".gif/GIF\0");
    if (filetype == 2 )
        strcpy(type,".ps/CPS\0");
    if (filetype == 3 )
        strcpy(type,".xwd/WD\0");
<FONT COLOR="570BA3">/*__________________________________
*   determine if this is the first time through
*___________________________________*/</FONT> 
    am_I_here= *getenv("PGPLOT_I_AM_HERE");        
    if ( am_I_here== '0' )  first_time_through = 1;
    if ( am_I_here== '1' )  first_time_through = 2;
<FONT COLOR="570BA3">/*__________________________________
*   First pass through 
*___________________________________*/</FONT>    
    if ( first_time_through == 1 )
    {     
        if ( max_sub_win == 0 ) 
        {
            max_main_file ++;

            <FONT COLOR="570BA3">/*__________________________________
            * Determine the filename and open the 
            * file
            *___________________________________*/</FONT>
            counter ++;
            sprintf(indx, "%d",counter);
            strcpy(filename,filepath);
            strcat(filename,indx);
            strcat(filename,basename);
            strcat(filename,type);
            ID = cpgopen(filename);
            if (ID &lt;= 0)
                <A href="#Message">Message</A>1, "plot_common.c", "plot_open_window_file", "couldn't open a file");
        }    
              
        <FONT COLOR="570BA3">/*__________________________________
        *   If there are sub windows then set
        *   the sub window layout and open the file
        *___________________________________*/</FONT>
         if( max_sub_win &gt; 0)
         {
            *n_sub_win = *n_sub_win + 1;
            if (*n_sub_win == 1 )
            {
               max_main_file ++;
                <FONT COLOR="570BA3">/*__________________________________
                * Determine the filename and open the 
                * file
                *___________________________________*/</FONT>
                counter ++;
                sprintf(indx, "%d",counter);
                strcpy(filename,filepath);
                strcat(filename,indx);
                strcat(filename,basename);
                strcat(filename,type);
                ID = cpgopen(filename);
                if (ID &lt;= 0)
                    <A href="#Message">Message</A>1, "plot_common.c", "plot_open_window_file", "couldn't open a file");
                <FONT COLOR="570BA3">/*__________________________________
                * Change the orientation of the plots here
                *___________________________________*/</FONT>
                if (max_sub_win ==2) cpgsubp(1,2);
                if (max_sub_win &gt;=3) cpgsubp(2,2);
            }
        }                
    }
    
<FONT COLOR="570BA3">/*__________________________________
*   All subsequent passes through
*___________________________________*/</FONT>       
    if ( first_time_through &gt;1 )
    {
        <FONT COLOR="570BA3">/*__________________________________
        *   No subwindows
        *___________________________________*/</FONT> 
        if ( max_sub_win == 0 ) 
        {
            <FONT COLOR="570BA3">/*__________________________________
            *   Determine the filename and open the 
            *   file
            *___________________________________*/</FONT>
            counter ++;
            strcpy(filename,filepath);
            sprintf(indx, "%d",counter);
            strcat(filename,indx);
            strcat(filename,basename);
            strcat(filename,type);
            ID = cpgopen(filename);
            if (ID &lt;= 0)
                <A href="#Message">Message</A>1, "plot_common.c", "plot_open_window_file", "couldn't open a file");      
        } 
                     
        <FONT COLOR="570BA3">/*__________________________________
        *   If there are sub windows then open
        *   a file and set the
        *   sub window layout
        *___________________________________*/</FONT>
         if( max_sub_win &gt; 0)
         {
            *n_sub_win = *n_sub_win + 1;

            if (*n_sub_win == 1 )
            {
                <FONT COLOR="570BA3">/*__________________________________
                *   Determine the filename and open the 
                *   file
                *___________________________________*/</FONT>
                counter ++;
                sprintf(indx, "%d",counter);
                strcpy(filename,filepath);
                strcat(filename,indx);
                strcat(filename,basename);
                strcat(filename,type);
                ID = cpgopen(filename); 
                if (ID &lt;= 0)
                    <A href="#Message">Message</A>1, "plot_common.c", "plot_open_window_file", "couldn't open a file");   
                if (max_sub_win ==2) cpgsubp(1,2);
                if (max_sub_win &gt;=3) cpgsubp(2,2);
            }
            
            <FONT COLOR="570BA3">/* if(*n_sub_win == max_sub_win) *n_sub_win = 0; */</FONT>
        }
    }      
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_generate_axis">plot_generate_axis</A>  VISUALIZATION: Generates the plot axes and labels.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose: generate the plot axis and label

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   

 IN args/commons        Units      Description
 ---------------        -----      -----------
 label                  char        label to put on plot
 x_min, x_max           float       max and min of x-axis
 y_min, y_max           float       max and min of y-axis 
 
  steps:
    1)  Determine the size of the characters that should be used in the 
        axis labels and the text
    2)  Generate the axis and label the plot
    3)  If one of the numbers is NAN or INF then print a warning message
Note:
    The standard margin surrounding each plot is 4 character heights
    surrounding each plot.
 ---------------------------------------------------------------------*/</FONT>

    void <A href="#plot_generate_axis">plot_generate_axis</A>  
    
    char    x_label[],                  <FONT COLOR="570BA3">/* label along x axis           */</FONT>
    char    y_label[],                  <FONT COLOR="570BA3">/* label along y axis           */</FONT>
    char    graph_label[],              <FONT COLOR="570BA3">/* label along the top of plot  */</FONT>    
    float   *x_min, 
    float   *x_max,
    float   *y_min,
    float   *y_max,
    int     *error          )           <FONT COLOR="570BA3">/* if NAN or INF has been found */</FONT>
{
    int     unit = 2;                   <FONT COLOR="570BA3">/* units of measure 2= mm       */</FONT>
            
    float   x1,x2,y1, y2;
    float   char_size_axis,
            char_size_text,
           c_x, c_y, delx, dely;
<FONT COLOR="570BA3">/*START_DOC*/</FONT> 
<FONT COLOR="570BA3">/*__________________________________
* Determine the size of the text
*___________________________________*/</FONT>
    cpgqvp(unit,&amp;x1, &amp;x2, &amp;y1, &amp;y2);

    delx            = x2 - x1;
    dely            = y2 - y1;
    
    c_x             = 60.0/delx;
    c_y             = 60.0/dely;
    char_size_axis  = FMAX(1.0, c_x);
    char_size_axis  = FMAX(char_size_axis, c_y);
    
    c_x             = 80.0/delx;
    c_y             = 80.0/dely;    
    char_size_text  = FMAX(1.0, c_x);
    char_size_text  = FMAX(char_size_text, c_y);

<FONT COLOR="570BA3">/*     fprintf(stderr,"x1 %f, x2 %f, y1 %f y2 %f \n",x1, x2, y1, y2); */</FONT>
<FONT COLOR="570BA3">/*__________________________________
* Generate axis a grid and label the plot
*___________________________________*/</FONT>
    cpgsch(char_size_axis);
  
    cpgenv(*x_min, *x_max, *y_min, *y_max, 0, show_grid); 
    cpgbox("G\0",0.0, 0, "G\0", 0.0, 0);
    cpgsch(char_size_text);
    cpglab(x_label, y_label,    graph_label);
    cpgsch(1.0); 
    
    
    
<FONT COLOR="570BA3">/*__________________________________
*   If NAN or INF has been detected
*   in the data array then warn the user
*___________________________________*/</FONT>   
    if (*error == 1) 
    {
        cpgsci(NUM_COLORS);
        cpgsch(char_size_text);
        cpgmtxt("T\0",2.5, 0.5, 0.5, "NAN or INF has been detected\0");
        cpgsch(1.0);
        cpgsci(1);
    }
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_legend">plot_legend</A>  VISUALIZATION: Generates a color wedge and labels it.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose: generate a color wedge on top of a contour plot
            add labels along with the data max and min values

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   

 IN args/commons        Units      Description
 ---------------        -----      -----------
 label                  char        label to put on plot
 x_min, x_max           float       max and min of x-axis
 y_min, y_max           float       max and min of y-axis 
 
  steps:
_______________________________________________________________________ */</FONT>

void    <A href="#plot_legend">plot_legend</A> 
    float   data_max,   
    float   data_min,
    float   x_max,
    float   y_max           )
{
    int     i, 
            unit = 2;                   <FONT COLOR="570BA3">/* units of measure 2= mm       */</FONT>     
            
    float   x1,     x2,     y1,         y2;
    float   char_size_axis,
            char_size_text,
            text,
            height,
            offset,
            c_x,    c_y,    
            delx,   dely;
    char    label[15];
<FONT COLOR="570BA3">/*__________________________________
* Determine the size of the text
*___________________________________*/</FONT>
    cpgqvp(unit,&amp;x1, &amp;x2, &amp;y1, &amp;y2);

    delx            = x2 - x1;
    dely            = y2 - y1;
    
    c_x             = 70.0/delx;
    c_y             = 70.0/dely;
    char_size_axis  = FMAX(0.0, c_x);
    char_size_axis  = FMAX(char_size_axis, c_y);
    
    c_x             = 80.0/delx;
    c_y             = 80.0/dely;    
    char_size_text  = FMAX(1.0, c_x);
    char_size_text  = FMAX(char_size_text, c_y);
    
<FONT COLOR="570BA3">/*__________________________________
*   Set th Wedge function and color range
*___________________________________*/</FONT>
    cpgscir(1,NUM_COLORS);
<FONT COLOR="570BA3">/*__________________________________
*   Define the color wedge
*___________________________________*/</FONT>
    cpgsch(char_size_axis);
    cpgsci(0);
    cpgwedg("RI\0",0.5, char_size_text, 0.0, 1.0, " \0");
<FONT COLOR="570BA3">/*__________________________________
*   Generate the label for the wedge
*   10 labels per wedge
*___________________________________*/</FONT>
    cpgsch(char_size_axis);
    cpgstbg(0);
    cpgsci(1);
<FONT COLOR="570BA3">/*__________________________________
*   Now generate the location of where 
*   to place the label and the labels 
*   themselves
*___________________________________*/</FONT>
     offset      = 0.0454550*fabs(data_max - data_min);
    data_min    = data_min + offset;
    data_max    = data_max - offset;
    
    for( i = 0; i &lt;=10; i++)
    {
        height  = (float)i/10.0;
        text    = data_min + (float) (i) * (data_max - data_min)/10.0;
        sprintf(label, "%.4g",text); 
         
        cpgptxt(x_max*1.02, y_max*height, 30.0, 0.0,label);  
    }    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_scaling">plot_scaling</A>  VISUALIZATION: Finds and max. and min. values of the plot data.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_color_spectrum">plot_color_spectrum</A>  VISUALIZATION: Generates the color spectrum for the plots.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_scaling_CC">plot_scaling_CC</A>  VISUALIZATION: OLD, Finds the max and min values of an array.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose:  Find the max and min values for a single material array

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written    
_______________________________________________________________________ */</FONT>

void <A href="#plot_scaling_CC">plot_scaling_CC</A> 

    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>            
    double  ***data_array,
    float   *y_min,
    float   *y_max          )
        
{ 
    int i, j, k;
<FONT COLOR="570BA3">/*__________________________________
* initialize
*___________________________________*/</FONT>
    *y_min = 1.0e10;
    *y_max = 0.0;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now find the max and min of the 
  array
______________________________  */</FONT>                
    for(k = zLoLimit; k &lt;= zHiLimit; k++)
    {
        for(j = yHiLimit; j &gt;= yLoLimit; j--)
        {
            for(i = xLoLimit; i &lt;= xHiLimit; i++)
            {
               if ( data_array[i][j][k] &gt;= *y_max) {
                    *y_max = (float) data_array[i][j][k];
                }
               if ( data_array[i][j][k] &lt;= *y_min) {
                    *y_min = (float) data_array[i][j][k];
                }  
               
            }
        }
    }
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_scaling_FC">plot_scaling_FC</A>  VISUALIZATION: OLD finds max. and min. values of a FC array.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_common.c
 Filename: plot_common.c

 Purpose:  Find the max and min values for a multi-material array

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   

 IN args/commons        Units      Description
 ---------------        -----      -----------
 data_array             ******double  (x,y,z,material,face)
 m                      int         material  
_______________________________________________________________________ */</FONT>

void <A href="#plot_scaling_FC">plot_scaling_FC</A> 
                        
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT> 
    double  ******data_array,
    int     m,                          <FONT COLOR="570BA3">/* material                         */</FONT>
    float   *y_min, 
    float   *y_max          )
        
{ 
    int 
        i, j, k, f,
        n_faces;
    float 
        offset;
<FONT COLOR="570BA3">/*__________________________________
* initialize
*___________________________________*/</FONT>
    *y_min  = 1.0e10;
    *y_max  = 0.0;
    n_faces = 2;
    
    #if (N_DIMENSIONS == 2)
        n_faces = 4;
    #endif
    
    #if (N_DIMENSIONS == 3)
        n_faces = 6;
    #endif
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM); 
    assert ( m &gt;= 0 &amp;&amp; m &lt;= N_MATERIAL);   
<FONT COLOR="570BA3">/* ______________________________
  Now find the max and min of the 
  array
______________________________  */</FONT>                
    for(k = zLoLimit; k &lt;= zHiLimit; k++)
    {
        for(j = yHiLimit; j &gt;= yLoLimit; j--)
        {
            for(i = xLoLimit; i &lt;= xHiLimit; i++)
            {
                for (f = 1; f &lt;= n_faces; f++)
                {
                    if ( *data_array[i][j][k][f][m] &gt;= *y_max) 
                    {
                         *y_max = (float)*data_array[i][j][k][f][m];
                    }
                    if ( *data_array[i][j][k][f][m] &lt;= *y_min)
                    { 
                         *y_min = (float)*data_array[i][j][k][f][m];  
                    }
               }
            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
*   if y_min = y_max
*___________________________________*/</FONT>
    offset = 0.025*fabs(*y_max - *y_min);
    *y_min = *y_min - offset;
    *y_max = *y_max + offset;
    
    if (offset &lt;= DIFFERENCE )
    {
        *y_min = *y_min - 0.1;
        *y_max = *y_max + 0.1;
    }    
<FONT COLOR="570BA3">/*__________________________________
* if y_min or y_max =0.0
*___________________________________*/</FONT>
    if( fabs(*y_min) &lt;= DIFFERENCE ) *y_min = -0.1;
    if( fabs(*y_max) &lt;= DIFFERENCE ) *y_max =  0.1;
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_contour">plot_contour</A>  VISUALIZATION: Generates a contour plot.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_contour.c
 Filename: plot_contour.c

 Purpose: generate a contour plot

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       07/29/99   Written   

 IN args/commons        Units      Description
 ---------------        -----      -----------
 label                  char        label to put on plot
 
  steps:
    1)  calculate the contour levels, and make sure that none of them
        are integers.  If they are then offset them slightly.  This prevents
        white space from appearing.
    2)  Loop through each of the contour levels and plot that contour.
    
Note: For details regarding the pgplot functions see the pgplot documentation
_______________________________________________________________________*/</FONT>

    void <A href="#plot_contour">plot_contour</A> 
    int     xLoLimit,      
    int     xHiLimit,
    int     yLoLimit,
    int     yHiLimit,       
    float   data_min,
    float   data_max,
    const   float   *data )
{            
    float   *contour_levels,
            small_number;
    static float    TR[6] = {-1.0, 1.0, 0.0, -1.0, 0.0, 1.0};

<FONT COLOR="570BA3">/*     static float    TR[6] = {-0.5, 1.0, 0.0, -0.5, 0.0, 1.0}; */</FONT>
            
    int     i, 
            xLo, yLo,
            xHi, yHi,
            n_contours,
            color;
    double  test;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Define some constants
*_______________________________________________________________________*/</FONT>
    n_contours  = 100;
    small_number = (data_max - data_min)/n_contours;
    <FONT COLOR="570BA3">/*__________________________________
    *   If you start at xLo or yLo = 0 then
    *   it doesn't work you need to offset
    *   the indicies by 1
    *___________________________________*/</FONT>
    xHi       = xHiLimit;
    yHi       = yHiLimit;
    xLo       = xLoLimit;
    yLo       = yLoLimit;
    if (xLoLimit ==0 || yLoLimit ==0)
    {  
        xHi       = xHiLimit+1;
        yHi       = yHiLimit+1;
        xLo       = xLoLimit+1;
        yLo       = yLoLimit+1;
    }
<FONT COLOR="570BA3">/*__________________________________
*   
*___________________________________*/</FONT>

    contour_levels  = vector(0, n_contours+2);
<FONT COLOR="570BA3">/*__________________________________
*   Step 1
*   Set the contour levels
*___________________________________*/</FONT>
    for (i =2; i &lt;= n_contours -1; i++)
    {
        contour_levels[i] = data_min + 
                            (float)i * (data_max - data_min)/(float)n_contours;
        <FONT COLOR="570BA3">/*__________________________________
        *   If one of the contour levels has a 
        *   fractional value of 0 then offset
        *   that value slightly
        *___________________________________*/</FONT>
        test = fmod((double)contour_levels[i], 1.0);
        if(  test == 0.0) 
        {
            contour_levels[i] = contour_levels[i] + small_number;
        }
    }    
    contour_levels[1]           = data_min - small_number;
    contour_levels[n_contours]  = data_max + small_number;
          
<FONT COLOR="570BA3">/*__________________________________
*   Step 2
*   Now loop through each contour level
*___________________________________*/</FONT>
    color = 0;   
    for( i = 1; i &lt;= n_contours-1; i++)
    {
        color = (int)(i*NUM_COLORS/n_contours) + 1;
        
        cpgsci(color);
        cpgconf(&amp;data[1],   xHi,  yHi,
                            xLo,  xHi,
                            yLo,  yHi,
                            contour_levels[i], contour_levels[i+1],TR);
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Deallocate the memory
*_______________________________________________________________________*/</FONT>
    free_vector(contour_levels, 0, n_contours+2);
    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_contour_checkerboard">plot_contour_checkerboard</A>  VISUALIZATION: Generates a checkerboard contour plot.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_contour.c
 Filename: plot_contour.c

 Purpose: generates a checker board contour plot that represents the
 cell-centered values as squares of a certain color

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       11/17/99   Written   
 
  steps:
    1)  calculate the contour levels, and make sure that none of them
        are integers.  If they are then offset them slightly.  This prevents
        white space from appearing.
    2)  Loop through each of the contour levels and draw rectangle.
    
Note: For details regarding the pgplot functions see the pgplot documentation
_______________________________________________________________________*/</FONT>

    void <A href="#plot_contour_checkerboard">plot_contour_checkerboard</A> 
    int     xLoLimit,      
    int     xHiLimit,
    int     yLoLimit,
    int     yHiLimit,       
    float   data_min,
    float   data_max,
    const   float   *data )
{            
    float   *contour_levels,
            small_number;
            
    int     i, j, c, counter,
            n_contours,
            color;
    float   x1, x2, y1, y2,
            scaleX, scaleY;
    double  test;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Define some constants
*_______________________________________________________________________*/</FONT>
    
    scaleX      = 1.0 - 1.0/xHiLimit;
    scaleY      = 1.0 - 1.0/yHiLimit;
    n_contours  = 100;
    small_number = (data_max - data_min)/n_contours;
<FONT COLOR="570BA3">/*__________________________________
*   
*___________________________________*/</FONT>

    contour_levels  = vector(0, n_contours+2);
<FONT COLOR="570BA3">/*__________________________________
*   Step 1
*   Set the contour levels
*___________________________________*/</FONT>
    for (i =2; i &lt;= n_contours -1; i++)
    {
        contour_levels[i] = data_min + 
                            (float)i * (data_max - data_min)/(float)n_contours;
        <FONT COLOR="570BA3">/*__________________________________
        *   If one of the contour levels has a 
        *   fractional value of 0 then offset
        *   that value slightly
        *___________________________________*/</FONT>
        test = fmod((double)contour_levels[i], 1.0);
        if(  test == 0.0) 
        {
            contour_levels[i] = contour_levels[i] + small_number;
        }
    }    
    contour_levels[1]           = data_min - small_number;
    contour_levels[n_contours]  = data_max + small_number;
          
<FONT COLOR="570BA3">/*__________________________________
*   Step 2
*   Now loop through each contour level
*___________________________________*/</FONT>
    color = 0;   
    for( c = 1; c &lt;= n_contours-1; c++)
    {

        color   = (int)(c*NUM_COLORS/n_contours) + 1;
        cpgsci(color);
        counter = 0;

        for(j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for(i = xLoLimit; i &lt;= xHiLimit; i++)
            {
                counter ++;
                if ((data[counter] &gt;= contour_levels[c]) &amp;&amp; (data[counter] &lt;= contour_levels[c+1]))
                {
                    x1 = (float) scaleX* i;
                    x2 = (float) scaleX* (i+1);
                    y1 = (float) scaleY* (j);
                    y2 = (float) scaleY* (j+1);
                    cpgrect(x1, x2, y1, y2);
                }
            }
        }
    }

<FONT COLOR="570BA3">/*______________________________________________________________________
*   Deallocate the memory
*_______________________________________________________________________*/</FONT>
    free_vector(contour_levels, 0, n_contours+2); 
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_2d_scatter">plot_2d_scatter</A>  Visualizaton: Generates a 2D line plot.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_2d_line
 Filename: plot_2d_line
 Purpose:
 This subroutine generates a 2-d scatter plot of the input variables.

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   

 IN args/commons        Units      Description
 ---------------        -----      -----------
 
 The length of the arrays is max_len
_______________________________________________________________________ */</FONT>
    void <A href="#plot_2d_scatter">plot_2d_scatter</A>
        const float     *x_data,
        const float     *y_data,
        int             max_len,
        int             color,
        int             symbol,
        float           symbol_size    )
{                  

<FONT COLOR="570BA3">/*______________________________________________________________________
*   Generate the plot window #1
*_______________________________________________________________________*/</FONT>  
    if ( max_len != 1) 
    {        
        cpgsci(color);
        cpgsch(symbol_size);
        cpgpt(max_len,    &amp;x_data[1], &amp;y_data[1],symbol);
        cpgline(max_len,  &amp;x_data[1], &amp;y_data[1]);
        cpgsci(1);
    }  
} 
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_dbl_flt">plot_dbl_flt</A>  VISUALIZATION: converts a vector of doubles to floats.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_2d_line
 Filename: plot_2d_line
 Purpose:
 Converts a 1-D double array into a 1D float array

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99   Written   

 IN args/commons        Units      Description
 ---------------        -----      -----------
 dbl_1                  double    4d array
 flt_1                  float     1-d array
 max_len                  int       maximum length of array
 
Note this function assumes that the arrays starting index is 1
_______________________________________________________________________ */</FONT>
    void <A href="#plot_dbl_flt">plot_dbl_flt</A>                        
        int     max_len,
        double  ****dbl_1,
        double  ****dbl_2,
        float   *flt_1,
        float   *flt_2 )
               
{       
     int  i;

       for (i = 1; i &lt;= max_len; i++)
       {   
          flt_1[i] = (float)dbl_1[i+N_GHOSTCELLS][N_GHOSTCELLS][N_GHOSTCELLS][1];
          flt_2[i] = (float)dbl_2[i+N_GHOSTCELLS][N_GHOSTCELLS][N_GHOSTCELLS][1];
       }
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="plot_find_cursor_pos">plot_find_cursor_pos</A>  VISUALIZATION: Allows user to get data from the window by clicking the mouse.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: plot_cursor_pos.c
 Filename: plot_cursor_pos.c

 Purpose:   This function allows the user to select points on a plot and it 
            returns the x and y coordinates of that plot.  This is usefull
            in debugging.  For lack of a better term I call it cursor data.
 Steps:
 ------
    1) The first time through the main loop have the user select the windows
       that cursor data is desired.  The array "get_cursor_data" contains
       the flags that are used to determine which windows are to be investigated
       with the cursor.
   
    2) For subsequent passes through the routine select the correct window
       the user simply selects points on the window and the routing prints
       to stderr the x y coordinates.
    

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       3/08/99   Written   
       
WARNING 
    Don't call any of the plotting routine inside of an iterative loop
       
_______________________________________________________________________ */</FONT>

    void plot_cursor_position(
    int        max_sub_win,             <FONT COLOR="570BA3">/* max number of sub_windows                */</FONT>
    int        *n_sub_win )             <FONT COLOR="570BA3">/* counter for the number of sub            */</FONT>
                                        <FONT COLOR="570BA3">/* windows                                  */</FONT>

{
    int     x_int, y_int;               <FONT COLOR="570BA3">/* position x and y converted to an integer */</FONT>
                
    float   x, y; 
                                           
   static  int 
            first_time_through,         <FONT COLOR="570BA3">/* if this is the first time                */</FONT> 
            n_windows,                  <FONT COLOR="570BA3">/* number of open windows counter           */</FONT>
            max_main_win,               <FONT COLOR="570BA3">/* max number of windows opened             */</FONT>
            get_cursor_data[12];        <FONT COLOR="570BA3">/* array of switches for getting cursor     */</FONT>
                                        <FONT COLOR="570BA3">/* data for that particular window          */</FONT>
            
    char    am_I_here,
            ans;                        <FONT COLOR="570BA3">/* mouse input or answer                    */</FONT> 

     double junk;       
         
<FONT COLOR="570BA3">/*______________________________________________________________________
*   MAIN CODE
*_______________________________________________________________________*/</FONT>
    
<FONT COLOR="570BA3">/*__________________________________
*   determine if this is the first time through
*___________________________________*/</FONT> 
    am_I_here= *getenv("PGPLOT_I_AM_HERE");        
    if ( am_I_here== '0' )  first_time_through = 1;
    if ( am_I_here== '1' )  first_time_through = 2;
      
<FONT COLOR="570BA3">/*__________________________________
*   First pass through 
*___________________________________*/</FONT> 
    if ( first_time_through == 1 )
    {
        <FONT COLOR="570BA3">/*__________________________________
        * No subwindows then just ask user
        * if they want that window interactive
        *___________________________________*/</FONT>
        if ( max_sub_win == 0 ) 
        {
            max_main_win ++;    
                
            cpgsci(NUM_COLORS);
            cpgsch(1.25 );
            cpgscf(1);
            cpgmtxt("T\0", 0.0, 0.5, 0.5, "Press Right mouse button to make this window interactive"); 
            cpgsci(1);  
            cpgcurs(&amp;x,&amp;y,&amp;ans);

            if(ans == 'X') 
            {
                get_cursor_data[max_main_win] = YES;
                <FONT COLOR="570BA3">/* fprintf(stderr, "ans %s,   array data[%i]= %i\n",&amp;ans, max_main_win,get_cursor_data[max_main_win]); */</FONT>
            } 
        }   
        <FONT COLOR="570BA3">/*__________________________________
        * If there are sub windows then ask
        * the user if they want it interactive
        * store the answer in get_cursor_data
        *___________________________________*/</FONT>
         if( max_sub_win &gt; 0)
         {
            *n_sub_win = *n_sub_win + 1;
            if (*n_sub_win == max_sub_win )
            {
                max_main_win ++;
                cpgsci(NUM_COLORS);
                cpgsch(1.25);
                cpgscf(1);
                cpgmtxt("B\0", 2.0, 0.5, 0.5, "Press Right mouse button to make this window interactive");
                cpgsci(1);  
                cpgcurs(&amp;x,&amp;y,&amp;ans);

                if(ans == 'X') 
                {
                    get_cursor_data[max_main_win] = YES;
                    <FONT COLOR="570BA3">/* fprintf(stderr, "ans %s,   array data[%i]= %i\n",&amp;ans, max_main_win,get_cursor_data[max_main_win]);  */</FONT>
                }
            }
        } 
    
   }    
<FONT COLOR="570BA3">/*__________________________________
*   All subsequent passes through
*   this routine
*___________________________________*/</FONT>       
    if ( first_time_through &gt;1 )
    {
        <FONT COLOR="570BA3">/*__________________________________
        *   If there are no subwindows 
        *___________________________________*/</FONT>
        if ( max_sub_win == 0 ) 
        {
            <FONT COLOR="570BA3">/*__________________________________
            * Find the window index
            *___________________________________*/</FONT>
            n_windows   ++;
            <FONT COLOR="570BA3">/*__________________________________
            * If get cursor data = yes then get it
            *___________________________________*/</FONT>    
            if(get_cursor_data[n_windows] == YES)
            {
                fprintf(stderr,"\n Click left to see data and right to exit\n");
                ans = 'n';
                <FONT COLOR="570BA3">/*__________________________________
                * Until the right mouse is clicked
                * get the x y coordinates and 
                * convert them into (int) and 
                * print it to stderr.
                *___________________________________*/</FONT>
                while( ans != 'X'  )
                {
                    
                    cpgcurs(&amp;x,&amp;y,&amp;ans);
                    <FONT COLOR="570BA3">/*__________________________________
                    * Now round off the x y data into ints
                    *___________________________________*/</FONT>
                    if( modf((double)x, &amp;junk) &lt; 0.5)
                        x_int =(int) x;
                        
                    if( modf((double)x, &amp;junk) &gt;= 0.5)
                        x_int =(int) x + 1;

                    if( modf((double)y, &amp;junk) &lt; 0.5)
                        y_int =(int) y;
                        
                    if( modf((double)y, &amp;junk) &gt;= 0.5)
                        y_int =(int) y + 1;
                    fprintf(stderr,"xpos %f \t %i \t ypos %f \t %i\n",x, x_int, y, y_int);
                    <FONT COLOR="570BA3">/* fprintf(stderr, "character %s\n",&amp;ch); */</FONT>
                }
            }
        } 
                     
        <FONT COLOR="570BA3">/*__________________________________
        *   If there are sub windows 
        *___________________________________*/</FONT>
         if( max_sub_win &gt; 0 )
         {
            <FONT COLOR="570BA3">/*__________________________________
            * Find the window index
            *___________________________________*/</FONT>
            *n_sub_win = *n_sub_win + 1;
            if (*n_sub_win == 1 )
            {
                n_windows   ++;
            }
            <FONT COLOR="570BA3">/*__________________________________
            * If get cursor data = yes then get it
            *___________________________________*/</FONT>
            if(get_cursor_data[n_windows] == YES)
            {
                fprintf(stderr,"\n Click left to see data and right to exit\n");
                <FONT COLOR="570BA3">/*__________________________________
                * Until the right mouse is clicked
                * get the x y coordinates and 
                * convert them into (int) and 
                * print it to stderr.
                *___________________________________*/</FONT>
                while( ans != 'X' )
                {
                    cpgcurs(&amp;x,&amp;y,&amp;ans);
                    
                    <FONT COLOR="570BA3">/*__________________________________
                    * Now round off the x y data into ints
                    *___________________________________*/</FONT>
                    if( modf((double)x, &amp;junk) &lt; 0.5)
                        x_int =(int) x;
                        
                    if( modf((double)x, &amp;junk) &gt;= 0.5)
                        x_int =(int) x + 1;

                    if( modf((double)y, &amp;junk) &lt; 0.5)
                        y_int =(int) y;
                        
                    if( modf((double)y, &amp;junk) &gt;= 0.5)
                        y_int =(int) y + 1;
                    fprintf(stderr,"xpos %f \t %i \t ypos %f \t %i\n",x, x_int, y, y_int);
                    <FONT COLOR="570BA3">/* fprintf(stderr, "character %s\n",&amp;ch); */</FONT>
                }
            } 
        }
    }
    <FONT COLOR="570BA3">/*__________________________________
    *   reset the number of windows count
    *___________________________________*/</FONT>
    if (n_windows == max_main_win &amp;&amp; *n_sub_win == max_sub_win) 
    {
        n_windows   = 0;
    }
   <FONT COLOR="570BA3">/*  fprintf(stderr, "win_indx %i max_main_win %i \n", win_indx, max_main_win);    */</FONT>   
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="explicit_delPress">explicit_delPress</A>  PRESSURE: Step 2, compute the change in pressure, explicitly</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: explicit_delPress.c
 Filename: explicit_delPress.c
 Purpose:
   This function calculates the change in pressure explicitly.  Basically it just 
   solves the pressure equation once.
 Note:  Units of delpress are [Pa]
 
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/10/00    
 ---------------------------------------------------------------------  */</FONT>
void explicit_delPress
             (  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT> 
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
        double  ****div_velFC_CC,       <FONT COLOR="570BA3">/* divergence of face cented vel at (INPUT) */</FONT>
        double  ****delPress_CC,        <FONT COLOR="570BA3">/* Change in the cell-centered press(INPUT) */</FONT>
        double  ****press_CC,           <FONT COLOR="570BA3">/* Cell-center pressure             (INPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* delta t                          (INPUT) */</FONT>
        double  ****speedSound,         <FONT COLOR="570BA3">/* speed of Sound(x,y,z,material    (INPUT) */</FONT>
        int     nMaterials )  
    
{
    int         i, j, k, m;

    double      vol, coeff;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
* and allocat some memory
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    <FONT COLOR="570BA3">/*__________________________________
    *   Now compute the pressure and
    *   change in pressure
    *___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            {
                for ( i = xLoLimit; i &lt;= xHiLimit; i++)
                { 
                    vol     = delX * delY * delZ; 
                    coeff   = delt * rho_CC[i][j][k][m] * pow(speedSound[i][j][k][m],2) / vol;

                    delPress_CC[i][j][k][m] = -coeff * div_velFC_CC[i][j][k][m]; 

                    press_CC[i][j][k][m]    = press_CC[i][j][k][m] + delPress_CC[i][j][k][m];
                }
            }
        }
    }
 
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING
*_______________________________________________________________________*/</FONT>
#if switchDebug_explicit_delPress
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        explicit_delPress\n");
    fprintf(stderr,"****************************************************************************\n");
   
                       
    <A href="#printData_4d">printData_4d</A>       xLo,                yLo,            zLo,
                        xHi,                yHi,            zHi,
                        m,                  m,
                       "explicit_delPress",     
                       "Press_CC",          press_CC);
                       
    <A href="#printData_4d">printData_4d</A>       xLo,                yLo,            zLo,
                        xHi,                yHi,            zHi,
                        m,                  m,
                       "explicit_delPress",     
                       "delPress_CC",       delPress_CC);
   fprintf(stderr,"****************************************************************************\n");
    
    fprintf(stderr,"press return to continue\n");
    getchar();
#endif
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="press_face">press_face</A>  FACE-CENTERED PRESS: Step 3,Computes the face-centered pressure from cell-centered data.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: p_face.c
 Filename: p_face.c
 
 Purpose:
    This function calculates the face centered pressure on each of the 
    cell faces for every cell in the computational domain and a single layer of
    ghost cells.  This routine assume that there is a single layer of ghostcells

Steps:
    1)  Compute the face-centered pressure for the top and right face for all
    cells in the computational domain.
    
Additional Notes:
    The computations were divided up to eliminate
    the need for a "if" statement inside of the loop.
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 
 NEED to add 3rd dimension
  ---------------------------------------------------------------------  */</FONT>
void    <A href="#press_face">press_face</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  ****press_CC,           <FONT COLOR="570BA3">/* cell-centered pressure           (INPUT) */</FONT>   
        double  ******press_FC,         <FONT COLOR="570BA3">/* face-centered pressure           (OUPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* cell-centered density            (INPUT) */</FONT>
        int     nMaterials      )
{
    int     i,j,k, m,
            xLo,        xHi,
            yLo,        yHi,
            zLo,        zHi, 
            cell;       
    double       
            sp_vol,                     <FONT COLOR="570BA3">/* specific vol.                    */</FONT>
            sp_vol_adj;                 <FONT COLOR="570BA3">/* specific vol. in adjacent cel.   */</FONT>
    char    should_I_write_output;
#if sw_p_face
    time_t start;                       <FONT COLOR="570BA3">/* timing variables                */</FONT>
    start = time(NULL);
#endif 
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_p_face
    double  delX = 1.0;
    double  delY = 1.0;
    #include "plot_declare_vars.h"   
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Step 1:
*   Interpolate the pressure from the 
*   cell-center on to the face on the top
*   and right face.
*___________________________________*/</FONT>  
    for(m = 1; m &lt;= nMaterials; m++)
    {
        xLo = GC_LO(xLoLimit);
        xHi = GC_HI(xHiLimit);
        yLo = GC_LO(yLoLimit);
        yHi = (yHiLimit);
        zLo = GC_LO(zLoLimit);
        zHi = GC_HI(zHiLimit); 
        
        for(k = zLo; k &lt;= zHi ; k++)
        {
            for(j = yLo; j &lt;= yHi; j++)
            { 
                for(i = xLo; i &lt;= xHi; i++)
                {
                    sp_vol      = 1.0/rho_CC[i][j][k][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    * Top Face
                    *___________________________________*/</FONT>
                    cell        = j+1;
                    sp_vol_adj  = 1.0/rho_CC[i][cell][k][m];
                    
                    
                    assert ( (sp_vol_adj + sp_vol) &lt;=BIG_NUM);
                    *press_FC[i][j][k][TOP][m]      = 
                    (press_CC[i][cell][k][m] * sp_vol_adj + press_CC[i][j][k][m] * sp_vol)/
                            (sp_vol + sp_vol_adj);    

                }
            }
        }
        yHi = GC_HI(yHiLimit);
        xHi = xHiLimit;
        xLo = GC_LO(xLoLimit);
        yLo = GC_LO(yLoLimit);
        for(k = zLo; k &lt;= zHi ; k++)
        {
            for(j = yLo; j &lt;= yHi; j++)
            { 
                for(i = xLo; i &lt;= xHi; i++)
                {
                    sp_vol      = 1.0/rho_CC[i][j][k][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    * Right Face
                    *___________________________________*/</FONT>
                    cell        = i+1;
                    sp_vol_adj  = 1.0/rho_CC[cell][j][k][m];
                    assert ( (sp_vol_adj + sp_vol) &lt;=BIG_NUM);
                    
                    *press_FC[i][j][k][RIGHT][m]    =
                    (press_CC[cell][j][k][m] * sp_vol_adj + press_CC[i][j][k][m] * sp_vol)/
                            (sp_vol_adj + sp_vol);                
                }
            }
        }
<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
        <FONT COLOR="570BA3">/*__________________________________
        *  Do something in the third dimension
        *  Need to add front or back face
        *___________________________________*/</FONT>    
        yHi = GC_HI(yHiLimit);
        xHi = GC_HI(xHiLimit);
        xLo = GC_LO(xLoLimit);
        yLo = GC_LO(yLoLimit);
        for(k = zLo; k &lt;= zHi ; k++)
        {
            for(j = yLo; j &lt;= yHi; j++)
            { 
                for(i = xLo; i &lt;= xHi; i++)
                {
                    *press_FC[i][j][k][FRONT][m]   = 0.0;
                    *press_FC[i][j][k][BACK][m]    = 0.0;                              
                }
            }
        }
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
        
    }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="equate_ptr_addresses_adjacent_cell_faces">equate_ptr_addresses_adjacent_cell_faces</A>  MISC: equates the pointer address of face-centered variables.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: equate_ptr_addrss.c
 Filename: equate_ptr_addrss.c
 Purpose:   Set the pointer address of adjacent cell faces equal to 
            each other.
            For example set the address of 
                 [i][j][k][RIGHT][m] = [i-1][j][k][LEFT][m] 
            and similarly for the other faces.
            
 Steps
    1)      Equate the face address on all cells except for those 
            along the top and right layer of cells.
              
    2)      Equate the face addresses in the top and right layer of cells
     
 History: 
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       010/13/99                                
                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face  
--------------------------------------------------
 WARNING: (1/18/00)
 You MUST set the top and bottom faces like this,
    (*)_FC[i][j+1][k][BOTTOM] = (*)_FC[i][j][k][TOP]; 
 If you set them the other way,
    (*)_FC[i][j][k][TOP]      = (*)_FC[i][j+1][k][BOTTOM];  
  the code will core dump when you deallocate that array.
---------------------------------------------------------------------*/</FONT> 

void <A href="#equate_ptr_addresses_adjacent_cell_faces">equate_ptr_addresses_adjacent_cell_faces</A>
        double  *****x_FC,              <FONT COLOR="570BA3">/*--------pointer-------------------*/</FONT>
        double  *****y_FC,              <FONT COLOR="570BA3">/* (*)_FC(i,j,k,face)               */</FONT>
        double  *****z_FC,
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* (*)vel_FC(i,j,k,face,material)   (IN/OUT)*/</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/*                                  (IN/OUT)*/</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/*                                  (IN/OUT)*/</FONT>
        double  ******press_FC,         <FONT COLOR="570BA3">/*                                  (IN/OUT)*/</FONT>
        double  ******tau_x_FC,         <FONT COLOR="570BA3">/* *x-stress component at each face (IN/OUT)*/</FONT>
        double  ******tau_y_FC,         <FONT COLOR="570BA3">/* *y-stress component at each face (IN/OUT)*/</FONT>
        double  ******tau_z_FC,         <FONT COLOR="570BA3">/* *z-stress component at each face (IN/OUT)*/</FONT>
        int     nMaterials)
{
    int i,j,k,m;

<FONT COLOR="570BA3">/*__________________________________
*   Step 1:
* Now make sure that the face centered
* values know about each other.
* for example 
* [i][j][k][RIGHT][m] = [i-1][j][k][LEFT][m]
*   This covers all of the cells except 
*   a single layer on the top and right
*   sides.
*___________________________________*/</FONT>  
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( k = 0; k &lt;= Z_MAX_LIM-1; k++)
        {
            for ( j = 0; j &lt;= Y_MAX_LIM-1; j++)
            {
                for ( i = 0; i &lt;= X_MAX_LIM-1; i++)
                {
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate left and right sides
                    *___________________________________*/</FONT>
                    x_FC[i][j][k][RIGHT]            = x_FC[i+1][j][k][LEFT];
                    y_FC[i][j][k][RIGHT]            = y_FC[i+1][j][k][LEFT];
                    z_FC[i][j][k][RIGHT]            = z_FC[i+1][j][k][LEFT];
                    press_FC[i][j][k][RIGHT][m]     = press_FC[i+1][j][k][LEFT][m];
                    tau_x_FC[i][j][k][RIGHT][m]     = tau_x_FC[i+1][j][k][LEFT][m];
                    tau_y_FC[i][j][k][RIGHT][m]     = tau_y_FC[i+1][j][k][LEFT][m];
                    tau_z_FC[i][j][k][RIGHT][m]     = tau_z_FC[i+1][j][k][LEFT][m];
                    uvel_FC[i][j][k][RIGHT][m]      = uvel_FC[i+1][j][k][LEFT][m];
                    vvel_FC[i][j][k][RIGHT][m]      = vvel_FC[i+1][j][k][LEFT][m];
                    wvel_FC[i][j][k][RIGHT][m]      = wvel_FC[i+1][j][k][LEFT][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate top and bottom sides
                    *___________________________________*/</FONT>
                    x_FC[i][j+1][k][BOTTOM]		= x_FC[i][j][k][TOP];	
                    y_FC[i][j+1][k][BOTTOM]		= y_FC[i][j][k][TOP];	
                    z_FC[i][j+1][k][BOTTOM]		= z_FC[i][j][k][TOP];	
                    press_FC[i][j+1][k][BOTTOM][m]	= press_FC[i][j][k][TOP][m];
                    tau_x_FC[i][j+1][k][BOTTOM][m]	= tau_x_FC[i][j][k][TOP][m];
                    tau_y_FC[i][j+1][k][BOTTOM][m]	= tau_y_FC[i][j][k][TOP][m];
                    tau_z_FC[i][j+1][k][BOTTOM][m] 	= tau_z_FC[i][j][k][TOP][m];
                    uvel_FC[i][j+1][k][BOTTOM][m]	= uvel_FC[i][j][k][TOP][m];
                    vvel_FC[i][j+1][k][BOTTOM][m]	= vvel_FC[i][j][k][TOP][m];
                    wvel_FC[i][j+1][k][BOTTOM][m]	= wvel_FC[i][j][k][TOP][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate  front and back sides
                    *___________________________________*/</FONT>
                    x_FC[i][j][k][FRONT]             = x_FC[i][j][k+1][BACK];
                    y_FC[i][j][k][FRONT]             = y_FC[i][j][k+1][BACK];
                    z_FC[i][j][k][FRONT]             = z_FC[i][j][k+1][BACK];
                    press_FC[i][j][k][FRONT][m]      = press_FC[i][j][k+1][BACK][m];
                    tau_x_FC[i][j][k][FRONT][m]      = tau_x_FC[i][j][k+1][BACK][m];
                    tau_y_FC[i][j][k][FRONT][m]      = tau_y_FC[i][j][k+1][BACK][m];
                    tau_z_FC[i][j][k][FRONT][m]      = tau_z_FC[i][j][k+1][BACK][m];                
                    uvel_FC[i][j][k][FRONT][m]       = uvel_FC[i][j][k+1][BACK][m];
                    vvel_FC[i][j][k][FRONT][m]       = vvel_FC[i][j][k+1][BACK][m];
                    wvel_FC[i][j][k][FRONT][m]       = wvel_FC[i][j][k+1][BACK][m];


                }
            }
        }  
    }  
    
<FONT COLOR="570BA3">/*__________________________________
*   Step 2:
*   Now equate the addresses along
*   the right, top and front layer of cells
*___________________________________*/</FONT> 
    for ( m = 1; m &lt;= nMaterials; m++)
    { 
        for ( k = 0; k &lt;= Z_MAX_LIM-1; k++)
        {
            for ( j = Y_MAX_LIM; j &lt;= Y_MAX_LIM; j++)
            {
                for ( i = 0; i &lt;= X_MAX_LIM-1; i++)
                {
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate left and right faces
                    *___________________________________*/</FONT>
                    x_FC[i][j][k][RIGHT]            = x_FC[i+1][j][k][LEFT];
                    y_FC[i][j][k][RIGHT]            = y_FC[i+1][j][k][LEFT];
                    z_FC[i][j][k][RIGHT]            = z_FC[i+1][j][k][LEFT];
                    press_FC[i][j][k][RIGHT][m]     = press_FC[i+1][j][k][LEFT][m];
                    tau_x_FC[i][j][k][RIGHT][m]     = tau_x_FC[i+1][j][k][LEFT][m];
                    tau_y_FC[i][j][k][RIGHT][m]     = tau_y_FC[i+1][j][k][LEFT][m];
                    tau_z_FC[i][j][k][RIGHT][m]     = tau_z_FC[i+1][j][k][LEFT][m];
                    uvel_FC[i][j][k][RIGHT][m]      = uvel_FC[i+1][j][k][LEFT][m];
                    vvel_FC[i][j][k][RIGHT][m]      = vvel_FC[i+1][j][k][LEFT][m];
                    wvel_FC[i][j][k][RIGHT][m]      = wvel_FC[i+1][j][k][LEFT][m];
                 }
            }
        }
    }
    <FONT COLOR="570BA3">/*__________________________________
    *   RIGHT layer of cells
    *___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( k = 0; k &lt;= Z_MAX_LIM-1; k++)
        {
            for ( j = 0; j &lt;= Y_MAX_LIM-1; j++)
            {
                for ( i = X_MAX_LIM; i &lt;= X_MAX_LIM; i++)
                {

                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate top and bottom faces
                    *___________________________________*/</FONT>
                    x_FC[i][j+1][k][BOTTOM]              = x_FC[i][j][k][TOP];
                    y_FC[i][j+1][k][BOTTOM]              = y_FC[i][j][k][TOP];
                    z_FC[i][j+1][k][BOTTOM]              = z_FC[i][j][k][TOP];
                    press_FC[i][j+1][k][BOTTOM][m]       = press_FC[i][j][k][TOP][m];
                    tau_x_FC[i][j+1][k][BOTTOM][m]       = tau_x_FC[i][j][k][TOP][m];
                    tau_y_FC[i][j+1][k][BOTTOM][m]       = tau_y_FC[i][j][k][TOP][m];
                    tau_z_FC[i][j+1][k][BOTTOM][m]       = tau_z_FC[i][j][k][TOP][m];
                     uvel_FC[i][j+1][k][BOTTOM][m]       = uvel_FC[i][j][k][TOP][m]; 
                     vvel_FC[i][j+1][k][BOTTOM][m]       = vvel_FC[i][j][k][TOP][m];
                     wvel_FC[i][j+1][k][BOTTOM][m]       = wvel_FC[i][j][k][TOP][m];
                }
            }
        }
    }
    <FONT COLOR="570BA3">/*__________________________________
    *   BACK layer of cells
    *___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( k = Z_MAX_LIM; k &lt;= Z_MAX_LIM; k++)
        {
            for ( j = 0; j &lt;= Y_MAX_LIM-1; j++)
            {
                for ( i = 0; i &lt;= X_MAX_LIM-1; i++)
                {
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate left and right faces
                    *___________________________________*/</FONT>
                    x_FC[i][j][k][RIGHT]            = x_FC[i+1][j][k][LEFT];
                    y_FC[i][j][k][RIGHT]            = y_FC[i+1][j][k][LEFT];
                    z_FC[i][j][k][RIGHT]            = z_FC[i+1][j][k][LEFT];
                    press_FC[i][j][k][RIGHT][m]     = press_FC[i+1][j][k][LEFT][m];
                    tau_x_FC[i][j][k][RIGHT][m]     = tau_x_FC[i+1][j][k][LEFT][m];
                    tau_y_FC[i][j][k][RIGHT][m]     = tau_y_FC[i+1][j][k][LEFT][m];
                    tau_z_FC[i][j][k][RIGHT][m]     = tau_z_FC[i+1][j][k][LEFT][m];
                    uvel_FC[i][j][k][RIGHT][m]      = uvel_FC[i+1][j][k][LEFT][m];
                    vvel_FC[i][j][k][RIGHT][m]      = vvel_FC[i+1][j][k][LEFT][m];
                    wvel_FC[i][j][k][RIGHT][m]      = wvel_FC[i+1][j][k][LEFT][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Equate top and bottom faces 
                    *___________________________________*/</FONT>
                    x_FC[i][j+1][k][BOTTOM]		= x_FC[i][j][k][TOP];	
                    y_FC[i][j+1][k][BOTTOM]		= y_FC[i][j][k][TOP];	
                    z_FC[i][j+1][k][BOTTOM]		= z_FC[i][j][k][TOP];	
                    press_FC[i][j+1][k][BOTTOM][m]	= press_FC[i][j][k][TOP][m];
                    tau_x_FC[i][j+1][k][BOTTOM][m]	= tau_x_FC[i][j][k][TOP][m];
                    tau_y_FC[i][j+1][k][BOTTOM][m]	= tau_y_FC[i][j][k][TOP][m];
                    tau_z_FC[i][j+1][k][BOTTOM][m] 	= tau_z_FC[i][j][k][TOP][m];
                    uvel_FC[i][j+1][k][BOTTOM][m]	= uvel_FC[i][j][k][TOP][m];
                    vvel_FC[i][j+1][k][BOTTOM][m]	= vvel_FC[i][j][k][TOP][m];
                    wvel_FC[i][j+1][k][BOTTOM][m]	= wvel_FC[i][j][k][TOP][m];

                }
            }
        }
    }
    
              
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="compute_face_centered_velocities">compute_face_centered_velocities</A>  PRESSURE: Step 2, Calculates the face centered velocities from cell-centered data. </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: interpolate_vel_CC_to_FC.c
 Filename: interpolate_vel_CC_to_FC.c
 Purpose:
   This function calculates the face centered velocities.
 
 steps:
    1)  Compute the face-centered velocities inside the compuational domain
    2)  Update the face-centered boundary conditions

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 
 NOTE:  I'm doing twice as much work by computing both the faces in each cell.
 By faces I mean top and bottom, left and right and front and back.
 
 Need to add the third dimension and multimaterial loop
 ---------------------------------------------------------------------  */</FONT>
void <A href="#compute_face_centered_velocities">compute_face_centered_velocities</A> 
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* delta t                          */</FONT>
        int     ***BC_types,            <FONT COLOR="570BA3">/* Dirichlet/Neuman [wall][var][m]  */</FONT>   
        int     ***BC_float_or_fixed,   <FONT COLOR="570BA3">/* float or fixed [wall][var][m]    */</FONT>
        double  ***BC_Values,           <FONT COLOR="570BA3">/* BC values BC_values[wall][var][m]*/</FONT> 
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            */</FONT>
        double  *grav,                  <FONT COLOR="570BA3">/* gravity xdir=1, ydir=2, zdir=3   */</FONT>      
        double  ****press_L_CC,         <FONT COLOR="570BA3">/* Cell-center pressure             */</FONT>
                                        <FONT COLOR="570BA3">/* [*]vel_CC(x,y,z,material         */</FONT>        
        double  ****uvel_CC,            <FONT COLOR="570BA3">/* u-cell-centered velocity         (INPUT) */</FONT>
        double  ****vvel_CC,            <FONT COLOR="570BA3">/*  v-cell-centered velocity        (INPUT) */</FONT>
        double  ****wvel_CC,            <FONT COLOR="570BA3">/* w cell-centered velocity         (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* [*]vel_FC(x,y,z,face,material)   */</FONT> 
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* u-face-centered velocity         (OUTPUT)*/</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/* v-face-centered velocity         (OUTPUT)*/</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* w-face-centered velocity         (OUTPUT)*/</FONT>
        int     nMaterials          )

{
    int i, j, k, f,m,                   <FONT COLOR="570BA3">/* cell face locators               */</FONT>            
        cell,                           <FONT COLOR="570BA3">/* variables that change in formula */</FONT>
        xLo, yLo, zLo,
        xHi, yHi, zHi;
    
    double  term1,term2,term3,          <FONT COLOR="570BA3">/* temp symbols to represent terms  */</FONT>
            rho_FC,                     <FONT COLOR="570BA3">/* face centered density            */</FONT>
            *grad_P;                    <FONT COLOR="570BA3">/* gradient of the pressure at each */</FONT>
                                        <FONT COLOR="570BA3">/* cell-face                        */</FONT>
         
<FONT COLOR="570BA3">/*__________________________________
* PLOTTING VARIABLES
*___________________________________*/</FONT>
#if switchDebug_compute_face_centered_velocities
    #include "plot_declare_vars.h" 
#endif 

#if switchsw_compute_face_centered_velocities      
    time_t start,secs;                  <FONT COLOR="570BA3">/* timing variables                */</FONT>
    start = time(NULL); 
#endif
<FONT COLOR="570BA3">/*__________________________________
*  Allocate memory for grad array
*___________________________________*/</FONT>
    grad_P = dvector(1,N_CELL_FACES);

<FONT COLOR="570BA3">/* _______________________________________________________________________

                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face
                                 
    y-dir faces
_______________________________________________________________________ */</FONT>

<FONT COLOR="570BA3">/*______________________________________________________________________
*   STEP 1)
*   Compute the face-centered velocities in the computational domain.
*_______________________________________________________________________*/</FONT>
    
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*   WARNING: (*) can't = 0 or (*)_MAX_LIM
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    
    <FONT COLOR="570BA3">/*__________________________________
    *   TOP AND BOTTOM FACE VALUES  
    *   Extend the computations into the left
    *   and right ghost cells
    *___________________________________*/</FONT>   
    xLo = xLoLimit;
    xHi = xHiLimit;

    yLo = yLoLimit;
    yHi = yHiLimit;
    zLo = zLoLimit;
    zHi = zHiLimit;

    term2 = 0.0;
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( k = zLo; k &lt;= zHi; k++)
        {
            for ( j = yLo; j &lt;= yHi; j++)
            {
                for ( i = xLo; i &lt;= xHi; i++)
                {   
                    cell   = j+1;            
                    <A href="#grad_FC_Ydir">grad_FC_Ydir</A>i, j, k, m, press_L_CC, delY, grad_P);

                    for(f = TOP; f &lt;= BOTTOM; f++)
                    {
                    <FONT COLOR="570BA3">/*__________________________________
                    * Time n face centered velocity
                    *___________________________________*/</FONT>

                        rho_FC = (rho_CC[i][cell][k][m]    + rho_CC[i][j][k][m])/2.0;

                        assert(rho_FC &gt;= SMALL_NUM);     <FONT COLOR="570BA3">/* bullet proofing      */</FONT>                
                        <FONT COLOR="570BA3">/*__________________________________
                        * interpolation to the face
                        *___________________________________*/</FONT>
                         term1  = (rho_CC[i][cell][k][m]    * vvel_CC[i][cell][k][m] 
                                +   rho_CC[i][j][k][m]      * vvel_CC[i][j][k][m])/ (2.0 * rho_FC);

                        <FONT COLOR="570BA3">/*__________________________________
                        * pressure correction
                        *___________________________________*/</FONT>
                        #if (switch_include_grad_pressure)
                        term2 =  (delt * grad_P[f]/ rho_FC);
                        #endif

                        <FONT COLOR="570BA3">/*__________________________________
                        * gravity term
                        *___________________________________*/</FONT>
                        term3 =  delt * grav[2]; 


                        *uvel_FC[i][j][k][f][m] = 0.0;
                        *vvel_FC[i][j][k][f][m] = term1- term2 + term3;                    
                        *wvel_FC[i][j][k][f][m] = 0.0; 

                        <FONT COLOR="570BA3">/*__________________________________
                        * change cell index and signs on 
                        * pressure terms
                        *___________________________________*/</FONT>
                        cell = j-1;
                    }
                }
            }
        }


    <FONT COLOR="570BA3">/*__________________________________
    * left and right faces
    * Extend the computations to the 
    * top and bottom ghostcells
    *___________________________________*/</FONT> 
        xLo = xLoLimit;
        xHi = xHiLimit;

        yLo = yLoLimit;
        yHi = yHiLimit;

        zLo = zLoLimit;
        zHi = zHiLimit;  
        term2 = 0.0;  
        for ( k = zLo; k &lt;= zHi; k++)
        {
            for ( j = yLo; j &lt;= yHi; j++)
            {
                for ( i = xLo; i &lt;= xHi; i++)
                {   
                    cell   = i+1;       
                    <A href="#grad_FC_Xdir">grad_FC_Xdir</A>i, j, k, m, press_L_CC, delX, grad_P);
                    for(f = RIGHT; f &lt;= LEFT; f++)
                    {
                    <FONT COLOR="570BA3">/*__________________________________
                    * Time n face centered velocity
                    *___________________________________*/</FONT> 
                        rho_FC = (rho_CC[cell][j][k][m]    + rho_CC[i][j][k][m])/2.0;
                        assert(rho_FC &gt;= SMALL_NUM);     <FONT COLOR="570BA3">/* bullet proofing      */</FONT>

                        <FONT COLOR="570BA3">/*__________________________________
                        * interpolation to the face
                        *___________________________________*/</FONT> ;           
                        term1   = (rho_CC[cell][j][k][m]    * uvel_CC[cell][j][k][m] 
                                +   rho_CC[i][j][k][m]      * uvel_CC[i][j][k][m])/ (2.0*rho_FC);

                        <FONT COLOR="570BA3">/*__________________________________
                        * pressure term
                        *___________________________________*/</FONT>
                        #if (switch_include_grad_pressure)
                        term2 =  (delt * grad_P[f]/rho_FC); 
                        #endif
                        <FONT COLOR="570BA3">/*__________________________________
                        * gravity term
                        *___________________________________*/</FONT>
                        term3 =  delt * grav[1]; 
                        *uvel_FC[i][j][k][f][m] = term1 - term2 + term3;
                        *vvel_FC[i][j][k][f][m] = 0.0;
                        *wvel_FC[i][j][k][f][m] = 0.0; 
                        <FONT COLOR="570BA3">/*__________________________________
                        * change cell index and signs on 
                        * pressure terms
                        *___________________________________*/</FONT>
                        cell = i-1;

                    }
                }
            }
        }
    <FONT COLOR="570BA3">/*__________________________________
    * front and back faces
    * Extend the computations to the front
    * and back ghostcells
    *___________________________________*/</FONT>
        xLo = xLoLimit;
        xHi = xHiLimit;    
        yLo = yLoLimit;
        yHi = yHiLimit;

        zLo = zLoLimit;
        zHi = zHiLimit;
        term2 = 0.0;
        for ( k = zLo; k &lt;= zHi; k++)
        {
            for ( j = yLo; j &lt;= yHi; j++)
            {
                for ( i = xLo; i &lt;= xHi; i++)
                {   
                    cell   = k+1;            
                    <A href="#grad_FC_Zdir">grad_FC_Zdir</A>i, j, k, m, press_L_CC, delZ, grad_P); 

                    for(f = FRONT; f &lt;= BACK; f++)
                    {
                    <FONT COLOR="570BA3">/*__________________________________
                    * Time n face centered velocity
                    *___________________________________*/</FONT>   
                        rho_FC = (rho_CC[i][j][cell][m]    + rho_CC[i][j][k][m])/2.0;
                        assert(rho_FC &gt;= SMALL_NUM);     <FONT COLOR="570BA3">/* bullet proofing          */</FONT> 

                        <FONT COLOR="570BA3">/*__________________________________
                        * interpolation to the face
                        *___________________________________*/</FONT>
                        term1 = (rho_CC[i][j][cell][m]    * wvel_CC[i][j][cell][m] 
                             +   rho_CC[i][j][k][m]       * wvel_CC[i][j][k][m])/ (2.0 * rho_FC);

                        <FONT COLOR="570BA3">/*__________________________________
                        * pressure term
                        *___________________________________*/</FONT>
                        #if (switch_include_grad_pressure)
                        term2 =  (delt * grad_P[f]/ rho_FC);
                        #endif
                        <FONT COLOR="570BA3">/*__________________________________
                        * gravity term
                        *___________________________________*/</FONT>
                        term3 =  delt * grav[3];                                   
                        *uvel_FC[i][j][k][f][m] = 0.0;
                        *vvel_FC[i][j][k][f][m] = 0.0;

                        *wvel_FC[i][j][k][f][m] = 0.0;

                        #if (N_DIMENSIONS == 3) 
                            *wvel_FC[i][j][k][f][m] = term1 - term2 + term3; 
                        #endif
                        <FONT COLOR="570BA3">/*__________________________________
                        * change cell index and signs on 
                        * pressure terms
                        *___________________________________*/</FONT>
                        cell = k-1;

                    }
                }
            }
        }
    }       <FONT COLOR="570BA3">/* material loop */</FONT>

<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 2) Update any neumann boundary conditions
*_______________________________________________________________________*/</FONT>                           
    <A href="#update_CC_FC_physical_boundary_conditions">update_CC_FC_physical_boundary_conditions</A> 
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        BC_types,       BC_float_or_fixed,
                        BC_Values, 
                        nMaterials,     3,                 
                        uvel_CC,        UVEL,           uvel_FC,
                        vvel_CC,        VVEL,           vvel_FC,
                        wvel_CC,        WVEL,           wvel_FC);
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING AND STOP WATCH INFORMATION
*_______________________________________________________________________*/</FONT>
#if switchDebug_compute_face_centered_velocities

    #define switchInclude_compute_face_centered_velocities 1
        #include "debugcode.i"
    #undef switchInclude_compute_face_centered_velocities
    
<FONT COLOR="570BA3">/*     for ( m = 1; m &lt;= nMaterials; m++)
    {    
        <A href="#printData_6d">printData_6d</A>       xLo,            yLo,      zLo,
                            xHi,            yHi,      zHi,
                            RIGHT,          LEFT,
                            m,              m,
                            "vel_Face_before_iterative_pressure_solver",     
                            "Uvel_FC",      uvel_FC,        0);

        <A href="#printData_6d">printData_6d</A>       xLo,            yLo,      zLo,
                            xHi,            yHi,      zHi,
                            TOP,            BOTTOM,
                            m,              m,
                            "vel_Face_before_iterative_pressure_solver",     
                            "Vvel_FC",  vvel_FC,            0); 
    } */</FONT>
#endif 
<FONT COLOR="570BA3">/*__________________________________
* Free up memory and stop the stopwatch
*___________________________________*/</FONT>
    free_dvector(grad_P, 1, N_CELL_FACES);
         
#if switchsw_compute_face_centered_velocities
    <A href="#stopwatch">stopwatch</A>"vel_face",start);
#endif

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="generateGrid">generateGrid</A>  MISC: Compute the x,y,z, coordinates of the cell-centeres and face-centeres</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: grid.c
 Filename: grid.c
 Purpose: Generate the x,y,z, coordinates of the cell-centered and face-centered 

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   
       
----------------------------------------------------------------------- */</FONT>

void    <A href="#generateGrid">generateGrid</A>   
            int         xLoLimit,
            int         yLoLimit,
            int         zLoLimit,
            int         xHiLimit,
            int         yHiLimit,
            int         zHiLimit,

            double      delX,           <FONT COLOR="570BA3">/* cell width                       (INPUT) */</FONT>
            double      delY,           <FONT COLOR="570BA3">/* cell width in y dir.             (INPUT) */</FONT>
            double      delZ,           <FONT COLOR="570BA3">/* cell width in z dir.             (INPUT) */</FONT>
            double      ***x_CC,        <FONT COLOR="570BA3">/* x-coord. cell-center             (OUTPUT)*/</FONT>
            double      ***y_CC,        <FONT COLOR="570BA3">/* y-coord. cell-center             (OUTPUT)*/</FONT>
            double      ***z_CC,        <FONT COLOR="570BA3">/* z-coord. cell-center             (OUTPUT)*/</FONT>
            double      ***Vol_CC,      <FONT COLOR="570BA3">/* cell volume cell-center          (OUTPUT)*/</FONT>
                        <FONT COLOR="570BA3">/* treated as pointers *(*)_FC(i,j,k,face)                  */</FONT>
            double      *****x_FC,      <FONT COLOR="570BA3">/* x-coordinate face-center         (OUTPUT)*/</FONT>  
            double      *****y_FC,      <FONT COLOR="570BA3">/* y-coordinate face-center         (OUTPUT)*/</FONT>
            double      *****z_FC  )    <FONT COLOR="570BA3">/* z-coordinate face-center         (OUTPUT)*/</FONT>
{
        int         i,j,k,
                    xLo, xHi,           <FONT COLOR="570BA3">/* array limits including ghost cells */</FONT>
                    yLo, yHi,
                    zLo, zHi;
<FONT COLOR="570BA3">/* _______________________________________________________________________
 calculate cell centered distances

                               _______ ________
                              |       |       |
                              | I,J,K |       |
                              |       |       |--- y_CC
                              |_______|_______|
                                   \      /
                                   x_CC

_______________________________________________________________________ */</FONT>
        xLo = GC_LO(xLoLimit);
        xHi = GC_HI(xHiLimit);
        yLo = GC_LO(yLoLimit);
        yHi = GC_HI(yHiLimit);
        zLo = GC_LO(zLoLimit);
        zHi = GC_HI(zHiLimit);
<FONT COLOR="570BA3">/*__________________________________
* bullet proofing
*___________________________________*/</FONT>
        if( xLo &lt; 0 || xLo &gt; X_MAX_LIM)
            <A href="#Message">Message</A>1, "grid.c", "generateGrid", "xLo &lt; 0 || xLo &gt; X_MAX_LIM");      
        if( xHi &lt; 0 || xHi &gt; X_MAX_LIM)
            <A href="#Message">Message</A>1, "grid.c", "generateGrid", "xHi &lt; 0 || xHi &gt; X_MAX_LIM");
        if( yLo &lt; 0 || yLo &gt; X_MAX_LIM)
            <A href="#Message">Message</A>1, "grid.c", "generateGrid", "yLo &lt; 0 || yLo &gt; Y_MAX_LIM");      
        if( yHi &lt; 0 || yHi &gt; Y_MAX_LIM)
            <A href="#Message">Message</A>1, "grid.c", "generateGrid", "yHi &lt; 0 || yHi &gt; Y_MAX_LIM");
        if( zLo &lt; 0 || zLo &gt; Z_MAX_LIM)
            <A href="#Message">Message</A>1, "grid.c", "generateGrid", "zLo &lt; 0 || zLo &gt; Z_MAX_LIM");      
        if( zHi &lt; 0 || zHi &gt; Z_MAX_LIM)
            <A href="#Message">Message</A>1, "grid.c", "generateGrid", "zHi &lt; 0 || zHi &gt; Z_MAX_LIM");                    
        for( k = zLo; k&lt;=zHi; k++)
        {
            for( j = yLo; j &lt;=yHi; j++)
            {
                for( i = xLo; i&lt;= xHi; i++)
                {
                
                    x_CC[i][j][k]   = (double)i*delX - delX/2.0;
                    y_CC[i][j][k]   = (double)j*delY - delY/2.0;
                    z_CC[i][j][k]   = (double)k*delZ - delZ/2.0;
                   
                    Vol_CC[i][j][k] = delX*delY*delZ;

                }
            }
        }

<FONT COLOR="570BA3">/* _______________________________________________________________________
 calculate face center coordinates
______________________________

                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face

FUTURE IMPROVEMENT:                                 
  I'm being stupid here since you only need to calculate the right
  and top and front face coordinates.  The address of 
  x_FC[i][j][k][RIGHT] = X_FC[i][j][k][LEFT]
_______________________________________________________________________ */</FONT>

        for( k = zLo; k&lt;= zHi; k++)
        {
            for( j = yLo; j &lt;=yHi; j++)
            {
                for( i = xLo; i&lt;=xHi; i++)
                {
                    
<FONT COLOR="570BA3">/*__________________________________
* x-cell face coordinates
*___________________________________*/</FONT>
                    *x_FC[i][j][k][TOP]      = x_CC[i][j][k];
                    *x_FC[i][j][k][BOTTOM]   = x_CC[i][j][k];
                    *x_FC[i][j][k][RIGHT]    = x_CC[i][j][k] + delX/2.0;
                    *x_FC[i][j][k][LEFT]     = x_CC[i][j][k] - delX/2.0;
                    *x_FC[i][j][k][FRONT]    = x_CC[i][j][k];
                    *x_FC[i][j][k][BACK]     = x_CC[i][j][k];
<FONT COLOR="570BA3">/*__________________________________
* y-cell face coordinates
*___________________________________*/</FONT>                     
                    *y_FC[i][j][k][TOP]      = y_CC[i][j][k] + delY/2.0;
                    *y_FC[i][j][k][BOTTOM]   = y_CC[i][j][k] - delY/2.0; 
                    *y_FC[i][j][k][RIGHT]    = y_CC[i][j][k];
                    *y_FC[i][j][k][LEFT]     = y_CC[i][j][k];
                    *y_FC[i][j][k][FRONT]    = y_CC[i][j][k];
                    *y_FC[i][j][k][BACK]     = y_CC[i][j][k];
<FONT COLOR="570BA3">/*__________________________________
* z-cell face coordinates
*___________________________________*/</FONT>
                    *z_FC[i][j][k][TOP]      = z_CC[i][j][k];
                    *z_FC[i][j][k][BOTTOM]   = z_CC[i][j][k];
                    *z_FC[i][j][k][RIGHT]    = z_CC[i][j][k];
                    *z_FC[i][j][k][LEFT]     = z_CC[i][j][k];
                    *z_FC[i][j][k][FRONT]    = z_CC[i][j][k] + delZ/2.0;
                    *z_FC[i][j][k][BACK]     = z_CC[i][j][k] - delZ/2.0;
                }
            }
        } 

<FONT COLOR="570BA3">/*__________________________________
*
*___________________________________*/</FONT>
#if switchDebug_grid
        fprintf(stderr,"\n Finished with generageGrid\n");
#endif       
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="calc_flux_or_primitive_vars">calc_flux_or_primitive_vars</A>  MISC: calculates the flux or primitive variables for the entire field including the ghosts cells.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 
    
 Purpose:
   This function calculates either the cell-centered,(x,y,x) 
   flux variables (mu), (mv), (mw), (me) or the primitive variables
   (u), (v), (w), (T) depending on the flag
Note:
    This function calculates the flux or primitive variables for the 
    entire field including the ghosts cells.   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       09/29/99
       
           
Index convention:
                    ****Variable  (i,j,k,material)
                    ***Variable (i,j,k) 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#calc_flux_or_primitive_vars">calc_flux_or_primitive_vars</A>    
        int     flag,                   <FONT COLOR="570BA3">/* = -1 calc. flux = 1 primitive    */</FONT>              
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Density                           (INPUT)*/</FONT>
        double   ***Vol_CC,             <FONT COLOR="570BA3">/* cell-centered volume              (INPUT)*/</FONT>
        double  ****uvel_CC,            <FONT COLOR="570BA3">/* u-face-centered velocity         (IN/OUT)*/</FONT> 
        double  ****vvel_CC,            <FONT COLOR="570BA3">/* v-face-centered velocity,        (IN/OUT)*/</FONT>
        double  ****wvel_CC,            <FONT COLOR="570BA3">/* w face-centered velocity         (IN/OUT)*/</FONT>
        double  ****xmom_CC,            <FONT COLOR="570BA3">/* x component of momentum          (IN/OUT)*/</FONT>
        double  ****ymom_CC,            <FONT COLOR="570BA3">/* y component of momentum          (IN/OUT)*/</FONT>
        double  ****zmom_CC,            <FONT COLOR="570BA3">/* z component of momentum          (IN/OUT)*/</FONT>
        double  ****cv_CC,              <FONT COLOR="570BA3">/* specific heat                     (INPUT)*/</FONT>        
        double  ****int_eng_CC,         <FONT COLOR="570BA3">/* internal energy                  (IN/OUT)*/</FONT>
        double  ****Temp_CC,            <FONT COLOR="570BA3">/* Temperature                      (IN/OUT)*/</FONT>
        int     nMaterials      )   
{
    int     i, j, k,m;                  <FONT COLOR="570BA3">/*   loop indices  locators         */</FONT> 
    double  mass;                              
    
#if sw_calc_flux_or_primitive_vars    
    time_t start,secs;                  <FONT COLOR="570BA3">/* timing variables                */</FONT>
    start = time(NULL);
#endif 

<FONT COLOR="570BA3">/*__________________________________
* Check that the inputs are reasonable
*___________________________________*/</FONT>
    assert ( xLoLimit &gt; 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt; 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt; 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert (flag == 1 || flag == -1);
    <FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Calculate the flux variables in the x,y,z dirs 
*   You need to include the ghost cells in the calculation or else
*   the advection routine won't work correctly
*_______________________________________________________________________*/</FONT>
    if ( flag == -1)
    {
        for (m = 1; m &lt;= nMaterials; m++)
        {     
            for ( i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)     
            {
                for ( j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
                {
                    for ( k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
                    {  
                        mass                = rho_CC[i][j][k][m] * Vol_CC[i][j][k];     
                        xmom_CC[i][j][k][m] = mass * uvel_CC[i][j][k][m];
                        ymom_CC[i][j][k][m] = mass * vvel_CC[i][j][k][m];
                        zmom_CC[i][j][k][m] = mass * wvel_CC[i][j][k][m];
                        int_eng_CC[i][j][k][m]
                                            = mass * cv_CC[i][j][k][m] * Temp_CC[i][j][k][m];
                    }
                }
            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
*   backout vel from primitive
*   Need to fix this
*   be careful of the boundary conditions don't overwrite dirichlet bcs'
*___________________________________*/</FONT>    
    if ( flag == 1)
    {
        for (m = 1; m &lt;= nMaterials; m++)
        {
            for ( i = xLoLimit; i &lt;= xHiLimit; i++)
            {
                for ( j = yLoLimit; j &lt;= yHiLimit; j++)
                {
                    for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                    {  
                        mass                = rho_CC[i][j][k][m] * Vol_CC[i][j][k];            
                        uvel_CC[i][j][k][m] = xmom_CC[i][j][k][m]/mass;
                        vvel_CC[i][j][k][m] = ymom_CC[i][j][k][m]/mass;
                        wvel_CC[i][j][k][m] = zmom_CC[i][j][k][m]/mass;
                        Temp_CC[i][j][k][m] = int_eng_CC[i][j][k][m]/(mass * cv_CC[i][j][k][m]);
                    }
                }
            }
        }
    }
 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING AND STOP WATCH INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_calc_flux_or_primitive_vars
    for (m = 1; m &lt;= nMaterials; m++)
    {
        <A href="#printData_4d">printData_4d</A>   xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        m,              m,
                        "calc_primitive","xmom_CC",     xmom_CC);

        <A href="#printData_4d">printData_4d</A>   xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        m,              m,
                        "calc_primitive","uvel_CC",     uvel_CC);
    }
                       
#endif 
       
#if sw_calc_flux_or_primitive_vars
    <A href="#stopwatch">stopwatch</A>"calc_momentum",start);
#endif

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="equation_of_state">equation_of_state</A>  EOS: Step 1, Compute the cell centered pressured using the equation of state.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: equation_of_state.c
 Filename: equation_of_state.c
 Purpose:   Compute the time advanced cell-centered pressure
 
 Computatonal Domain: INTERIOR Cells
            
 Ghostcell data dependency: NONE
              
            
   
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       10/13/99 

Warning:    This is currently setup for an incompressible ideal gas.
this will need to be changed when the energy equation is added.     
                        
 ---------------------------------------------------------------------  */</FONT>
void <A href="#equation_of_state">equation_of_state</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
        double  *R,                     <FONT COLOR="570BA3">/* Gas constant                     (INPUT) */</FONT>
        double  ****press_CC,           <FONT COLOR="570BA3">/* Cell-center pressure             (OUPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  ****Temp_CC,            <FONT COLOR="570BA3">/* Cell-centered Temperature        (INPUT) */</FONT>
        double  ****cv_CC,              <FONT COLOR="570BA3">/* currently extra stuff            */</FONT>
        int     nMaterials   )

{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>
    char    should_I_write_output;
    double  neg_test1 = 0.0;            <FONT COLOR="570BA3">/* test for negative variables      */</FONT>
    double  neg_test2 = 0.0;
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_equation_of_state
    double delX = 1;
    #include "plot_declare_vars.h"
#endif
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);

    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {
                    press_CC[i][j][k][m] = rho_CC[i][j][k][m] * R[m] * Temp_CC[i][j][k][m];
                    
                    neg_test1 = DMIN(neg_test1, press_CC[i][j][k][m]);
                    neg_test2 = DMIN(neg_test2, Temp_CC[i][j][k][m]);
                }
            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
*   Bullet Proofing
*___________________________________*/</FONT>
    if(neg_test1 &lt;0.0)
        <A href="#Message">Message</A>1, "File:equation_of_state.c",
        "Function equation_of_state","Negative pressure detected");

    if(neg_test2 &lt;0.0)
        <A href="#Message">Message</A>1, "File:equation_of_state.c",
        "Function equation_of_state","Negative Temperature detected"); 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION   
*_______________________________________________________________________*/</FONT>
#if switchDebug_equation_of_state
    should_I_write_output = *getenv("SHOULD_I_WRITE_OUTPUT");
    if ( should_I_write_output == '1')
    {
         #define switchInclude_equation_of_state 1
         #include "debugcode.i"
         #undef switchInclude_equation_of_state
    }    
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(cv_CC[0][0][0][1]);          QUITE_FULLWARN(nMaterials);
    should_I_write_output = should_I_write_output;
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="speed_of_sound">speed_of_sound</A>  EOS: Step 1, Compute the cell centered speed of sound</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: speed_of_sound.c
 Filename: speed_of_sound.c
 Purpose:   Compute the time advanced speed of sound
 
 Computatonal Domain: INTERIOR Cells
                    
   
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       3/10/99     
                        
 ---------------------------------------------------------------------  */</FONT>
void <A href="#speed_of_sound">speed_of_sound</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
        double  *gamma,                 <FONT COLOR="570BA3">/* ratio of specific heats          (INPUT) */</FONT>
        double  *R,                     <FONT COLOR="570BA3">/* ideal gas constant               (INPUT) */</FONT>
        double  ****Temp_CC,            <FONT COLOR="570BA3">/* Cell-centered Temperature        (INPUT) */</FONT>
        double  ****speedSound,         <FONT COLOR="570BA3">/* speed of sound                   (OUTPUT)*/</FONT>
        int     nMaterials   )
{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>
    char    should_I_write_output;

<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_equation_of_state
    double delX = 1;
    #include "plot_declare_vars.h"
#endif
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);

    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {
                    speedSound[i][j][k][m] = sqrt(gamma[m] * R[m] * Temp_CC[i][j][k][m]);
 
                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION   
*_______________________________________________________________________*/</FONT>
#if switchDebug_speed_of_sound
    should_I_write_output = *getenv("SHOULD_I_WRITE_OUTPUT");
    if ( should_I_write_output == '1')
    {
         #define switchInclude_speed_of_sound 1
         #include "debugcode.i"
         #undef switchInclude_speed_of_sound
    }    
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(nMaterials);
    should_I_write_output = should_I_write_output;
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="lagrangian_vol">lagrangian_vol</A>  LAGRANGIAN: Step 5, Computes the cell-centered, time n+1, lagrangian volume </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: lagrangian.c
 Filename: lagrangian.c

 Purpose:
   This function calculates the The cell-centered, time n+1, lagrangian volume
   
 Computational Domain:
    The face-centered velocity of each face is needed by each cell in the 
    domain
    
 Ghostcell data dependency: 
   None

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/22/99    

 
 ---------------------------------------------------------------------  */</FONT>
void    <A href="#lagrangian_vol">lagrangian_vol</A>  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* delta t                          (INPUT) */</FONT>
        double  ****Vol_L_CC,           <FONT COLOR="570BA3">/* Lagrangian volume                (OUPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (i,j,k,m)                        */</FONT>
        double   ***Vol_CC,             <FONT COLOR="570BA3">/* cell-centered volume             (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (i,j,k)                          */</FONT>
                                        <FONT COLOR="570BA3">/* (*)vel_FC(x,y,z, face,material)  */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* u-face-centered velocity         (INPUT) */</FONT> 
        double  ******vvel_FC,          <FONT COLOR="570BA3">/*  v-face-centered velocity        (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* w face-centered velocity         (INPUT) */</FONT>
        int     nMaterials      )
{
    int     i, j, k,m;                  <FONT COLOR="570BA3">/*   loop indices  locators         */</FONT> 
                         
    double  ****div_vel_FC;             <FONT COLOR="570BA3">/* array containing the divergence  */</FONT>            
    char    should_I_write_output;             
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_lagrangian_vol
    double ****plot_1;                     <FONT COLOR="570BA3">/* plot_1ing array                    */</FONT>       
    #include "./Header_files/plot_declare_vars.h"   
    plot_1    = darray_4d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL); 
    
    <A href="#zero_arrays_4d">zero_arrays_4d</A>     (xLoLimit),     (yLoLimit),      (zLoLimit),              
                        (xHiLimit),     (yHiLimit),      (zHiLimit), 
                        1,              nMaterials,         
                        1,              plot_1); 
     
#endif  
<FONT COLOR="570BA3">/*__________________________________
* Check that the inputs are reasonable
*___________________________________*/</FONT>
    assert ( xLoLimit &gt; 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt; 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt; 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert ( delt &gt; 0 );
    assert ( delX &gt; 0 &amp;&amp; delY &gt; 0 &amp;&amp; delZ &gt; 0);
    div_vel_FC= darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);    

<FONT COLOR="570BA3">/*______________________________________________________________________
*
*_______________________________________________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    {  
    <FONT COLOR="570BA3">/*__________________________________
    *   Compute the divergence of the
    *   face centered velocity
    *___________________________________*/</FONT>
    <A href="#divergence_of_face_centered_velocity">divergence_of_face_centered_velocity</A>  
                    xLoLimit,           yLoLimit,           zLoLimit,
                    xHiLimit,           yHiLimit,           zHiLimit,
                    delX,               delY,               delZ,
                    uvel_FC,            vvel_FC,            wvel_FC,
                    div_vel_FC,         nMaterials);      
                    
        <FONT COLOR="570BA3">/*__________________________________
        *   Now compute the lagrangian volume
        *___________________________________*/</FONT>   
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {     
                    Vol_L_CC[i][j][k][m] = Vol_CC[i][j][k] + delt* div_vel_FC[i][j][k][m];

                    #if switchDebug_lagrangian_vol
                        plot_1[i][j][k][m] = delt * div_vel_FC[i][j][k][m];
                    #endif
                }
            }
        }
    }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="lagrangian_values">lagrangian_values</A>  LAGRANGIAN: Step 5, calculates the cell-centered, time n+1, lagrangian mass, momentum and internal energy </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: lagrangian.c
 Filename: lagrangian.c
 
 Purpose:
   This function calculates the cell-centered, time n+1, lagrangian mass, 
   momentum and internal energy
  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/22/99    
       
Note:
    Index convention
                    ****Variable  (i,j,k,material)
                    ***Variable (i,j,k)
Implementation notes:
    Note that the lagrangian values are computed over the entire 
    domain including the ghostcells.  The lagrangian values in the 
    ghost cells are assumed to be the cell-centered quantities.  Therefore
    the mass, xmom, ymom, zmom, int_eng source terms must be zero in the ghost
    cells  
 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#lagrangian_values">lagrangian_values</A>            
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  ****Vol_L_CC,           <FONT COLOR="570BA3">/* Lagrangian volume                (INPUT) */</FONT>
        double  ***Vol_CC,              <FONT COLOR="570BA3">/* cell-centered volume             (INPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* cell-centered material density   (INPUT) */</FONT>
        double  ****rho_L_CC,           <FONT COLOR="570BA3">/* cell-centered lagrangian density (INPUT) */</FONT>
        double  ****xmom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (INPUT) */</FONT>
        double  ****ymom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (INPUT) */</FONT>
        double  ****zmom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (INPUT) */</FONT>        
        double  ****uvel_CC,            <FONT COLOR="570BA3">/* u-cell-centered velocity         (INPUT) */</FONT>
        double  ****vvel_CC,            <FONT COLOR="570BA3">/*  v-cell-centered velocity        (INPUT) */</FONT>
        double  ****wvel_CC,            <FONT COLOR="570BA3">/* w cell-centered velocity         (INPUT) */</FONT>
        double  ****xmom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(OUPUT) */</FONT>
        double  ****ymom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(OUPUT) */</FONT>
        double  ****zmom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(OUPUT) */</FONT>
        double  ****mass_L_CC,          <FONT COLOR="570BA3">/* cell-centered lagrangian mass    (OUPUT) */</FONT>
        double  ****mass_source,        <FONT COLOR="570BA3">/* cell-centered source term for mass(INPUT)*/</FONT>
        double  ****xmom_source,        <FONT COLOR="570BA3">/* cell-centered source term        (INPUT) */</FONT>
        double  ****ymom_source,        <FONT COLOR="570BA3">/* cell-centered source term        (INPUT) */</FONT>
        double  ****zmom_source,        <FONT COLOR="570BA3">/* cell-centered source term        (INPUT) */</FONT>
        double  ****int_eng_CC,         <FONT COLOR="570BA3">/* internal energy                  (INPUT) */</FONT>
        double  ****int_eng_L_CC,       <FONT COLOR="570BA3">/* internal energy                  (OUPUT) */</FONT>
        double  ****int_eng_source,     <FONT COLOR="570BA3">/* internal energy                  (INPUT) */</FONT>        
        int     nMaterials     )
{
    int i, j, k,m;                      <FONT COLOR="570BA3">/*   loop indices  locators         */</FONT>
    
#if sw_lagrangian_values
    time_t start,secs;                  <FONT COLOR="570BA3">/* timing variables                */</FONT>
    start = time(NULL);
#endif 

<FONT COLOR="570BA3">/*__________________________________
* Check that the inputs are reasonable
*___________________________________*/</FONT>
    assert ( xLoLimit &gt; 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt; 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt; 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
 
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*  CODE
*  The source terms must be 0.0 in the ghostcells
*_______________________________________________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
        {
            for ( j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
            {
                for ( k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
                { 

                    <FONT COLOR="570BA3">/*__________________________________
                    * Lagrangian mass
                    *___________________________________*/</FONT>
                    mass_L_CC[i][j][k][m] = ( rho_CC[i][j][k][m] * Vol_CC[i][j][k] 
                                           +  mass_source[i][j][k][m]);
                                           
                    rho_L_CC[i][j][k][m] = mass_L_CC[i][j][k][m]/Vol_CC[i][j][k];
                    <FONT COLOR="570BA3">/*__________________________________
                    * Lagrangian Momentum
                    *___________________________________*/</FONT>           
                    xmom_L_CC[i][j][k][m] = xmom_CC[i][j][k][m]
                    - uvel_CC[i][j][k][m] * mass_source[i][j][k][m]
                    + xmom_source[i][j][k][m];

                    ymom_L_CC[i][j][k][m] = ymom_CC[i][j][k][m]
                    - vvel_CC[i][j][k][m] * mass_source[i][j][k][m]
                    + ymom_source[i][j][k][m];

                    zmom_L_CC[i][j][k][m] = zmom_CC[i][j][k][m]
                    - wvel_CC[i][j][k][m] * mass_source[i][j][k][m]
                    + zmom_source[i][j][k][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    * Lagrangian energy
                    *___________________________________*/</FONT>
                    int_eng_L_CC[i][j][k][m] = int_eng_CC[i][j][k][m] 
                    - int_eng_CC[i][j][k][m] * mass_source[i][j][k][m]
                    + int_eng_source[i][j][k][m];


                }
            }
        }
    }

<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_delta_time_based_on_FC_vel">find_delta_time_based_on_FC_vel</A>  MISC: Computes the time step for the next cycle. </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:
   This function calculates delta time based on the Courant number &lt; 1.0
   Where the Courant number is u[i][j][k] Delta{time}/Delta{x}
 Note:
    Delt is computed using face-centered velocities.
  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03.20.00    
 Refererences:
    "Computational Fluid Mechanics and Heat Transfer" 2nd edition
    pg 56
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#find_delta_time_based_on_FC_vel">find_delta_time_based_on_FC_vel</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  *delt,                  <FONT COLOR="570BA3">/* delta t                          (OUTPUT)*/</FONT>
        double  *delt_limits,           <FONT COLOR="570BA3">/* delt_limits[1] = delt minimum    (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[2] = delt_maximum    (INPUT) */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (*)vel_CC(x,y,z,material         */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* u-face-centered velocity         (INPUT) */</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/* v-face-centered velocity         (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* v-face-centered velocity         (INPUT) */</FONT>
        double  ****speedSound,         <FONT COLOR="570BA3">/* speed of sound cell cell-center  (INPUT) */</FONT>
        double  CFL,                     <FONT COLOR="570BA3">/* CFL number                       (INPUT) */</FONT>
        int     nMaterials          )
{
    int     i, j, k,m, f,                <FONT COLOR="570BA3">/*   loop indices  locators        */</FONT>
            faceLo, faceHi,
            xLo,    xHi,
            yLo,    yHi,
            zLo,    zHi;
    double  A, B,
            fudge_factor,
            delt_stability,             <FONT COLOR="570BA3">/* based on stability               */</FONT>
            delt_CFL;                   <FONT COLOR="570BA3">/* based on the CFL number          */</FONT>
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Determine the upper and lower 
*   looping indices for the faces
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        faceLo = LEFT;  faceHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        faceLo = TOP;   faceHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        faceLo = TOP;   faceHi = BACK;
#endif

<FONT COLOR="570BA3">/*__________________________________
* Initialize variables
* and calculate the looping indicies to 
* include the ghostcells
*___________________________________*/</FONT>
    *delt           = BIG_NUM;
    delt_stability  = BIG_NUM;
    delt_CFL        = BIG_NUM;
    fudge_factor= .95;
    
    xLo = GC_LO(xLoLimit);
    yLo = GC_LO(yLoLimit);
    zLo = GC_LO(zLoLimit);
    xHi = GC_HI(xHiLimit);
    yHi = GC_HI(yHiLimit);
    zHi = GC_HI(zHiLimit);
<FONT COLOR="570BA3">/*______________________________________________________________________
* Now calculate the next time step based on the CFL restraint
* Note this 
*_______________________________________________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m ++)
    {
        for ( i = xLo; i &lt;= xHi; i++)
        {
            for ( j = yLo; j &lt;= yHi; j++)
            {
                for ( k = zLo; k &lt;= zHi; k++)
                {  
                    for(f = faceLo; f &lt;= faceHi; f++)
                    {
                        <FONT COLOR="570BA3">/*__________________________________
                        *   Based on the convective velocity
                        *___________________________________*/</FONT>  
                    #if (compute_delt_based_on_velocity == 1)
                        A   = fudge_factor*CFL*delX/fabs(*uvel_FC[i][j][k][f][m] + SMALL_NUM); 
                        B   = fudge_factor*CFL*delY/fabs(*vvel_FC[i][j][k][f][m] + SMALL_NUM);
                        delt_CFL = DMIN(A, delt_CFL);
                        delt_CFL = DMIN(B, delt_CFL);
                    #endif
                        <FONT COLOR="570BA3">/*__________________________________
                        *   Based on the speed of sound
                        *___________________________________*/</FONT>
                    #if (compute_delt_based_on_velocity == 2)
                        A   = fudge_factor*CFL*delX/fabs(speedSound[i][j][k][m] + SMALL_NUM); 
                        B   = fudge_factor*CFL*delY/fabs(speedSound[i][j][k][m] + SMALL_NUM);
                        delt_CFL = DMIN(A, delt_CFL);
                        delt_CFL = DMIN(B, delt_CFL);
                    #endif

                        <FONT COLOR="570BA3">/*__________________________________
                        *   Based on the speed of sound AND
                        *   the convective velocity
                        *___________________________________*/</FONT>
                    #if (compute_delt_based_on_velocity == 3)
                        A   = fudge_factor*CFL*delX/( speedSound[i][j][k][m] + fabs(*uvel_FC[i][j][k][f][m]) + SMALL_NUM); 
                        B   = fudge_factor*CFL*delY/( speedSound[i][j][k][m] + fabs(*vvel_FC[i][j][k][f][m]) + SMALL_NUM);
                        delt_CFL = DMIN(A, delt_CFL);
                        delt_CFL = DMIN(B, delt_CFL);
                    #endif
                        <FONT COLOR="570BA3">/*__________________________________
                        * based on stability requirements
                        * see references
                        *___________________________________*/</FONT>
                        A   = fudge_factor * 0.5 * pow(delX, 2.0)/fabs(*uvel_FC[i][j][k][f][m]); 
                        B   = fudge_factor * 0.5 * pow(delY, 2.0)/fabs(*vvel_FC[i][j][k][f][m]);
                    
                        delt_stability = DMIN(A, delt_stability);
                        delt_stability = DMIN(B, delt_stability);
                    }
                }
            }
        }
    }
    
    *delt = DMIN(delt_stability, delt_CFL);
    
 <FONT COLOR="570BA3">/*`==========TESTING========== Not sure whether to used delt_stability or delt_cfl*/</FONT> 
 *delt = delt_CFL;
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
    <FONT COLOR="570BA3">/*__________________________________
    *   Print some error messages
    *___________________________________*/</FONT>
    if ( *delt &lt; delt_limits[1] )
    {
        fprintf(stderr,"Current delt %f , minimum allowable delt: %f\n",
        *delt, delt_limits[1]);
        <A href="#Message">Message</A>1,"Warning:","The current time step is &lt; than the allowable minimum",
           "specifed in the input file, now setting delt = delt_min.");
        *delt = delt_limits[1];
    }
    
    if ( *delt &gt; delt_limits[2] )
    {
        fprintf(stderr,"Current delt %f , max. allowable delt: %f\n",
        *delt, delt_limits[2]);
        <A href="#Message">Message</A>0,"Warning:","The current time step is &gt; than the allowable max",
           "now setting the delt = delt_maximum");
        *delt = delt_limits[2];
    }   

<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_find_delta_time                                          
        fprintf(stderr," ______________________________________________\n");
        fprintf(stderr,"find_delta_time\n");
        fprintf(stderr,"delta_time based on CFL=%f \t %f \n",CFL, delt_CFL);
        fprintf(stderr,"delta_time based on stability  \t%f \n",delt_stability);        
        fprintf(stderr,"The new time step is \t\t%f\n",*delt);
        fprintf(stderr," ______________________________________________\n");

#endif 
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(delZ);   QUITE_FULLWARN(wvel_FC[0][0][0][1][1]);
    speedSound  = speedSound;
    CFL         = CFL;

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_delta_time_based_on_CC_vel">find_delta_time_based_on_CC_vel</A>  MISC: Computes the time step for the next cycle. </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c
  

 Purpose:
   This function calculates delta time based on the Courant number &lt; 1.0
   Where the Courant number is u[i][j][k] Delta{time}/Delta{x}
  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       05/12/99    
 Refererences:
    "Computational Fluid Mechanics and Heat Transfer" 2nd edition
    pg 56
    
 Implementation Note:
     When testing Sod's shock tube problem it was discovered that the solution
     had to stabilize over several iterations before the computed velocity field 
     was close to the actual solution.  Subsequently, during the first few 
     iterations the computed delt was significantly larger than what
     it should be.  to get around this during the first N_ITERATIONS_TO_STABILIZE
     the CFL linearly increases  from 1/N_ITERATIONS_TO_STABILIZE to 
     CFL from the input file over N_ITERATIONS_TO_STABILIZE.
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#find_delta_time_based_on_CC_vel">find_delta_time_based_on_CC_vel</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  *delt,                  <FONT COLOR="570BA3">/* delta t                          (OUTPUT)*/</FONT>
        double  *delt_limits,           <FONT COLOR="570BA3">/* delt_limits[1] = delt minimum    (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* delt_limits[2] = delt_maximum    (INPUT) */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (*)vel_CC(x,y,z,material         */</FONT>
        double  ****uvel_CC,            <FONT COLOR="570BA3">/* u-cell-centered velocity         (INPUT) */</FONT>
        double  ****vvel_CC,            <FONT COLOR="570BA3">/* v-cell-centered velocity         (INPUT) */</FONT>
        double  ****wvel_CC,            <FONT COLOR="570BA3">/* v-cell-centered velocity         (INPUT) */</FONT>
        double  ****speedSound,         <FONT COLOR="570BA3">/* speed of sound cell cell-center  (INPUT) */</FONT>
        double  CFL,                     <FONT COLOR="570BA3">/* CFL number                       (INPUT) */</FONT>
        int     nMaterials          )
{
    int     i, j, k,m,                   <FONT COLOR="570BA3">/*   loop indices  locators        */</FONT>
            xLo,    xHi,
            yLo,    yHi,
            zLo,    zHi;
            
static int  iterNum;                    <FONT COLOR="570BA3">/* Iteration number                 */</FONT>
    
    double  A, B,
            fudge_factor,
            delt_stability,             <FONT COLOR="570BA3">/* based on stability               */</FONT>
            delt_CFL;                   <FONT COLOR="570BA3">/* based on the CFL number          */</FONT>
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
    iterNum ++;
<FONT COLOR="570BA3">/*______________________________________________________________________
*  While the solution is stabilizing linearly increase the CFL until
*   it reaches the value from the input file
*_______________________________________________________________________*/</FONT>
    if ( iterNum &lt; N_ITERATIONS_TO_STABILIZE )
    {
        CFL =  CFL * (double)iterNum * (1.0/N_ITERATIONS_TO_STABILIZE);
    }
        
<FONT COLOR="570BA3">/*__________________________________
* Initialize variables
* and calculate the looping indicies to 
* include the ghostcells
*___________________________________*/</FONT>
    *delt           = BIG_NUM;
    delt_stability  = BIG_NUM;
    delt_CFL        = BIG_NUM;
    fudge_factor    = 1.0;

    xLo = GC_LO(xLoLimit);
    yLo = GC_LO(yLoLimit);
    zLo = GC_LO(zLoLimit);
    xHi = GC_HI(xHiLimit);
    yHi = GC_HI(yHiLimit);
    zHi = GC_HI(zHiLimit);
<FONT COLOR="570BA3">/*______________________________________________________________________
* Now calculate the next time step based on the CFL restraint
* Note this 
*_______________________________________________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m ++)
    {
        for ( i = xLo; i &lt;= xHi; i++)
        {
            for ( j = yLo; j &lt;= yHi; j++)
            {
                for ( k = zLo; k &lt;= zHi; k++)
                {  
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Based on the convective velocity
                    *___________________________________*/</FONT>  
                #if (compute_delt_based_on_velocity == 1)
                    A   = fudge_factor*CFL*delX/fabs(uvel_CC[i][j][k][m] + SMALL_NUM); 
                    B   = fudge_factor*CFL*delY/fabs(vvel_CC[i][j][k][m] + SMALL_NUM);
                    delt_CFL = DMIN(A, delt_CFL);
                    delt_CFL = DMIN(B, delt_CFL);
                #endif
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Based on the speed of sound
                    *___________________________________*/</FONT>
                #if (compute_delt_based_on_velocity == 2)
                    A   = fudge_factor*CFL*delX/fabs(speedSound[i][j][k][m] + SMALL_NUM); 
                    B   = fudge_factor*CFL*delY/fabs(speedSound[i][j][k][m] + SMALL_NUM);
                    delt_CFL = DMIN(A, delt_CFL);
                    delt_CFL = DMIN(B, delt_CFL);
                #endif

                    <FONT COLOR="570BA3">/*__________________________________
                    *   Based on the speed of sound AND
                    *   the convective velocity
                    *___________________________________*/</FONT>
                #if (compute_delt_based_on_velocity == 3)
                    A   = fudge_factor*CFL*delX/( speedSound[i][j][k][m] + fabs(uvel_CC[i][j][k][m]) + SMALL_NUM); 
                    B   = fudge_factor*CFL*delY/( speedSound[i][j][k][m] + fabs(vvel_CC[i][j][k][m]) + SMALL_NUM);
                    delt_CFL = DMIN(A, delt_CFL);
                    delt_CFL = DMIN(B, delt_CFL);
                #endif
                    <FONT COLOR="570BA3">/*__________________________________
                    * based on stability requirements
                    * see references
                    *___________________________________*/</FONT>
                    A   = fudge_factor * 0.5 * pow(delX, 2.0)/fabs(uvel_CC[i][j][k][m]); 
                    B   = fudge_factor * 0.5 * pow(delY, 2.0)/fabs(vvel_CC[i][j][k][m]);
                    delt_stability = DMIN(A, delt_stability);
                    delt_stability = DMIN(B, delt_stability);
                }
            }
        }
    }

    *delt = DMIN(delt_stability, delt_CFL);

   <FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
 *delt = delt_CFL;
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
    <FONT COLOR="570BA3">/*__________________________________
    *   Print some error messages
    *___________________________________*/</FONT>
    if ( *delt &lt; delt_limits[1] )
    {
        fprintf(stderr,"Current delt %f , minimum allowable delt: %f\n",
        *delt, delt_limits[1]);
        <A href="#Message">Message</A>1,"Warning:","The current time step is &lt; than the allowable minimum",
           "specifed in the input file, now setting delt = delt_min.");
        *delt = delt_limits[1];
    }

    if ( *delt &gt; delt_limits[2] )
    {
        fprintf(stderr,"Current delt %f , max. allowable delt: %f\n",
        *delt, delt_limits[2]);
        <A href="#Message">Message</A>0,"Warning:","The current time step is &gt; than the allowable max",
           "now setting the delt = delt_maximum");
        *delt = delt_limits[2];
    }  

<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_find_delta_time                                          
        fprintf(stderr," ______________________________________________\n");
        fprintf(stderr,"find_delta_time\n");
        fprintf(stderr,"delta_time while the solution stabilizes CFL =%f \t %f\n", 
                        CFL, delt_CFL);
        fprintf(stderr,"delta_time based on CFL=%f \t %f \n",CFL, delt_CFL);
        fprintf(stderr,"delta_time based on stability  \t%f \n",delt_stability);        
        fprintf(stderr,"The new time step is \t\t%f\n",*delt);
        fprintf(stderr," ______________________________________________\n");

#endif 
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(delZ);   QUITE_FULLWARN(wvel_CC[0][0][0][1]);
    speedSound  = speedSound;
    CFL         = CFL;

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>  MISC: Deterimine </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c
 Purpose:   Determine the loop limits along one ghostcell outside of the 
 computational domain. 

NOTE:   The returned indices do not include the corner cells. you need
to deal with those separately.
    
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       09/9/99    

 ---------------------------------------------------------------------  */</FONT>
 void <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>                
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              (INPUT) */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              (INPUT) */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              (INPUT) */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              (INPUT) */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              (INPUT) */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              (INPUT) */</FONT>
    int     *xLo,                       <FONT COLOR="570BA3">/* Modified values                  (OUTPUT)*/</FONT>
    int     *yLo,                       <FONT COLOR="570BA3">/* Indices for the walls            (OUTPUT)*/</FONT>
    int     *zLo,                       <FONT COLOR="570BA3">/*                                  (OUTPUT)*/</FONT>
    int     *xHi,                       <FONT COLOR="570BA3">/*                                  (OUTPUT)*/</FONT>
    int     *yHi,                       <FONT COLOR="570BA3">/*                                  (OUTPUT)*/</FONT>
    int     *zHi,                       <FONT COLOR="570BA3">/*                                  (OUTPUT)*/</FONT>
    int     wall    )                   <FONT COLOR="570BA3">/* What wall are we interesed in    (INPUT) */</FONT>
{

<FONT COLOR="570BA3">/*START_DOC*/</FONT>

<FONT COLOR="570BA3">/*______________________________________________________________________
*
*                           xLoLimit    xHiLimit
*                               |          |
*                        _________________________
*                       /    /    /    /    /    /|
*                      /    /    /    /    /    / |
*                     /____/____/____/____/____/  |
*                    /    /    /    /    /    /| -------         back_GC
*                   /    /    /    /    /    / |  | 
*                  /____/____/____/____/____/  | /|
*                 /    /    /    /    /    /| -|--|--         zHiLimit
*                /    /    /    /    /    / |  |  |
*               /____/____/____/____/____/  | /|  |
*              /    /    /    /    /    /| -|--|-/|       zLoLimit
*             /    /    /    /    /    / |  |  |/ |
*            /____/____/____/____/____/  | /|  |  |
*            |    |    |    |    |    |  |/ | /|  |
*            |    |    |    |    |    |  |  |/ | /|
*            |    |    |    |    |    | /|  |  |/ |
*            |____|____|____|____|____|/ | /|  |  /                           
*            |    |    |    |    |    |  |/ | /| /
*   yHiLimit |    |    |    |    |    | /|  |/ |/   
*            |____|____|____|____|____|/ | /|  /
*            |    |    |    |    |    |  |/ | / 
*            |    |    |    |    |    |  |  |/
*   yLoLimit |    |    |    |    |    | /|  /
*            |____|____|____|____|____|/ | /
*            |    |    |    |    |    |  |/
*            |    |    |    |    |    |  /
*            |    |    |    |    |    | /
*            |____|____|____|____|____|/                
               
                    
*
*_______________________________________________________________________*/</FONT>
    <FONT COLOR="570BA3">/*__________________________________
    *   Define the corner of each wall
    *   BE CAREFULL HERE NOT TO OVERLAP!
    *   NEED TO ADD 3D 
    *___________________________________*/</FONT>
   if( wall == LEFT ) 
   {
        *xLo = xLoLimit - N_GHOSTCELLS;     *xHi = xLoLimit - N_GHOSTCELLS;
        *yLo = yLoLimit;                    *yHi = yHiLimit; 
        *zLo = zLoLimit - N_GHOSTCELLS;     *zHi = zHiLimit + N_GHOSTCELLS;
    }
   if( wall == RIGHT ) 
   {
        *xLo = xHiLimit + N_GHOSTCELLS;     *xHi = xHiLimit + N_GHOSTCELLS;
        *yLo = yLoLimit;                    *yHi = yHiLimit; 
        *zLo = zLoLimit - N_GHOSTCELLS;     *zHi = zHiLimit + N_GHOSTCELLS;
    }
   if( wall == TOP ) 
   {
        *xLo = xLoLimit;                    *xHi = xHiLimit;
        *yLo = yHiLimit + N_GHOSTCELLS;     *yHi = yHiLimit + N_GHOSTCELLS; 
        *zLo = zLoLimit - N_GHOSTCELLS;     *zHi = zHiLimit + N_GHOSTCELLS;
    }
   if( wall == BOTTOM ) 
   {
        *xLo = xLoLimit;                    *xHi = xHiLimit;
        *yLo = yLoLimit - N_GHOSTCELLS;     *yHi = yLoLimit - N_GHOSTCELLS; 
        *zLo = zLoLimit - N_GHOSTCELLS;     *zHi = zHiLimit + N_GHOSTCELLS;
    }
   if( wall == FRONT ) 
   {
 <FONT COLOR="570BA3">/*        *xLo = xLoLimit + N_GHOSTCELLS; *xHi = xHiLimit - N_GHOSTCELLS;
        *yLo = yLoLimit + N_GHOSTCELLS; *yHi = yHiLimit - N_GHOSTCELLS; 
        *zLo = zLoLimit;     *zHi = zLoLimit; */</FONT>
    }
   if( wall == BACK ) 
   {
       <FONT COLOR="570BA3">/*  *xLo = xLoLimit + N_GHOSTCELLS; *xHi = xHiLimit - N_GHOSTCELLS;
        *yLo = yLoLimit + N_GHOSTCELLS; *yHi = yHiLimit - N_GHOSTCELLS; 
        *zLo = zHiLimit;     *zHi = zHiLimit; */</FONT>
    }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="zero_arrays_4d">zero_arrays_4d</A>  MISC: initialize input data arrays</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Zero 4d double arrays

Note on implementation:
            This function uses a variable length argument list.  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/27/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#zero_arrays_4d">zero_arrays_4d</A>  
    int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    int     n4dl,
    int     n4dh,
    int     n_data_arrays,          <FONT COLOR="570BA3">/* number of data arrays            (INPUT) */</FONT>
    double  ****array1,...)         <FONT COLOR="570BA3">/* data(x,y,z,M)                    (INPUT) */</FONT>             
{
    va_list ptr_data_array;         <FONT COLOR="570BA3">/* pointer to each data array       */</FONT> 
    int i, j, k, m,
        array;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>
    va_start(ptr_data_array, n_data_arrays);
    array = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   Loop through each data array in the
    *   argument list
    *___________________________________*/</FONT> 
    for (array = 1; array &lt;=n_data_arrays; array++)
    {   
        array1 = va_arg(ptr_data_array, double****);
         
        for(m = n4dl; m &lt;= n4dh; m++)
        {                
            for(k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
            {
                for(j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
                {
                    for(i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
                    {
                       array1[i][j][k][m] = 0.0;              
                    }
                }
            }
        }
    } 
    va_end(ptr_data_array);                     <FONT COLOR="570BA3">/* clean up when done   */</FONT>            
   
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="zero_arrays_5d">zero_arrays_5d</A>  MISC: initialize input data arrays</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Initialize 5d double arrays

Note on implementation:
            This function uses a variable length argument list.  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/27/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#zero_arrays_5d">zero_arrays_5d</A>  
    int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    int     n4dlo,                  <FONT COLOR="570BA3">/* 4d lower limit                   */</FONT>
    int     n4dhi,                  <FONT COLOR="570BA3">/* 4d upper limit                   */</FONT>
    int     n5dlo,                  <FONT COLOR="570BA3">/* 5d lower limit                   */</FONT>
    int     n5dhi,                  <FONT COLOR="570BA3">/* 5d upper limit                   */</FONT>
    int     n_data_arrays,          <FONT COLOR="570BA3">/* number of data arrays            (INPUT) */</FONT>
    double  *****array1,...)        <FONT COLOR="570BA3">/* data(x,y,z,M)                    (INPUT) */</FONT>             
{
    va_list ptr_data_array;         <FONT COLOR="570BA3">/* pointer to each data array       */</FONT> 
    int i, j, k, m, n,
        array;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>
    va_start(ptr_data_array, n_data_arrays);
    array = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   Loop through each data array in the
    *   argument list
    *___________________________________*/</FONT> 
    for (array = 1; array &lt;=n_data_arrays; array++)
    {   
        array1 = va_arg(ptr_data_array, double*****);


        for(n = n5dlo; n &lt;= n5dhi; n++)
        {         
            for(m = n4dlo; m &lt;= n4dhi; m++)
            {                
                for(k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
                {
                    for(j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
                    {
                        for(i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
                        {
                           array1[i][j][k][m][n] = 0.0;              
                        }
                    }
                }
            }
        }
    } 
    va_end(ptr_data_array);                     <FONT COLOR="570BA3">/* clean up when done   */</FONT>            
   
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="zero_arrays_6d">zero_arrays_6d</A>  MISC: initialize input data arrays</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Initialize 6d double arrays

Note on implementation:
            This function uses a variable length argument list.  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       01/20/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#zero_arrays_6d">zero_arrays_6d</A>  
    int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    int     n4dlo,                  <FONT COLOR="570BA3">/* 4d lower limit                   */</FONT>
    int     n4dhi,                  <FONT COLOR="570BA3">/* 4d upper limit                   */</FONT>
    int     n5dlo,                  <FONT COLOR="570BA3">/* 5d lower limit                   */</FONT>
    int     n5dhi,                  <FONT COLOR="570BA3">/* 5d upper limit                   */</FONT>
    int     n_data_arrays,          <FONT COLOR="570BA3">/* number of data arrays            (INPUT) */</FONT>
    double  ******array1,...)       <FONT COLOR="570BA3">/* data(x,y,z,f,M)                  (INPUT) */</FONT>             
{
    va_list ptr_data_array;         <FONT COLOR="570BA3">/* pointer to each data array       */</FONT> 
    int i, j, k, f, m,
        array;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>
    va_start(ptr_data_array, n_data_arrays);
    array = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   Loop through each data array in the
    *   argument list
    *___________________________________*/</FONT> 
    for (array = 1; array &lt;=n_data_arrays; array++)
    {   
        array1 = va_arg(ptr_data_array, double******);

        
        for(m = n5dlo; m &lt;= n5dhi; m++)
        {         
            for(f = n4dlo; f &lt;= n4dhi; f++)
            {                
                for(k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
                {
                    for(j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
                    {
                        for(i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
                        {
                           *array1[i][j][k][f][m] = 0.0;              
                        }
                    }
                }
            }
        }
    } 
    va_end(ptr_data_array);                     <FONT COLOR="570BA3">/* clean up when done   */</FONT>            
   
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="zero_arrays_3d">zero_arrays_3d</A>  MISC: initialize input data arrays</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Zero multi-material arrays

Note on implementation:
            This function uses a variable length argument list.  
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/27/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#zero_arrays_3d">zero_arrays_3d</A>  
    int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    int     n_data_arrays,          <FONT COLOR="570BA3">/* number of data arrays            (INPUT) */</FONT>
    double  ***array1,...)          <FONT COLOR="570BA3">/* data(x,y,z)                      (INPUT) */</FONT>             
{
    va_list ptr_data_array;         <FONT COLOR="570BA3">/* pointer to each data array       */</FONT> 
    int i, j, k,
        array;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>
    va_start(ptr_data_array, n_data_arrays);
    array = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   Loop through each data array in the
    *   argument list
    *___________________________________*/</FONT> 
    for (array = 1; array &lt;=n_data_arrays; array++)
    {   array1 = va_arg(ptr_data_array, double***);
                      
        for(k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
        {
            for(j = GC_LO(yLoLimit); j&lt;= GC_HI(yHiLimit); j++)
            {
                for(i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
                {
                   array1[i][j][k] = 0.0;              
                }
            }
        }
        
    } 
    va_end(ptr_data_array);                     <FONT COLOR="570BA3">/* clean up when done   */</FONT>            
   
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="divergence_of_face_centered_velocity">divergence_of_face_centered_velocity</A>  MISC: Computes that divergence of the face centered velocity</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:   For each cell compute the divergence of the face centered 
            velocities.  This is done in a function as opposed to a 
            inside each function inorder to keep the discretization 
            identical.  
Note:       When you apply the divergence theorem the divergence of the 
            the velocity field is the surface integral over a volume.
            The units of div_vel_FCl are  m^3/sec
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/13/99   Written   
       
Reference:
            "Computational Fluid Mechanics and Heat Transfer", Tannehill
            Anderson and Plether, pg 73
_______________________________________________________________________ */</FONT>

void    <A href="#divergence_of_face_centered_velocity">divergence_of_face_centered_velocity</A>  
    int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
    double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
    double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
    double  ******uvel_FC,          <FONT COLOR="570BA3">/* u-face-centered velocity         (INPUT) */</FONT>
    double  ******vvel_FC,          <FONT COLOR="570BA3">/*  v-face-centered velocity        (INPUT) */</FONT>
    double  ******wvel_FC,          <FONT COLOR="570BA3">/* w face-centered velocity         (INPUT) */</FONT>
    double  ****div_vel_FC,
    int     nMaterials)
{
   
    int     i, j, k, m;
      
    double  topface, bottomface,        <FONT COLOR="570BA3">/* temp symbols to represent terms  */</FONT>
            rightface, leftface,
            frontface, backface;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);  
    frontface   = 0.0;
    backface    = 0.0;     
       
    for (m = 1; m &lt;= nMaterials; m++)
    {  
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                { 
                   <FONT COLOR="570BA3">/*__________________________________
                    * top and bottom face contributions
                    *___________________________________*/</FONT>
                   topface      =  delX*delZ* *vvel_FC[i][j][k][TOP][m];
                   bottomface   = -delX*delZ* *vvel_FC[i][j][k][BOTTOM][m];
                    <FONT COLOR="570BA3">/*__________________________________
                    * left and right face contributions
                    *___________________________________*/</FONT>
                   leftface     = -delY*delZ* *uvel_FC[i][j][k][LEFT][m];
                   rightface    =  delY*delZ* *uvel_FC[i][j][k][RIGHT][m];
#if (N_DIMENSIONS == 3)           
                    <FONT COLOR="570BA3">/*__________________________________
                    * front and back face contributions
                    *___________________________________*/</FONT>
                   frontface    =  delX*delY* *wvel_FC[i][j][k][FRONT][m];
                   backface     = -delX*delY* *wvel_FC[i][j][k][BACK][m];
#endif
                    <FONT COLOR="570BA3">/*__________________________________
                    * 
                    *___________________________________*/</FONT>
                    div_vel_FC[i][j][k][m] = (   topface   + bottomface    + leftface 
                                               + rightface + frontface     + backface );
                }
            }
        }  
    }
<FONT COLOR="570BA3">/*__________________________________
*   QUITE FULLWARN 
*___________________________________*/</FONT> 
    delX    = delX;         delY    = delY;     delZ    = delZ;
    QUITE_FULLWARN(wvel_FC[1][1][1][1][1]);      
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="grad_q">grad_q</A>  MISC: Computes the gradients of (q) in the x, y and z dirs.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c
 Purpose:
   This routine calculates the gradient in the x, y and z directions.  The general 
   algorithm is described in the references shown below.  In this code where delX = delY = delZ = constant
   the derviatives reduce to second order centered finite difference expressions  
   
 References:
    CFDLIB98
    
    "Computational Methods in Viscous Aerodynamics", edited by T.K.S Murthy and C.A. Brebbia,
    Elsevier, 1990, pg. 123.
    
    Kashiwa, B, (1987) "Statistical Theory of Turbulent Incompressible Multimaterial Flow" 
    Technical Report LA-11088, Los Alamos National Laborator            
 Steps
 -------------------- 
    1)  check to see that the inputs are valid and determine what walls of the computational
    domain should be included in the calculation.
    2)  Compute the cell-centered gradients for all of the cells inside of the
    computational domain.
    3)  Calculate the gradients for the cells in a single ghostcell layer
    surrounding the computational domain.
    4)  Compute the gradients in each of the corner cells.      
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       7/1/99 
       
       
 NEED TO INCLUDE DERIVATIVES IN THE Z DIRECTION   
 ---------------------------------------------------------------------  */</FONT>
void <A href="#grad_q">grad_q</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* Cell width                       */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* cell center data                 (INPUT) */</FONT>
        double  ***grad_q_X,            <FONT COLOR="570BA3">/* gradient of q in x dir           (OUTPUT)*/</FONT>
        double  ***grad_q_Y,            <FONT COLOR="570BA3">/* gradient of q in y dir           (OUTPUT)*/</FONT>
        double  ***grad_q_Z,             <FONT COLOR="570BA3">/* gradient of q in z dir          (OUTPUT)*/</FONT>
        int     m           )           <FONT COLOR="570BA3">/* material                         */</FONT>
{
        int     i, j, k,                <FONT COLOR="570BA3">/* cell indices                     */</FONT>
                wall,
                wallLo, wallHi,
                xLo, xHi,
                yLo, yHi,
                zLo, zHi;
         
<FONT COLOR="570BA3">/*START_DOC*/</FONT>                      
<FONT COLOR="570BA3">/*__________________________________
*   Step 1)
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt; 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt; 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt; 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert ( m &lt;= N_MATERIAL);
    assert ( delX &gt; (double)0.0 );
    assert ( delY &gt; (double)0.0 );
#if N_DIMENSIONS == 3
    assert ( delZ &gt; 0.0 );
#endif
<FONT COLOR="570BA3">/*__________________________________
*  Determine what walls are used in the 
*   computational domain.
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif


<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 2)
*   Calculate the gradients inside of the computational domain
*   2nd order center differences in all directions
    ---------------------------------------------
    |   |   |   |   |   |   |   |   |   |   |   |   -- top_GC       
    ---------------------------------------------                   
    |   | + | o | + | + | + | + | + | + | + |   |   -- yHiLimit     
    ---------------------------------------------                   
    |   | o | o | o | + | + | + | + | + | + |   |                   
    ---------------------------------------------                   
    |   | + | o | + | + | + | + | + | + | + |   |                   
    ---------------------------------------------                    
    |   | + | + | + | + | + | + | + | + | + |   |   -- yLoLimit     
    ---------------------------------------------                   
    |   |   |   |   |   |   |   |   |   |   |   |   -- bottom_GC    
    ---------------------------------------------                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC                

      
      x = grad_q_X and grad_q_Y
      o = data needed: q_CC 
*_______________________________________________________________________*/</FONT>
                                  
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            { 
            grad_q_X[i][j][k] =         (q_CC[i+1][j][k][m] - q_CC[i-1][j][k][m])/(2.0*delX);
            grad_q_Y[i][j][k] =         (q_CC[i][j+1][k][m] - q_CC[i][j-1][k][m])/(2.0*delY); 
            grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) );   
                      
            }
        }
    }  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 3)
*   Compute the gradients in a single layer of ghostcells surrounding the 
*   the computational domain.  The derivatives use data from inside
*   of the computational domain and adjacent ghostcells.
*
*   2nd order center differences along the wall 
*   2nd order forward or backward differences perpendicular to the wall
*
    _____________________________________________
    |   |   |   |   |   | o | xo| o |   |   |   |   -- top_GC       
    ---------------------------------------------                   
    | o | + | + | + | + | + | o | + | + | + | o |   -- yHiLimit     
    ---------------------------------------------                   
    | xo| o | o | + | + | + | o | + | o | o | xo|                   
    ---------------------------------------------                   
    | o | + | + | + | o | + | + | + | + | + | o |                   
    ---------------------------------------------                    
    |   | + | + | + | o | + | + | + | + | + |   |   -- yLoLimit     
    ---------------------------------------------                   
    |   |   |   | o | xo| o |   |   |   |   |   |   -- bottom_GC    
    ---------------------------------------------                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC
      
      x = grad_q_X and grad_q_Y
      o = data needed: q_CC 
*_______________________________________________________________________*/</FONT>
    for( wall = wallLo; wall &lt;= wallHi; wall ++)
    {
        <FONT COLOR="570BA3">/*__________________________________
        *  Find the looping indices associated
        *   with a particular wall
        *___________________________________*/</FONT>
         <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>                
                    xLoLimit,                  yLoLimit,                   zLoLimit,
                    xHiLimit,                  yHiLimit,                   zHiLimit,
                    &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                    &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                    wall    );
    
        for ( i = xLo; i &lt;= xHi; i++ )
        {
            for ( j = yLo; j &lt;= yHi; j++ )
            { 
                for ( k = zLo; k &lt;= zHi; k++ )
                {        
                
                   if ( wall == LEFT )
                   {
                        grad_q_X[i][j][k] =         (-3.0 * q_CC[i][j][k][m]   + 4.0 * q_CC[i+1][j][k][m] - q_CC[i+2][j][k][m])/(delX);
                        grad_q_Y[i][j][k] =         (q_CC[i][j+1][k][m] - q_CC[i][j-1][k][m])/(2.0*delY); 
                        grad_q_Z[i][j][k] =         0.0;
                       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
                   }
                                
                   if ( wall == RIGHT )
                   {
                        grad_q_X[i][j][k] =         (3.0 * q_CC[i][j][k][m]   - 4.0 * q_CC[i-1][j][k][m] + q_CC[i-2][j][k][m])/(delX);
                        grad_q_Y[i][j][k] =         (q_CC[i][j+1][k][m] - q_CC[i][j-1][k][m])/(2.0*delY); 
                        grad_q_Z[i][j][k] =         0.0;
                       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
                    }
                   if ( wall == TOP )
                   {
                        grad_q_X[i][j][k] =         (q_CC[i+1][j][k][m] - q_CC[i-1][j][k][m])/(2.0*delX);
                        grad_q_Y[i][j][k] =         (3.0 * q_CC[i][j][k][m]   - 4.0 * q_CC[i][j-1][k][m] + q_CC[i][j-2][k][m])/(delY);
                        grad_q_Z[i][j][k] =         0.0;
                       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
                    }
                    if ( wall == BOTTOM )
                   {
                        grad_q_X[i][j][k] =         (q_CC[i+1][j][k][m] - q_CC[i-1][j][k][m])/(2.0*delX);
                        grad_q_Y[i][j][k] =         (-3.0 * q_CC[i][j][k][m]   + 4.0 * q_CC[i][j+1][k][m] - q_CC[i][j+2][k][m])/(delY);
                        grad_q_Z[i][j][k] =         0.0;
                       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
                    }

                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 4)
*   Compute the gradients in each of the corner ghostcells.
*   Need to include 3D here
*   2nd order forward or backward difference are used.

    ---------------------------------------------
    | xo| o | o |   |   |   |   |   | o | o | xo|   -- top_GC       
    ---------------------------------------------                  
    | o | + | + | + | + | + | + | + | + | + | o |   -- yHiLimit     
    ---------------------------------------------                   
    | o | + | + | + | + | + | + | + | + | + | o |                   
    ---------------------------------------------                   
    | o | + | + | + | + | + | + | + | + | + | o |                   
    ---------------------------------------------                    
    | o | + | + | + | + | + | + | + | + | + | o |   -- yLoLimit     
    ---------------------------------------------                   
    | xo| o | o |   |   |   |   |   | o | o | xo|   -- bottom_GC    
    ---------------------------------------------                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC

      x = grad_q_X and grad_q_Y
      o = data needed: q_CC 
*_______________________________________________________________________*/</FONT>
<FONT COLOR="570BA3">/*   Upper Left ghostcell corner 
*___________________________________*/</FONT>
    i   = GC_LO(xLoLimit);
    j   = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
    for (k = zLo; k &lt;=  zHi; k++)
    {
        grad_q_X[i][j][k] =         (-3.0 * q_CC[i][j][k][m]   + 4.0 * q_CC[i+1][j][k][m] - q_CC[i+2][j][k][m])/(delX);
        grad_q_Y[i][j][k] =         ( 3.0 * q_CC[i][j][k][m]   - 4.0 * q_CC[i][j-1][k][m] + q_CC[i][j-2][k][m])/(delY);
        grad_q_Z[i][j][k] =         0.0;
       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
    }

<FONT COLOR="570BA3">/*__________________________________
*   Upper right ghostcell corner
*___________________________________*/</FONT>
    i = GC_HI(xHiLimit);
    j = GC_HI(yHiLimit);
    for (k = zLo; k &lt;=  zHi; k++)
    {
        grad_q_X[i][j][k] =         ( 3.0 * q_CC[i][j][k][m]   - 4.0 * q_CC[i-1][j][k][m] + q_CC[i-2][j][k][m])/(delX);
        grad_q_Y[i][j][k] =         ( 3.0 * q_CC[i][j][k][m]   - 4.0 * q_CC[i][j-1][k][m] + q_CC[i][j-2][k][m])/(delY);
        grad_q_Z[i][j][k] =         0.0;
       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
    }
    

<FONT COLOR="570BA3">/*__________________________________
*   Lower right ghostcell corner
*___________________________________*/</FONT>
    i = GC_HI(xHiLimit);
    j = GC_LO(yLoLimit);
    for (k = zLo; k &lt;=  zHi; k++)
    {
        grad_q_X[i][j][k] =         (  3.0 * q_CC[i][j][k][m]   - 4.0 * q_CC[i-1][j][k][m] + q_CC[i-2][j][k][m])/(delX);
        grad_q_Y[i][j][k] =         ( -3.0 * q_CC[i][j][k][m]   + 4.0 * q_CC[i][j+1][k][m] - q_CC[i][j+2][k][m])/(delY);
        grad_q_Z[i][j][k] =         0.0;
       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
    }

<FONT COLOR="570BA3">/*__________________________________
*   Lower left ghostcell corner
*___________________________________*/</FONT>
    i = GC_LO(xLoLimit);
    j = GC_LO(yLoLimit);
    for (k = zLo; k &lt;=  zHi; k++)
    {
        grad_q_X[i][j][k] =         ( -3.0 * q_CC[i][j][k][m]   + 4.0 * q_CC[i+1][j][k][m] - q_CC[i+2][j][k][m])/(delX);
        grad_q_Y[i][j][k] =         ( -3.0 * q_CC[i][j][k][m]   + 4.0 * q_CC[i][j+1][k][m] - q_CC[i][j+2][k][m])/(delY);
        grad_q_Z[i][j][k] =         0.0;
       <FONT COLOR="570BA3">/*  grad_q_Z[i][j][k] = IF_3D(  (q_CC[i][j][k+1][m] - q_CC[i][j][k-1][m])/(2.0*delZ) ); */</FONT>   
    }   

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(delZ);   
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="grad_FC_Xdir">grad_FC_Xdir</A>  MISC: Calculates gradients of cell-centered data </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: CommonFunctions.c
 Filename: CommonFunctions.c

 Purpose:
   This function calculates the gradient of a scalar using cell-center data
   in the x-dir that is located on a face.  This is second order.
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 ---------------------------------------------------------------------  */</FONT>
 void <A href="#grad_FC_Xdir">grad_FC_Xdir</A>
        int i,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int j,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int k,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int m,                  <FONT COLOR="570BA3">/* material                                 (INPUT) */</FONT>
        double  ****data,       <FONT COLOR="570BA3">/* data(i,j,k,material                      (INPUT) */</FONT>
        double  delX,           <FONT COLOR="570BA3">/* cell width in x-dir                      (INPUT) */</FONT>
        double  *grad )         <FONT COLOR="570BA3">/* resultant gradient                       (OUTPUT)*/</FONT>
{
<FONT COLOR="570BA3">/*__________________________________
* bullet proofing
*___________________________________*/</FONT>
    assert ( i &gt; 0 || i &lt; X_MAX_LIM);
    assert ( j &gt; 0 || j &lt; Y_MAX_LIM);
    assert ( k &gt; 0 || k &lt; Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
* Note that this is centered on the 
* face, so the 2 cancels in the denominator
*___________________________________*/</FONT>
    assert( delX &gt;= SMALL_NUM);             <FONT COLOR="570BA3">/* bullet proofing          */</FONT>
    
    grad[LEFT]  = (data[i][j][k][m] - data[i-1][j][k][m]) /(delX);
    
    grad[RIGHT] = (data[i+1][j][k][m] - data[i][j][k][m]) /(delX);    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="grad_FC_Ydir">grad_FC_Ydir</A>  MISC: Calculates gradients of cell-centered data in the (y) dir. that live on the face-center.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c
 Purpose:
   This function calculates the gradient of a multimaterial scalar using 
   cell center data in the y-dir that lives on a cell face.  This is second order.
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 ---------------------------------------------------------------------  */</FONT>
 void <A href="#grad_FC_Ydir">grad_FC_Ydir</A>
        int i,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int j,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int k,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int m,                  <FONT COLOR="570BA3">/* material                                 (INPUT) */</FONT>
        double  ****data,       <FONT COLOR="570BA3">/* data(i,j,k,material                      (INPUT) */</FONT>
        double  delY,           <FONT COLOR="570BA3">/* cell width in y-dir                      (INPUT) */</FONT>
        double  *grad )         <FONT COLOR="570BA3">/* resultant gradient                       (OUTPUT)*/</FONT>
{
<FONT COLOR="570BA3">/*__________________________________
* bullet proofing
*___________________________________*/</FONT>
    assert ( i &gt;= 0 || i &lt; X_MAX_LIM);
    assert ( j &gt;  0 || j &lt; Y_MAX_LIM);
    assert ( k &gt;= 0 || k &lt; Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
* Note that this is centered on the 
* face, so the 2 cancels in the denominator
*___________________________________*/</FONT> 
    assert( delY &gt;= SMALL_NUM);             <FONT COLOR="570BA3">/* bullet proofing          */</FONT>
    
    grad[TOP]       = (data[i][j+1][k][m]   - data[i][j][k][m])   /delY;
    
    grad[BOTTOM]    = (data[i][j][k][m]     - data[i][j-1][k][m]) /delY;    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="grad_FC_Zdir">grad_FC_Zdir</A>  MISC: Calculates gradients of cell-centered datat in the (z) dir. that live on the face-center.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:
   This function calculates the gradient of a scalar using cell center data
   in the Z-dir.  This is second order
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 Prerequisites: The vector grad[1:6] must be previously defined
 
 ---------------------------------------------------------------------  */</FONT>
 void <A href="#grad_FC_Zdir">grad_FC_Zdir</A>
        int i,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int j,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int k,                  <FONT COLOR="570BA3">/* array index                              (INPUT) */</FONT>
        int m,                  <FONT COLOR="570BA3">/* material                                 (INPUT) */</FONT>
        double  ****data,       <FONT COLOR="570BA3">/* data(i,j,k,material                      (INPUT) */</FONT>
        double  delZ,           <FONT COLOR="570BA3">/* cell width in z-dir                      (INPUT) */</FONT>
        double  *grad )         <FONT COLOR="570BA3">/* resultant gradient                       (OUTPUT)*/</FONT>
{
<FONT COLOR="570BA3">/*__________________________________
* bullet proofing
*___________________________________*/</FONT>
    assert ( i &gt;= 0 || i &lt; X_MAX_LIM);
    assert ( j &gt;= 0 || j &lt; Y_MAX_LIM);
    assert ( k &gt; 0 || k &lt; Z_MAX_LIM);   
<FONT COLOR="570BA3">/*__________________________________
* Note that this is centered on the 
* face, so the 2 cancels in the denominator
*___________________________________*/</FONT> 
    assert( delZ &gt;= SMALL_NUM);             <FONT COLOR="570BA3">/* bullet proofing          */</FONT>
    grad[FRONT] = (data[i][j][k+1][m] - data[i][j][k][m]) /delZ;
    
    grad[BACK]  = (data[i][j][k][m] - data[i][j][k-1][m]) /delZ;    
} 
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="interpolate_to_FC">interpolate_to_FC</A>  MISC: interpolate cell-centered data to face-center, weighted by the density.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:
   This function calculates the interpolated value of cell centered data
   to the face-center.  The interpolated value is weighted by A
   For example an interpolated value on the left cell face 
   result[face] = 
   
   A[i-1][j][k]*B[i-1][j][k] - A[i][j][k]*B[i][j][k]
   ---------------------------------------------------------------------
              A[i-1][j][k] - A[i][j][k]
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

 IN args/commons         Units      Description
 ---------------         -----      ----------- 
  needed
  
 Prerequisites: Memory for the single dimensional array "results" needs to be 
                previously allocated.
                
                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face
                                 
 
 ---------------------------------------------------------------------  */</FONT>
 
 void interpolate_to_FC_MF(
        double  ****A,                  <FONT COLOR="570BA3">/* A (x, y, z, material)        */</FONT>
        double  ****B,                  <FONT COLOR="570BA3">/* B (x, y, z, material)        */</FONT>
        double  *results,                <FONT COLOR="570BA3">/* interpolated results for each*/</FONT>
                                        <FONT COLOR="570BA3">/* cell face                    */</FONT>
        int     i,
        int     j,
        int     k,
        int     m )

         
{
    int     f,
            cell;
#if sw_interpolate_to_FC      
    time_t start;                       <FONT COLOR="570BA3">/* timing variables             */</FONT>
    start = time(NULL);
#endif  
<FONT COLOR="570BA3">/* _______________________________________________________________________
*  Check for valid inputs
*_______________________________________________________________________*/</FONT>
    assert ( i &gt;= 0 || i &lt;= X_MAX_LIM);
    assert ( j &gt;= 0 || j &lt;= Y_MAX_LIM);
    assert ( k &gt;= 0 || k &lt;= Z_MAX_LIM);
    assert ( m &gt;= 0 || m &lt;= N_MATERIAL);
<FONT COLOR="570BA3">/*___________________________________*   
*  Top and bottom cell faces
*___________________________________*/</FONT>
    
    cell = j + 1;
    
    for (f = TOP; f &lt;= BOTTOM; f++)
    {
        results[f]=     (A[i][cell][k][m]      * B[i][cell][k][m]
                    +    A[i][j][k][m]         * B[i][j][k][m])/
                        (A[i][cell][k][m]      + A[i][j][k][m]);
        cell = j - 1;
    }
<FONT COLOR="570BA3">/*__________________________________
*left and right cell faces
*___________________________________*/</FONT>
    cell = i + 1;
    for (f = RIGHT; f &lt;= LEFT; f++)
    {
        results[f]=     (A[cell][j][k][m]      * B[cell][j][k][m]
                    +    A[i][j][k][m]         * B[i][j][k][m])/
                        (A[cell][j][k][m]      + A[i][j][k][m]);
        cell = i - 1;
    }
<FONT COLOR="570BA3">/*__________________________________
* front and back cell faces
*___________________________________*/</FONT>
    cell = k + 1;
    for (f = FRONT; f &lt;= BACK; f++)
    {
        results[f]=     (A[i][j][cell][m]      * B[i][j][cell][m]
                    +    A[i][j][k][m]         * B[i][j][k][m])/
                        (A[i][j][cell][m]      + A[i][j][k][m]);
        cell = k - 1;
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Now test the outputs
*_______________________________________________________________________*/</FONT> 
    assert(results[TOP]     &lt;= BIG_NUM);
    assert(results[BOTTOM]  &lt;= BIG_NUM);
    assert(results[RIGHT]   &lt;= BIG_NUM);
    assert(results[LEFT]    &lt;= BIG_NUM);
    assert(results[FRONT]   &lt;= BIG_NUM);
    assert(results[BACK]    &lt;= BIG_NUM);  
<FONT COLOR="570BA3">/*__________________________________
* Nprintout debugging and timing info
*___________________________________*/</FONT>         
#if sw_interpolate_to_FC
     <A href="#stopwatch">stopwatch</A>"interpolate_to_FC",start);
#endif
     
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="Message">Message</A>  BULLET PROOFING: Writes an error message to (stderr) and stop the program if requested.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:  Output an error message and stop the program if requested. 

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#Message">Message</A>
        int     abort,          <FONT COLOR="570BA3">/* =1 then abort                            */</FONT>                 
        char    filename[],     <FONT COLOR="570BA3">/* description of filename                  */</FONT>
        char    subroutine[],   <FONT COLOR="570BA3">/* description of function your in          */</FONT>
        char    message[])      <FONT COLOR="570BA3">/* message to the user                      */</FONT>
{        
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
        fprintf(stderr,"\n\n ______________________________________________\n");
        fprintf(stderr,"%s\n",filename);
        fprintf(stderr,"%s\n",subroutine);
        fprintf(stderr,"%s\n",message);
        fprintf(stderr,"\n\n ______________________________________________\n");

<FONT COLOR="570BA3">/* ______________________________
 Now aborting program
______________________________ */</FONT>
        if(abort == 1)
             exit(1);
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="stopwatch">stopwatch</A>  PERFORMANCE:</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c
 Purpose:   Output a message and print a time  

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99      
_______________________________________________________________________ */</FONT>

void <A href="#stopwatch">stopwatch</A>
    char message[],             <FONT COLOR="570BA3">/* print message to the user                */</FONT>
    time_t start)               <FONT COLOR="570BA3">/* time in seconds since watch started      */</FONT>
 
{    
    double secs;
    time_t stop;                 <FONT COLOR="570BA3">/* timing variables             */</FONT>
            
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
______________________________  */</FONT> 
    stop = time(NULL);
    secs = difftime(stop, start);               

    fprintf(stderr,"\n___________________________________________TIMER\n");
    fprintf(stderr,"Function %s\n",message);
    fprintf(stderr,"Time it took %lg seconds,\n",secs);
    fprintf(stderr,"______________________________________________\n");       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="printData_5d">printData_5d</A>  DEBUG: Write a 5D array to stderr.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:  Print to stderr the data array 

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#printData_5d">printData_5d</A>                         
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    int     n4dlo, 
    int     n4dhi,
    int     n5dlo, 
    int     n5dhi,
    char    subroutine[],               <FONT COLOR="570BA3">/* name of function                 (INPUT) */</FONT>
    char    message[],                  <FONT COLOR="570BA3">/* message to the user              (INPUT) */</FONT>
    double  *****data_array,            <FONT COLOR="570BA3">/* data(x,y,z,face,material         (INPUT) */</FONT>
    int     ptr_flag,                   <FONT COLOR="570BA3">/* =1 if data_array is a 4d array   */</FONT>
                                        <FONT COLOR="570BA3">/* and the 5th dimension is a pointer*/</FONT>
                                        <FONT COLOR="570BA3">/* address, I'm sure this is confusing*/</FONT>
    int     ghostcells       )          <FONT COLOR="570BA3">/* include ghostcell data in printout(INPUT)*/</FONT>       
{ 
    char c[2];
    int i, j, k, f,
        xLo,    xHi,
        yLo,    yHi,
        zLo,    zHi;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit - ghostcells &gt;= 0 &amp;&amp; xHiLimit + ghostcells &lt;= X_MAX_LIM);
    assert ( yLoLimit - ghostcells &gt;= 0 &amp;&amp; yHiLimit + ghostcells &lt;= Y_MAX_LIM);
    assert ( zLoLimit - ghostcells &gt;= 0 &amp;&amp; zHiLimit + ghostcells &lt;= Z_MAX_LIM);
    assert ( n5dlo &gt;=1 &amp;&amp; n5dhi &lt;= N_MATERIAL);
    strcpy(c,"  ");   
    xLo = xLoLimit - ghostcells;    xHi = xHiLimit + ghostcells;
    yLo = yLoLimit - ghostcells;    yHi = yHiLimit + ghostcells;
 <FONT COLOR="570BA3">/*    zLo = zLoLimit - ghostcells;    zHi = zHiLimit + ghostcells; */</FONT>
    zLo =   zLoLimit;               zHi = zHiLimit;
       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(k = zLo; k &lt;= zHi; k++)
    {
        for(j = yHi; j &gt;= yLo; j--)
        {
        for(f = n4dlo; f &lt;=n4dhi; f++)
                {
            for(i = xLo; i &lt;= xHi; i++)
            {
                
                    if (f == (int)TOP)      strcpy(c,"T ");
                    if (f == (int)BOTTOM)   strcpy(c,"B ");
                    if (f == (int)RIGHT)    strcpy(c,"R ");
                    if (f == (int)LEFT)     strcpy(c,"L ");
                    if (f == (int)FRONT)    strcpy(c,"F ");
                    if (f == (int)BACK)     strcpy(c,"BK");
                    if (ptr_flag != 1)
                        fprintf(stderr,"[%d,%d,%d,%s,%d]= %4.3lf  ",
                        i,j,k,c,n5dlo, data_array[i][j][k][f][n5dlo]);
                    else if (ptr_flag == 1)  
                        fprintf(stderr,"[%d,%d,%d,%s,%d]= %4.3lf  ",
                        i,j,k,c,n5dlo, *data_array[i][j][k][f]);
                

                }
                fprintf(stderr,"\n");
            }
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"\n");
    }
    fprintf(stderr,"______________________________________________\n");
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="printData_6d">printData_6d</A>  DEBUG: Write a 6D array to stderr.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Print to stderr the array 
 Special Note:
            This function assumes that the array data is a pointer array
            meaning
                *data[i][j][k][face][m] = value
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#printData_6d">printData_6d</A>                         
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    int     n4dlo,                      <FONT COLOR="570BA3">/* 4th dimension lower limit        */</FONT> 
    int     n4dhi,                      <FONT COLOR="570BA3">/* 4th dimension upper limit        */</FONT>
    int     n5dlo,                      <FONT COLOR="570BA3">/* 5th dimension lower limit        */</FONT>
    int     n5dhi,                      <FONT COLOR="570BA3">/* 5th dimension upper limit        */</FONT>
    char    subroutine[],               <FONT COLOR="570BA3">/* name of funcion                  */</FONT>
    char    message[],                  <FONT COLOR="570BA3">/* message to the user              */</FONT>
    double  ******data_array,           <FONT COLOR="570BA3">/* *data[i][j][k][f][m] = value     */</FONT>
    int     ghostcells       )          <FONT COLOR="570BA3">/* Include ghostcells when printing */</FONT>        
{ 
    char c[2];
    int i, j, k, f, m,
        xLo,    xHi,
        yLo,    yHi,
        zLo,    zHi;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit - ghostcells &gt;= 0 &amp;&amp; xHiLimit + ghostcells &lt;= X_MAX_LIM);
    assert ( yLoLimit - ghostcells &gt;= 0 &amp;&amp; yHiLimit + ghostcells &lt;= Y_MAX_LIM);
    assert ( zLoLimit - ghostcells &gt;= 0 &amp;&amp; zHiLimit + ghostcells &lt;= Z_MAX_LIM);
    assert ( n5dlo &gt;=1 &amp;&amp; n5dhi &lt;= N_MATERIAL);
    strcpy(c,"  ");   
    xLo = xLoLimit - ghostcells;    xHi = xHiLimit + ghostcells;
    yLo = yLoLimit - ghostcells;    yHi = yHiLimit + ghostcells;
 <FONT COLOR="570BA3">/*    zLo = zLoLimit - ghostcells;    zHi = zHiLimit + ghostcells; */</FONT>
    zLo =   zLoLimit;               zHi = zHiLimit;
<FONT COLOR="570BA3">/*__________________________________
*   HARDWIRE FOR NOW
*___________________________________*/</FONT>   
    m = n5dlo;    
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    
    for(k = zLo; k &lt;= zHi; k++)
    {
        for(j = yHi; j &gt;= yLo; j--)
        {
        for(f = n4dlo; f &lt;=n4dhi; f++)
                {
            for(i = xLo; i &lt;= xHi; i++)
            {
                
                    if (f == (int)TOP)      strcpy(c,"T ");
                    if (f == (int)BOTTOM)   strcpy(c,"B ");
                    if (f == (int)RIGHT)    strcpy(c,"R ");
                    if (f == (int)LEFT)     strcpy(c,"L ");
                    if (f == (int)FRONT)    strcpy(c,"F ");
                    if (f == (int)BACK)     strcpy(c,"BK");
                    fprintf(stderr,"[%d,%d,%d,%s,%d]= %4.3lf  ",
                    i,j,k,c,n5dlo, *data_array[i][j][k][f][m]);
                }
                fprintf(stderr,"\n");
            }
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"\n");
    }
    fprintf(stderr,"______________________________________________\n");
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="printData_4d">printData_4d</A>  DEBUG: Write a 4D array to stderr.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:  Print to stderr a cell-centered, multimaterial array

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#printData_4d">printData_4d</A>  
          int     xLoLimit,             <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
          int     yLoLimit,             <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
          int     zLoLimit,             <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
          int     xHiLimit,             <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
          int     yHiLimit,             <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
          int     zHiLimit,             <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
          int     n4dlo,                <FONT COLOR="570BA3">/* 4th dimension lower limit        */</FONT>
          int     n4dhi,                <FONT COLOR="570BA3">/* 4th dimension upper limit        */</FONT>
          char    subroutine[],         <FONT COLOR="570BA3">/* name of the function             (INPUT) */</FONT>
          char    message[],            <FONT COLOR="570BA3">/* message to the user              (INPUT) */</FONT>
          double  ****data_array      ) <FONT COLOR="570BA3">/* data(i,j,k,m)                    (INPUT) */</FONT>
        
{ 
    int i, j, k, m;
<FONT COLOR="570BA3">/*__________________________________
* HARDWIRED
*___________________________________*/</FONT>
    m=n4dlo;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(k = zLoLimit; k &lt;= zHiLimit; k++)
    {
        for(j = yHiLimit; j &gt;= yLoLimit; j--)
        {
            for(m = n4dlo; m &lt;= n4dhi; m++)
            {
                 for(i = xLoLimit; i &lt;= xHiLimit; i++)
                {    
                    #if (switchDebug_printData_4d == 1)
                    fprintf(stderr,"[%d,%d,%d,%d]= %4.3lf  ",
                      i,j,k,m, data_array[i][j][k][m]);
                    #endif 
                    
                    #if (switchDebug_printData_4d == 2)                      
                    fprintf(stderr,"[%d,%d,%d,%d]= %6.5lf  ",
                      i,j,k,m, data_array[i][j][k][m]);
                    #endif
                }
               
                fprintf(stderr,"\n");
            }
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"\n");
    }
    fprintf(stderr," ______________________________________________\n");
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks 
*___________________________________*/</FONT>      
    QUITE_FULLWARN(data_array); 
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="printData_3d">printData_3d</A>  DEBUG: Write a 3D array to stderr.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Print to stderr a cell-centered, single material

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#printData_3d">printData_3d</A>  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        char    subroutine[],           <FONT COLOR="570BA3">/* name of the function             */</FONT>
        char    message[],              <FONT COLOR="570BA3">/* message to user                  */</FONT>
        double  ***data_array   )       <FONT COLOR="570BA3">/* data(x,y,z)                      */</FONT>
{ 
    int i, j, k;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(k = zLoLimit; k &lt;= zHiLimit; k++)
    {
        for(j = yHiLimit; j &gt;= yLoLimit; j--)
        {
            for(i = xLoLimit; i &lt;= xHiLimit; i++)
            {
               fprintf(stderr,"[%d,%d,%d] = %4.3lf  ",
                      i,j,k, data_array[i][j][k]);
               
               <FONT COLOR="570BA3">/*  fprintf(stderr,"\n"); */</FONT>
            }
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"\n");
    }
    fprintf(stderr," ______________________________________________\n");
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="printData_1d">printData_1d</A>  DEBUG: Write a 1D array to stderr.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: 
 Filename: 

 Purpose:  Print to stderr a cell-centered, single material

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/7/00   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#printData_1d">printData_1d</A>  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        char    subroutine[],           <FONT COLOR="570BA3">/* name of the function             */</FONT>
        char    message[],              <FONT COLOR="570BA3">/* message to user                  */</FONT>
        double  *data_array   )         <FONT COLOR="570BA3">/* data(x)                          */</FONT>
{ 
    int i;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);     
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(i = xLoLimit; i &lt;= xHiLimit; i++)
    {
       fprintf(stderr,"[%d] = %6.5lf  ",
              i, data_array[i]);          
    }
    fprintf(stderr,"\n______________________________________________\n");
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="print_5d_where_computations_have_taken_place">print_5d_where_computations_have_taken_place</A>  DEBUG: Function that writes to stderr where a computation has taken place.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:  print to stderr only the entries in the data_array
    that are equal to 1.  This is mainly used in debugging the code
    specifically where computations have taken place.
    In a test array just set the value of data_array to 1.0
    and this funcion will print out that location 

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       10/10/99   Written   
_______________________________________________________________________ */</FONT>
void    <A href="#print_5d_where_computations_have_taken_place">print_5d_where_computations_have_taken_place</A>                         
    int     xLo,                        <FONT COLOR="570BA3">/* x-array lower               */</FONT>
    int     yLo,                        <FONT COLOR="570BA3">/* y-array lower               */</FONT>
    int     zLo,                        <FONT COLOR="570BA3">/* z-array lower               */</FONT>
    int     xHi,                        <FONT COLOR="570BA3">/* x-array upper               */</FONT>
    int     yHi,                        <FONT COLOR="570BA3">/* y-array upper               */</FONT>
    int     zHi,                        <FONT COLOR="570BA3">/* z-array upper               */</FONT>
    int     n4dlo,                      
    int     n4dhi,
    int     n5dlo, 
    int     n5dhi,
    char    subroutine[],               <FONT COLOR="570BA3">/* name of function             (INPUT) */</FONT>
    char    message[],                  <FONT COLOR="570BA3">/* message to the user          (INPUT) */</FONT>
    double  *****data_array,            <FONT COLOR="570BA3">/* data(i,j,k,f,m)              (INPUT) */</FONT>
    int     ghostcells       )          <FONT COLOR="570BA3">/* =1 include ghostcelldata     (INPUT) */</FONT>
        
{ 
    char    c[2];
    int     i, j, k, f;

<FONT COLOR="570BA3">/*__________________________________
*   Define limits
*___________________________________*/</FONT>
    strcpy(c,"  ");
    if (ghostcells == 1)
    {   
        xLo = GC_LO(xLo);    xHi = GC_HI(xHi);
        yLo = GC_LO(yLo);    yHi = GC_HI(yHi);
 <FONT COLOR="570BA3">/*     zLo = GC_LO(zLo);    zHi = GC_HI(zHi); */</FONT>
        zLo =   zLo;               zHi = zHi;
    }
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLo &gt;= 0 &amp;&amp; xHi &lt;= X_MAX_LIM);
    assert ( yLo &gt;= 0 &amp;&amp; yHi &lt;= Y_MAX_LIM);
    assert ( zLo &gt;= 0 &amp;&amp; zHi &lt;= Z_MAX_LIM);
    assert ( n5dlo &gt;=1 &amp;&amp; n5dhi &lt;= N_MATERIAL);

       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(k = zLo; k &lt;= zHi; k++)
    {
        for(j = yHi; j &gt;= yLo; j--)
        {
            for(f = n4dlo; f &lt;=n4dhi; f++)
            {
                for(i = xLo; i &lt;= xHi; i++)
                {
                
                    if (f == (int)TOP)      strcpy(c,"T ");
                    if (f == (int)BOTTOM)   strcpy(c,"B ");
                    if (f == (int)RIGHT)    strcpy(c,"R ");
                    if (f == (int)LEFT)     strcpy(c,"L ");
                    if (f == (int)FRONT)    strcpy(c,"F ");
                    if (f == (int)BACK)     strcpy(c,"BK");
                    if ( fabs(data_array[i][j][k][f][n5dlo] - YES) &lt;= DIFFERENCE  )
                        fprintf(stderr,"[%d,%d,%d,%s,%d]  ",i,j,k,c,n5dlo);
                    else 
                        fprintf(stderr,"              ");
                }
                fprintf(stderr,"\n");
            }
            fprintf(stderr,"\n");
        }
        <FONT COLOR="570BA3">/* fprintf(stderr,"\n"); */</FONT>
    }
    fprintf(stderr,"______________________________________________\n");
       
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="print_4d_where_computations_have_taken_place">print_4d_where_computations_have_taken_place</A>  DEBUG: Function that writes to stderr where a computation has taken place.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:  print to stderr only the entries in the data_array
    that are equal to 1.  This is mainly used in debugging the code
    specifically where computations have taken place.
    In a test array just set the value of data_array to 1.0
    and this funcion will print out that location 

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       10/10/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#print_4d_where_computations_have_taken_place">print_4d_where_computations_have_taken_place</A>                         
    int     xLo,                        <FONT COLOR="570BA3">/* x-array lower                */</FONT>
    int     yLo,                        <FONT COLOR="570BA3">/* y-array lower                */</FONT>
    int     zLo,                        <FONT COLOR="570BA3">/* z-array lower                */</FONT>
    int     xHi,                        <FONT COLOR="570BA3">/* x-array upper                */</FONT>
    int     yHi,                        <FONT COLOR="570BA3">/* y-array upper                */</FONT>
    int     zHi,                        <FONT COLOR="570BA3">/* z-array upper                */</FONT>
    int     n4dlo,                      <FONT COLOR="570BA3">/* 4th dimension lower limit    (INPUT) */</FONT>
    int     n4dhi,
    char    subroutine[],
    char    message[],
    double  ****data_array,
    int     ghostcells       )        
{ 
    int     i, j, k, m;
<FONT COLOR="570BA3">/*__________________________________
*   Define limits
*___________________________________*/</FONT>
    if (ghostcells == 1)
    {   
        xLo = GC_LO(xLo);    xHi = GC_HI(xHi);
        yLo = GC_LO(yLo);    yHi = GC_HI(yHi);
 <FONT COLOR="570BA3">/*     zLo = GC_LO(zLo);    zHi = GC_HI(zHi); */</FONT>
        zLo =   zLo;               zHi = zHi;
    }
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLo &gt;= 0 &amp;&amp; xHi &lt;= X_MAX_LIM);
    assert ( yLo &gt;= 0 &amp;&amp; yHi &lt;= Y_MAX_LIM);
    assert ( zLo &gt;= 0 &amp;&amp; zHi &lt;= Z_MAX_LIM);

       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(k = zLo; k &lt;= zHi; k++)
    {
        for(j = yHi; j &gt;= yLo; j--)
        {
            for(m = n4dlo; m &lt;= n4dhi; m++)
            {
                 for(i = xLo; i &lt;= xHi; i++)
                {    
                    if ( fabs(data_array[i][j][k][m] - YES) &lt;= DIFFERENCE  )
                        fprintf(stderr,"[%d,%d,%d,%d]  ",i,j,k,m);
                    else 
                        fprintf(stderr,"                  ");
                        
                }
               
                fprintf(stderr,"\n");
            }
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"\n");
    }
    fprintf(stderr," ______________________________________________\n");
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="print_3d_where_computations_have_taken_place">print_3d_where_computations_have_taken_place</A>  DEBUG: Function that writes to stderr where a computation has taken place.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: commonFunctions.c
 Filename: commonFunctions.c

 Purpose:  print to stderr only the entries in the data_array
    that are equal to 1.  This is mainly used in debugging the code
    specifically where computations have taken place.
    In a test array just set the value of data_array to 1.0
    and this funcion will print out that location 

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       10/10/99   Written   
_______________________________________________________________________ */</FONT>

void    <A href="#print_3d_where_computations_have_taken_place">print_3d_where_computations_have_taken_place</A>                         
    int     xLo,                        <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLo,                        <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLo,                        <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHi,                        <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHi,                        <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHi,                        <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    char    subroutine[],               <FONT COLOR="570BA3">/* name of function                 (INPUT) */</FONT>
    char    message[],                  <FONT COLOR="570BA3">/* message to the user              (INPUT) */</FONT>
    double  ***data_array,              <FONT COLOR="570BA3">/* data(i,j,k)                      (INPUT) */</FONT>
    int     ghostcells       )        
{ 
    int     i, j, k;


<FONT COLOR="570BA3">/*__________________________________
*   Define limits
*___________________________________*/</FONT>
    if (ghostcells == 1)
    {   
        xLo = GC_LO(xLo);    xHi = GC_HI(xHi);
        yLo = GC_LO(yLo);    yHi = GC_HI(yHi);
 <FONT COLOR="570BA3">/*     zLo = GC_LO(zLo);    zHi = GC_HI(zHi); */</FONT>
        zLo =   zLo;               zHi = zHi;
    }
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLo &gt;= 0 &amp;&amp; xHi &lt;= X_MAX_LIM);
    assert ( yLo &gt;= 0 &amp;&amp; yHi &lt;= Y_MAX_LIM);
    assert ( zLo &gt;= 0 &amp;&amp; zHi &lt;= Z_MAX_LIM);
       
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                
    fprintf(stderr,"\n ______________________________________________\n");
    fprintf(stderr,"%s\n",subroutine);
    fprintf(stderr,"%s\n",message);
    fprintf(stderr,"\n");
    for(k = zLo; k &lt;= zHi; k++)
    {
        for(j = yHi; j &gt;= yLo; j--)
        {
             for(i = xLo; i &lt;= xHi; i++)
            {    
                if ( fabs(data_array[i][j][k] - YES) &lt;= DIFFERENCE  )
                    fprintf(stderr,"[%d,%d,%d]  ",i,j,k);
                else 
                    fprintf(stderr,"                  ");
            }    
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"\n");
    }
    fprintf(stderr," ______________________________________________\n");
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="advect_and_advance_in_time">advect_and_advance_in_time</A>  Steps 6 and 7</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: timeadvanced.c 
 Filename: timeadvanced.c 

 Purpose:
   This function calculates the The cell-centered, time n+1, mass, momentum
   and internal energy
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       09/??/99    
       2.0      //               04/19/00   Now computes the flux across each 
                                            face independently. 

Need to include kinetic energy 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#advect_and_advance_in_time">advect_and_advance_in_time</A>  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT> 
        double  ***Vol_CC,              <FONT COLOR="570BA3">/* cell-centered volume             (INPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* cell-centered density            (OUPUT) */</FONT>
        double  ****xmom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (OUPUT) */</FONT>
        double  ****ymom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (OUPUT) */</FONT>
        double  ****zmom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (OUPUT) */</FONT>
        double  ****Vol_L_CC,           <FONT COLOR="570BA3">/* Lagrangian cell-centered volume  (INPUT) */</FONT>
        double  ****rho_L_CC,           <FONT COLOR="570BA3">/* Lagrangian cell-centered density (INPUT) */</FONT>
        double  ****mass_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered mass    (INPUT) */</FONT>
        double  ****xmom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(INPUT) */</FONT>
        double  ****ymom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(INPUT) */</FONT>
        double  ****zmom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(INPUT) */</FONT>
        double  ****int_eng_CC,         <FONT COLOR="570BA3">/* internal energy                  (OUPUT) */</FONT>
        double  ****int_eng_L_CC,       <FONT COLOR="570BA3">/* Lagrangian CC internal energy    (INPUT) */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/*  u-face-centered velocity        (INPUT) */</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/*  v-face-centered velocity        (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* w face-centered velocity         (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* delta t                          (INPUT) */</FONT>
        int     nMaterials      )
<FONT COLOR="570BA3">/* Local Definitions________________________________________________________*/</FONT>
{
    int     i, j, k,m;                  <FONT COLOR="570BA3">/*   loop indices  locators         */</FONT>
           
    
    double  vol,                        <FONT COLOR="570BA3">/* Temporary variable               */</FONT>
            ****advct_xmom_CC,          <FONT COLOR="570BA3">/* Advected momemtum                */</FONT>
            ****advct_ymom_CC,
            ****advct_zmom_CC,
            ****mass_L_TEMP,
            ****xmom_L_TEMP,              <FONT COLOR="570BA3">/* temporary variables              */</FONT>
            ****ymom_L_TEMP,
            ****zmom_L_TEMP,
            ****int_eng_L_TEMP,
            ****advct_rho_CC,
            ****advct_int_eng_CC,       <FONT COLOR="570BA3">/* Advected interal energy          */</FONT>            
            ****r_out_x,                <FONT COLOR="570BA3">/* x-dir centroid array (i,j,k,vol  */</FONT>           
            ****r_out_y,                <FONT COLOR="570BA3">/* y-dir centroid array             */</FONT>                            
            ****r_out_z,                <FONT COLOR="570BA3">/* z-dir centroid array             */</FONT>            
            ****outflux_vol,            <FONT COLOR="570BA3">/* array containing the size of each*/</FONT>
                                        <FONT COLOR="570BA3">/* of the outflux volumes           */</FONT> 
                                        <FONT COLOR="570BA3">/* (i,j,k,vol)                      */</FONT>  
            ****influx_vol,             <FONT COLOR="570BA3">/* influx volume for each slab      */</FONT>
            ****r_out_x_CF,             <FONT COLOR="570BA3">/* corner flux centroid x-dir       */</FONT>
            ****r_out_y_CF,             <FONT COLOR="570BA3">/* corner flux centroid y-dir       */</FONT> 
            ****r_out_z_CF,             <FONT COLOR="570BA3">/* corner flux centroid z-dir       */</FONT>
            ****influx_vol_CF,          <FONT COLOR="570BA3">/* corner flux contributions        */</FONT> 
            ****outflux_vol_CF;         <FONT COLOR="570BA3">/* corner flux contributions        */</FONT>                   
                                      
    char    should_I_write_output;       
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if (switchDebug_advect_and_advance_in_time)
    #include "plot_declare_vars.h"   
#endif
#if sw_advect_and_advance_in_time    
    time_t start,secs;                  <FONT COLOR="570BA3">/* timing variables                 */</FONT>               
    start = time(NULL);
#endif
<FONT COLOR="570BA3">/*START_DOC*/</FONT> 

<FONT COLOR="570BA3">/*__________________________________
* Check that the inputs are reasonable
*___________________________________*/</FONT>
    assert ( xLoLimit &gt; 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt; 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt; 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
* Allocate memory for local arrays
*___________________________________*/</FONT>
    advct_xmom_CC   = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    advct_ymom_CC   = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    advct_zmom_CC   = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    advct_rho_CC    = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    advct_int_eng_CC= darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);

    mass_L_TEMP     = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    xmom_L_TEMP     = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    ymom_L_TEMP     = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    zmom_L_TEMP     = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);
    int_eng_L_TEMP  = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_MATERIAL);

    r_out_x         = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_FACES);
    r_out_y         = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_FACES);
    r_out_z         = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_FACES);    
    outflux_vol     = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_FACES);
    influx_vol      = darray_4d(-1,X_MAX_LIM+1,     -1,Y_MAX_LIM+1,-1,  Z_MAX_LIM+1,    1, N_CELL_FACES);  
    
    r_out_x_CF      = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_VERTICES);
    r_out_y_CF      = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_VERTICES);
    r_out_z_CF      = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_VERTICES);
    outflux_vol_CF  = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM,      1, N_CELL_VERTICES);
    influx_vol_CF   = darray_4d(-1,   X_MAX_LIM+1, -1, Y_MAX_LIM+1,-1,  Z_MAX_LIM+1,    1, N_CELL_VERTICES);



    <A href="#zero_arrays_4d">zero_arrays_4d</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,
                        1,              nMaterials,     11,             
                        advct_xmom_CC,  advct_ymom_CC,  advct_zmom_CC,  
                        advct_int_eng_CC,advct_rho_CC,  int_eng_L_TEMP, 
                        xmom_L_TEMP,    ymom_L_TEMP,    zmom_L_TEMP,
                        mass_L_TEMP,
                        outflux_vol);
    
#if switch_step6_OnOff

<FONT COLOR="570BA3">/*__________________________________
*   since all of the momentum arrays
*   are defined as mass*velocity
*   we need to convert them into 
*   rho * velocity before we pass that
*   data into the advection operator.
*   So we divide the momentum arrays by the volume
*___________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    {     
        for ( i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
        {
            for ( j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
            {
                for ( k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
                {            
                    assert ( Vol_CC[i][j][k] &gt;0.0);

                    vol = Vol_CC[i][j][k];                
                    mass_L_TEMP[i][j][k][m]       = mass_L_CC[i][j][k][m]/vol;
                    xmom_L_TEMP[i][j][k][m]       = xmom_L_CC[i][j][k][m]/vol;
                    ymom_L_TEMP[i][j][k][m]       = ymom_L_CC[i][j][k][m]/vol;
                    zmom_L_TEMP[i][j][k][m]       = zmom_L_CC[i][j][k][m]/vol;
                    int_eng_L_TEMP[i][j][k][m]    = int_eng_L_CC[i][j][k][m]/vol;

                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
* Calculate the advection terms
*_______________________________________________________________________*/</FONT>

    for (m = 1; m &lt;= nMaterials; m++)
    {   
        putenv("PGPLOT_PLOTTING_ON_OFF=1");
    <FONT COLOR="570BA3">/*__________________________________
    * Compute stuff that only needs to be
    * calculated only once (i.e. r_out[*],
    * influx_vol, outflux_vol, 
    * influx_counter
    *___________________________________*/</FONT>  
        <A href="#advect_preprocess">advect_preprocess</A>
                        xLoLimit,       yLoLimit,       zLoLimit,         
                        xHiLimit,       yHiLimit,       zHiLimit,         
                        delX,           delY,           delZ,
                        delt, 
                        uvel_FC,        vvel_FC,        wvel_FC,                             
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,     
                        outflux_vol,    outflux_vol_CF, 
                        influx_vol,     influx_vol_CF,
                        m );   

        putenv("PGPLOT_PLOTTING_ON_OFF=0"); 
        <FONT COLOR="570BA3">/*-------density-------*/</FONT>                                
         <A href="#advect_q">advect_q</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        mass_L_TEMP,         
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        outflux_vol,    outflux_vol_CF, 
                        influx_vol,     influx_vol_CF,
                        advct_rho_CC,   m);

          
        putenv("PGPLOT_PLOTTING_ON_OFF=1");
        <FONT COLOR="570BA3">/*-----Internal Energy-----*/</FONT>
         <A href="#advect_q">advect_q</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        int_eng_L_TEMP,         
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        outflux_vol,    outflux_vol_CF, 
                        influx_vol,     influx_vol_CF,
                        advct_int_eng_CC,m);
        putenv("PGPLOT_PLOTTING_ON_OFF=0"); 

        <FONT COLOR="570BA3">/*-------x-momentum------*/</FONT>
         <A href="#advect_q">advect_q</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        xmom_L_TEMP,         
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        outflux_vol,    outflux_vol_CF, 
                        influx_vol,     influx_vol_CF,
                        advct_xmom_CC,  m); 
        <FONT COLOR="570BA3">/*-------y-momentum------*/</FONT>
         <A href="#advect_q">advect_q</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        ymom_L_TEMP,         
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        outflux_vol,    outflux_vol_CF, 
                        influx_vol,     influx_vol_CF,
                        advct_ymom_CC,  m);


    <FONT COLOR="570BA3">/*  advect_q(
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        zmom_L_TEMP,         
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        outflux_vol,    outflux_vol_CF, 
                        influx_vol,     influx_vol_CF,
                        advct_zmom_CC,  m); */</FONT>

    }
                    

#endif

#if switch_step7_OnOff 
putenv("PGPLOT_PLOTTING_ON_OFF=1");
<FONT COLOR="570BA3">/*__________________________________
* Now advance in time
*___________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    { 
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {            
                    assert ( Vol_CC[i][j][k] &gt;0.0);

                    <FONT COLOR="570BA3">/*__________________________________
                    * update x, y, z components of momentum
                    *___________________________________*/</FONT>
                    xmom_CC[i][j][k][m] = ( xmom_L_CC[i][j][k][m] + advct_xmom_CC[i][j][k][m] );
                    ymom_CC[i][j][k][m] = ( ymom_L_CC[i][j][k][m] + advct_ymom_CC[i][j][k][m] );
                    zmom_CC[i][j][k][m] = ( zmom_L_CC[i][j][k][m] + advct_zmom_CC[i][j][k][m] );  

                    <FONT COLOR="570BA3">/*__________________________________
                    *   Update the internal energy
                    *___________________________________*/</FONT>
                    int_eng_CC[i][j][k][m] = ( int_eng_L_CC[i][j][k][m] + advct_int_eng_CC[i][j][k][m] );
                    
                    <FONT COLOR="570BA3">/*__________________________________
                    *  update density You must do this last
                    *   so you don't overwrite the rho_CC
                    *___________________________________*/</FONT>

                   rho_CC[i][j][k][m] = (mass_L_CC[i][j][k][m] + 
                                         advct_rho_CC[i][j][k][m] )/ Vol_CC[i][j][k];                             

                }
            }
        }
    }
#endif
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING AND STOP WATCH INFORMATION
*_______________________________________________________________________*/</FONT>
#if switchDebug_advect_and_advance_in_time
    should_I_write_output = *getenv("SHOULD_I_WRITE_OUTPUT");
    if ( should_I_write_output == '1')
    {
        #define switchInclude_advect_and_advance_in_time 1
        #include "debugcode.i"
        #undef switchInclude_advect_and_advance_in_time 
    }                  
#endif 
       
#if sw_advect_and_advance_in_time
    <A href="#stopwatch">stopwatch</A>"time_advance function",start);
#endif


<FONT COLOR="570BA3">/*__________________________________
* Free local memory
*___________________________________*/</FONT>
   free_darray_4d( advct_xmom_CC,   0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( advct_ymom_CC,   0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( advct_zmom_CC,   0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( mass_L_TEMP,     0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( xmom_L_TEMP,     0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( ymom_L_TEMP,     0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( zmom_L_TEMP,     0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( int_eng_L_TEMP,  0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);

   free_darray_4d( advct_rho_CC,    0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
   free_darray_4d( advct_int_eng_CC,0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_MATERIAL);
 
   free_darray_4d( r_out_x,         0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_FACES);
   free_darray_4d( r_out_y,         0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_FACES);
   free_darray_4d( r_out_z,         0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_FACES);
   free_darray_4d(outflux_vol,      0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_FACES);
   free_darray_4d(influx_vol,       -1,X_MAX_LIM+1,-1, Y_MAX_LIM+1, -1, Z_MAX_LIM+1, 1, N_CELL_FACES);
   
   free_darray_4d( r_out_x_CF,      0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_VERTICES);
   free_darray_4d( r_out_y_CF,      0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_VERTICES);
   free_darray_4d( r_out_z_CF,      0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_VERTICES);
   free_darray_4d(outflux_vol_CF,   0, X_MAX_LIM,   0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_VERTICES);
   free_darray_4d(influx_vol_CF,    -1,X_MAX_LIM+1,-1, Y_MAX_LIM+1, -1, Z_MAX_LIM+1, 1, N_CELL_VERTICES);
   
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(Vol_L_CC[0][0][0][1]); 
    QUITE_FULLWARN(rho_L_CC[0][0][0][1]);
    should_I_write_output = should_I_write_output;

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="doubleCheckConservationLaws">doubleCheckConservationLaws</A>  checks to see if mass, momentum and energy are conserved over the whole domain  </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: timeadvanced.c 
 Filename: timeadvanced.c 

 Purpose:
   This function calculates the time n+1, density,
   internal energy and momentum over the entire domain.
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       09/??/99     

Need to include kinetic energy 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#doubleCheckConservationLaws">doubleCheckConservationLaws</A>  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT> 
        double  ***Vol_CC,              <FONT COLOR="570BA3">/* cell-centered volume             (INPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* cell-centered density            (OUPUT) */</FONT>
        double  ****uvel_CC,            <FONT COLOR="570BA3">/* u cell-centered velocity         (INPUT) */</FONT>
        double  ****vvel_CC,            <FONT COLOR="570BA3">/* v cell-centered velocity         (INPUT) */</FONT>
        double  ****wvel_CC,            <FONT COLOR="570BA3">/* w cell-centered velocity         (INPUT) */</FONT>
        double  ****xmom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (OUPUT) */</FONT>
        double  ****ymom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (OUPUT) */</FONT>
        double  ****zmom_CC,            <FONT COLOR="570BA3">/* cell-centered x-momentum         (OUPUT) */</FONT>
        double  ****Vol_L_CC,           <FONT COLOR="570BA3">/* Lagrangian cell-centered volume  (INPUT) */</FONT>
        double  ****rho_L_CC,           <FONT COLOR="570BA3">/* Lagrangian cell-centered density (INPUT) */</FONT>
        double  ****mass_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered mass    (INPUT) */</FONT>
        double  ****xmom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(INPUT) */</FONT>
        double  ****ymom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(INPUT) */</FONT>
        double  ****zmom_L_CC,          <FONT COLOR="570BA3">/* Lagrangian cell-centered momentum(INPUT) */</FONT>
        double  ****int_eng_CC,         <FONT COLOR="570BA3">/* internal energy                  (OUPUT) */</FONT>
        double  ****int_eng_L_CC,       <FONT COLOR="570BA3">/* Lagrangian CC internal energy    (INPUT) */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/*  u-face-centered velocity        (INPUT) */</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/*  v-face-centered velocity        (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* w face-centered velocity         (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* delta t                          (INPUT) */</FONT>
        int     nMaterials      )
<FONT COLOR="570BA3">/* Local Definitions________________________________________________________*/</FONT>
{
    int     i, j, k,m,                  <FONT COLOR="570BA3">/*   loop indices  locators         */</FONT>
            ***influx_counter,          <FONT COLOR="570BA3">/* volume segments flowing from one */</FONT>
                                        <FONT COLOR="570BA3">/* cell to another                  */</FONT>
            wall, wallLo, wallHi,       <FONT COLOR="570BA3">/* wall upper and lower indices     */</FONT> 
            xLo, xHi,
            yLo, yHi,
            zLo, zHi;           
    
    double  vol,                        <FONT COLOR="570BA3">/* Temporary variable               */</FONT>
            *sum_xmom_CC,               <FONT COLOR="570BA3">/* sum over the entire domain of the*/</FONT>   
            *sum_ymom_CC,               <FONT COLOR="570BA3">/* conserved quantities             */</FONT>
            *sum_zmom_CC,               <FONT COLOR="570BA3">/*----------//----------------------*/</FONT>
            *sum_int_eng_CC,            <FONT COLOR="570BA3">/*----------//----------------------*/</FONT>
            *sum_mass_CC,               <FONT COLOR="570BA3">/*----------//----------------------*/</FONT>
            ****advct_xmom_CC,          <FONT COLOR="570BA3">/* Advected momemtum                */</FONT>
            ****advct_ymom_CC,
            ****advct_zmom_CC,
            ****mass_L_TEMP,
            ****xmom_L_TEMP,            <FONT COLOR="570BA3">/* temporary variables              */</FONT>
            ****ymom_L_TEMP,
            ****zmom_L_TEMP,
            ****int_eng_L_TEMP,
            ****advct_rho_CC,
            ****advct_int_eng_CC,       <FONT COLOR="570BA3">/* Advected interal energy          */</FONT>            
            *****r_out_x,               <FONT COLOR="570BA3">/* x-dir centroid array (i,j,k,vol  */</FONT> 
            *****r_out_y,               <FONT COLOR="570BA3">/* y-dir centroid array             */</FONT>                   
            *****r_out_z,               <FONT COLOR="570BA3">/* z-dir centroid array             */</FONT>                 
            ****outflux_vol,         <FONT COLOR="570BA3">/* array containing the size of each*/</FONT>
                                        <FONT COLOR="570BA3">/* of the outflux volumes           */</FONT> 
                                        <FONT COLOR="570BA3">/* (i,j,k,vol)                      */</FONT>                      
            ****influx_vol;          <FONT COLOR="570BA3">/* array containing the size of each*/</FONT>
                                        <FONT COLOR="570BA3">/* of the influx volumes            */</FONT> 
                                        <FONT COLOR="570BA3">/* (i,j,k,counter)                  */</FONT>    
<FONT COLOR="570BA3">/*__________________________________
* Check that the inputs are reasonable
*___________________________________*/</FONT>
    assert ( xLoLimit &gt; 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt; 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt; 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
* Allocate memory for local arrays
*___________________________________*/</FONT>

    sum_xmom_CC     = dvector(1, N_MATERIAL);
    sum_ymom_CC     = dvector(1, N_MATERIAL);
    sum_zmom_CC     = dvector(1, N_MATERIAL);
    sum_int_eng_CC  = dvector(1, N_MATERIAL);
    sum_mass_CC     = dvector(1, N_MATERIAL);
      
    advct_xmom_CC   = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    advct_ymom_CC   = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    advct_zmom_CC   = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    advct_rho_CC    = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    advct_int_eng_CC= darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);

    mass_L_TEMP     = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    xmom_L_TEMP     = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    ymom_L_TEMP     = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    zmom_L_TEMP     = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
    int_eng_L_TEMP  = darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);

    influx_counter  = iarray_3d(-1, X_MAX_LIM+1,    -1, Y_MAX_LIM+1,-1, Z_MAX_LIM+1);
    r_out_x         = darray_5d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM, 1, N_MATERIAL,  1, N_OUTFLOW_DEL_V);
    r_out_y         = darray_5d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM, 1, N_MATERIAL,  1, N_OUTFLOW_DEL_V);
    r_out_z         = darray_5d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM, 1, N_MATERIAL,  1, N_OUTFLOW_DEL_V);    
    outflux_vol  = darray_4d(0, X_MAX_LIM,       0, Y_MAX_LIM, 0,    Z_MAX_LIM, 1, N_OUTFLOW_DEL_V);
    influx_vol   = darray_4d(-1,   X_MAX_LIM+1, -1, Y_MAX_LIM+1,-1,  Z_MAX_LIM+1,               1, N_INFLOW_DEL_V);    
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
    wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
    wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
    wallLo = TOP;   wallHi = BACK;
#endif

   <FONT COLOR="570BA3">/*__________________________________
   * zero the locally defined arrays
   * I don't need to zero the entire
   * domain just each wall.  However,
   * it is simpler this way
   *___________________________________*/</FONT>
    <A href="#zero_arrays_4d">zero_arrays_4d</A>
                        xLoLimit,           yLoLimit,           zLoLimit,             
                        xHiLimit,           yHiLimit,           zHiLimit,
                        1,                  nMaterials,         11,             
                        advct_xmom_CC,      advct_ymom_CC,      advct_zmom_CC,  
                        advct_int_eng_CC,   advct_rho_CC,       int_eng_L_TEMP, 
                        xmom_L_TEMP,        ymom_L_TEMP,        zmom_L_TEMP,
                        mass_L_TEMP,
                        outflux_vol);

    <A href="#zero_arrays_5d">zero_arrays_5d</A>
                        xLoLimit,           yLoLimit,           zLoLimit,             
                        xHiLimit,           yHiLimit,           zHiLimit,
                        1,                  nMaterials,         1,
                        N_OUTFLOW_DEL_V,                    3,             
                        r_out_x,            r_out_y,            r_out_z);
<FONT COLOR="570BA3">/*__________________________________
*   since all of the conserved quantities
*   are defined as q*Volume
*   we need to convert them mass, momentum
*   and internal energy densities before we pass that
*   data into the advection operator.
*   So we divide the Lagrangian arrays by the volume
*___________________________________*/</FONT> 
    for (m = 1; m &lt;= nMaterials; m++)
    {    
        for ( i = GC_LO(xLoLimit); i &lt;= GC_HI(xHiLimit); i++)
        {
            for ( j = GC_LO(yLoLimit); j &lt;= GC_HI(yHiLimit); j++)
            {
                for ( k = GC_LO(zLoLimit); k &lt;= GC_HI(zHiLimit); k++)
                {            
                    assert ( Vol_CC[i][j][k] &gt;0.0);

                    vol = Vol_CC[i][j][k];                
                    mass_L_TEMP[i][j][k][m]       = mass_L_CC[i][j][k][m]/vol;
                    xmom_L_TEMP[i][j][k][m]       = xmom_L_CC[i][j][k][m]/vol;
                    ymom_L_TEMP[i][j][k][m]       = ymom_L_CC[i][j][k][m]/vol;
                    zmom_L_TEMP[i][j][k][m]       = zmom_L_CC[i][j][k][m]/vol;
                    int_eng_L_TEMP[i][j][k][m]    = int_eng_L_CC[i][j][k][m]/vol;
                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   For each material advect each of the conserved quantities
*   Note:   You only need to advect on each of the walls.  I'm doing WAY too
*           much work here.  I only need to advect on each of the walls.
*           
*_______________________________________________________________________*/</FONT>
    for(m = 1; m &lt;=nMaterials; m++)
    { 
        <FONT COLOR="570BA3">/*______________________________________________________________________
        * Calculate the advection terms
        *_______________________________________________________________________*/</FONT>

        <FONT COLOR="570BA3">/*__________________________________
        * Compute stuff that only needs to be
        * calculated only once (i.e. r_out[*],
        * influx_vol, outflux_vol, 
        * influx_counter
        *___________________________________*/</FONT>  
            <A href="#advect_preprocess">advect_preprocess</A>
                            xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                            delX,           delY,           delZ,
                            delt,             
                            uvel_CC,        vvel_CC,        wvel_CC,             
                            uvel_FC,        vvel_FC,        wvel_FC,    
                            r_out_x,        r_out_y,        r_out_z,     
                            outflux_vol,  influx_counter, influx_vol,
                            m );   

            <FONT COLOR="570BA3">/*-------density-------*/</FONT>                                
             <A href="#advect_q">advect_q</A>
                            xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                            delX,           delY,           delZ,
                            mass_L_TEMP,
                            uvel_FC,        vvel_FC,        wvel_FC,         
                            r_out_x,        r_out_y,        r_out_z,
                            outflux_vol, influx_counter, influx_vol,
                            advct_rho_CC,   m);   

            <FONT COLOR="570BA3">/*-----Internal Energy-----*/</FONT>
            <A href="#advect_q">advect_q</A>
                            xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                            delX,           delY,           delZ,
                            int_eng_L_TEMP,
                            uvel_FC,        vvel_FC,        wvel_FC, 
                            r_out_x,        r_out_y,        r_out_z,
                            outflux_vol, influx_counter, influx_vol,
                            advct_int_eng_CC,m);

            <FONT COLOR="570BA3">/*-------x-momentum------*/</FONT>
            <A href="#advect_q">advect_q</A>
                            xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                            delX,           delY,           delZ,
                            xmom_L_TEMP,
                            uvel_FC,        vvel_FC,        wvel_FC, 
                             r_out_x,        r_out_y,        r_out_z,
                            outflux_vol, influx_counter, influx_vol,
                            advct_xmom_CC,  m); 
            <FONT COLOR="570BA3">/*-------y-momentum------*/</FONT>
             <A href="#advect_q">advect_q</A>
                            xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                            delX,           delY,           delZ,
                            ymom_L_TEMP,
                            uvel_FC,        vvel_FC,        wvel_FC,      
                            r_out_x,        r_out_y,        r_out_z,
                            outflux_vol, influx_counter, influx_vol,
                            advct_ymom_CC,  m);


        <FONT COLOR="570BA3">/*      advect_q(
                            xLoLimit,            yLoLimit,            zLoLimit,
                            xHiLimit,            yHiLimit,            zHiLimit,
                            delX,           delY,           delZ,
                            zmom_L_TEMP,
                            uvel_FC,        vvel_FC,        wvel_FC,    
                             r_out_x,        r_out_y,        r_out_z,
                            outflux_vol, influx_counter, influx_vol,
                            advct_zmom_CC,  m); */</FONT>    
        }
        
        <FONT COLOR="570BA3">/*______________________________________________________________________
        *       Need to straighten this out.
        *_______________________________________________________________________*/</FONT>
        
       sum_xmom_CC[m]     = 0.0;
        sum_ymom_CC[m]     = 0.0;
        sum_zmom_CC[m]     = 0.0;
        sum_int_eng_CC[m]  = 0.0;
        sum_mass_CC[m]     = 0.0;        
        
        
        
        
        for(wall = wallLo; wall &lt;= wallHi; wall ++)
        {
           <FONT COLOR="570BA3">/*__________________________________
           * Defined the looping indices for each
           *   edge
           *___________________________________*/</FONT>
           if( wall == LEFT )   <FONT COLOR="570BA3">/* includes upper and lower corner cells        */</FONT> 
           {
                xLo = xLoLimit;     xHi = xLoLimit;
                yLo = yLoLimit;     yHi = yHiLimit; 
                zLo = zLoLimit;     zHi = zHiLimit;
            }
           if( wall == RIGHT )  <FONT COLOR="570BA3">/* includes upper and lower corner cells        */</FONT>
           {
                xLo = xHiLimit;     xHi = xHiLimit;
                yLo = yLoLimit;     yHi = yHiLimit; 
                zLo = zLoLimit;     zHi = zHiLimit;
            }
           if( wall == TOP )    <FONT COLOR="570BA3">/* left and right corner cells NOT included     */</FONT>
           {
                xLo = xLoLimit + 1; xHi = xHiLimit - 1;
                yLo = yHiLimit;     yHi = yHiLimit; 
                zLo = zLoLimit;     zHi = zHiLimit;
            }
           if( wall == BOTTOM )<FONT COLOR="570BA3">/* left and right corner cells NOT included     */</FONT> 
           {
                xLo = xLoLimit + 1; xHi = xHiLimit - 1;
                yLo = yLoLimit;     yHi = yLoLimit; 
                zLo = zLoLimit;     zHi = zHiLimit;
            }
           if( wall == FRONT ) 
           {
         <FONT COLOR="570BA3">/*     xLo = xLoLimit + N_GHOSTCELLS; xHi = xHiLimit - N_GHOSTCELLS;
                yLo = yLoLimit + N_GHOSTCELLS; yHi = yHiLimit - N_GHOSTCELLS; 
                zLo = zLoLimit;     zHi = zLoLimit; */</FONT>
            }
           if( wall == BACK ) 
           {
        <FONT COLOR="570BA3">/*      xLo = xLoLimit + N_GHOSTCELLS; xHi = xHiLimit - N_GHOSTCELLS;
                yLo = yLoLimit + N_GHOSTCELLS; yHi = yHiLimit - N_GHOSTCELLS; 
                zLo = zHiLimit;     zHi = zHiLimit; */</FONT>
            }                            
            sum_advct_xmom      = 0.0;
            sum_advct_ymom      = 0.0;
            sum_advct_zmom      = 0.0;
            sum_advct_int_eng   = 0.0;
            sum_advct_rho       = 0.0;
            <FONT COLOR="570BA3">/*__________________________________
            * Now sum the various contributions
            *___________________________________*/</FONT>
            for ( i = xLo; i &lt;= xHi; i++)
            {
                for ( j = yLo; j &lt;= yHi; j++)
                {
                    for ( k = zLo; k &lt;= zHi; k++)
                    {            
                        assert ( Vol_CC[i][j][k] &gt;0.0);
                        <FONT COLOR="570BA3">/*__________________________________
                        * x, y, z components of momentum
                        *___________________________________*/</FONT>
                        sum_advct_xmom      = sum_advct_xmom    + advct_xmom_CC[i][j][k][m];
                        sum_advct_ymom      = sum_advct_ymom    + advct_ymom_CC[i][j][k][m];
                        sum_advct_xmom      = sum_advct_zmom    + advct_zmom_CC[i][j][k][m];
                        <FONT COLOR="570BA3">/*__________________________________
                        *   Internal energy
                        *___________________________________*/</FONT>
                        sum_advct_int_eng   = sum_advct_int_eng + advct_int_eng_CC[i][j][k][m];
                        <FONT COLOR="570BA3">/*__________________________________
                        *  Mass
                        *___________________________________*/</FONT>
                        sum_advct_rho       = sum_advct_rho     + advct_rho_CC[i][j][k][m];
                    }
                }
            }
        }       <FONT COLOR="570BA3">/* wall loop    */</FONT>   
        <FONT COLOR="570BA3">/*__________________________________
        * Sum up the lagrangian contributions
        * on the interior of the domain
        *___________________________________*/</FONT>    
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {                      
                    sum_xmom_L_CC[m] = sum_xmom_L_CC[m] + xmom_L_CC[i][j][k][m];
                    sum_ymom_L_CC[m] = sum_ymom_L_CC[m] + ymom_L_CC[i][j][k][m];
                    sum_zmom_L_CC[m] = sum_zmom_L_CC[m] + zmom_L_CC[i][j][k][m];  
                }
            }
        }        
        
    }           <FONT COLOR="570BA3">/* material loop*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Output info here.
*_______________________________________________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    {   fprintf(stderr,"Material: \t %i\n",m);
        fprintf(stderr,"sum_xmom_CC \t %f  \t sum_ymom_CC \t %f \t sum_zmom_CC \t %f \n",sum_xmom_CC[m], sum_ymom_CC[m], sum_zmom_CC[m]);
        fprintf(stderr,"sum_int_eng_CC \t %f\n",sum_int_eng_CC[m]);
        fprintf(stderr,"sum_mass_CC \t %f\n",sum_mass_CC[m]);

    }
<FONT COLOR="570BA3">/*__________________________________
* Free local memory
*___________________________________*/</FONT>
   free_dvector( sum_xmom_CC,       1, N_MATERIAL);
   free_dvector( sum_ymom_CC,       1, N_MATERIAL);
   free_dvector( sum_zmom_CC,       1, N_MATERIAL);
   free_dvector( sum_int_eng_CC,    1, N_MATERIAL);
   free_dvector( sum_mass_CC,       1, N_MATERIAL);
   
   free_darray_4d( advct_xmom_CC,   0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( advct_ymom_CC,   0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( advct_zmom_CC,   0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( mass_L_TEMP,     0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( xmom_L_TEMP,     0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( ymom_L_TEMP,     0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( zmom_L_TEMP,     0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( int_eng_L_TEMP,  0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);

   free_darray_4d( advct_rho_CC,    0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
   free_darray_4d( advct_int_eng_CC,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);
  
   free_darray_4d( r_out_x,         0, X_MAX_LIM, 0,    Y_MAX_LIM,  0,  Z_MAX_LIM,  1, N_CELL_FACES);
   free_darray_4d( r_out_y,         0, X_MAX_LIM, 0,    Y_MAX_LIM,  0,  Z_MAX_LIM,  1, N_CELL_FACES);
   free_darray_4d( r_out_z,         0, X_MAX_LIM, 0,    Y_MAX_LIM,  0,  Z_MAX_LIM,  1, N_CELL_FACES);
   free_darray_4d( outflux_vol,     0, X_MAX_LIM, 0,    Y_MAX_LIM,  0,  Z_MAX_LIM,  1, N_CELL_FACES);
   free_darray_4d( influx_vol,     -1, X_MAX_LIM+1,-1, Y_MAX_LIM+1,-1, Z_MAX_LIM+1,    1, N_CELL_FACES);
   
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(Vol_L_CC[0][0][0][1]); 
    rho_L_CC = rho_L_CC; 
    QUITE_FULLWARN(xmom_CC[0][0][0][1]);
    QUITE_FULLWARN(ymom_CC[0][0][0][1]);
    QUITE_FULLWARN(zmom_CC[0][0][0][1]);    
    QUITE_FULLWARN(rho_CC[0][0][0][1]);
    QUITE_FULLWARN(int_eng_CC[0][0][0][1]);

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="gradient_limiter">gradient_limiter</A>  ADVECTION: Step 6.?, Compute (alpha) the gradient limiter used when computing second order derivatives.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_grad_limiter.c
 Filename: advect_grad_limiter.c
 Purpose:
   This routine calculates the coefficient (alpha) used in the calculation of the 
   gradients of q used in the advection operator
   
 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden 
    and B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) 
    and  Uintah-ICE CFD Multidimensional Compatible Advection Operator


Computational Domain:  
    The gradient limiter is calculated for each cell in the
    computational domain, and it lives at the cell center.  Dat from each of the 
    vertices is needed, step 1.
    
Ghostcell data dependency:
    The value of q is need in the ghost cell layer to compute the max and min value
    of q from the surrounding cells, step 3.
            
 Steps for each cell:
 --------------------     
    1)  Find the max and min of vertex data q for every cell.
    2)  Find the max and min of the surrounding cell-centered data q
    3)  Calculate the max. and min. of the gradient limiter
        and finally compute the actual gradient limiter for cell (i,j,k) 


 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/17/99    

 
Vertex Notation 
 
                   4 ______________  3
                    /|            /|
                   / |           / |
                7 /__|__________/ 8|
                 |   |          |  |
                 |   |          |  |
                 | 1 |__________|__| 2
                 |  /           |  /
                 | /            | /
                 |/_____________|/
                5                 6
     y
      |
      |___ x
     /
    z
 
 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#gradient_limiter">gradient_limiter</A>    
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* Cell width                       */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* q-cell-centered                  (INPUT) */</FONT>
        double  ***grad_limiter,        <FONT COLOR="570BA3">/* gradient limiter(i,j,k)          (OUPUT) */</FONT>
        int     m           )           <FONT COLOR="570BA3">/* material                         */</FONT>
  
{
    int         i, j, k,                <FONT COLOR="570BA3">/* cell face locators               */</FONT>
                xLo, xHi,
                yLo, yHi,
                zLo, zHi;      
           
    double      temp,                   <FONT COLOR="570BA3">/* temporary variable               */</FONT>
                frac,                   <FONT COLOR="570BA3">/* fraction                         */</FONT>
                alf,
                alf1,
                alf2,
                grad_lim_max,           <FONT COLOR="570BA3">/* max. gradient limiter for ijk    */</FONT>
                grad_lim_min,           <FONT COLOR="570BA3">/* min. gradient limiter for ijk    */</FONT>
                q_CC_ijk,               <FONT COLOR="570BA3">/* abrevation for q_CC[i][j][k][m]  */</FONT>
                ***q_VRTX_MAX,          <FONT COLOR="570BA3">/* max value of q at the vertices   */</FONT>
                ***q_VRTX_MIN,          <FONT COLOR="570BA3">/* max value of q at the vertices   */</FONT>
                ***q_CC_max,            <FONT COLOR="570BA3">/* max value of q in the surrounding cells   */</FONT>
                ***q_CC_min;            <FONT COLOR="570BA3">/* min value of q in the surrounding cells   */</FONT>

<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_Advect_gradient_limiter 
    #include "plot_declare_vars.h"
    double
            ***test,                    <FONT COLOR="570BA3">/* testing array                    */</FONT>       
            ***test2;                   <FONT COLOR="570BA3">/* testing array                    */</FONT>    
        test        = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);    
        test2       = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM); 
#endif      
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Allocate some local memory and zero the arrays
*_______________________________________________________________________*/</FONT>
    q_VRTX_MAX  = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    q_VRTX_MIN  = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    q_CC_min    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    q_CC_max    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);  
    <A href="#zero_arrays_3d">zero_arrays_3d</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,
                        4,
                        q_VRTX_MAX,     q_VRTX_MIN,     q_CC_min,
                        q_CC_max);     
      
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM); 
    
<FONT COLOR="570BA3">/*START_DOC*/</FONT> 
<FONT COLOR="570BA3">/*______________________________________________________________________
*
*_______________________________________________________________________*/</FONT>
  
<FONT COLOR="570BA3">/*__________________________________
* step 1 find the max and min of 
* vertex data q for the computational
* domain and one layer of ghost cells
*___________________________________*/</FONT>
    <A href="#find_q_vertex_max_min">find_q_vertex_max_min</A>    
                    xLoLimit,       yLoLimit,       zLoLimit,
                    xHiLimit,       yHiLimit,       zHiLimit,
                    delX,           delY,           delZ,
                    q_CC,           q_VRTX_MAX,     q_VRTX_MIN,
                            m);
                            
<FONT COLOR="570BA3">/*__________________________________
* step 2 max and min of the surrounding
* cell-centered data q for all of the cells
* in the computational domain and one
* layer of ghost cells
*___________________________________*/</FONT> 
    <A href="#find_q_CC_max_min">find_q_CC_max_min</A>    
                    xLoLimit,       yLoLimit,       zLoLimit,
                    xHiLimit,       yHiLimit,       zHiLimit,
                    q_CC,           q_CC_max,       q_CC_min,
                            m);  
                            
<FONT COLOR="570BA3">/*__________________________________
* step 3 calculate the max and min.
* gradient limiter and finally
* that actual gradient limiter for cell
* i,j,k
*___________________________________*/</FONT>                            
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);                            
                                 
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 


 
#if (LIMIT_GRADIENT_FLAG == 0)        
                grad_limiter[i][j][k] = 1.0;  
#endif
            
            
#if(LIMIT_GRADIENT_FLAG == 1)         
                q_CC_ijk =  q_CC[i][j][k][m];
                frac     = (q_CC_max[i][j][k]   - q_CC_ijk + SMALL_NUM)/
                           (q_VRTX_MAX[i][j][k] - q_CC_ijk + SMALL_NUM);
                grad_lim_max = DMAX(0.0, frac); 

                frac     = (q_CC_min[i][j][k]   - q_CC_ijk + SMALL_NUM)/
                           (q_VRTX_MIN[i][j][k] - q_CC_ijk + SMALL_NUM);
                grad_lim_min = DMAX(0.0, frac);

                temp = DMIN(1.0, grad_lim_max);
                temp = DMIN(temp,grad_lim_min);
                grad_limiter[i][j][k] = temp; 
                <FONT COLOR="570BA3">/*__________________________________
                *   DEBUGGINGS
                *___________________________________*/</FONT>
#if switchDebug_Advect_gradient_limiter
                test[i][j][k]   =  grad_limiter[i][j][k];
#endif 
#endif
            <FONT COLOR="570BA3">/*__________________________________
            * CFDLIB limiter
            *___________________________________*/</FONT>
#if(LIMIT_GRADIENT_FLAG == 2)
                q_CC_ijk=  q_CC[i][j][k][m];
                frac    = DMAX( SMALL_NUM, (q_VRTX_MAX[i][j][k] - q_CC_ijk) );
                alf1    = ( q_CC_max[i][j][k] - DMIN( q_CC_ijk, q_CC_max[i][j][k]) )/frac;
                
                
                frac    = DMAX( SMALL_NUM, (q_CC_ijk - q_VRTX_MIN[i][j][k]) );
                alf2    = ( DMAX( q_CC_ijk, q_CC_min[i][j][k] ) - q_CC_min[i][j][k])/frac;
 
                alf      = DMIN( 1.0, alf1);
                alf      = DMIN( alf, alf2 );
                grad_limiter[i][j][k]  = DMAX( 0.0, alf ); 
                
                <FONT COLOR="570BA3">/*__________________________________
                *   DEBUGGINGS
                *___________________________________*/</FONT>
#if switchDebug_Advect_gradient_limiter
                test[i][j][k]   =  grad_limiter[i][j][k];
#endif
                <FONT COLOR="570BA3">/*__________________________________
                *
                *___________________________________*/</FONT>
#endif                        
            }
        }
    }
<PRE>
<A HREF="#topofpage">back to the top</A>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_q_CC_max_min">find_q_CC_max_min</A>  ADVECTION: Step 6.?, Compute the max and min. calculates the max and min value of q_CC from the four surrounding cells. </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_grad_limiter.c
 Filename: advect_grad_limiter.c
 
 Purpose:
   This routine calculates the max and min value of q_CC from the four
   surrounding cells.   

            
 Steps for each cell:
 --------------------
 1) Double check the inputs and determine what walls of the computaional
 domain should be included in the calculation.
 2) Compute q_cc_max and q_cc_min for all cells inside of the computational
 domain.
 3) Calculate q_CC_max and q_CC_man in a single ghostcell layer surrounding
 the computational domain
 4) Now compute the corner ghostcells    
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       11/17/99    

 ---------------------------------------------------------------------  */</FONT>
void <A href="#find_q_CC_max_min">find_q_CC_max_min</A>    
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* cell center data                 (INPUT) */</FONT>
        double  ***q_CC_max,            <FONT COLOR="570BA3">/* max. value of q_CC               (OUTPUT)*/</FONT>
        double  ***q_CC_min,            <FONT COLOR="570BA3">/* min. value of q_CC               (OUTPUT)*/</FONT>
        int     m                )      <FONT COLOR="570BA3">/* material                         */</FONT>
  
{
        int     i, j, k,                <FONT COLOR="570BA3">/* cell indices                     */</FONT>
                wall,                   <FONT COLOR="570BA3">/* wall indices                     */</FONT>
                wallLo, wallHi, 
                xLo, xHi,
                yLo, yHi,
                zLo, zHi;
           
        double
                q_CC_max_temp,          <FONT COLOR="570BA3">/* q_CC max and min temp           */</FONT>
                q_CC_min_temp;
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_find_q_CC_max_min
    #include plot_declare_vars.h"   
#endif     
<FONT COLOR="570BA3">/*__________________________________
*   Step 1)
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert ( m &lt;= N_MATERIAL); 
<FONT COLOR="570BA3">/*__________________________________
*  Determine what walls are used in the 
*   computational domain.
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif    
       
<FONT COLOR="570BA3">/*START_DOC*/</FONT>  
<FONT COLOR="570BA3">/*______________________________________________________________________
* step 2)  Find the max and min in the interior
    ---------------------------------------------
    |   |   |   |   |   |   |   |   |   |   |   |   -- top_GC       
    ---------------------------------------------                   
    |   | + | + | + | + | + | + | + | + | + |   |   -- yHiLimit     
    ---------------------------------------------                   
    |   | + | + | + | + | + | o | + | + | + |   |                   
    ---------------------------------------------                   
    |   | + | + | + | + | o | X | o | + | + |   |                   
    ---------------------------------------------                    
    |   | + | + | + | + | + | o | + | + | + |   |   -- yLoLimit     
    ---------------------------------------------                   
    |   |   |   |   |   |   |   |   |   |   |   |   -- bottom_GC    
    ---------------------------------------------                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC                                                                                
      x = q_CC_max and q_CC_min
      o = data needed: q_CC  
*_______________________________________________________________________*/</FONT>
    xLo = (xLoLimit);
    xHi = (xHiLimit);
    yLo = (yLoLimit);
    yHi = (yHiLimit);
    zLo = (zLoLimit);
    zHi = (zHiLimit);
                                  
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
                q_CC_max_temp       =  DMAX(q_CC[i+1][j][k][m], q_CC[i-1][j][k][m]);
                q_CC_max_temp       =  DMAX(q_CC[i][j+1][k][m], q_CC_max_temp);         <FONT COLOR="570BA3">/* top  */</FONT>
                q_CC_max_temp       =  DMAX(q_CC[i][j-1][k][m], q_CC_max_temp);         <FONT COLOR="570BA3">/*bottom*/</FONT>
                <FONT COLOR="570BA3">/* q_CC_max_temp    =  DMAX(q_CC[i][j][k+1][m], q_CC_max_temp); */</FONT>      <FONT COLOR="570BA3">/*front */</FONT>
                <FONT COLOR="570BA3">/* q_CC_max_temp    =  DMAX(q_CC[i][j][k-1][m], q_CC_max_temp); */</FONT>      <FONT COLOR="570BA3">/* back */</FONT>
                q_CC_max[i][j][k]   = q_CC_max_temp;
                
                q_CC_min_temp       =  DMIN(q_CC[i+1][j][k][m], q_CC[i-1][j][k][m]);
                q_CC_min_temp       =  DMIN(q_CC[i][j+1][k][m], q_CC_min_temp);         <FONT COLOR="570BA3">/* top  */</FONT>
                q_CC_min_temp       =  DMIN(q_CC[i][j-1][k][m], q_CC_min_temp);          <FONT COLOR="570BA3">/*bottom*/</FONT>
                <FONT COLOR="570BA3">/* q_CC_min_temp    =  DMIN(q_CC[i][j][k+1][m], q_CC_min_temp); */</FONT>      <FONT COLOR="570BA3">/*front */</FONT>
                <FONT COLOR="570BA3">/* q_CC_min_temp    =  DMIN(q_CC[i][j][k-1][m], q_CC_min_temp); */</FONT>      <FONT COLOR="570BA3">/* back */</FONT>
                q_CC_min[i][j][k]   = q_CC_min_temp;
       
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 3)
*   Find q_CC_max and q_CC_min in the single layer of ghost cells  This only 
*   looks at the three nearest  neighbors
*
    _____________________________________________
    | o |   |   |   |   |   |   |   | o | x | o |   -- top_GC       
    ---------------------------------------------                   
    | x | o | + | + | + | + | + | + | + | o |   |   -- yHiLimit     
    ---------------------------------------------                   
    | o | + | + | + | + | + | + | + | + | + |   |                   
    ---------------------------------------------                   
    |   | + | + | + | + | + | + | + | + | + | o |                   
    ---------------------------------------------                    
    |   | o | + | + | + | + | + | + | + | o | x |   -- yLoLimit     
    ---------------------------------------------                   
    | o | x | o |   |   |   |   |   |   |   | o |   -- bottom_GC    
    ---------------------------------------------                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC
      
      x = q_CC_min and q_CC_max
      o = data needed: q_CC 
*_______________________________________________________________________*/</FONT>
    for( wall = wallLo; wall &lt;= wallHi; wall ++)
    {
        <FONT COLOR="570BA3">/*__________________________________
        *  Find the looping indices associated
        *   with a particular wall
        *___________________________________*/</FONT>
         <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>                
                    xLoLimit,                  yLoLimit,                   zLoLimit,
                    xHiLimit,                  yHiLimit,                   zHiLimit,
                    &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                    &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                    wall    );
    
        for ( i = xLo; i &lt;= xHi; i++ )
        {
            for ( j = yLo; j &lt;= yHi; j++ )
            { 
                for ( k = zLo; k &lt;= zHi; k++ )
                {        
                
                   if ( wall == LEFT )
                   {
                       q_CC_max_temp        =  DMAX(q_CC[i][j+1][k][m], q_CC[i][j-1][k][m]);      
                       q_CC_max_temp        =  DMAX(q_CC[i+1][j][k][m], q_CC_max_temp);           
                       q_CC_max[i][j][k]    = q_CC_max_temp;

                       q_CC_min_temp        =  DMIN(q_CC[i][j+1][k][m], q_CC[i][j-1][k][m]);
                       q_CC_min_temp        =  DMIN(q_CC[i][i+1][k][m], q_CC_min_temp);
                       q_CC_min[i][j][k]    = q_CC_min_temp;          
                  }
                                
                   if ( wall == RIGHT )
                   {
                       q_CC_max_temp        =  DMAX(q_CC[i][j+1][k][m], q_CC[i][j-1][k][m]);      
                       q_CC_max_temp        =  DMAX(q_CC[i-1][j][k][m], q_CC_max_temp);           
                       q_CC_max[i][j][k]    = q_CC_max_temp;

                       q_CC_min_temp        =  DMIN(q_CC[i][j+1][k][m], q_CC[i][j-1][k][m]);
                       q_CC_min_temp        =  DMIN(q_CC[i-1][j][k][m], q_CC_min_temp);
                       q_CC_min[i][j][k]    = q_CC_min_temp;                   
                   
                     }
                   if ( wall == TOP )
                   {
                       q_CC_max_temp        =  DMAX(q_CC[i+1][j][k][m], q_CC[i-1][j][k][m]);      
                       q_CC_max_temp        =  DMAX(q_CC[i][j-1][k][m], q_CC_max_temp);           
                       q_CC_max[i][j][k]    = q_CC_max_temp;

                       q_CC_min_temp        =  DMIN(q_CC[i+1][j][k][m], q_CC[i-1][j][k][m]);
                       q_CC_min_temp        =  DMIN(q_CC[i][j-1][k][m], q_CC_min_temp);
                       q_CC_min[i][j][k]    = q_CC_min_temp;                    
                   
                     }
                    if ( wall == BOTTOM )
                   {
                       q_CC_max_temp        =  DMAX(q_CC[i+1][j][k][m], q_CC[i-1][j][k][m]);      
                       q_CC_max_temp        =  DMAX(q_CC[i][j+1][k][m], q_CC_max_temp);           
                       q_CC_max[i][j][k]    = q_CC_max_temp;

                       q_CC_min_temp        =  DMIN(q_CC[i+1][j][k][m], q_CC[i-1][j][k][m]);
                       q_CC_min_temp        =  DMIN(q_CC[i][j+1][k][m], q_CC_min_temp);
                       q_CC_min[i][j][k]    = q_CC_min_temp;
                   }

                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 4)
*   Find q_CC_max and q_CC_min in the corner ghostcells  This only 
*   looks at the three nearest neighbors.

    ---------------------------------------------
    | x | o |   |   |   |   |   |   |   | o | x |   -- top_GC       
    ---------------------------------------------                  
    | o | o | + | + | + | + | + | + | + | o | o |   -- yHiLimit     
    ---------------------------------------------                   
    |   | + | + | + | + | + | + | + | + | + |   |                   
    ---------------------------------------------                   
    |   | + | + | + | + | + | + | + | + | + |   |                   
    ---------------------------------------------                    
    | o | o | + | + | + | + | + | + | + | o | o |   -- yLoLimit     
    ---------------------------------------------                   
    | x | o |   |   |   |   |   |   |   | o | x |   -- bottom_GC    
    ---------------------------------------------                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC

      x = q_CC_max, q_CC_min.
      o = data needed: q_CC 
*_______________________________________________________________________*/</FONT>
<FONT COLOR="570BA3">/*   Upper Left ghostcell corner 
*___________________________________*/</FONT>
    i = GC_LO(xLoLimit);
    j = GC_HI(yHiLimit);
    k = zLoLimit;
    q_CC_max_temp       =  DMAX(q_CC[i][j-1][k][m], q_CC[i+1][j-1][k][m]);      
    q_CC_max_temp       =  DMAX(q_CC[i+1][j][k][m], q_CC_max_temp);           
    q_CC_max[i][j][k]   = q_CC_max_temp;

    q_CC_min_temp       =  DMIN(q_CC[i][j-1][k][m], q_CC[i+1][j-1][k][m]);
    q_CC_min_temp       =  DMIN(q_CC[i+1][j][k][m], q_CC_min_temp);
    q_CC_min[i][j][k]   = q_CC_min_temp;    

<FONT COLOR="570BA3">/*__________________________________
*   Upper right ghostcell corner
*___________________________________*/</FONT>
    i = GC_HI(xHiLimit);
    j = GC_HI(yHiLimit);
    k = zLoLimit;
    q_CC_max_temp       =  DMAX(q_CC[i][j-1][k][m], q_CC[i-1][j-1][k][m]);      
    q_CC_max_temp       =  DMAX(q_CC[i-1][j][k][m], q_CC_max_temp);           
    q_CC_max[i][j][k]   = q_CC_max_temp;

    q_CC_min_temp       =  DMIN(q_CC[i][j-1][k][m], q_CC[i-1][j-1][k][m]);
    q_CC_min_temp       =  DMIN(q_CC[i-1][j][k][m], q_CC_min_temp);
    q_CC_min[i][j][k]   = q_CC_min_temp;    

<FONT COLOR="570BA3">/*__________________________________
*   Lower right ghostcell corner
*___________________________________*/</FONT>
    i = GC_HI(xHiLimit);
    j = GC_LO(yLoLimit);
    k = zLoLimit;
    q_CC_max_temp       =  DMAX(q_CC[i][j+1][k][m], q_CC[i-1][j+1][k][m]);      
    q_CC_max_temp       =  DMAX(q_CC[i-1][j][k][m], q_CC_max_temp);           
    q_CC_max[i][j][k]   = q_CC_max_temp;

    q_CC_min_temp       =  DMIN(q_CC[i][j+1][k][m], q_CC[i-1][j+1][k][m]);
    q_CC_min_temp       =  DMIN(q_CC[i-1][j][k][m], q_CC_min_temp);
    q_CC_min[i][j][k]   = q_CC_min_temp;

<FONT COLOR="570BA3">/*__________________________________
*   Lower left ghostcell corner
*___________________________________*/</FONT>
    i = GC_LO(xLoLimit);
    j = GC_LO(yLoLimit);
    k = zLoLimit;
    q_CC_max_temp       =  DMAX(q_CC[i][j+1][k][m], q_CC[i+1][j+1][k][m]);      
    q_CC_max_temp       =  DMAX(q_CC[i+1][j][k][m], q_CC_max_temp);           
    q_CC_max[i][j][k]   = q_CC_max_temp;

    q_CC_min_temp       =  DMIN(q_CC[i][j+1][k][m], q_CC[i+1][j+1][k][m]);
    q_CC_min_temp       =  DMIN(q_CC[i+1][j][k][m], q_CC_min_temp);
    q_CC_min[i][j][k]   = q_CC_min_temp;   
<PRE>
<A HREF="#topofpage">back to the top</A>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="outflow_vol_centroid">outflow_vol_centroid</A>  ADVECTION: Step 6.?, calculates the x, y, and z centroid components of each outflow flux of volume. </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_centroid.c
 Filename: advect_centroid.c
 Purpose:
 --------------------
   This routine calculates the x, y, and z centroid components of each outflow flux of volume,  
   both the slabs and the corner fluxes.
   
 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) 
       
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/17/99    

Notation in 2D

                       
   ______________________          ______________________  _
   |   |             |  |          |   |             |  |  |  delY_top
   | + |      +      | +|          | + |      +      | +|  |
   |---|----------------|  --ytop  |---|----------------|  -
   |   |             |  |          |   |             |  |
   | + |     i,j,k   | +|          | + |     i,j,k   | +|
   |   |             |  |          |   |             |  |
   |---|----------------|  --y0    |---|----------------|  -
   | + |      +      | +|          | + |      +      | +|  | delY_bottom
   ----------------------          ----------------------  -
       |             |             |---|             |--|
       x0            xright          delX_left         delX_right
     
     
                          r_out_*(TOP)
                    ______________________
                    |   |             |  |
  r_out_*_CF(TOP_L) | + |      +      | +| r_out_*_CF(TOP_R)
                    |---|----------------|
                    |   |             |  |
  r_out_*(LEFT)     | + |     i,j,k   | +| r_out_*(RIGHT)
                    |   |             |  |
                    |---|----------------|
 r_out_*_CF(BOT_L)  | + |      +      | +| r_out_*_CF(BOT_R)
                    ----------------------
                         r_out_*(BOTTOM)
 ---------------------------------------------------------------------  */</FONT>
void <A href="#outflow_vol_centroid">outflow_vol_centroid</A>    
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* cell dimensions                  (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/*                                  (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/*                                  (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* time increment sec.              (INPUT) */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* u-face-centered velocity         (INPUT) */</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/* v-face-centered velocity         (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* w-face-centered velocity         (INPUT) */</FONT>
        double  ****r_out_x,            <FONT COLOR="570BA3">/* x-dir centroid array             (OUPUT) */</FONT>
        double  ****r_out_y,            <FONT COLOR="570BA3">/* y-dir centroid array             (OUPUT) */</FONT>
        double  ****r_out_z,            <FONT COLOR="570BA3">/* z-dir centroid array             (OUPUT) */</FONT>
        double  ****r_out_x_CF,         <FONT COLOR="570BA3">/* Corner Flux contributions        */</FONT>
        double  ****r_out_y_CF,         <FONT COLOR="570BA3">/* ----------//------------         */</FONT>
        double  ****r_out_z_CF,         <FONT COLOR="570BA3">/* ----------//------------         */</FONT>
        int     m )                     <FONT COLOR="570BA3">/* material                         (OUPUT) */</FONT>

{
    int     i, j, k,                     <FONT COLOR="570BA3">/* cell indices                     */</FONT>
            xLo, xHi,
            yLo, yHi,
            zLo, zHi;           
    double 
            delY_top,                   <FONT COLOR="570BA3">/* lengh of corner flux cells       */</FONT>
            delY_bottom,
            delX_right,
            delX_left,
            y0, ytop,                    <FONT COLOR="570BA3">/* coordinates of the slabs         */</FONT>
            x0, xright,
            r_y,                        <FONT COLOR="570BA3">/* centroids in the x and y dir     */</FONT>
            r_x,
            rx_TOP_R, 
            rx_TOP_L, 
            ry_TOP_R, 
            rx_BOT_R,
            ry_BOT_R;          
     
<FONT COLOR="570BA3">/*_________________
* double check inputs
*__________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);

<FONT COLOR="570BA3">/*START_DOC*/</FONT>  
    
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
                                       
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
                <FONT COLOR="570BA3">/*__________________________________
                *   Find the length of each side of 
                *   a corner flux volume
                *___________________________________*/</FONT>
                delY_top    = MAX(0.0, *vvel_FC[i][j][k][TOP][m]     * delt );
                delY_bottom = MAX(0.0,-*vvel_FC[i][j][k][BOTTOM][m]  * delt );
                delX_right  = MAX(0.0, *uvel_FC[i][j][k][RIGHT][m]   * delt );
                delX_left   = MAX(0.0,-*uvel_FC[i][j][k][LEFT][m]    * delt );
                
                <FONT COLOR="570BA3">/*__________________________________
                * x and y coordinates of the slabs
                *___________________________________*/</FONT>
                y0          = delY_bottom;
                ytop        = delY - delY_top;
                x0          = delX_left;
                xright      = delX - delX_right;     
                   
                <FONT COLOR="570BA3">/*__________________________________
                *   For each slab
                *___________________________________*/</FONT>
                r_y         = (ytop - y0)/2.0 + y0 - delY/2.0;
                r_out_x[i][j][k][RIGHT]      =  delX/2.0        - delX_right/2.0;
                r_out_y[i][j][k][RIGHT]      =  r_y;
                r_out_z[i][j][k][RIGHT]      =  0.0;

                r_out_x[i][j][k][LEFT]       =   delX_left/2.0   - delX/2.0;
                r_out_y[i][j][k][LEFT]       =   r_y;
                r_out_z[i][j][k][LEFT]       =   0.0;

                r_x         = (xright - x0)/2.0 + x0 - delX/2.0;
                r_out_x[i][j][k][TOP]        =   r_x;
                r_out_y[i][j][k][TOP]        =   delY/2.0        - delY_top/2.0;
                r_out_z[i][j][k][TOP]        =   0.0;
                
                r_out_x[i][j][k][BOTTOM]     =   r_x;
                r_out_y[i][j][k][BOTTOM]     =   delY_bottom/2.0 - delY/2.0;
                r_out_z[i][j][k][BOTTOM]     =   0.0;                

                <FONT COLOR="570BA3">/*__________________________________
                *   Compute the centroid of each outflux
                *   corner flux
                *___________________________________*/</FONT>
                rx_TOP_R = delX/2.0          - delX_right/2.0;
                rx_TOP_L = delX_left/2.0     - delX/2.0;
                ry_TOP_R = delY/2.0          - delY_top/2.0;
                ry_BOT_R = delY_bottom/2.0   - delY/2.0;     

                r_out_x_CF[i][j][k][TOP_R]    =   rx_TOP_R;
                r_out_y_CF[i][j][k][TOP_R]    =   ry_TOP_R;
                r_out_z_CF[i][j][k][TOP_R]    =   0.0;

                r_out_x_CF[i][j][k][TOP_L]    =   rx_TOP_L;
                r_out_y_CF[i][j][k][TOP_L]    =   ry_TOP_R;
                r_out_z_CF[i][j][k][TOP_L]    =   0.0;

                r_out_x_CF[i][j][k][BOT_R]    =   rx_TOP_R;
                r_out_y_CF[i][j][k][BOT_R]    =   ry_BOT_R;
                r_out_z_CF[i][j][k][BOT_R]    =   0.0;

                r_out_x_CF[i][j][k][BOT_L]    =   rx_TOP_L;
                r_out_y_CF[i][j][k][BOT_L]    =   rx_BOT_R;
                r_out_z_CF[i][j][k][BOT_L]    =   0.0;
            }
        }
    }

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(wvel_FC[1][1][1][1][1]);
    QUITE_FULLWARN(delZ);               
    QUITE_FULLWARN(r_out_z[1][1][1][1]);
    QUITE_FULLWARN(r_out_z_CF[1][1][1][1]);
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="advect_preprocess">advect_preprocess</A>  Advection:Steps 6.? and 6.?, Compute influx and outflux of volume for each cell.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q.c
 Filename: advect_q.c
 Purpose:   Calculate the influx, outflux of volume for each cell and the 
 outflux volume centroid.  Essentially, this function calculates stuff that
 only needs to be computed once but is used repeatedly in timeadvance.c
   
 References:
 --------------------
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) 
    and "Blueprint for the Uintah ICE-CFD code, Todd Harman
            
       
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       11/29/99  

 ---------------------------------------------------------------------  */</FONT>
void <A href="#advect_preprocess">advect_preprocess</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* cell dimensions                  (INPUT) */</FONT>
        double  delY,
        double  delZ,
        double  delt,                   <FONT COLOR="570BA3">/* time increment [sec]             (INPUT) */</FONT>
                <FONT COLOR="570BA3">/* pointers             *(*)vel_FC(x,y,z,face,material              */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* *u-face-centered velocity        (INPUT) */</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/* *v-face-centered velocity        (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* *w face-centered velocity        (INPUT) */</FONT>
        double  ****r_out_x,            <FONT COLOR="570BA3">/* x-dir centroid array (i,j,k,vol  (OUTPUT)*/</FONT> 
        double  ****r_out_y,            <FONT COLOR="570BA3">/* y-dir centroid array             (OUTPUT)*/</FONT>                   
        double  ****r_out_z,            <FONT COLOR="570BA3">/* z-dir centroid array             (OUTPUT)*/</FONT>                  
        double  ****r_out_x_CF,         <FONT COLOR="570BA3">/* Corner Flux Contributions        (OUTPUT)*/</FONT> 
        double  ****r_out_y_CF,         <FONT COLOR="570BA3">/*                                  (OUTPUT)*/</FONT>                   
        double  ****r_out_z_CF,         <FONT COLOR="570BA3">/*                                  (OUTPUT)*/</FONT>                  
        double  ****outflux_vol,        <FONT COLOR="570BA3">/* array containing the size of each(OUTPUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* of the outflux vols(i,j,k,vol)*/</FONT> 
        double  ****outflux_vol_CF,     <FONT COLOR="570BA3">/* corner flux contributions         */</FONT>
        double  ****influx_vol,         <FONT COLOR="570BA3">/* array containing the size of each(OUTPUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* of the influx volumes            */</FONT> 
        double  ****influx_vol_CF,      <FONT COLOR="570BA3">/* corner flux contributions        */</FONT>                                        
         int     m               )      <FONT COLOR="570BA3">/* material                         */</FONT>  
{
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_advect_preprocess
    int     i, j, k, in, out;
    double
        ***plot1,                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT>       
        ***plot2;                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT>
  #include "plot_declare_vars.h" 
  plot1       = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);    
  plot2       = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
#endif            
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>   
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
* Compute the influx, outflux vols and the outflux vol centroids.
*_______________________________________________________________________*/</FONT>
    <A href="#influx_outflux_volume">influx_outflux_volume</A>    
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        delt,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        influx_vol,     influx_vol_CF,
                        outflux_vol,    outflux_vol_CF,
                        m);

    <A href="#outflow_vol_centroid">outflow_vol_centroid</A>    
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        delt,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        m);
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Plotting stuff
*_______________________________________________________________________*/</FONT>
#if switchDebug_advect_preprocess
    #define switchInclude_advect_preprocess 1 
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            { 
                plot1[i][j][k]  = 0.0;
                plot2[i][j][k] = 0.0;
                for( out = TOP; out &lt;= LEFT; out++ )
                {
                    plot1[i][j][k]    = plot1[i][j][k] + outflux_vol[i][j][k][out];
                }
                
                for( in = TOP; in &lt;= LEFT; in++ )
                {
                    plot2[i][j][k]  = plot2[i][j][k] +influx_vol[i][j][k][in];
                }
            }
        }
    }

    #include "debugcode.i"
    free_darray_3d( plot1, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    free_darray_3d( plot2,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    
    #undef switchInclude_Advect_q 
#endif
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="advect_q">advect_q</A>  ADVECTION: Step 6, Main controller code for the advection operator.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q.c
 Filename: advect_q.c
 Purpose:   Calculate the advection of q_CC 
   
 References:
 --------------------
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) 
    and Uintah-ICE CFD Multidimensional Compatible Advection Operator, Todd Harman
            
 Steps for each cell:  
 --------------------    
1)  Compute the gradient limiter for 2nd order advection
2)  Compute q outflux and q influx for each cell.
3)  Finally sum the influx and outflux portions
       
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/17/99    

The function advect_preprocess MUST be called prior to this function
 ---------------------------------------------------------------------  */</FONT>
void <A href="#advect_q">advect_q</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* cell dimensions                  (INPUT) */</FONT>
        double  delY,
        double  delZ,
        double  ****q_CC,               <FONT COLOR="570BA3">/* q cell-center (i,j,k,m)          (INPUT) */</FONT>
        double  ****r_out_x,            <FONT COLOR="570BA3">/* x-dir centroid array (i,j,k,vol  (INPUT) */</FONT> 
        double  ****r_out_y,            <FONT COLOR="570BA3">/* y-dir centroid array             (INPUT) */</FONT>                   
        double  ****r_out_z,            <FONT COLOR="570BA3">/* z-dir centroid array             (INPUT) */</FONT> 
        double  ****r_out_x_CF,         <FONT COLOR="570BA3">/* corner flux centroids            (INPUT) */</FONT>
        double  ****r_out_y_CF,         <FONT COLOR="570BA3">/* -------//-------------                   */</FONT>
        double  ****r_out_z_CF,         <FONT COLOR="570BA3">/* -------//-------------                   */</FONT>           
        double  ****outflux_vol,        <FONT COLOR="570BA3">/* array containing the size of each(INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* of the outflux volumes(i,j,k,vol)*/</FONT> 
        double  ****outflux_vol_CF,     <FONT COLOR="570BA3">/* corner flux outflux volumes      (INPUT) */</FONT>     
        double  ****influx_vol,         <FONT COLOR="570BA3">/* array containing the size of each(INPUT) */</FONT>
        double  ****influx_vol_CF,      <FONT COLOR="570BA3">/* corner flux influx volumes       (INPUT) */</FONT>

        double  ****advect_q_CC,        <FONT COLOR="570BA3">/* advected q_CC (i,j,k,m)          (OUPUT) */</FONT>
         int     m               )      <FONT COLOR="570BA3">/* material                         */</FONT>  
{
    int     i, j, k,                    <FONT COLOR="570BA3">/* cell indices                     */</FONT>
            face, corner;               <FONT COLOR="570BA3">/* face and corner indices          */</FONT>

    double
            sum_q_outflux,              <FONT COLOR="570BA3">/* sum of the contributions of the  */</FONT>
                                        <FONT COLOR="570BA3">/* outflux of q                     */</FONT>
            sum_q_outflux_CF,           <FONT COLOR="570BA3">/* corner flux contributions        */</FONT>
            sum_q_influx,               <FONT COLOR="570BA3">/* sum of the contributions of the  */</FONT>
            sum_q_influx_CF,            <FONT COLOR="570BA3">/* corner flux contributions        */</FONT>
            ***grad_limiter,            <FONT COLOR="570BA3">/* limiter used to limit the gradient*/</FONT>
                                        <FONT COLOR="570BA3">/* in a compatible fashion(i,j,k,vol*/</FONT>
            ****q_influx,               <FONT COLOR="570BA3">/* influx of q for cell (i,j,k,vol) */</FONT>
            ****q_influx_CF,            <FONT COLOR="570BA3">/* corner flux contributions        */</FONT>
            ****q_outflux,              <FONT COLOR="570BA3">/* influx of q for cell (i,j,k,vol) */</FONT> 
            ****q_outflux_CF;           <FONT COLOR="570BA3">/* corner flux contributions        */</FONT>
            
    char    should_I_write_output;                     
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_Advect_q
    double
        ***plot1,                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT>       
        ***plot2,                       <FONT COLOR="570BA3">/* plot1ing array                    */</FONT>
        ***plot3;
    #include "plot_declare_vars.h" 
    plot1 = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);    
    plot2 = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
    plot3 = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
    #endif                                       
<FONT COLOR="570BA3">/* -----------------------------------------------------------------------  */</FONT>
<FONT COLOR="570BA3">/*  Allocate memory for the arrays                */</FONT>
<FONT COLOR="570BA3">/* -----------------------------------------------------------------------  */</FONT>
    grad_limiter    = darray_3d(0,  X_MAX_LIM,      0, Y_MAX_LIM,    0, Z_MAX_LIM);
    q_influx        = darray_4d(-1, X_MAX_LIM+1,   -1, Y_MAX_LIM+1, -1, Z_MAX_LIM, 1, N_CELL_FACES);
    q_influx_CF     = darray_4d(-1, X_MAX_LIM+1,   -1, Y_MAX_LIM+1, -1, Z_MAX_LIM, 1, N_CELL_VERTICES);
    q_outflux       = darray_4d(0,  X_MAX_LIM,      0, Y_MAX_LIM,    0, Z_MAX_LIM, 1, N_CELL_FACES);
    q_outflux_CF    = darray_4d(0,  X_MAX_LIM,      0, Y_MAX_LIM,    0, Z_MAX_LIM, 1, N_CELL_VERTICES);
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>   
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    
    if(xLoLimit &lt; 1 || yLoLimit &lt; 1 || zLoLimit &lt; 1)
    {
        <A href="#Message">Message</A>1,"ADVECTION:","The lower limits of the array must be = 1",
                "and there must be at least one layer of ghostcells");
    }   
<FONT COLOR="570BA3">/*___________________________________
* Step 1) Determine the gradient limiter, alpha
*____________________________________*/</FONT>
                        
    <A href="#gradient_limiter">gradient_limiter</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        q_CC,           grad_limiter,
                        m);
                              
<FONT COLOR="570BA3">/*__________________________________
*  Step 2) Determine the influx and 
*   outflux of q at each cell
*___________________________________*/</FONT>
                            
       <A href="#q_out_flux">q_out_flux</A>                                              
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        grad_limiter,                   
                        outflux_vol,    outflux_vol_CF,
                        r_out_x,        r_out_y,        r_out_z,
                        r_out_x_CF,     r_out_y_CF,     r_out_z_CF,
                        q_outflux,      q_outflux_CF,   q_CC,
                        m);
  
                               
        <A href="#q_in_flux">q_in_flux</A>                                              
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        q_influx,       q_influx_CF,
                        q_outflux,      q_outflux_CF,
                        m);
 
<FONT COLOR="570BA3">/*__________________________________
*  Step 3) Finally determine the 
* advection of q
*___________________________________*/</FONT>                            
                                  
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            { 
            
                <FONT COLOR="570BA3">/*__________________________________
                *  OUTFLUX: SLAB 
                *___________________________________*/</FONT>
                sum_q_outflux       = 0.0;
                sum_q_outflux_CF    = 0.0;
                sum_q_influx        = 0.0;
                sum_q_influx_CF     = 0.0;
                
          
                for( face = TOP; face &lt;= LEFT; face++ )
                {
                    sum_q_outflux   = sum_q_outflux + 
                                    q_outflux[i][j][k][face] * outflux_vol[i][j][k][face];
                }
                <FONT COLOR="570BA3">/*__________________________________
                *  OUTFLUX: CORNER FLUX
                *___________________________________*/</FONT>

                for (corner = TOP_R; corner &lt;= BOT_R; corner ++)
                {
                    sum_q_outflux_CF = sum_q_outflux_CF + 
                                    q_outflux_CF[i][j][k][corner]   * outflux_vol_CF[i][j][k][corner];
                }
                <FONT COLOR="570BA3">/*__________________________________
                *  INFLUX: INFLUX
                *___________________________________*/</FONT>
               for( face = TOP; face &lt;= LEFT; face++ )
                {
                    sum_q_influx    = sum_q_influx +
                                     q_influx[i][j][k][face]*influx_vol[i][j][k][face];
                }
                <FONT COLOR="570BA3">/*__________________________________
                *  INFLUX: CORNER FLUX
                *___________________________________*/</FONT>
                for (corner = TOP_R; corner &lt;= BOT_R; corner ++)
                {
                    sum_q_influx_CF = sum_q_influx_CF + 
                                    q_influx_CF[i][j][k][corner]   * influx_vol_CF[i][j][k][corner];
                }
                <FONT COLOR="570BA3">/*__________________________________
                * Calculate the advected q at t + delta t
                *___________________________________*/</FONT> 
                
                advect_q_CC[i][j][k][m] = - sum_q_outflux - sum_q_outflux_CF 
                                          + sum_q_influx  + sum_q_influx_CF; 
             
                <FONT COLOR="570BA3">/*__________________________________
                *   PLOTTING VARIABLES
                *___________________________________*/</FONT>
                #if switchDebug_Advect_q
                    plot1[i][j][k] = 0.0;
                    plot2[i][j][k] = 0.0;
                   
                    plot1[i][j][k]  = sum_q_outflux + sum_q_outflux_CF;
                    plot2[i][j][k]  = sum_q_influx + sum_q_influx_CF;
                    plot3[i][j][k]  = advect_q_CC[i][j][k][m];
                #endif

            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Plot the results (MUST HARDWIRE WHAT YOU WANT TO VIEW)
*_______________________________________________________________________*/</FONT>
#if switchDebug_Advect_q 
    should_I_write_output = *getenv("SHOULD_I_WRITE_OUTPUT");
    if ( should_I_write_output == '1')
    {
        #define switchInclude_Advect_q 1 
        #include "debugcode.i"
        free_darray_3d( plot1, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
        free_darray_3d( plot2, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
        free_darray_3d( plot3, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);    
        #undef switchInclude_Advect_q 
    }
 
#endif   

<FONT COLOR="570BA3">/*______________________________________________________________________
* DEALLOCATE MEMORY
*_______________________________________________________________________*/</FONT>
   free_darray_3d( grad_limiter,0, X_MAX_LIM,    0, Y_MAX_LIM,   0, Z_MAX_LIM);
   free_darray_4d(q_influx,    -1, X_MAX_LIM+1, -1, Y_MAX_LIM+1, -1, Z_MAX_LIM+1, 1, N_CELL_FACES  );                   
   free_darray_4d(q_outflux ,   0, X_MAX_LIM,    0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_FACES  );
   free_darray_4d(q_influx_CF, -1, X_MAX_LIM+1, -1, Y_MAX_LIM+1, -1, Z_MAX_LIM+1, 1, N_CELL_VERTICES  );                   
   free_darray_4d(q_outflux_CF ,0, X_MAX_LIM,    0, Y_MAX_LIM,    0, Z_MAX_LIM,   1, N_CELL_VERTICES  );

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT> 
    should_I_write_output = should_I_write_output;
}   
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="influx_outflux_volume">influx_outflux_volume</A>  ADVECTION: Step 6.?, Computes the fluxes of volume Delta_V_1 to Delta_V_6.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q.c
 Filename: advect_q.c
 Purpose:   calculate the individual outfluxes and influxes for each cell.
            This includes the slabs and corner fluxes
 
 References:
 --------------------
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) 
    and Uintah-ICE CFD Multidimensional Compatible Advection Operator, Todd Harman
            
 Steps for each cell:  
 --------------------
 1) calculate the volume for each outflux
 3) set the influx_volume for the appropriate cell = to the q_outflux of the 
    adjacent cell. 

Implementation notes:
    The outflux of volume is calculated in each cell in the computational domain
    + one layer of ghostcells surrounding the domain. 
    
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/22/99
       2.0                       4/19/00     Completely rewritten


outflow volume notation in 2D
                 
                         q_outflux(TOP)
                        ______________________
                        |   |             |  |
  q_outflux_CF(TOP_L)   | + |      +      | +| q_outflux_CF(TOP_R)
                        |---|----------------|
                        |   |             |  |
  q_outflux(LEFT)       | + |     i,j,k   | +| q_outflux(RIGHT)
                        |   |             |  |
                        |---|----------------|
 q_outflux_CF(BOT_L)    | + |      +      | +| q_outflux_CF(BOT_R)
                        ----------------------
                         q_outflux(BOTTOM)  
                         
                         
  ______________________          ______________________  _
   |   |             |  |          |   |             |  |  |  delY_top
   | + |      +      | +|          | + |      +      | +|  |
   |---|----------------|  --ytop  |---|----------------|  -
   |   |             |  |          |   |             |  |
   | + |     i,j,k   | +|          | + |     i,j,k   | +|
   |   |             |  |          |   |             |  |
   |---|----------------|  --y0    |---|----------------|  -
   | + |      +      | +|          | + |      +      | +|  | delY_bottom
   ----------------------          ----------------------  -
       |             |             |---|             |--|
       x0            xright          delX_left         delX_right                         
                         
                              
 CAVEAT:
    The face-centered velocity needs to be defined on all faces for each cell
    in the computational domain and a single ghostcell layer.   
 ---------------------------------------------------------------------  */</FONT>
void <A href="#influx_outflux_volume">influx_outflux_volume</A>    
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* cell dimensions                  (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/*                                  (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/*                                  (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* time increment [sec]             (INPUT) */</FONT>
                <FONT COLOR="570BA3">/* pointers             *(*)vel_FC(x,y,z,face,material              */</FONT>
        double  ******uvel_FC,          <FONT COLOR="570BA3">/* u-face-centered velocity         (INPUT) */</FONT>
        double  ******vvel_FC,          <FONT COLOR="570BA3">/* *v-face-centered velocity        (INPUT) */</FONT>
        double  ******wvel_FC,          <FONT COLOR="570BA3">/* w face-centered velocity         (INPUT) */</FONT>
        double  ****influx_vol,         <FONT COLOR="570BA3">/* influx of vol(x, y, z, vol.)     (OUPUT) */</FONT>
        double  ****influx_vol_CF,      <FONT COLOR="570BA3">/* corner flux contributions        (OUTPUT)*/</FONT>
        double  ****outflux_vol,        <FONT COLOR="570BA3">/* outflux of vol(x, y, z, vol.)    (OUPUT) */</FONT>
        double  ****outflux_vol_CF,     <FONT COLOR="570BA3">/* corner flux contributions        (OUTPUT)*/</FONT>
        int     m           )           <FONT COLOR="570BA3">/* material                         */</FONT>
        
                                       
{
    int     i, j, k,                    <FONT COLOR="570BA3">/* cell indices                     */</FONT>
            xLo, xHi,
            yLo, yHi,
            zLo, zHi,
            face;
    double
            delY_top,                   <FONT COLOR="570BA3">/* see diagram above                */</FONT>   
            delY_bottom,
            delX_right, 
            delX_left,  
            delX_tmp,
            delY_tmp,
            total_vol,                  <FONT COLOR="570BA3">/* total volume of the cell         */</FONT>
            total_fluxvol;              <FONT COLOR="570BA3">/* sum of all of the fluxed volumes */</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_Advect_influx_outflux_volume
    double
        ***plot1,                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT>       
        ***plot2;                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT> 

        #include "plot_declare_vars.h"
        plot1       = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);    
        plot2       = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM); 
#endif
<FONT COLOR="570BA3">/*_________________
* double check inputs
*__________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);  
    

<FONT COLOR="570BA3">/*__________________________________
*   initialize the looping limits
*   and the influx array
*___________________________________*/</FONT>     
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit); 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Calculate the outflux of volume for everycell inside of the computational
*   domain + 1 layer of ghost cells. 
*_______________________________________________________________________*/</FONT>     
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            {
                <FONT COLOR="570BA3">/*__________________________________
                *   SLAB outfluxes
                *___________________________________*/</FONT>
                delY_top    = MAX(0.0, (*vvel_FC[i][j][k][TOP][m]     * delt) );
                delY_bottom = MAX(0.0,-(*vvel_FC[i][j][k][BOTTOM][m]  * delt) );
                delX_right  = MAX(0.0, (*uvel_FC[i][j][k][RIGHT][m]   * delt) );
                delX_left   = MAX(0.0,-(*uvel_FC[i][j][k][LEFT][m]    * delt) );

                delX_tmp    = delX - delX_right - delX_left;
                outflux_vol[i][j][k][TOP]        = MAX(0.0, *vvel_FC[i][j][k][TOP][m]     * delt * delX_tmp * delZ);
                outflux_vol[i][j][k][BOTTOM]     = MAX(0.0,-*vvel_FC[i][j][k][BOTTOM][m]  * delt * delX_tmp * delZ);

                delY_tmp    = delY - delY_top - delY_bottom;
                outflux_vol[i][j][k][RIGHT]      = MAX(0.0, *uvel_FC[i][j][k][RIGHT][m]   * delt * delY_tmp * delZ);
                outflux_vol[i][j][k][LEFT]       = MAX(0.0,-*uvel_FC[i][j][k][LEFT][m]    * delt * delY_tmp * delZ);

                #if 0   <FONT COLOR="570BA3">/* need for 3D  */</FONT>
                outflux_vol[i][j][k][FRONT]      = MAX(0.0, *wvel_FC[i][j][k][FRONT][m]   * delt * delX * delY);
                outflux_vol[i][j][k][BACK]       = MAX(0.0,-*wvel_FC[i][j][k][BACK][m]    * delt * delX * delY);  
                #endif   
                <FONT COLOR="570BA3">/*__________________________________
                *   Corner flux terms
                *___________________________________*/</FONT>
                outflux_vol_CF[i][j][k][TOP_R]   = delY_top      * delX_right;
                outflux_vol_CF[i][j][k][TOP_L]   = delY_top      * delX_left;
 
                outflux_vol_CF[i][j][k][BOT_R]   = delY_bottom   * delX_right;
                outflux_vol_CF[i][j][k][BOT_L]   = delY_bottom   * delX_left;
                
                
                
<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
#if 0
               <FONT COLOR="570BA3">/*__________________________________
               *    Take out the corner flux terms
               *___________________________________*/</FONT>
 
                delY_top    = MAX(0.0, (*vvel_FC[i][j][k][TOP][m]     * delt) );
                delY_bottom = MAX(0.0,-(*vvel_FC[i][j][k][BOTTOM][m]  * delt) );
                delX_right  = MAX(0.0, (*uvel_FC[i][j][k][RIGHT][m]   * delt) );
                delX_left   = MAX(0.0,-(*uvel_FC[i][j][k][LEFT][m]    * delt) );

                delX_tmp    = delX;
                outflux_vol[i][j][k][TOP]        = MAX(0.0, *vvel_FC[i][j][k][TOP][m]     * delt * delX_tmp * delZ);
                outflux_vol[i][j][k][BOTTOM]     = MAX(0.0,-*vvel_FC[i][j][k][BOTTOM][m]  * delt * delX_tmp * delZ);

                delY_tmp    = delY;
                outflux_vol[i][j][k][RIGHT]      = MAX(0.0, *uvel_FC[i][j][k][RIGHT][m]   * delt * delY_tmp * delZ);
                outflux_vol[i][j][k][LEFT]       = MAX(0.0,-*uvel_FC[i][j][k][LEFT][m]    * delt * delY_tmp * delZ);

                #if 0   <FONT COLOR="570BA3">/* need for 3D  */</FONT>
                outflux_vol[i][j][k][FRONT]      = MAX(0.0, *wvel_FC[i][j][k][FRONT][m]   * delt * delX * delY);
                outflux_vol[i][j][k][BACK]       = MAX(0.0,-*wvel_FC[i][j][k][BACK][m]    * delt * delX * delY);  
                #endif   
                <FONT COLOR="570BA3">/*__________________________________
                *   Corner flux terms
                *___________________________________*/</FONT>
                outflux_vol_CF[i][j][k][TOP_R]   = 0.0;
                outflux_vol_CF[i][j][k][TOP_L]   = 0.0;
 
                outflux_vol_CF[i][j][k][BOT_R]   = 0.0;
                outflux_vol_CF[i][j][k][BOT_L]   = 0.0;
#endif
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
                
            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
*   INFLUX TERMS
*___________________________________*/</FONT>
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            {                
               <FONT COLOR="570BA3">/*__________________________________
               *   INFLUX SLABS
               *___________________________________*/</FONT>
               influx_vol[i][j][k][TOP]        = outflux_vol[i][j+1][k][BOTTOM];
               influx_vol[i][j][k][BOTTOM]     = outflux_vol[i][j-1][k][TOP];

               influx_vol[i][j][k][RIGHT]      = outflux_vol[i+1][j][k][LEFT];
               influx_vol[i][j][k][LEFT]       = outflux_vol[i-1][j][k][RIGHT];

               influx_vol[i][j][k][FRONT]      = outflux_vol[i][j][k+1][BACK];
               influx_vol[i][j][k][BACK]       = outflux_vol[i][j][k-1][FRONT];

               <FONT COLOR="570BA3">/*__________________________________
               *   INFLUX CORNER FLUXES
               *___________________________________*/</FONT>
               influx_vol_CF[i][j][k][TOP_R]   = outflux_vol_CF[i+1][j+1][k][BOT_L];
               influx_vol_CF[i][j][k][BOT_R]   = outflux_vol_CF[i+1][j-1][k][TOP_L];

               influx_vol_CF[i][j][k][TOP_L]   = outflux_vol_CF[i-1][j+1][k][BOT_R];
               influx_vol_CF[i][j][k][BOT_L]   = outflux_vol_CF[i-1][j-1][k][TOP_R];       

                <FONT COLOR="570BA3">/*__________________________________
                * Bullet proofing
                *___________________________________*/</FONT>
                total_fluxvol =  
                              outflux_vol[i][j][k][TOP]         + outflux_vol[i][j][k][BOTTOM]
                            + outflux_vol[i][j][k][RIGHT]       + outflux_vol[i][j][k][LEFT]
                            + outflux_vol_CF[i][j][k][TOP_R]    + outflux_vol_CF[i][j][k][BOT_R]
                            + outflux_vol_CF[i][j][k][TOP_L]    + outflux_vol_CF[i][j][k][BOT_L];
                #if (N_DIMENSIONS == 1)
                    total_vol = delX;
                #endif
                #if (N_DIMENSIONS == 2)
                    total_vol = delX * delY;
                #endif                           
                #if (N_DIMENSIONS == 3)                            
                    total_vol = delX * delY * delZ;
                #endif
                assert (total_fluxvol &gt;= 0.0);
                assert (total_fluxvol &lt; total_vol);

            }
        }
    }

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(*wvel_FC[0][0][0][1][1]);      
    QUITE_FULLWARN(delZ);         
    face = face;                  
    
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Section for Plotting
*_______________________________________________________________________*/</FONT> 
#if switchDebug_Advect_influx_outflux_volume
    #define switchInclude_Advect_influx_outflux_volume 1
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            { 
                plot1[i][j][k]  = 0.0;
                plot2[i][j][k]  = 0.0;

                for( face = TOP; face &lt;= LEFT; face++ )
                {
                    plot1[i][j][k]    = plot1[i][j][k] + outflux_vol[i][j][k][face] * 1000.0;
                }

                for( face = TOP; face &lt;= LEFT; face++ )
                {
                    plot2[i][j][k]  = plot2[i][j][k] +influx_vol[i][j][k][face] * 1000.0;
                }
               
                
            }
        }
    }
    #include "debugcode.i"
    free_darray_3d( plot1,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    free_darray_3d( plot2,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    #undef switchInclude_Advect_influx_outflux_volume

 #endif
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="q_out_flux">q_out_flux</A>  ADVECTION: Step 6.?, Compute the outflux of (q) </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q_flux.c
 Filename: advect_q_flux.c
 Purpose:
    Calculate the quantity \langle q \rangle for each outflux, including
    the corner flux terms

 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 
    146, 1-28, (1998) 
            
 Steps for each cell:  
 --------------------       
    1) calculate the gradients of q in the x, y, and z dir.        
    2) If the switch is turned on limit the gradients by the variable gradient_limiter 
    3) Calculate the quantity outflux of q for each of the outflowing volumes 
       
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/21/99
                                 4/19/00    rewritten so each face is 
                                            computed separately    
 
outflow volume notation in 2D
                 
                         q_outflux(TOP)
                        ______________________
                        |   |             |  |
  q_outflux_CF(TOP_L)   | + |      +      | +| q_outflux_CF(TOP_R)
                        |---|----------------|
                        |   |             |  |
  q_outflux(LEFT)       | + |     i,j,k   | +| q_outflux(RIGHT)
                        |   |             |  |
                        |---|----------------|
 q_outflux_CF(BOT_L)    | + |      +      | +| q_outflux_CF(BOT_R)
                        ----------------------
                         q_outflux(BOTTOM)
 
---------------------------------------------------------------------  */</FONT>  
void <A href="#q_out_flux">q_out_flux</A> 
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* cell dimensions                  (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/*                                  (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/*                                  (INPUT) */</FONT>
        double  ***gradient_limiter,    <FONT COLOR="570BA3">/* vanleer type gradient limiter    (INPUT) */</FONT>
        double  ****outflux_vol,        <FONT COLOR="570BA3">/* outflux volume                   (INPUT) */</FONT>
        double  ****outflux_vol_CF,     <FONT COLOR="570BA3">/* corner flux contribution         (INPUT) */</FONT>
        double  ****r_out_x,            <FONT COLOR="570BA3">/* x-dir centroid array (i,j,k,vol  (INPUT) */</FONT> 
        double  ****r_out_y,            <FONT COLOR="570BA3">/* y-dir centroid array             (INPUT) */</FONT>                   
        double  ****r_out_z,            <FONT COLOR="570BA3">/* z-dir centroid array             (INPUT) */</FONT> 
        double  ****r_out_x_CF,         <FONT COLOR="570BA3">/* corner flux centroids            (INPUT) */</FONT>
        double  ****r_out_y_CF,         <FONT COLOR="570BA3">/* -------//-------------                   */</FONT>
        double  ****r_out_z_CF,         <FONT COLOR="570BA3">/* -------//-------------                   */</FONT> 
        double  ****q_outflux,          <FONT COLOR="570BA3">/* &lt; q &gt; outflux of q               (OUPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (i, j, k, m, face)                       */</FONT>
        double  ****q_outflux_CF,       <FONT COLOR="570BA3">/* corner flux contribution         (OUTPUT)*/</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* primary data ( i, j, k, m)       (INPUT) */</FONT>
        int     m               )       <FONT COLOR="570BA3">/* material                                 */</FONT>
  
{
    int     i, j, k,                    <FONT COLOR="570BA3">/* cell indices                     */</FONT>
            face, corner,                <FONT COLOR="570BA3">/* corner and face indices          */</FONT>
            xLo, xHi,
            yLo, yHi,
            zLo, zHi;            
        
    double
            grad_x,                     <FONT COLOR="570BA3">/* Limited gradients               */</FONT>
            grad_y,
            grad_z,
            ***grad_q_X,                <FONT COLOR="570BA3">/* gradients of q in the x,y,z dir  */</FONT>
                                        <FONT COLOR="570BA3">/* temporary variables              */</FONT>
            ***grad_q_Y,
            ***grad_q_Z;
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_Advect_q_out_flux
    double
        ***plot1,                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT>       
        ***plot2;                        <FONT COLOR="570BA3">/* plot1ing array                    */</FONT> 

    #include "plot_declare_vars.h"
        plot1       = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);    
        plot2       = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM); 
#endif

<FONT COLOR="570BA3">/*__________________________________
* Double check inputs
*___________________________________*/</FONT>                        
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Allocate Memory
*_______________________________________________________________________*/</FONT>
    grad_q_X    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    grad_q_Y    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    grad_q_Z    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);

    <A href="#zero_arrays_3d">zero_arrays_3d</A>
             xLoLimit,      yLoLimit,       zLoLimit,             
             xHiLimit,      yHiLimit,       zHiLimit,
             3,
             grad_q_X,      grad_q_Y,       grad_q_Z); 

<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 1 calculate the gradients of q in the x, y and z directions 
*   Include on layer of ghost cells in the computation
*_______________________________________________________________________*/</FONT>
    #if SECOND_ORDER_ADVECTION == 1
    <A href="#grad_q">grad_q</A> 
             xLoLimit,      yLoLimit,       zLoLimit,
             xHiLimit,      yHiLimit,       zHiLimit,
             delX,          delY,           delZ,
             q_CC,           
             grad_q_X,      grad_q_Y,       grad_q_Z,
             m);
    #endif
  
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Loop over all cells in the computational domain and one layer of 
*   ghostcells.
*_______________________________________________________________________*/</FONT>
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);                                  
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
            
                <FONT COLOR="570BA3">/*__________________________________
                * Plotting Variables
                *___________________________________*/</FONT>
                #if switchDebug_Advect_q_out_flux
                plot1[i][j][k]  = 0.0;
                plot2[i][j][k]  = 0.0;
                #endif
                <FONT COLOR="570BA3">/*__________________________________
                *  Step 2) limit the gradients if switch
                *  is on
                *___________________________________*/</FONT> 
                grad_x = 0.0;
                grad_y = 0.0;
                grad_z = 0.0;
                
                #if( LIMIT_GRADIENT_FLAG &gt; 0 &amp;&amp; SECOND_ORDER_ADVECTION == 1)
                
                    grad_x = grad_q_X[i][j][k] * gradient_limiter[i][j][k];
                    grad_y = grad_q_Y[i][j][k] * gradient_limiter[i][j][k];
                    grad_z = grad_q_Z[i][j][k] * gradient_limiter[i][j][k];
                #endif
                #if( LIMIT_GRADIENT_FLAG == 0 &amp;&amp; SECOND_ORDER_ADVECTION == 1)
                
                    grad_x = grad_q_X[i][j][k];
                    grad_y = grad_q_Y[i][j][k];
                    grad_z = grad_q_Z[i][j][k];
                #endif

                <FONT COLOR="570BA3">/*__________________________________
                *  SLABS
                *___________________________________*/</FONT>                       
                for ( face = TOP; face &lt;= LEFT; face ++)
                {
                    q_outflux[i][j][k][face] = 0.0;
                    
                    if ( outflux_vol[i][j][k][face] &gt; SMALL_NUM)
                    {
                        q_outflux[i][j][k][face] = 
                            q_CC[i][j][k][m] 
                         +  grad_x * r_out_x[i][j][k][face]
                         +  grad_y * r_out_y[i][j][k][face] 
                         +  grad_z * r_out_z[i][j][k][face];
                    }
                    #if switchDebug_Advect_q_out_flux
                    plot1[i][j][k] =  plot1[i][j][k] + q_outflux[i][j][k][face];
                    #endif
                }
                                
                <FONT COLOR="570BA3">/*__________________________________
                *   CORNER FLUX CONTRIBUTIONS   
                *___________________________________*/</FONT>
                for ( corner = TOP_R; corner &lt;= BOT_R; corner ++)
                {
                    q_outflux_CF[i][j][k][corner] = 0.0;
                    if(outflux_vol_CF[i][j][k][corner] &gt; SMALL_NUM)
                    {
                        q_outflux_CF[i][j][k][corner] = 
                            q_CC[i][j][k][m] 
                         +  grad_x * r_out_x_CF[i][j][k][corner]
                         +  grad_y * r_out_y_CF[i][j][k][corner] 
                         +  grad_z * r_out_z_CF[i][j][k][corner];
                    }
                    #if switchDebug_Advect_q_out_flux
                    plot2[i][j][k] = plot2[i][j][k] + q_outflux_CF[i][j][k][corner];
                    #endif
                } 
   
            }
        }
    }

<FONT COLOR="570BA3">/*______________________________________________________________________
*   Section for Plotting
*_______________________________________________________________________*/</FONT> 
#if switchDebug_Advect_q_out_flux
    #define switchInclude_Advect_q_out_flux 1
    #include "debugcode.i"
    free_darray_3d( plot1,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    free_darray_3d( plot2,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    #undef switchInclude_Advect_q_out_flux

 #endif
 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Deallocate memory
*_______________________________________________________________________*/</FONT>
   free_darray_3d( grad_q_X, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
   free_darray_3d( grad_q_Y, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
   free_darray_3d( grad_q_Z, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn messages
*___________________________________*/</FONT>
    QUITE_FULLWARN(gradient_limiter);
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="q_in_flux">q_in_flux</A>  ADVECTION: Step 6.?, Compute the influx of (q) for each cell.  </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q_flux.c
 Filename: advect_q_flux.c
 Purpose:
    Calculate the influx contribution \langle q \rangle for each slab and corner
    flux.   
 
 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden 
    and B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) 
             
    
Implementation Notes:
---------------------
    The quantity q_outflux is needed from one layer of ghostcells surrounding
    the computational domain.  To avoid if-then statements inside of the
    nested for-loops is q_influx is computed out two layers of ghostcells.  The 
    array q_influx starts indexing from -1.
    
          
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/21/99  
       2.0          //           4/19/00    rewritten.  Allows outfluxes
                                            to come from any direction  
out/in flow volume notation in 2D
                 
                         q_outflux(TOP)
                        ______________________
                        |   |             |  |
  q_outflux_CF(TOP_L)   | + |      +      | +| q_outflux_CF(TOP_R)
                        |---|----------------|
                        |   |             |  |
  q_outflux(LEFT)       | + |     i,j,k   | +| q_outflux(RIGHT)
                        |   |             |  |
                        |---|----------------|
 q_outflux_CF(BOT_L)    | + |      +      | +| q_outflux_CF(BOT_R)
                        ----------------------
                         q_outflux(BOTTOM)
---------------------------------------------------------------------  */</FONT>
void <A href="#q_in_flux">q_in_flux</A>
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  ****q_influx,           <FONT COLOR="570BA3">/* &lt;q&gt; influx of q                  (OUPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (i, j, k,face)                   */</FONT>
        double  ****q_influx_CF,        <FONT COLOR="570BA3">/* corner flux contributions        (OUTPUT)*/</FONT>
        double  ****q_outflux,          <FONT COLOR="570BA3">/* &lt;q&gt;  outflux of q                (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (i, j, k, face)                  */</FONT> 
        double  ****q_outflux_CF,       <FONT COLOR="570BA3">/* corner flux contributions        (INPUT) */</FONT>
        int     m               )       <FONT COLOR="570BA3">/* material                         */</FONT>        
{
    int     i, j, k;                    <FONT COLOR="570BA3">/* cell indices                     */</FONT>            
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if (switchDebug_Advect_q_in_flux)
    double  ***plot1,
            ***plot2,
            delX = 1.0;
    #include "plot_declare_vars.h"
    plot1   = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);    
    plot2   = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM); 
   
#endif
<FONT COLOR="570BA3">/*______________________________________________________________________
* Allocate memory,
*_______________________________________________________________________*/</FONT>                       
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
         
<FONT COLOR="570BA3">/*START_DOC*/</FONT> 

<FONT COLOR="570BA3">/*______________________________________________________________________
*  Loop over all of the cells in the computational domain and 
*   the ghostcells
*_______________________________________________________________________*/</FONT>
                                  
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            { 
            
                 <FONT COLOR="570BA3">/*__________________________________
                *   Contributions from the slabs
                *___________________________________*/</FONT>
                q_influx[i][j][k][TOP]        = q_outflux[i][j+1][k][BOTTOM];
                q_influx[i][j][k][BOTTOM]     = q_outflux[i][j-1][k][TOP];

                q_influx[i][j][k][RIGHT]      = q_outflux[i+1][j][k][LEFT];
                q_influx[i][j][k][LEFT]       = q_outflux[i-1][j][k][RIGHT];
                
                
                <FONT COLOR="570BA3">/*__________________________________
                *   ADD 3D HERE
                *___________________________________*/</FONT>
                <FONT COLOR="570BA3">/*q_influx[i][j][k][FRONT]      = q_outflux[i][j][k+1][BACK];
                q_influx[i][j][k][BACK]       = q_outflux[i][j][k-1][FRONT];*/</FONT>

                <FONT COLOR="570BA3">/*__________________________________
                *   Contributions from the corner flux volumes
                *___________________________________*/</FONT>
                q_influx_CF[i][j][k][TOP_R]   = q_outflux_CF[i+1][j+1][k][BOT_L];
                q_influx_CF[i][j][k][BOT_R]   = q_outflux_CF[i+1][j-1][k][TOP_L];

                q_influx_CF[i][j][k][TOP_L]   = q_outflux_CF[i-1][j+1][k][BOT_R];
                q_influx_CF[i][j][k][BOT_L]   = q_outflux_CF[i-1][j-1][k][TOP_R]; 
                
                
                <FONT COLOR="570BA3">/*__________________________________
                *   Plotting variables
                *___________________________________*/</FONT> 
                #if (switchDebug_Advect_q_in_flux)
                plot1[i][j][k] =   q_influx[i][j][k][TOP]   + q_influx[i][j][k][BOTTOM]
                                 + q_influx[i][j][k][RIGHT] + q_influx[i][j][k][LEFT];   
                                 
                plot2[i][j][k] =   q_influx[i][j][k][TOP_R]   + q_influx[i][j][k][BOT_R]
                                 + q_influx[i][j][k][TOP_L] + q_influx[i][j][k][BOT_L]; 
                #endif            
            }
        }
    }    

 <FONT COLOR="570BA3">/*______________________________________________________________________
*   Section for Plotting
*_______________________________________________________________________*/</FONT> 
#if switchDebug_Advect_q_in_flux
    #define switchInclude_Advect_q_in_flux 1
   #include "debugcode.i"
   free_darray_3d( plot1, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
   free_darray_3d( plot2, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    #undef switchInclude_Advect_q_in_flux

 #endif
<FONT COLOR="570BA3">/*__________________________________
*   QUITEFULL WARN
*___________________________________*/</FONT> 
    m = m;
 
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_q_vertex_max_min">find_q_vertex_max_min</A>  Advection: Step 6.?, Find max. and min. of (q) at vertices </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: q_vertex.c
 Filename: q_vertex.c
 
 Purpose:
   This routine calculates the max and min value of q at the vertices of each cell.
   
 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) and 
    Uintah-ICE CFD Multidimensional Compatible Advection Operator

Computational Domain:
    The max and min. values of (q) at the vertices is a cell-centered quantity
    that is computed throughout the computational domain.  
    
Ghostcell data dependency:
    In order to compute the vertex values data from the ghost cells is used.
            
 Steps
 --------------------
 1) Declare local memory for the vertex data and equate the common vertices
 2) Interpolate the values of q out to the vertices
 3) Find the max. and min. of the vertex data      
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/17/99    


 
Vertex Notation 
 
                   4 ______________  3
                    /|            /|
                   / |           / |
                7 /__|__________/ 8|
                 |   |          |  |
                 |   |          |  |
                 | 1 |__________|__| 2
                 |  /           |  /
                 | /            | /
                 |/_____________|/
                5                 6
     y
      |
      |___ x
     /
    z
 
 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#find_q_vertex_max_min">find_q_vertex_max_min</A>    
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* Cell width                       */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* cell center data                 (INPUT) */</FONT>
        double  ***q_VRTX_MAX,          <FONT COLOR="570BA3">/* max. value of the vertices       (OUTPUT)*/</FONT>
        double  ***q_VRTX_MIN,          <FONT COLOR="570BA3">/* min. value of the vertices       (OUTPUT)*/</FONT>
        int     m                )      <FONT COLOR="570BA3">/* material                         */</FONT>
  
{
        int i, j, k, v,                 <FONT COLOR="570BA3">/* cell indices                     */</FONT> 
            n_vertices,                 <FONT COLOR="570BA3">/* number of cell vertices          */</FONT>
            xLo, xHi,
            yLo, yHi,
            zLo, zHi;
           
        double
            *****q_VRTX,                <FONT COLOR="570BA3">/* q at the vertex (pointer)        */</FONT>
                                        <FONT COLOR="570BA3">/* (i, j, k, vertice)               */</FONT>
            q_vrtex_max,                <FONT COLOR="570BA3">/* vertex max and min               */</FONT>
             q_vrtex_min;
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT> 
#if switchDebug_find_q_vertex_max
    #include plot_declare_vars.h"   
#endif 
    
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert ( m &lt;= N_MATERIAL);
    assert ( delX &gt; 0.0 );
    assert ( delY &gt; 0.0 );
#if (N_DIMENSIONS == 3)
    assert ( delZ &gt; 0.0 );
#endif
    n_vertices = 4 + IF_3D(4);          <FONT COLOR="570BA3">/* calculate the number of vertices */</FONT>
    
<FONT COLOR="570BA3">/*START_DOC*/</FONT>  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 1)
*  - Allocate Memory
*  - Define upper and lower looping indices
*  - Equate the pointer address of the vertices.  For example
*    q_VRTX[1][1][1][1] = q_VRTX[0][1][1][2]
*_______________________________________________________________________*/</FONT>
    q_VRTX   = darray_5d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_CELL_VERTICES,1,1);
    
    <FONT COLOR="570BA3">/*__________________________________
    * 12/15/99: keep around until you resolve
    * which find_q_vertex function to use
    *___________________________________*/</FONT>   
<FONT COLOR="570BA3">/* 
xLo = 1;
    xHi = X_MAX_LIM-1;
    yLo = 1;
    yHi = Y_MAX_LIM-1;
    zLo = 1;
    zHi = Z_MAX_LIM -1;
   
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
                 q_VRTX[i-1][j][k][2]        = q_VRTX[i][j][k][1];
                q_VRTX[i-1][j-1][k][3]      = q_VRTX[i][j][k][1];
                q_VRTX[i][j-1][k][4]        = q_VRTX[i][j][k][1]; */</FONT>
                <FONT COLOR="570BA3">/* *q_VRTX[i][j][k][1]         = 0.0;  */</FONT>
                <FONT COLOR="570BA3">/*__________________________________
                *  I'll need this for 3D
                *___________________________________*/</FONT>
               <FONT COLOR="570BA3">/*  q_VRTX[i][j][k-1][5]        = q_VRTX[i][j][k][1];
                q_VRTX[i-1][j][k-1][6]      = q_VRTX[i][j][k][1];
                q_VRTX[i][j-1][k-1][7]      = q_VRTX[i][j][k][1];
                q_VRTX[i-1][j-1][k-1][8]    = q_VRTX[i][j][k][1];
            }
        }
    }
*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
* step 2)  Interpolate the values of q out to the vertices
*_______________________________________________________________________*/</FONT>

    <A href="#find_q_vertex">find_q_vertex</A>          xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                            delX,           delY,           delZ,
                            q_CC,           q_VRTX,        m);
<FONT COLOR="570BA3">/*__________________________________
* step 3) Find the max and min of the
*   vertex data
*___________________________________*/</FONT>
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
                                  
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
                q_vrtex_max = *q_VRTX[i][j][k][1];
                q_vrtex_min = *q_VRTX[i][j][k][1];
                for (v = 2; v &lt;= n_vertices ; v++)
                {
                   q_vrtex_max = DMAX(q_vrtex_max, *q_VRTX[i][j][k][v]);
                   q_vrtex_min = DMIN(q_vrtex_min, *q_VRTX[i][j][k][v]);
                    
                }
                q_VRTX_MAX[i][j][k] = q_vrtex_max;
                q_VRTX_MIN[i][j][k] = q_vrtex_min;
                      
            }
        }
    }
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Section for Plotting
*_______________________________________________________________________*/</FONT>    

#if switchDebug_find_q_vertex_max
    #define switchInclude_find_q_vertex_max 1
    #include debugcode.i"
    #undef switchInclude_find_q_vertex_max
#endif  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Deallocate memory
*_______________________________________________________________________*/</FONT>
   free_darray_5d( q_VRTX,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_CELL_VERTICES, 1,1);

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_q_vertex">find_q_vertex</A>  Advection: Step 6.?, Compute (q) at vertices of each cell</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q_vertex.c
 Filename: advect_q_vertex.c
 Purpose:
   This routine calculates the values of q at the vertices of each cell.
   
 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) and 
    Uintah-ICE CFD Multidimensional Compatible Advection Operator
            
 Steps for each cell:
 --------------------     
            1) Calculate the gradients of q in the x, y and z dir for 
            all of the cells in the domain and one ghostcell 
            layer surrounding the domain.
            2) For each vertice calculate the relative distance between the 
               the cell centroid and the vertex ()_term
            3) determing q_VRTX at each of the vertices   
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       6/17/99    

 
Vertex Notation 
 
                   4 ______________  3
                    /|            /|
                   / |           / |
                7 /__|__________/ 8|
                 |   |          |  |
                 |   |          |  |
                 | 1 |__________|__| 2
                 |  /           |  /
                 | /            | /
                 |/_____________|/
                5                 6
     y
      |
      |___ x
     /
    z
 
 Data Dependencies of the corner ghostcells
    x---x-----------------------------------x---x
    | o | o | o |   |   |   |   |   | o | o | o |   -- top_GC       
    x---x-----------------------------------x---x                  
    | o | + | + | + | + | + | + | + | + | + | o |   -- yHiLimit     
    ---------------------------------------------                   
    | o | + | + | + | + | + | + | + | + | + | o |                   
    ---------------------------------------------                   
    | o | + | + | + | + | + | + | + | + | + | o |                   
    ---------------------------------------------                    
    | o | + | + | + | + | + | + | + | + | + | o |   -- yLoLimit     
    x---x-----------------------------------x---x                   
    | o | o | o |   |   |   |   |   | o | o | o |   -- bottom_GC    
    x---x-----------------------------------x---x                   
      |   | xLoLimit             xHiLimit |   |                     
      |                                       |                     
      left_GC                               right_GC

  x = q_vertex in the corner cells
  o = data needed: q_CC in function grad_q only for the corner cells
 
 ---------------------------------------------------------------------  */</FONT>
void <A href="#find_q_vertex">find_q_vertex</A> 
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* Cell width                       */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* q-cell-centered                  */</FONT>
        double  *****q_VRTX,            <FONT COLOR="570BA3">/* q at the vertex                  */</FONT>
                                        <FONT COLOR="570BA3">/* (i, j, k, vertice)               */</FONT>
        int     m         )             <FONT COLOR="570BA3">/* material                         */</FONT>
  
{
    int     i, j, k,                    <FONT COLOR="570BA3">/* cell face locators               */</FONT> 
            xLo, xHi,
            yLo, yHi,
            zLo, zHi;
    double 
            ***grad_q_X,                <FONT COLOR="570BA3">/* gradients of q in the x,y,z dir  */</FONT>
                                        <FONT COLOR="570BA3">/* temporary variables              */</FONT>
            ***grad_q_Y,
            ***grad_q_Z,
                                        <FONT COLOR="570BA3">/* distance between the cell centroid*/</FONT>
                                        <FONT COLOR="570BA3">/* and the vertex in x, y, and zdir */</FONT>
            q_vrtx1,                    <FONT COLOR="570BA3">/* temporary variables to used to   */</FONT>
            q_vrtx2,                    <FONT COLOR="570BA3">/* help in the debugging process    */</FONT>
            q_vrtx3,
            q_vrtx4,
            x_term,                                           
            y_term,
            z_term;           
       
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Allocate Memory and initialize the arrays 
*_______________________________________________________________________*/</FONT>
    grad_q_X    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    grad_q_Y    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
    grad_q_Z    = darray_3d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM); 
       
    <A href="#zero_arrays_3d">zero_arrays_3d</A>
             xLoLimit,      yLoLimit,       zLoLimit,             
             xHiLimit,      yHiLimit,       zHiLimit,
             3,
             grad_q_X,      grad_q_Y,       grad_q_Z);    
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert ( m &lt;= N_MATERIAL);
    assert ( delX &gt; 0.0 );
    assert ( delY &gt; 0.0 );
#if (N_DIMENSIONS == 3)
    assert ( delZ &gt; 0.0 );
#endif   
<FONT COLOR="570BA3">/*______________________________________________________________________
* 
*_______________________________________________________________________*/</FONT>
    <FONT COLOR="570BA3">/*__________________________________
    * Step 1 
    * calculate the gradients of q
    * in the x, y, and z direction for all
    * cells in the domain and one ghostcell
    * layer surrounding the domain
    *___________________________________*/</FONT>
    <A href="#grad_q">grad_q</A> 
             xLoLimit,       yLoLimit,       zLoLimit,
             xHiLimit,       yHiLimit,       zHiLimit,
             delX,           delY,           delZ,
             q_CC,           
             grad_q_X,      grad_q_Y,        grad_q_Z,
             m);
    <FONT COLOR="570BA3">/*__________________________________
    *  Now calculate the vertex values of q
    * for all cells in the domain and one
    * ghostcell layer surrounding the domain
    *___________________________________*/</FONT>
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
       
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
            
            <FONT COLOR="570BA3">/*__________________________________
            * vertex 1 
            *___________________________________*/</FONT>
            x_term              = grad_q_X[i][j][k] * (-delX/2.0);
            y_term              = grad_q_Y[i][j][k] * (-delY/2.0);
            z_term              = IF_3D(0.0);        <FONT COLOR="570BA3">/* temporary 6.15.99*/</FONT>
            q_vrtx1             = q_CC[i][j][k][m] + x_term + y_term + z_term;
            *q_VRTX[i][j][k][1]  = q_vrtx1;  
            
            <FONT COLOR="570BA3">/*__________________________________
            * vertex 2
            *___________________________________*/</FONT>
            x_term              = grad_q_X[i][j][k] * (delX - (delX/2.0));
            y_term              = grad_q_Y[i][j][k] * (-delY/2.0);
            z_term              = IF_3D(0.0);       <FONT COLOR="570BA3">/* temporary 6.15.99*/</FONT>
            q_vrtx2             = q_CC[i][j][k][m] + x_term + y_term + z_term;
            *q_VRTX[i][j][k][2]  = q_vrtx2;             
           

            <FONT COLOR="570BA3">/*__________________________________
            * vertex 3
            *___________________________________*/</FONT>
            x_term              = grad_q_X[i][j][k] * (delX - (delX/2.0));
            y_term              = grad_q_Y[i][j][k] * (delY - (delY/2.0));
            z_term              = IF_3D(0.0);    <FONT COLOR="570BA3">/* temporary 6.15.99*/</FONT>
            q_vrtx3             = q_CC[i][j][k][m] + x_term + y_term + z_term;
            *q_VRTX[i][j][k][3]  = q_vrtx3;  
            
            <FONT COLOR="570BA3">/*__________________________________
            * vertex 4
            *___________________________________*/</FONT>
            x_term              = grad_q_X[i][j][k] * (-(delX/2.0));
            y_term              = grad_q_Y[i][j][k] * (delY - (delY/2.0));
            z_term              = IF_3D(0.0);     <FONT COLOR="570BA3">/* temporary 6.15.99*/</FONT>
            q_vrtx4             = q_CC[i][j][k][m] + x_term + y_term + z_term;
            *q_VRTX[i][j][k][4]  = q_vrtx4;             
                      
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Deallocate memory
*_______________________________________________________________________*/</FONT>
   free_darray_3d( grad_q_X, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
   free_darray_3d( grad_q_Y, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
   free_darray_3d( grad_q_Z, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_q_vertex">find_q_vertex</A>  Advection: Step 6.?, Compute (q) at vertices of each cell</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: advect_q_vertex.c
 Filename: advect_q_vertex.c
 
 Purpose:
   This routine calculates the values of q at the vertices of each cell.
   
 References:
    "Compatible Fluxes for van Leer Advection" W.B VanderHeyden and 
    B.A. Kashiwa, Journal of Computational Physics, 146, 1-28, (1998) and 
    Uintah-ICE CFD Multidimensional Compatible Advection Operator
 
 Governing Eq:
    for vertex 1
    q_VRTX[i,j,k,1] = 0.25*(  q_CC[i,j,k,m] + q_CC[i-1,j,k,m] 
                            + q_CC[i-1,j-1,k,m] + q[i,j-1,k,m]) 
 Implementation Notes:
    We compute q_VRTX by first 
        q_VRTX[i,j,k,2] = q_VRTX[i,j,k,2] + (q_CC[i,j,k,m] + q_CC[i+1,j,k,m]) /2.0
        q_VRTX[i,j,k,3] = q_VRTX[i,j,k,3] + (q_CC[i,j,k,m] + q_CC[i+1,j,k,m]) /2.0 
        
    Since the initial values of q_VRTX[i,j,k,2] and q_VRTX[i,j,k,3] = 0.0 
    
                                       
 Steps for each cell:
 --------------------     
    1)  Compute the vertex 2 and 3 in all the cell except the left and
        right ghostcell layers.  
    2)  Compute vertices 3 and 4 in the left and right ghost cell layers
    3)  Take care of the lower left and right ghostcell corners
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/13/99    

 
Vertex Notation 
 
                   4 ______________  3
                    /|            /|
                   / |           / |
                7 /__|__________/ 8|
                 |   |          |  |
                 |   |          |  |
                 | 1 |__________|__| 2
                 |  /           |  /
                 | /            | /
                 |/_____________|/
                5                 6
     y
      |
      |___ x
     /
    z
 ---------------------------------------------------------------------  */</FONT>
void <A href="#find_q_vertex">find_q_vertex</A> 
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* Cell width                       */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
        double  ****q_CC,               <FONT COLOR="570BA3">/* q-cell-centered                  */</FONT>
        double  *****q_VRTX,            <FONT COLOR="570BA3">/* q at the vertex                  */</FONT>
                                        <FONT COLOR="570BA3">/* (i, j, k, vertice)               */</FONT>
        int     m         )             <FONT COLOR="570BA3">/* material                         */</FONT>
  
{
    int     i, j, k,                    <FONT COLOR="570BA3">/* cell face locators               */</FONT> 
            xLo, xHi,
            yLo, yHi,
            zLo, zHi;
    double                                   
            q_vrtx_temp;          
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt; X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt; Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt; Z_MAX_LIM);
    assert ( m &lt;= N_MATERIAL);
    assert ( delX &gt; 0.0 );
    assert ( delY &gt; 0.0 );
#if (N_DIMENSIONS == 3)
    assert ( delZ &gt; 0.0 );
#endif   
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 1)
*   Compute vertices 2 and 3 in all the cells except the left and right
*   ghostcells walls.
*_______________________________________________________________________*/</FONT>
    <FONT COLOR="570BA3">/*__________________________________
    *  Now calculate the vertex values for
    *   vertex 2 and 3 
    *   x = Half Updated vertex values
    *   o = Fully updated vertex values
    *   ----X---X---X---X---X---X----
    *   |   |   |   |   |   |   |   |   -- top_GC       
    *   |---o---o---o---o---o---o---|                  
    *   |   | + | + | + | + | + |   |   -- yHiLimit     
    *   |---o---o---o---o---o---o---|                   
    *   |   | + | + | + | + | + |   |                   
    *   |---o---o---o---o---o---o---|                   
    *   |   | + | + | + | + | + |   |                   
    *   |---o---o---o---o---o---o---|                    
    *   |   | + | + | + | + | + |   |   -- yLoLimit     
    *   |---o---o---o---o---o---o---|                   
    *   |   |   |   |   |   |   |   |   -- bottom_GC    
    *   ----X---X---X---X---X---X----                   
    *___________________________________*/</FONT>
    xLo = GC_LO(xLoLimit);
    xHi = (xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
       
    for ( i = xLo; i &lt;= xHi; i++)
    {
        for ( j = yLo; j &lt;= yHi; j++)
        {
            for ( k = zLo; k &lt;= zHi; k++)
            { 
                q_vrtx_temp          =  (q_CC[i][j][k][m] + q_CC[i+1][j][k][m]) /2.0;
                <FONT COLOR="570BA3">/*__________________________________
                * vertex 2
                *___________________________________*/</FONT>
                *q_VRTX[i][j][k][2]  = *q_VRTX[i][j][k][2] + q_vrtx_temp; 

                <FONT COLOR="570BA3">/*__________________________________
                * vertex 3
                *___________________________________*/</FONT>
                *q_VRTX[i][j][k][3]  = *q_VRTX[i][j][k][3] + q_vrtx_temp;
            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
*   Step 2)
*   Now loop through the left and right
*   layer of ghostcells minus the corner cells
*   LEFT and Right walls
*___________________________________*/</FONT>
    xLo = GC_LO(xLoLimit);
    xHi = GC_HI(xHiLimit);
    yLo = GC_LO(yLoLimit);
    yHi = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
    for ( j = yLo; j &lt;= yHi; j++)
    {
        for ( k = zLo; k &lt;= zHi; k++)
        {
            *q_VRTX[xLo][j][k][4] = (q_CC[xLo][j][k][m] + q_CC[xLo][j+1][k][m]) /2.0;
            *q_VRTX[xHi][j][k][3] = (q_CC[xHi][j][k][m] + q_CC[xHi][j+1][k][m]) /2.0; 
        }
    }
    
<FONT COLOR="570BA3">/*__________________________________
*   Step 3)
*   Compute vertex 1 in the lower left
*   corner ghostcell and 
*   vertex 2 in the lower right ghostcell
*___________________________________*/</FONT>
    for ( k = zLo; k &lt;= zHi; k++)
    {
        *q_VRTX[xLo][yLo][k][4] =  q_CC[xLo][yLo][k][m];
        *q_VRTX[xHi][yLo][k][2] =  q_CC[xLo][yHi][k][m];
    } 

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="set_Neumann_BC_FC">set_Neumann_BC_FC</A>  BOUNDARY CONDITIONS: Sets Neumann BC for all face-centered variables.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond_FC.c
 Filename: boundary_cond_FC.c
 Purpose:
            This function sets the face centered values along the inner and
            outer perimeter of the ghostcells for each dependent variable.
            Only do this if the dependent variable is "FLOAT" throughout the
            computation. 
  Steps:
    1) Find the looping indices for the problem
    2) Test to see if you should be in this function
    3) Loop over all of the walls (minus the corner ghostcells)
            - Determine what the upper an lower indices are for that wall
            - Set the face-centered data_FC = data_CC
    4) Set the face-centered BC in each of the corner ghostcells

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/8/99    

Note: You must call "set_Neumann_BC" BEFORE this function.  Specifically,
this function needs an updated data_CC.
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#set_Neumann_BC_FC">set_Neumann_BC_FC</A> 
              
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  ****data_CC,                <FONT COLOR="570BA3">/* cell-centered data               (INPUT) */</FONT>    
    double  ******data_FC,              <FONT COLOR="570BA3">/* u-face-centered velocity         (IN/OUT)*/</FONT>
    int     var,                        <FONT COLOR="570BA3">/* TEMP, PRESS, UVEL                (INPUT) */</FONT>                    

    int     ***BC_types,                <FONT COLOR="570BA3">/* defines which boundary conditions(INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* have been set on each wall               */</FONT>
    int     ***BC_float_or_FLOAT,       <FONT COLOR="570BA3">/* BC_float_or_FLOAT[wall][var][m]  (INPUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* Variable on boundary is either   */</FONT>
                                        <FONT COLOR="570BA3">/* FLOAT or it floats during the    */</FONT>
                                        <FONT COLOR="570BA3">/* computation                      */</FONT>
    int     nMaterials        )

 {
    int     i,j,k,f,m,                  <FONT COLOR="570BA3">/* indices                           */</FONT>
            wall,      
            xLo,        xHi,         
            yLo,        yHi, 
            zLo,        zHi,
            wallLo,     wallHi,
            faceLo,     faceHi, 
            should_I_leave;
            m = nMaterials;             <FONT COLOR="570BA3">/* Hardwired                        */</FONT>
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);

<FONT COLOR="570BA3">/*__________________________________
*   Step 1)
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1) 
        wallLo = LEFT;  wallHi = RIGHT;
        faceLo = LEFT;  faceHi = RIGHT;
#endif
#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
        faceLo = TOP;   faceHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
        faceLo = TOP;   faceHi = BACK;
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Step 2)
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    for(m = 1; m &lt;= nMaterials; m++)
    {    
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(( BC_types[wall][var][m]            == NEUMANN ||
                 BC_types[wall][var][m]            == PERIODIC ) &amp;&amp;
                 BC_float_or_FLOAT[wall][var][m]   == FLOAT) should_I_leave = NO;
        }
    }
    if (should_I_leave == YES) return;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 3)
*   Now loop over all materials and walls and set the appropriate BC
*   whether its velocity or pressure
*   You need to find the appropriate looping limits for each wall
*_______________________________________________________________________*/</FONT>
    for(m = 1; m &lt;= nMaterials; m++)
    {            
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {

             <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>                
                        xLoLimit,                  yLoLimit,                   zLoLimit,
                        xHiLimit,                  yHiLimit,                   zHiLimit,
                        &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                        &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                        wall    );
           <FONT COLOR="570BA3">/*__________________________________
           * Finally set the boundary condition
           *___________________________________*/</FONT>
            for ( k = zLo; k &lt;= zHi; k++)
            {
                for ( j = yLo; j &lt;= yHi; j++)
                { 
                    for ( i = xLo; i &lt;= xHi; i++)
                    {        
                        for(f = faceLo ; f &lt;= faceHi; f ++)
                        {            
                            *data_FC[i][j][k][f][m] = data_CC[i][j][k][m];
                        }
                    }
                }
            } 
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
    Step 4
*   NOW TAKE CARE OF THE CORNER GHOSTCELLS

        
     --A---------------------------------------A--
    D| 2 |   |   |   |   |   |   |   |   |   | 3 |B  -- top_GC       
     ---------------------------------------------                   
     |   | + | + | + | + | + | + | + | + | + |   |   -- yHiLimit     
     ---------------------------------------------                   
     |   | + | + | + | + | + | + | + | + | + |   |                   
     ---------------------------------------------                   
     |   | + | + | + | + | + | + | + | + | + |   |                   
     ---------------------------------------------                    
     |   | + | + | + | + | + | + | + | + | + |   |   -- yLoLimit     
     ---------------------------------------------                   
    D| 1 |   |   |   |   |   |   |   |   |   | 4 |B  -- bottom_GC    
     --C---------------------------------------C--                   
       |   | xLoLimit             xHiLimit |   |                     
       |                                       |                     
       left_GC                              right_GC  
      
*   NEED TO ADD 3D, specifically the other corner cells on the front face
*_______________________________________________________________________*/</FONT>
    for(m = 1; m &lt;= nMaterials; m++)
    {   
        for ( k = zLo; k &lt;= zHi; k++)
        {   
            i = GC_LO(xLoLimit); 
            j = GC_LO(yLoLimit);
            *data_FC[i][j][k][BOTTOM][m] = data_CC[i][j][k][m];
            *data_FC[i][j][k][LEFT][m]   = data_CC[i][j][k][m];
            
            i = GC_LO(xLoLimit); 
            j = GC_HI(yHiLimit);
            *data_FC[i][j][k][TOP][m]    = data_CC[i][j][k][m];
            *data_FC[i][j][k][LEFT][m]   = data_CC[i][j][k][m];
            
            i = GC_HI(xHiLimit); 
            j = GC_HI(yHiLimit);
            *data_FC[i][j][k][TOP][m]    = data_CC[i][j][k][m];
            *data_FC[i][j][k][RIGHT][m]  = data_CC[i][j][k][m];
            
            i = GC_HI(xHiLimit); 
            j = GC_LO(yLoLimit);
            *data_FC[i][j][k][BOTTOM][m] = data_CC[i][j][k][m];
            *data_FC[i][j][k][RIGHT][m]  = data_CC[i][j][k][m];
        }
    } 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_set_Neumann_BC_FC
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        SET_Neumann_BC_FC\n");
    fprintf(stderr,"****************************************************************************\n");         
    for (m = 1; m &lt;= nMaterials; m++)
    {         
        fprintf(stderr,"\t Material %i \n",m);         
        <A href="#printData_6d">printData_6d</A>       GC_LO(xLoLimit),    GC_LO(yLoLimit),       (zLoLimit),
                            GC_HI(xHiLimit),    GC_HI(yHiLimit),       (zHiLimit),
                            TOP,                LEFT,
                            m,                  m,
                            "set_Neumann_BC_FC",     
                           "data_FC with ghost cells",                  data_FC,        0);
    }
    fprintf(stderr,"****************************************************************************\n");         
    
    fprintf(stderr,"press return to continue\n");
    getchar();            
#endif

 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="set_Dirichlet_BC_FC">set_Dirichlet_BC_FC</A>  BOUNDARY CONDITIONS: Set Dirichlet BC for all fac-centered variables.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond_FC.c
 Filename: boundary_cond_FC.c
 Purpose:
            This function sets the face centered values along the inner and
            outer perimeter of the ghostcells for each dependent variable.
            Only do this if the dependent variable is "fixed" throughout the
            computation. 
  Steps:
    1) Find the looping indices for the problem
    2) Test to see if you should be in this function
    3) Loop over all of the walls (minus the corner ghostcells)
            - Determine what the upper an lower indices are for that wall
            - Set the face-centered data_FC = BC_Values[wall][*][m]
    4) Set the face-centered BC in each of the corner ghostcells

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       08/22/99    

 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#set_Dirichlet_BC_FC">set_Dirichlet_BC_FC</A> 
              
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
                <FONT COLOR="570BA3">/*---------Face Centered Values-----[*]_FC(x,y,z,face, material)----*/</FONT>
    double  ******data_FC,              <FONT COLOR="570BA3">/* face-centered data               (IN/OUT)*/</FONT>
    int     var,                        <FONT COLOR="570BA3">/* used to designate whether        (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* the input array is UVEL,TEMP.... */</FONT>                   
    int     ***BC_types,                <FONT COLOR="570BA3">/* defines which boundary conditions(INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* have been set on each wall               */</FONT>
    double  ***BC_Values,               <FONT COLOR="570BA3">/* BC values BC_values[wall][variable(INPUT)*/</FONT>
    int     ***BC_float_or_fixed,       <FONT COLOR="570BA3">/* BC_float_or_fixed[wall][var][m]   (INPUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* Variable on boundary is either   */</FONT>
                                        <FONT COLOR="570BA3">/* fixed or it floats during the    */</FONT>
                                        <FONT COLOR="570BA3">/* compuation                       */</FONT>
    int     nMaterials        )

 {
    int     i,j,k,f,m,                  <FONT COLOR="570BA3">/* indices                           */</FONT>
            wall,       
            xLo,        xHi,         
            yLo,        yHi, 
            zLo,        zHi,
            wallLo,     wallHi,
            faceLo,     faceHi,     
            should_I_leave;
            m = nMaterials;             <FONT COLOR="570BA3">/* Hardwired                        */</FONT>
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
*   Step 1)
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1) 
        wallLo = LEFT;  wallHi = RIGHT;
        faceLo = LEFT;  faceHi = RIGHT;
#endif
#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
        faceLo = TOP;   faceHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
        faceLo = TOP;   faceHi = BACK;
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Step 2)
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    for(m = 1; m &lt;= nMaterials; m++)
    {    
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(BC_types[wall][var][m]               == DIRICHLET &amp;&amp;
               BC_float_or_fixed[wall][var][m]      == FIXED) should_I_leave = NO;
        }
    }
    if (should_I_leave == YES) return;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Step 3)
*   Now loop over all materials and walls and set the appropriate BC
*   whether its velocity or pressure
*   You need to find what the appropriate looping limits are for each 
*   ghostcells layers for each wall.
*_______________________________________________________________________*/</FONT>
    for(m = 1; m &lt;= nMaterials; m++)
    {            
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {                                     
             <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>
                        xLoLimit,                  yLoLimit,                   zLoLimit,
                        xHiLimit,                  yHiLimit,                   zHiLimit,
                        &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                        &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                        wall    );
           <FONT COLOR="570BA3">/*__________________________________
           * Finally set the boundary condition
           *___________________________________*/</FONT>

            for ( k = zLo; k &lt;= zHi; k++)
            {
                for ( j = yLo; j &lt;= yHi; j++)
                {
                    for ( i = xLo; i &lt;= xHi; i++)
                    {
                        for(f = faceLo ; f &lt;= faceHi; f ++)
                        {
                            *data_FC[i][j][k][f][m] = BC_Values[wall][var][m];

                        }
                    }
                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
    Step 4
*   NOW TAKE CARE OF THE CORNER GHOSTCELLS

        
     --A---------------------------------------A--
    D| 2 |   |   |   |   |   |   |   |   |   | 3 |B  -- top_GC       
     ---------------------------------------------                   
     |   | + | + | + | + | + | + | + | + | + |   |   -- yHiLimit     
     ---------------------------------------------                   
     |   | + | + | + | + | + | + | + | + | + |   |                   
     ---------------------------------------------                   
     |   | + | + | + | + | + | + | + | + | + |   |                   
     ---------------------------------------------                    
     |   | + | + | + | + | + | + | + | + | + |   |   -- yLoLimit     
     ---------------------------------------------                   
    D| 1 |   |   |   |   |   |   |   |   |   | 4 |B  -- bottom_GC    
     --C---------------------------------------C--                   
       |   | xLoLimit             xHiLimit |   |                     
       |                                       |                     
       left_GC                              right_GC  
       
    Face A =    BC_values[TOP][*][m]
    Face B =    BC_values[RIGHT][*][m]
    Face C =    BC_values[BOTTOM][*][m]
    Face D =    BC_values[LEFT][*][m]   
      
*   NEED TO ADD 3D
*_______________________________________________________________________*/</FONT>
    for(m = 1; m &lt;= nMaterials; m++)
    {   
        for ( k = zLo; k &lt;= zHi; k++)
        {      
            *data_FC[GC_LO(xLoLimit)][GC_LO(yLoLimit)][k][BOTTOM][m] = BC_Values[BOTTOM][var][m];
            *data_FC[GC_LO(xLoLimit)][GC_LO(yLoLimit)][k][LEFT][m]   = BC_Values[LEFT][var][m];

            *data_FC[GC_LO(xLoLimit)][GC_HI(yHiLimit)][k][TOP][m]    = BC_Values[TOP][var][m];
            *data_FC[GC_LO(xLoLimit)][GC_HI(yHiLimit)][k][LEFT][m]   = BC_Values[LEFT][var][m]; 

            *data_FC[GC_HI(xHiLimit)][GC_HI(yHiLimit)][k][TOP][m]    = BC_Values[TOP][var][m];
            *data_FC[GC_HI(xHiLimit)][GC_HI(yHiLimit)][k][RIGHT][m]  = BC_Values[RIGHT][var][m];      

            *data_FC[GC_HI(xHiLimit)][GC_LO(yLoLimit)][k][BOTTOM][m] = BC_Values[BOTTOM][var][m];
            *data_FC[GC_HI(xHiLimit)][GC_LO(yLoLimit)][k][RIGHT][m]  = BC_Values[RIGHT][var][m];
        }
    }         
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_set_Dirichlet_BC_FC
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        SET_DIRICHLET_BC_FC\n");
    fprintf(stderr,"****************************************************************************\n");         
    for (m = 1; m &lt;= nMaterials; m++)
    {         
        fprintf(stderr,"\t Material %i \n",m);          
         
        <A href="#printData_6d">printData_6d</A>       GC_LO(xLoLimit),    GC_LO(yLoLimit),       (zLoLimit),
                            GC_HI(xHiLimit),    GC_HI(yHiLimit),       (zHiLimit),
                            TOP,                LEFT,
                            m,                  m,
                            "set_Dirichlet_BC_FC",     
                           "data_FC with ghost cells",                  data_FC,        0);
    }
    fprintf(stderr,"****************************************************************************\n");         
    
    fprintf(stderr,"press return to continue\n");
    getchar();            
#endif

 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="definition_of_different_physical_boundary_conditions">definition_of_different_physical_boundary_conditions</A>  BOUNDARY CONDITIONS: Define in-terms-of Neumann and Dirchlet, no slip, subsonic inflow and subsonic outflow.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function is used to define the BC_type( Neuman or Dirichlet)
            and whether it floats or is fixed throughout the compuation, for each
            dependent variable.
              
            This routine doesn't actually set the boundary conditions, 
            it is just used to define what a particular boundary condition means
            with regards to neuman and dirichlet 
            
            BC_inputs:
            -no slip
            -subsonic input     (velocity components and rho are specified)    
            -subsonic outflow   (normal component of velocity)
            implement different flavors of each boundary condition
            
            BC_types:
                Neuman
                Dirichlet

references:
    APACHE: A generalized-Mesh Eulerian Computer Code for Multicomponent
    Chemically Reactive Fluid Flow, LA-7427, 1979
            
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/03/99    
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#definition_of_different_physical_boundary_conditions">definition_of_different_physical_boundary_conditions</A> 
    int     **BC_inputs,                <FONT COLOR="570BA3">/* What the user has defined as     (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* boundary conditions              */</FONT> 
    int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (OUTPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* types of boundary conditions     */</FONT>
                                        <FONT COLOR="570BA3">/* BC_types[wall][variable]=type    */</FONT>
    int     ***BC_float_or_fixed,       <FONT COLOR="570BA3">/* BC_float_or_fixed[wall][var][m]  (OUTPUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* Variable on boundary is either   */</FONT>
                                        <FONT COLOR="570BA3">/* fixed or it floats during the    */</FONT>
                                        <FONT COLOR="570BA3">/* compuation                       */</FONT>
    double ***BC_Values,                <FONT COLOR="570BA3">/* Values of the variables at the   (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* boundaries                       */</FONT> 
    int       nMaterials        )

 {
    int     m,   
            wall,                       <FONT COLOR="570BA3">/* wall index                       */</FONT>
            wallLo, wallHi;             <FONT COLOR="570BA3">/* lower and upper wall indices     */</FONT>                                   
      
<FONT COLOR="570BA3">/*__________________________________
*   Set looping
*   indices for the number of walls.
*___________________________________*/</FONT>
    
#if (N_DIMENSIONS == 1)
    wallLo = LEFT;  wallHi = RIGHT;
#endif  
#if (N_DIMENSIONS == 2)
    wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3)
    wallLo = TOP;   wallHi = BACK;
#endif  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Loop over all of the outer walls and set what it means to have noslip
*   subsonic inflow or subsonic outflow boundary condition
*_______________________________________________________________________*/</FONT>
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {

            <FONT COLOR="570BA3">/*__________________________________
            *   No slip boundary condition
            *___________________________________*/</FONT>
            if(BC_inputs[wall][m] == NO_SLIP)
            {
                BC_types[wall][UVEL][m]             = DIRICHLET;
                BC_types[wall][VVEL][m]             = DIRICHLET;
                BC_types[wall][WVEL][m]             = DIRICHLET;
                BC_types[wall][TEMP][m]             = NEUMANN;
                BC_types[wall][PRESS][m]            = NEUMANN;
                BC_types[wall][DENSITY][m]          = NEUMANN;
                BC_types[wall][DELPRESS][m]         = NEUMANN;

                BC_Values[wall][UVEL][m]            = 0.0;
                BC_Values[wall][VVEL][m]            = 0.0;
                BC_Values[wall][WVEL][m]            = 0.0;
                BC_Values[wall][PRESS][m]           = 0.0;
                BC_Values[wall][TEMP][m]            = 0.0;
                BC_Values[wall][DENSITY][m]         = 0.0;
                BC_Values[wall][DELPRESS][m]        = 0.0; 

                BC_float_or_fixed[wall][UVEL][m]    = FIXED;
                BC_float_or_fixed[wall][VVEL][m]    = FIXED;
                BC_float_or_fixed[wall][WVEL][m]    = FIXED;
                BC_float_or_fixed[wall][PRESS][m]   = FIXED;
                BC_float_or_fixed[wall][TEMP][m]    = FIXED;
                BC_float_or_fixed[wall][DENSITY][m] = FIXED;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED;
            }
            <FONT COLOR="570BA3">/*__________________________________
            *   Subsonic inflow
            *___________________________________*/</FONT>
             if(BC_inputs[wall][m] == SUBSONIC_INFLOW)
            {
                BC_types[wall][UVEL][m]             = DIRICHLET;
                BC_types[wall][VVEL][m]             = DIRICHLET;
                BC_types[wall][WVEL][m]             = DIRICHLET;
                BC_types[wall][TEMP][m]             = DIRICHLET;
                BC_types[wall][PRESS][m]            = NEUMANN;  
                BC_types[wall][DENSITY][m]          = DIRICHLET;
                BC_types[wall][DELPRESS][m]         = DIRICHLET;                

                BC_Values[wall][UVEL][m]            = BC_Values[wall][UVEL][m];
                BC_Values[wall][VVEL][m]            = BC_Values[wall][VVEL][m];
                BC_Values[wall][WVEL][m]            = BC_Values[wall][WVEL][m];
                BC_Values[wall][PRESS][m]           = 0.0;
                BC_Values[wall][TEMP][m]            = BC_Values[wall][TEMP][m];
                BC_Values[wall][DENSITY][m]         = BC_Values[wall][DENSITY][m];
                BC_Values[wall][DELPRESS][m]        = 0.0; 

                BC_float_or_fixed[wall][UVEL][m]    = FIXED;
                BC_float_or_fixed[wall][VVEL][m]    = FIXED;
                BC_float_or_fixed[wall][WVEL][m]    = FIXED;
                BC_float_or_fixed[wall][PRESS][m]   = FLOAT;         
                BC_float_or_fixed[wall][TEMP][m]    = FIXED;
                BC_float_or_fixed[wall][DENSITY][m] = FIXED;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED;
            }
            <FONT COLOR="570BA3">/*__________________________________
            *   subsonic outflow
            *   Velocity is set and pressure
            *   density and temperature can float
            *___________________________________*/</FONT>
             if(BC_inputs[wall][m] == SUBSONIC_OUTFLOW)
            {
                BC_types[wall][UVEL][m]             = DIRICHLET;
                BC_types[wall][VVEL][m]             = DIRICHLET;
                BC_types[wall][WVEL][m]             = DIRICHLET;
                BC_types[wall][TEMP][m]             = NEUMANN;
                BC_types[wall][PRESS][m]            = NEUMANN;
                BC_types[wall][DENSITY][m]          = NEUMANN;
                BC_types[wall][DELPRESS][m]         = DIRICHLET;
                
                <FONT COLOR="570BA3">/* set the values of the neumann condition*/</FONT>
                BC_Values[wall][UVEL][m]            = BC_Values[wall][UVEL][m];
                BC_Values[wall][VVEL][m]            = BC_Values[wall][VVEL][m];
                BC_Values[wall][WVEL][m]            = BC_Values[wall][WVEL][m];
                BC_Values[wall][PRESS][m]           = 0.0;
                BC_Values[wall][TEMP][m]            = 0.0;
                BC_Values[wall][DENSITY][m]         = 0.0;
                BC_Values[wall][DELPRESS][m]        = 0.0; 
                
                <FONT COLOR="570BA3">/* set the fixed or float flags             */</FONT>
                BC_float_or_fixed[wall][UVEL][m]    = FIXED;
                BC_float_or_fixed[wall][VVEL][m]    = FIXED;
                BC_float_or_fixed[wall][WVEL][m]    = FIXED;
                BC_float_or_fixed[wall][PRESS][m]   = FLOAT;
                BC_float_or_fixed[wall][TEMP][m]    = FLOAT;
                BC_float_or_fixed[wall][DENSITY][m] = FLOAT;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED;
                
            }
            
            <FONT COLOR="570BA3">/*__________________________________
            *   subsonic outflow
            *   Velocity is set and pressure
            *   density and temperature can float
            *___________________________________*/</FONT>
             if(BC_inputs[wall][m] == SUBSONIC_OUTFLOW_V2)
            {
                BC_types[wall][UVEL][m]             = NEUMANN;
                BC_types[wall][VVEL][m]             = NEUMANN;
                BC_types[wall][WVEL][m]             = NEUMANN;
                BC_types[wall][TEMP][m]             = NEUMANN;
                BC_types[wall][PRESS][m]            = DIRICHLET;
                BC_types[wall][DENSITY][m]          = NEUMANN;
                BC_types[wall][DELPRESS][m]         = DIRICHLET;
                
                <FONT COLOR="570BA3">/* set the values of the neumann condition*/</FONT>
                BC_Values[wall][UVEL][m]            = 0.0;
                BC_Values[wall][VVEL][m]            = 0.0;
                BC_Values[wall][WVEL][m]            = 0.0;
                BC_Values[wall][PRESS][m]           = BC_Values[wall][PRESS][m];
                BC_Values[wall][TEMP][m]            = 0.0;
                BC_Values[wall][DENSITY][m]         = 0.0;
                BC_Values[wall][DELPRESS][m]        = 0.0; 
                
                <FONT COLOR="570BA3">/* set the fixed or float flags             */</FONT>
                BC_float_or_fixed[wall][UVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][VVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][WVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][PRESS][m]   = FIXED;
                BC_float_or_fixed[wall][TEMP][m]    = FLOAT;
                BC_float_or_fixed[wall][DENSITY][m] = FLOAT;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED; 
            }
            <FONT COLOR="570BA3">/*__________________________________
            *   REFLECTIVE
            *   Velocity,pressure
            *   density and temperature all float
            *___________________________________*/</FONT>

             if(BC_inputs[wall][m] == REFLECTIVE)
            {
                <FONT COLOR="570BA3">/*__________________________________
                *   Left and right walls
                *___________________________________*/</FONT>
                if (wall == LEFT || wall == RIGHT)
                {
                    BC_types[wall][UVEL][m]         = DIRICHLET;
                    BC_types[wall][VVEL][m]         = NEUMANN;
                    BC_types[wall][WVEL][m]         = NEUMANN;
                    
                    BC_float_or_fixed[wall][UVEL][m]= FIXED;
                    BC_float_or_fixed[wall][VVEL][m]= FLOAT;
                    BC_float_or_fixed[wall][WVEL][m]= FLOAT;
                }
                <FONT COLOR="570BA3">/*__________________________________
                *   Top and bottom walls
                *___________________________________*/</FONT>
                if (wall == TOP || wall == BOTTOM)
                {
                    BC_types[wall][UVEL][m]         = NEUMANN;
                    BC_types[wall][VVEL][m]         = DIRICHLET;
                    BC_types[wall][WVEL][m]         = NEUMANN;
                    
                    BC_float_or_fixed[wall][UVEL][m]= FLOAT;
                    BC_float_or_fixed[wall][VVEL][m]= FIXED;
                    BC_float_or_fixed[wall][WVEL][m]= FLOAT;
                } 

                BC_types[wall][TEMP][m]             = NEUMANN;
                BC_types[wall][PRESS][m]            = NEUMANN;
                BC_types[wall][DENSITY][m]          = NEUMANN;
                BC_types[wall][DELPRESS][m]         = DIRICHLET;
                
                <FONT COLOR="570BA3">/* set the values of the neumann and dirichlet condition*/</FONT>
                BC_Values[wall][UVEL][m]            = 0.0;
                BC_Values[wall][VVEL][m]            = 0.0;
                BC_Values[wall][WVEL][m]            = 0.0;
                BC_Values[wall][PRESS][m]           = 0.0;
                BC_Values[wall][TEMP][m]            = 0.0;
                BC_Values[wall][DENSITY][m]         = 0.0;
                BC_Values[wall][DELPRESS][m]        = 0.0; 
                
                <FONT COLOR="570BA3">/* set the fixed or float flags             */</FONT>
                BC_float_or_fixed[wall][PRESS][m]   = FLOAT;
                BC_float_or_fixed[wall][TEMP][m]    = FLOAT;
                BC_float_or_fixed[wall][DENSITY][m] = FLOAT;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED;
            }            

<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
            <FONT COLOR="570BA3">/*__________________________________
            *   All_NEUMANN
            *   Velocity,pressure
            *   density and temperature all float
            *___________________________________*/</FONT>
             if(BC_inputs[wall][m] == ALL_NEUMAN)
            {
                BC_types[wall][UVEL][m]             = NEUMANN;
                BC_types[wall][VVEL][m]             = NEUMANN;
                BC_types[wall][WVEL][m]             = NEUMANN;
                BC_types[wall][TEMP][m]             = NEUMANN;
                BC_types[wall][PRESS][m]            = NEUMANN;
                BC_types[wall][DENSITY][m]          = NEUMANN;
                BC_types[wall][DELPRESS][m]         = DIRICHLET;
                
                <FONT COLOR="570BA3">/* set the values of the neumann condition*/</FONT>
                BC_Values[wall][UVEL][m]            = BC_Values[wall][UVEL][m];
                BC_Values[wall][VVEL][m]            = BC_Values[wall][VVEL][m];
                BC_Values[wall][WVEL][m]            = BC_Values[wall][WVEL][m];
                BC_Values[wall][PRESS][m]           = BC_Values[wall][PRESS][m];
                BC_Values[wall][TEMP][m]            = BC_Values[wall][TEMP][m];
                BC_Values[wall][DENSITY][m]         = BC_Values[wall][DENSITY][m];
                BC_Values[wall][DELPRESS][m]        = 0;                

                <FONT COLOR="570BA3">/* set the fixed or float flags             */</FONT>
                BC_float_or_fixed[wall][UVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][VVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][WVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][PRESS][m]   = FLOAT;
                BC_float_or_fixed[wall][TEMP][m]    = FLOAT;
                BC_float_or_fixed[wall][DENSITY][m] = FLOAT;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED; 
                <FONT COLOR="570BA3">/*__________________________________
                *   Left and right walls
                *___________________________________*/</FONT>
                if (wall == LEFT )
                   BC_Values[LEFT][DELPRESS][m]      = -1.0; 
                if (wall == RIGHT )
                   BC_Values[RIGHT][DELPRESS][m]     = 1.0;
            }
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
 
 <FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
            <FONT COLOR="570BA3">/*__________________________________
            *   All_PERIODIC
            *   Velocity,pressure
            *   density and temperature all float
            *    equal to the the value on the opposing 
            *   wall
            *___________________________________*/</FONT>
             if(BC_inputs[wall][m] == ALL_PERIODIC)
            {
                BC_types[wall][UVEL][m]             = PERIODIC;
                BC_types[wall][VVEL][m]             = PERIODIC;
                BC_types[wall][WVEL][m]             = PERIODIC;
                BC_types[wall][TEMP][m]             = PERIODIC;
                BC_types[wall][PRESS][m]            = NEUMANN;
                BC_types[wall][DENSITY][m]          = NEUMANN;
                BC_types[wall][DELPRESS][m]         = DIRICHLET;
                
                <FONT COLOR="570BA3">/* set the values of the neumann condition*/</FONT>
                BC_Values[wall][UVEL][m]            = 0.0;
                BC_Values[wall][WVEL][m]            = 0.0;
                BC_Values[wall][PRESS][m]           = 0.0;
                BC_Values[wall][TEMP][m]            = 0.0;
                BC_Values[wall][DENSITY][m]         = 0.0;
                BC_Values[wall][DENSITY][m]         = 0.0;
                BC_Values[wall][DELPRESS][m]        = 0.0;              

                <FONT COLOR="570BA3">/* set the fixed or float flags             */</FONT>
                BC_float_or_fixed[wall][UVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][VVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][WVEL][m]    = FLOAT;
                BC_float_or_fixed[wall][PRESS][m]   = FLOAT;
                BC_float_or_fixed[wall][TEMP][m]    = FLOAT;
                BC_float_or_fixed[wall][DENSITY][m] = FLOAT;
                BC_float_or_fixed[wall][DELPRESS][m]= FIXED; 
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
                
            }
        }
    }       
}

<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="update_CC_physical_boundary_conditions">update_CC_physical_boundary_conditions</A>  BOUNDARY CONDITIONS: Visit all the ghost cells and reset the BC for each cell-centered variable.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function is used to set the values for each variable
            along the walls based on it's type (Neuman, Dirichlet) and whether
            it is a fixed or floating variable.  This function sets the cell-centered
            quantities ONLY.
            Currently this is setup so that the boundary conditions 
            are uniform for the entire wall, mixed boundary conditions 
            have not been implemented.
            
            The user can select from the following boundary conditons
            -no slip
            -subsonic input     (velocity components and rho are specified)    
            -subsonic outflow   (normal component of velocity)
            
Note on implementation:
            This function uses a variable length argument list.  For each data_array
            in the argument list the boundary conditions are set.
            The reason for doing it this way is simple.  In some instances we
            only need the velocity boundary conditions updated while other times we 
            need the pressure tweaked. 

Sticky Point:
            Each array that is passed into MUST also have a variable type
            passed in with it.  For example 
            
            Temp_CC,    TEMP,  
            rho_CC,     DENSITY
            ....
            
           Warning: type checking isn't done on the variables in the ... of the
           parameter list.
            
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/09/99    
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#update_CC_physical_boundary_conditions">update_CC_physical_boundary_conditions</A> 
              
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  delX,                       <FONT COLOR="570BA3">/* cell size in x-direction         (INPUT) */</FONT>
    double  delY,                       <FONT COLOR="570BA3">/* cell size in y-direction         (INPUT) */</FONT>
    double  delZ,                       <FONT COLOR="570BA3">/* cell size in z-directin          (INPUT) */</FONT>
    int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* types of boundary conditions             */</FONT>
                                        <FONT COLOR="570BA3">/* BC_types[wall][variable]=type            */</FONT>
    int     ***BC_float_or_fixed,       <FONT COLOR="570BA3">/* array that designates which variable is  */</FONT>
                                        <FONT COLOR="570BA3">/* either fixed or floating on each wall of */</FONT>
                                        <FONT COLOR="570BA3">/* the compuational domain                  */</FONT>
    double  ***BC_Values,               <FONT COLOR="570BA3">/* Values of the variables at the   (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* boundaries                       */</FONT> 
    int     nMaterials,                 <FONT COLOR="570BA3">/* number of materials              */</FONT>
    int     n_data_arrays,              <FONT COLOR="570BA3">/* number of data arrays            (INPUT) */</FONT>
    double  ****data_CC,                <FONT COLOR="570BA3">/* cell-centered data array         (IN/OUT)*/</FONT>
    int     var,...)                    <FONT COLOR="570BA3">/* used to designate whether        (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* the input array is UVEL,TEMP....         */</FONT>
                       
 {
    va_list ptr_data_array;             <FONT COLOR="570BA3">/* pointer to each data array       */</FONT>
    int     m,               
            array;                      <FONT COLOR="570BA3">/* array number                     */</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   double check inputs.
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now set the  physical boundary condtions for each dependent variable
*_______________________________________________________________________*/</FONT>
    va_start(ptr_data_array, n_data_arrays);
    array = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   Loop through each data array in the
    *   argument list
    *___________________________________*/</FONT> 
    for (array = 1; array &lt;=n_data_arrays; array++)
    {
        <FONT COLOR="570BA3">/*__________________________________
        *   Get the data array and var from
        *   the variable length argument list
        *___________________________________*/</FONT>
        data_CC = va_arg(ptr_data_array, double****); 
        var     = va_arg(ptr_data_array, int);
        for (m = 1; m &lt;= nMaterials; m++)
        { 
            <A href="#set_Dirichlet_BC">set_Dirichlet_BC</A>          
                                xLoLimit,       yLoLimit,      zLoLimit,
                                xHiLimit,       yHiLimit,      zHiLimit,
                                data_CC,        var,           
                                BC_types,       BC_Values,     m        );
            <A href="#set_Neumann_BC">set_Neumann_BC</A>          
                                xLoLimit,       yLoLimit,      zLoLimit,
                                xHiLimit,       yHiLimit,      zHiLimit,
                                delX,           delY,          delZ,
                                data_CC,        var,          
                                BC_types,       BC_Values,     
                                m        );
            <A href="#set_Periodic_BC">set_Periodic_BC</A>          
                                xLoLimit,        yLoLimit,      zLoLimit,
                                xHiLimit,        yHiLimit,      zHiLimit,
                                data_CC,         var,          
                                BC_types,        m );

            <A href="#set_corner_cells_BC">set_corner_cells_BC</A> 
                                xLoLimit,       yLoLimit,       zLoLimit,       
                                xHiLimit,       yHiLimit,       zHiLimit,       
                                data_CC,      
                                m        );
        }
                 
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
    #if switchDebug_update_CC_physical_boundary_conditions
        fprintf(stderr,"****************************************************************************\n");
        fprintf(stderr,"            UPDATE_CC_PHYSICAL_BOUNDARY_CONDITIONS\n");
        fprintf(stderr,"****************************************************************************\n");  
        for (m = 1; m &lt;= nMaterials; m++)
        {       
            fprintf(stderr,"\t Material %i \n",m);
            <A href="#printData_4d">printData_4d</A>       GC_LO(xLoLimit),     GC_LO(yLoLimit),       GC_LO(zLoLimit),
                                GC_HI(xHiLimit),     GC_HI(yHiLimit),       GC_HI(zHiLimit),
                                m,                  m,
                               "update_CC_physical_boundary_conditions",     
                               "data with ghost cells",                  data_CC);
        }

        fprintf(stderr,"****************************************************************************\n");         

        fprintf(stderr,"press return to continue\n");
        getchar();            
    #endif  

    }     

    va_end(ptr_data_array);                     <FONT COLOR="570BA3">/* clean up when done   */</FONT>            
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks is a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(BC_float_or_fixed);
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="update_CC_FC_physical_boundary_conditions">update_CC_FC_physical_boundary_conditions</A>  BOUNDARY CONDITIONS: Visit all the ghost cells and reset the BC for each cell-centered and face-centered variable.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function is used to set the values for each variable
            along the walls based on it's type (Neuman, Dirichlet) and whether
            it is a fixed or floating variable.  This function sets both
            the cell and face-centered quantities.
            Currently this is setup so that the boundary conditions 
            are uniform for the entire wall, mixed boundary conditions 
            have not been implemented.
            
            The user can select from the following boundary conditons
            -no slip
            -subsonic input     (velocity components and rho are specified)    
            -subsonic outflow   (normal component of velocity)
            
Note on implementation:
            This function uses a variable length argument list.  For each data_array
            in the argument list the boundary conditions are set.
            The reason for doing it this way is simple.  In some instances we
            only need the velocity boundary conditions updated while other times we 
            need the pressure tweaked. 

Sticky Point:
            Each array that is passed into MUST also have a variable type
            passed in with it.  For example 
            
            uvel_CC,    UVEL,   uvel_FC,   
            vvel_CC,    VVEL,   vvel_FC,
            wvel_CC,    WVEL,   wvel_FC,
            ....
            
           Warning: type checking isn't done on the variables in the ... of the
           parameter list.
            
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/09/99    
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#update_CC_FC_physical_boundary_conditions">update_CC_FC_physical_boundary_conditions</A> 
              
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  delX,                       <FONT COLOR="570BA3">/* cell size in x-direction         (INPUT) */</FONT>
    double  delY,                       <FONT COLOR="570BA3">/* cell size in y-direction         (INPUT) */</FONT>
    double  delZ,                       <FONT COLOR="570BA3">/* cell size in z-directin          (INPUT) */</FONT>
    int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* types of boundary conditions             */</FONT>
                                        <FONT COLOR="570BA3">/* BC_types[wall][variable]=type            */</FONT>
    int     ***BC_float_or_fixed,       <FONT COLOR="570BA3">/* array that designates which variable is  */</FONT>
                                        <FONT COLOR="570BA3">/* either fixed or floating on each wall of */</FONT>
                                        <FONT COLOR="570BA3">/* the compuational domain                  */</FONT>
    double ***BC_Values,                <FONT COLOR="570BA3">/* Values of the variables at the   (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* boundaries                       */</FONT> 
    int    nMaterials,                  <FONT COLOR="570BA3">/* number of materials              */</FONT>
    int    n_data_arrays,               <FONT COLOR="570BA3">/* number of data arrays            */</FONT>
    double ****data_CC,                 <FONT COLOR="570BA3">/* cell-centered data array         */</FONT>
    int     var,                        <FONT COLOR="570BA3">/* used to designate whether        */</FONT>
                                        <FONT COLOR="570BA3">/* the input array is UVEL,TEMP.... */</FONT>
    double ******data_FC, ...)          <FONT COLOR="570BA3">/* face-centered data               (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/*     (x,y,z,face, material)       */</FONT>              
                       
 {
    va_list ptr_data_array;             <FONT COLOR="570BA3">/* pointer to each data array       */</FONT>
    int    m,
            array;                      <FONT COLOR="570BA3">/* array number                     */</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   double check inputs.
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now set the  physical boundary condtions for each dependent variable
*_______________________________________________________________________*/</FONT>
    va_start(ptr_data_array, n_data_arrays);
    array = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   Loop through each data array in the
    *   argument list
    *___________________________________*/</FONT> 
    for (array = 1; array &lt;=n_data_arrays; array++)
    {
        <FONT COLOR="570BA3">/*__________________________________
        *   Get the data array and var from
        *   the variable length argument list
        *___________________________________*/</FONT>
        data_CC = va_arg(ptr_data_array, double****); 
        var     = va_arg(ptr_data_array, int);
        data_FC = va_arg(ptr_data_array, double******);

        for (m = 1; m &lt;= nMaterials; m++)
        { 
            <A href="#set_Dirichlet_BC">set_Dirichlet_BC</A>          
                                xLoLimit,        yLoLimit,      zLoLimit,
                                xHiLimit,        yHiLimit,      zHiLimit,
                                data_CC,         var,          
                                BC_types,        BC_Values,     m        );
            <A href="#set_Neumann_BC">set_Neumann_BC</A>          
                                 xLoLimit,       yLoLimit,      zLoLimit,
                                 xHiLimit,       yHiLimit,      zHiLimit,
                                 delX,           delY,          delZ,
                                 data_CC,        var,          
                                 BC_types,       BC_Values,     
                                 m        );

            <A href="#set_Periodic_BC">set_Periodic_BC</A>          
                                xLoLimit,        yLoLimit,      zLoLimit,
                                xHiLimit,        yHiLimit,      zHiLimit,
                                data_CC,         var,          
                                BC_types,        m );


            <A href="#set_corner_cells_BC">set_corner_cells_BC</A> 
                                xLoLimit,       yLoLimit,       zLoLimit,       
                                xHiLimit,       yHiLimit,       zHiLimit,       
                                data_CC,      
                                m        );

            <A href="#set_Dirichlet_BC_FC">set_Dirichlet_BC_FC</A>          
                                xLoLimit,       yLoLimit,       zLoLimit,
                                xHiLimit,       yHiLimit,       zHiLimit,
                                data_FC,        var,             
                                BC_types,       BC_Values,      BC_float_or_fixed,     
                                m        );

            <FONT COLOR="570BA3">/*__________________________________
            *   set the boundary conditions for
            *   both Neuman and Periodic
            *___________________________________*/</FONT>
           <A href="#set_Neumann_BC_FC">set_Neumann_BC_FC</A>          
                                xLoLimit,       yLoLimit,       zLoLimit,
                                xHiLimit,       yHiLimit,       zHiLimit,
                                data_CC,        data_FC,        var,
                                BC_types,       BC_float_or_fixed,     
                                m        );
      }  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
        #if switchDebug_update_CC_FC_physical_boundary_conditions
            fprintf(stderr,"****************************************************************************\n");
            fprintf(stderr,"            UPDATE_CC_FC_PHYSICAL_BOUNDARY_CONDITIONS\n");
            fprintf(stderr,"****************************************************************************\n");
           for (m = 1; m &lt;= nMaterials; m++)
           {          
                fprintf(stderr,"\t Material %i \n",m);
                <A href="#printData_4d">printData_4d</A>       GC_LO(xLoLimit),     GC_LO(yLoLimit),       GC_LO(zLoLimit),
                                    GC_HI(xHiLimit),     GC_HI(yHiLimit),       GC_HI(zHiLimit),
                                    m,                  m,
                                   "update_CC_FC_physical_boundary_conditions",     
                                   "data with ghost cells",     
                                                data_CC);

                <A href="#printData_6d">printData_6d</A>       GC_LO(xLoLimit),    GC_LO(yLoLimit),       (zLoLimit),
                                    GC_HI(xHiLimit),    GC_HI(yHiLimit),       (zHiLimit),
                                    TOP,                LEFT,
                                    m,                  m,
                                   "update_CC_FC_physical_boundary_conditions",     
                                   "data_FC with ghost cells",                  data_FC,        0);
            }

            fprintf(stderr,"****************************************************************************\n");         

            fprintf(stderr,"press return to continue\n");
            getchar();            
        #endif  

    }     

    va_end(ptr_data_array);                     <FONT COLOR="570BA3">/* clean up when done   */</FONT>            
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="set_Dirichlet_BC">set_Dirichlet_BC</A>  BOUNDARY CONDITIONS: Set the Dirichlet BC for each variable at the cell center.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function sets the boundary conditions along the walls
            of the computational domain for dependent variable.  This does
            NOT include the corner cells.  

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       08/22/99    
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#set_Dirichlet_BC">set_Dirichlet_BC</A> 
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  ****data_CC,                <FONT COLOR="570BA3">/* cell-centered data               (IN/OUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* data_CC(x,y,z, material)                 */</FONT>
    int     var,                        <FONT COLOR="570BA3">/* variable (TEMP,PRESS,UVEL,VVEL,DENSITY...*/</FONT>
    int     ***BC_types,                <FONT COLOR="570BA3">/* defines which boundary conditions(INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* have been set on each wall               */</FONT>
    double  ***BC_Values,               <FONT COLOR="570BA3">/* BC values BC_values[wall][variable(INPUT) */</FONT>
    int        nMaterials        )

 {
    int     i,j,k,m,                     <FONT COLOR="570BA3">/* indices                         */</FONT>
            wall,       
            xLo,        xHi, 
            yLo,        yHi, 
            zLo,        zHi,
            wallLo,     wallHi,
            should_I_leave;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(BC_types[wall][var][m] == DIRICHLET ) should_I_leave = NO;
           
        }
    }
    if (should_I_leave == YES) return;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now loop over all of the walls and set the appropriate BC
*   You need to find what the appropriate looping limits are for each 
*   different wall.
*_______________________________________________________________________*/</FONT>
            
    for( wall = wallLo; wall &lt;= wallHi; wall ++)
    {
        
        for(m = 1; m &lt;= nMaterials; m++)
        {
            if( BC_types[wall][var][m] == DIRICHLET)
            {
                 <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>                
                            xLoLimit,                  yLoLimit,                   zLoLimit,
                            xHiLimit,                  yHiLimit,                   zHiLimit,
                            &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                            &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                            wall    );
               <FONT COLOR="570BA3">/*__________________________________
               *   For each variable set the boundary condition
               *   if appropriate
               *___________________________________*/</FONT>

                for ( k = zLo; k &lt;= zHi; k++)
                {
                    for ( j = yLo; j &lt;= yHi; j++)
                    {
                        for ( i = xLo; i &lt;= xHi; i++)
                        {
                            <FONT COLOR="570BA3">/*__________________________________
                            *   Velocity BC
                            *___________________________________*/</FONT>
                            data_CC[i][j][k][m] = BC_Values[wall][var][m];

                        }
                    }
                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_set_Dirichlet_BC
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        SET_Dirichlet_BC\n");
    fprintf(stderr,"****************************************************************************\n");         
    for (m = 1; m &lt;= nMaterials; m++)
    {
        fprintf(stderr,"\t Material %i \n",m);
        <A href="#printData_4d">printData_4d</A>       GC_LO(xLoLimit),    GC_LO(yLoLimit),        GC_LO(zLoLimit),
                            GC_HI(xHiLimit),    GC_HI(yHiLimit),        GC_HI(zHiLimit),
                            m,                  m,
                           "set_Dirichlet_BC",     
                           "data_CC with ghost cells",                  uvel_CC);
    }

    fprintf(stderr,"****************************************************************************\n");             
    fprintf(stderr,"press return to continue\n");
    getchar();            
#endif

 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="set_Neumann_BC">set_Neumann_BC</A>  BOUNDARY CONDITIONS: Set the Neuman BC for each variable at the cell center.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function backs out the proper value for the dependent variable
            from the specified Neuman condition.  

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       09/17/99    

    Currently the differences are 1st order approximations
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#set_Neumann_BC">set_Neumann_BC</A> 
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                   <FONT COLOR="570BA3">/* cell size in x direction         (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* cell size in y direction         (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* cell size in z direction         (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* (*)vel_CC(x,y,z,material)                */</FONT>
        double  ****data_CC,            <FONT COLOR="570BA3">/* cell-centered data               (IN/OUT)*/</FONT>
        int     var,                    <FONT COLOR="570BA3">/* variable type (TEMP,PRESS,RHO,UVEL...... */</FONT>         
        int     ***BC_types,            <FONT COLOR="570BA3">/* defines which boundary conditions(INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* have been set on each wall               */</FONT>
        double  ***BC_Values,           <FONT COLOR="570BA3">/* BC values BC_values[wall][variable(INPUT)*/</FONT>
        int     nMaterials        )

 {
    int     m,                          <FONT COLOR="570BA3">/* indices                           */</FONT>
            wall,      
            xLo,        xHi, 
            yLo,        yHi, 
            zLo,        zHi,
            wallLo,     wallHi,
            should_I_leave;

<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1) 
        wallLo = LEFT;  wallHi = RIGHT;
#endif
#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(BC_types[wall][var][m] == NEUMANN ) should_I_leave = NO;
        }
    }
    if (should_I_leave == YES) return;
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now loop over all of the walls and set the appropriate BC
*   You need to find what the looping limits are for each 
*   side of the computational domain.  These limits don't include the 
*   corner cells
*_______________________________________________________________________*/</FONT>
           
    for( wall = wallLo; wall &lt;= wallHi; wall ++)
    {
        for(m = 1; m &lt;= nMaterials; m++)
        {        
            if( BC_types[wall][var][m] == NEUMANN)
            {
                <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>
                       xLoLimit,                  yLoLimit,                   zLoLimit,
                       xHiLimit,                  yHiLimit,                   zHiLimit,
                       &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                       &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                       wall    );
                <FONT COLOR="570BA3">/*__________________________________
                *   Now set the boundary conditions
                *___________________________________*/</FONT>

                     <A href="#neumann_BC_diffenence_formula">neumann_BC_diffenence_formula</A>
                        xLo,            yLo,            zLo,
                        xHi,            yHi,            zHi,
                        wall,
                        delX,            delY,          delZ,
                        data_CC,        BC_Values,      var,
                        m        );

            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_set_Neumann_BC
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        SET_NEUMANN_BC\n");
    fprintf(stderr,"****************************************************************************\n");         
    for (m = 1; m &lt;= nMaterials; m++)
    {
        fprintf(stderr,"\t Material %i \n",m);
        <A href="#printData_4d">printData_4d</A>       GC_LO(xLoLimit),    GC_LO(yLoLimit),       (zLoLimit),
                            GC_HI(xHiLimit),    GC_HI(yHiLimit),       (zHiLimit),
                            m,                  m,
                           "set_Neumann_BC",     
                           "data_FC with ghost cells",                  data_CC);
    }

    fprintf(stderr,"****************************************************************************\n");         
    
    fprintf(stderr,"press return to continue\n");
    getchar();            
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks is a way that
*   is compiler independent
*___________________________________*/</FONT>
           QUITE_FULLWARN(delZ);

 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="neumann_BC_diffenence_formula">neumann_BC_diffenence_formula</A>  BOUNDARY CONDITIONS: Definition of the differencing formula used when computing Neumann BC.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:   This function does the actual computation for the set_neuman_BC
            function  

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/7/99    

    Currently the differences are 1st order approximations
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#neumann_BC_diffenence_formula">neumann_BC_diffenence_formula</A> 
         int     xLo,             
         int     yLo,             
         int     zLo,             
         int     xHi,             
         int     yHi,             
         int     zHi,
         int     wall,             
         double  delX,                  <FONT COLOR="570BA3">/* cell size in x direction         (INPUT) */</FONT>
         double  delY,                  <FONT COLOR="570BA3">/* cell size in y direction         (INPUT) */</FONT>
         double  delZ,                  <FONT COLOR="570BA3">/* cell size in z direction         (INPUT) */</FONT>
         double  ****data_CC,           <FONT COLOR="570BA3">/* cell-centered data(i,j,k,m)      (IN/OUT)*/</FONT>
         double  ***BC_Values,          <FONT COLOR="570BA3">/* BC values BC_values[wall][var][m](INPUT)*/</FONT>
         int     var,                   <FONT COLOR="570BA3">/* name of the field dependent variable     */</FONT>
                                        <FONT COLOR="570BA3">/* UVEL, VVEL, WVEL,PRESS, TEMP, DENSITY    */</FONT>
         int     nMaterials        )
{         
    int i, j, k, m; 
    m = nMaterials;

    
   for ( i = xLo; i &lt;= xHi; i++ )
    {
        for ( j = yLo; j &lt;= yHi; j++ )
        {
            for ( k = zLo; k &lt;= zHi; k++ )
            {

               if ( wall == LEFT )
               {
                    data_CC[i][j][k][m] = data_CC[i+1][j][k][m]
                        - BC_Values[wall][var][m] * delX;
                }
               if ( wall == RIGHT )
               {
                    data_CC[i][j][k][m] = data_CC[i-1][j][k][m]
                        + BC_Values[wall][var][m] * delX;
                }
               if ( wall == TOP )
               {
                    data_CC[i][j][k][m] = data_CC[i][j-1][k][m]
                        + BC_Values[wall][var][m] * delY;
                }
                if ( wall == BOTTOM )
               {
                    data_CC[i][j][k][m] = data_CC[i][j+1][k][m]
                        - BC_Values[wall][var][m] * delY;
                }

            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks is a way that
*   is compiler independent
*___________________________________*/</FONT>
    delZ =delZ; 
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="set_Periodic_BC">set_Periodic_BC</A>  BOUNDARY CONDITIONS: Set the Periodic BC for each variable at the cell center.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function sets the boundary conditions along the walls
            of the computational domain for dependent variable.  This does
            NOT include the corner cells.  

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/10/99    
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#set_Periodic_BC">set_Periodic_BC</A> 
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  ****data_CC,                <FONT COLOR="570BA3">/* cell-centered data               (IN/OUT)*/</FONT>
                                        <FONT COLOR="570BA3">/* data_CC(x,y,z, material)                 */</FONT>
    int     var,                        <FONT COLOR="570BA3">/* variable (TEMP,PRESS,UVEL,VVEL,DENSITY...*/</FONT>
    int     ***BC_types,                <FONT COLOR="570BA3">/* defines which boundary conditions(INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* have been set on each wall               */</FONT>
    int        nMaterials        )

 {
    int     i,j,k,m,                     <FONT COLOR="570BA3">/* indices                         */</FONT>
            wall,       
            xLo,        xHi, 
            yLo,        yHi, 
            zLo,        zHi,
            wallLo,     wallHi,
            should_I_leave;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(BC_types[wall][var][m] == PERIODIC ) should_I_leave = NO;
           
        }
    }
    if (should_I_leave == YES) return;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Now loop over all of the walls and set the appropriate BC
*   You need to find what the appropriate looping limits are for each 
*   different wall.
*_______________________________________________________________________*/</FONT>
            
    for( wall = wallLo; wall &lt;= wallHi; wall ++)
    {
        
        for(m = 1; m &lt;= nMaterials; m++)
        {
            if( BC_types[wall][var][m] == PERIODIC)
            {
                 <A href="#find_loop_index_limits_at_domain_edges">find_loop_index_limits_at_domain_edges</A>                
                            xLoLimit,                  yLoLimit,                   zLoLimit,
                            xHiLimit,                  yHiLimit,                   zHiLimit,
                            &amp;xLo,                      &amp;yLo,                       &amp;zLo,
                            &amp;xHi,                      &amp;yHi,                       &amp;zHi,
                            wall    );
               <FONT COLOR="570BA3">/*__________________________________
               *   For each variable set the boundary condition
               *    I'm doing twice as much work as I need to
               *___________________________________*/</FONT>

                for ( k = zLo; k &lt;= zHi; k++)
                {
                    for ( j = yLo; j &lt;= yHi; j++)
                    {
                        for ( i = xLo; i &lt;= xHi; i++)
                        {
                            if ( wall == LEFT )
                            {
                                 data_CC[i][j][k][m] = data_CC[xHiLimit][j][k][m];
                             }
                            if ( wall == RIGHT )
                            {
                                 data_CC[i][j][k][m] = data_CC[xLoLimit][j][k][m];
                             } 
                             if ( wall == TOP )
                            {
                                 data_CC[i][j][k][m] = data_CC[i][yLoLimit][k][m];
                             }
                             if ( wall == BOTTOM )
                            {
                                 data_CC[i][j][k][m] = data_CC[i][yHiLimit][k][m];
                             } 
                            

                        }
                    }
                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING INFORMATION
*_______________________________________________________________________*/</FONT> 
#if switchDebug_set_Periodic_BC
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        SET_PERIODIC_BC\n");
    fprintf(stderr,"****************************************************************************\n");         
    for (m = 1; m &lt;= nMaterials; m++)
    {
        fprintf(stderr,"\t Material %i \n",m);
        <A href="#printData_4d">printData_4d</A>       GC_LO(xLoLimit),    GC_LO(yLoLimit),        GC_LO(zLoLimit),
                            GC_HI(xHiLimit),    GC_HI(yHiLimit),        GC_HI(zHiLimit),
                            m,                  m,
                           "set_Periodic_BC",     
                           "data_CC with ghost cells",                  data_CC);
    }

    fprintf(stderr,"****************************************************************************\n");             
    fprintf(stderr,"press return to continue\n");
    getchar();            
#endif

 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="set_corner_cells_BC">set_corner_cells_BC</A>  BOUNDARY CONDITIONS: Set the cell-center </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: boundary_cond.c
 Filename: boundary_cond.c
 Purpose:
            This function sets the primative cell-centered boundary conditions 
            in the corner ghost cells.  The value in the corner cell is assumed
            to be the average value of the intersecting walls

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       08/22/99    


CAVEAT:     This function must be called after set_Dirichlet_BC and
            set_Neuman_BC.
 ---------------------------------------------------------------------  */</FONT>
 
 void <A href="#set_corner_cells_BC">set_corner_cells_BC</A> 
              
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  ****data_CC,                <FONT COLOR="570BA3">/* cell-centered data               (IN/OUT)*/</FONT>
    int        m        )

 {
    int     i,j,k,                     <FONT COLOR="570BA3">/* indices                           */</FONT>
            zLo, zHi;
<FONT COLOR="570BA3">/*__________________________________
*   double check inputs 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*   NEED TO ADD THE 3D
*_______________________________________________________________________*/</FONT>
    i   = GC_LO(xLoLimit);
    j   = GC_HI(yHiLimit);
    zLo = GC_LO(zLoLimit);
    zHi = GC_HI(zHiLimit);
    for (k = zLo; k &lt;= zHi; k++)
    {
        data_CC[i][j][k][m]     = ( data_CC[i][j-1][k][m] + data_CC[i+1][j][k][m]) /2.0;
    }
<FONT COLOR="570BA3">/*__________________________________
*   Upper right ghostcell corner
*___________________________________*/</FONT>
    i = GC_HI(xHiLimit);
    j = GC_HI(yHiLimit);
    for (k = zLo; k &lt;= zHi; k++)
    {
        data_CC[i][j][k][m]     = ( data_CC[i][j-1][k][m] + data_CC[i-1][j][k][m]) /2.0;
    }
    
<FONT COLOR="570BA3">/*__________________________________
*   Lower right ghostcell corner
*___________________________________*/</FONT>
    i = GC_HI(xHiLimit);
    j = GC_LO(yLoLimit);
    k = zLoLimit;
    for (k = zLo; k &lt;= zHi; k++)
    {
        data_CC[i][j][k][m]     = ( data_CC[i][j+1][k][m] + data_CC[i-1][j][k][m]) /2.0;
    }
<FONT COLOR="570BA3">/*__________________________________
*   Lower left ghostcell corner
*___________________________________*/</FONT>
    i = GC_LO(xLoLimit);
    j = GC_LO(yLoLimit);
    for (k = zLo; k &lt;= zHi; k++)
    {   
        data_CC[i][j][k][m]     = ( data_CC[i][j+1][k][m] + data_CC[i+1][j][k][m]) /2.0;
    }
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="tecplot_FC">tecplot_FC</A>  TECPLOT: Main controlling code for write face-centered variables to a tecplot file. </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_FC.c
 Filename: output_FC.c
 
 Purpose:
   Write a binary file of all of the Face-centered variables
   that can be read by tecplot
   
 References: see the tecplot manual for details on the dump routines
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

POTENTIAL IMPROVEMENT:
 THIS IS STUPID IN THAT IT DUMPS ALL OF THE FACES.
IT SHOULD BE TWEAKED SO THAT ONLY THE RIGHT AND LEFT FACES ARE DUMPED
IN 1-D, LEFT, RIGHT,TOP AND BOTTOM FACES FOR 2D AND ALL FACES FOR 3D.

 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#tecplot_FC">tecplot_FC</A>
            int     xLoLimit,           <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
            int     yLoLimit,           <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
            int     zLoLimit,           <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
            int     xHiLimit,           <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
            int     yHiLimit,           <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
            int     zHiLimit,           <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
                                        <FONT COLOR="570BA3">/*-----------pointers---------------*/</FONT>
            double  *****x_FC,          <FONT COLOR="570BA3">/* x-coordinate of cell center      */</FONT>
            double  *****y_FC,          <FONT COLOR="570BA3">/* y-coordinate of cell center      */</FONT>
            double  *****z_FC,          <FONT COLOR="570BA3">/* z-coordinate of cell center      */</FONT>
                                        <FONT COLOR="570BA3">/* (x,y,z,face,material)            */</FONT>
                                        <FONT COLOR="570BA3">/*----------------------------------*/</FONT>
            double  ******uvel_FC,      <FONT COLOR="570BA3">/* u-cell-centered velocity (ptr)   */</FONT>
            double  ******vvel_FC,      <FONT COLOR="570BA3">/*  v-cell-centered velocity(ptr)   */</FONT>
            double  ******wvel_FC,      <FONT COLOR="570BA3">/* w cell-centered velocity (ptr)   */</FONT>
            int     fileNum,            <FONT COLOR="570BA3">/* num to add to the filename       */</FONT>
            char    output_file_basename[],         <FONT COLOR="570BA3">/* Description to put in the filename*/</FONT>
            char    title[],            <FONT COLOR="570BA3">/* title to put on plots            */</FONT>
            int     nMaterials      )   <FONT COLOR="570BA3">/* number of materials              */</FONT>
{
<FONT COLOR="570BA3">/*__________________________________
*   Local variables
*___________________________________*/</FONT>    
    char    fileName[20], 
            extension[] = ".plt",
            num[5];
    
    int     xHi, yHi, zHi,
            n_cell_faces;
    int     Debug, 
            I,
            DIsDouble, 
            VIsDouble;
    
<FONT COLOR="570BA3">/*__________________________________
* Define local variables
*___________________________________*/</FONT>
    Debug        = 0;
#if( switchDebug_output_FC || switch_output_FC_MM)  
     Debug       = 1;          <FONT COLOR="570BA3">/* 1= debug, 0 = no debugging       */</FONT>
#endif
     VIsDouble   = 1;          <FONT COLOR="570BA3">/* Double precision =1              */</FONT>
     DIsDouble   = 1;          <FONT COLOR="570BA3">/* Double precision =1              */</FONT>
     

<FONT COLOR="570BA3">/*______________________________________________________________________
* Main code
* First put together a file name, then open the file
*_______________________________________________________________________*/</FONT>
    sprintf(num,"%03d",fileNum);
    strcat(fileName,num);
    strcat(fileName,output_file_basename);
    strcat(fileName,"_FC");
    strcat(fileName,extension);           
            <FONT COLOR="570BA3">/*  "X_FC Y_FC Z_FC U_FC V_FC W_FC", */</FONT> 
    I = TECINI(title,
             "X_f_c Y_f_c Z_f_c U_f_c V_f_c W_f_c",
             fileName,
             ".",
             &amp;Debug,
             &amp;VIsDouble);
 <FONT COLOR="570BA3">/*__________________________________
 * Write the zone header information
 *___________________________________*/</FONT>
        xHi = (xHiLimit - xLoLimit + 1);
        yHi = (yHiLimit - yLoLimit + 1);
        zHi = (zHiLimit - zLoLimit + 1);     
#if (N_DIMENSIONS == 1)  
       n_cell_faces = 2;
       xHi = (xHiLimit - xLoLimit + 1) * 2;
#endif

#if (N_DIMENSIONS == 2) 
        n_cell_faces = 4;
        xHi = (xHiLimit - xLoLimit + 1) * 2;
        yHi = (yHiLimit - yLoLimit + 1) * 2;
#endif
#if (N_DIMENSIONS == 3) 
        n_cell_faces = 6;
        xHi = (xHiLimit - xLoLimit + 1) * 2;
        yHi = (yHiLimit - yLoLimit + 1) * 2;
        zHi = (zHiLimit - zLoLimit + 1) * 2; 
#endif    
    
    
    
    I = TECZNE("Face-Centered Data",
               &amp;xHi,          
               &amp;yHi,      
               &amp;zHi,
               "BLOCK",        NULL);

<FONT COLOR="570BA3">/*__________________________________
* Write out the Face-center coordinates
*___________________________________*/</FONT>
    <A href="#dumpArrayTecplotFC">dumpArrayTecplotFC</A>     xLoLimit,       yLoLimit,   zLoLimit,
                            xHiLimit,       yHiLimit,   zHiLimit,
                            x_FC );
                            
    <A href="#dumpArrayTecplotFC">dumpArrayTecplotFC</A>     xLoLimit,       yLoLimit,   zLoLimit,
                            xHiLimit,       yHiLimit,   zHiLimit,
                            y_FC);
                                
    <A href="#dumpArrayTecplotFC">dumpArrayTecplotFC</A>     xLoLimit,       yLoLimit,   zLoLimit,
                            xHiLimit,       yHiLimit,   zHiLimit,
                            z_FC); 

<FONT COLOR="570BA3">/*__________________________________
* Write out the Face-center velocities
*___________________________________*/</FONT>
     <A href="#dumpArrayTecplotFC_MM">dumpArrayTecplotFC_MM</A> xLoLimit,       yLoLimit,   zLoLimit,
                            xHiLimit,       yHiLimit,   zHiLimit,
                            uvel_FC,        nMaterials);
                            
    <A href="#dumpArrayTecplotFC_MM">dumpArrayTecplotFC_MM</A>  xLoLimit,       yLoLimit,   zLoLimit,
                            xHiLimit,       yHiLimit,   zHiLimit,
                            vvel_FC,        nMaterials);
                                
    <A href="#dumpArrayTecplotFC_MM">dumpArrayTecplotFC_MM</A>  xLoLimit,       yLoLimit,   zLoLimit,
                            xHiLimit,       yHiLimit,   zHiLimit,
                            wvel_FC,        nMaterials);  
<FONT COLOR="570BA3">/*__________________________________
* close file
*___________________________________*/</FONT>
    I = TECEND();  
    if (I == -1)
        <A href="#Message">Message</A>1,"ERROR: <A href="#tecplot_FC">tecplot_FC</A>)","There was a problem detected while writing out ",
       "the tecplot files, Now exiting");
           
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                       Wrote Tecplot file %s\n",fileName);
    fprintf(stderr,"****************************************************************************\n");
    
#if switchDebug_output_FC
        fprintf(stderr,"\n Exiting tecplotFC\n");
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    QUITE_FULLWARN(I);                  QUITE_FULLWARN(DIsDouble);
    QUITE_FULLWARN(n_cell_faces);

 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="dumpArrayTecplotFC">dumpArrayTecplotFC</A>  TECPLOT: Write a single material, face-centered array to a tecplot file.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_FC.c
 Filename: output_FC.c
 
 Purpose:
   copy a Face-centered array to a dummy array that tecplot can read and
   then dump it to the tecplot file, single fluid.  
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face
_______________________________________________________________________ 
 Prerequisites:  The functions TECINI and TECZNE MUST have been previously
 called.
 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#dumpArrayTecplotFC">dumpArrayTecplotFC</A>
            int     xLoLimit,           <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
            int     yLoLimit,           <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
            int     zLoLimit,           <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
            int     xHiLimit,           <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
            int     yHiLimit,           <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
            int     zHiLimit,           <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
            double  *****data_array  )
{
    int     i,j,k,f,                     <FONT COLOR="570BA3">/* Loop variables                   */</FONT>
            lim,
            faceLo,                     <FONT COLOR="570BA3">/* face looping indices             */</FONT> 
            faceHi,
            n_cell_faces,
                                                                            <FONT COLOR="570BA3">/*REFERENCED*/</FONT>
            I,
            III,                        <FONT COLOR="570BA3">/* number of values in that array   */</FONT>
            DIsDouble   = 1,            <FONT COLOR="570BA3">/* Array is double precision =1     */</FONT>
            counter     = 0;            <FONT COLOR="570BA3">/* counts the total number          */</FONT>
                                        <FONT COLOR="570BA3">/* of entries written to the x2     */</FONT> 
    double  *x2; 
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Code
*   Initialize the loop steps and array limits
*_______________________________________________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        faceLo = LEFT;  faceHi = RIGHT;
        n_cell_faces = 2;
#endif
#if (N_DIMENSIONS == 2) 
        faceLo = TOP;   faceHi = LEFT;
        n_cell_faces = 4;
#endif
#if (N_DIMENSIONS == 3) 
        faceLo = TOP;   faceHi = BACK;
        n_cell_faces = 6;
#endif

    lim     =   (xHiLimit - xLoLimit +1) * 
                (yHiLimit - yLoLimit +1) * 
                (zHiLimit - zLoLimit +1) * n_cell_faces;
<FONT COLOR="570BA3">/*__________________________________
*  Allocate memory for the dummy array
*___________________________________*/</FONT>                
    x2= dvector(0, lim ); 

<FONT COLOR="570BA3">/*__________________________________
* Fill the dummy array
*___________________________________*/</FONT>    
  
    for(k = zLoLimit; k &lt;= zHiLimit ; k++)
    {
        for(j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for(i = xLoLimit; i &lt;= xHiLimit; i++)
            {
                for(f = faceLo; f &lt;=faceHi; f++)
                {
                    x2[counter]= *data_array[i][j][k][f];
                    
                 }
            }
        }
    }    
<FONT COLOR="570BA3">/*__________________________________
* Print debugging if requested
*___________________________________*/</FONT> 
#if switchDebug_output_FC 
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        DUMPARRAYTECPLOTFC\n");
    fprintf(stderr,"****************************************************************************\n");

 <FONT COLOR="570BA3">/*    printData_FC    (       xLoLimit,       yLoLimit,       zLoLimit,
                            xHiLimit,       yHiLimit,       zHiLimit,
                           "dumpArrayTecplotFC,  "",        data_array); */</FONT>
#endif

<FONT COLOR="570BA3">/*__________________________________
* Write out the field data to the open
* tecplot file
*___________________________________*/</FONT>
    III = counter; 
     I   = TECDAT(&amp;III,&amp;x2[1],&amp;DIsDouble);
<FONT COLOR="570BA3">/*__________________________________
* deallocate the memory
*___________________________________*/</FONT>
    free_dvector(x2, 0, lim );
    
<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    QUITE_FULLWARN(I);

    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="dumpArrayTecplotFC_MM">dumpArrayTecplotFC_MM</A>  TECPLOT: Write a multimaterial, face-centered array to a tecplot file.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_FC.c
 Filename: output_FC.c
 
 Purpose:
   copy a Face-cented array to a dummy array that tecplot can read and
   then dump it to the tecplot file, multiple materials  
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

                                 ________ 
                                /  1    /|
                               /_______/ |
                              |       | ______(3)
                       (4)____| I,J,K |  |     
                              |       | /      
                              |_______|/
                                  |               (6) = back face
                                 (2)              (5) = front face
_______________________________________________________________________ 
 Prerequisites:  The functions TECINI and TECZNE MUST have been previously
 called.
 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#dumpArrayTecplotFC_MM">dumpArrayTecplotFC_MM</A> 
            int     xLoLimit,           <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
            int     yLoLimit,           <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
            int     zLoLimit,           <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
            int     xHiLimit,           <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
            int     yHiLimit,           <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
            int     zHiLimit,           <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
            double  ******data_array,
            int     nMaterials     )    <FONT COLOR="570BA3">/* number of materials              */</FONT>

{
    int     i,j,k,f,m,                  <FONT COLOR="570BA3">/* Loop variables                   */</FONT>
            lim,
            faceLo,                     <FONT COLOR="570BA3">/* face looping indices             */</FONT> 
            faceHi,
            n_cell_faces,                                                   
            I,
            III,                        <FONT COLOR="570BA3">/* number of values in that array   */</FONT>
            DIsDouble   = 1,            <FONT COLOR="570BA3">/* Array is double precision =1     */</FONT>
            counter     = 0;            <FONT COLOR="570BA3">/* counts the total number          */</FONT>
                                        <FONT COLOR="570BA3">/* of entries written to the x2     */</FONT> 
    double  *x2; 
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Code
*   Initialize the loop steps and array limits
*_______________________________________________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        faceLo = LEFT;  faceHi = RIGHT;
        n_cell_faces = 2;
#endif
#if (N_DIMENSIONS == 2) 
        faceLo = TOP;   faceHi = LEFT;
        n_cell_faces = 4;
#endif
#if (N_DIMENSIONS == 3) 
        faceLo = TOP;   faceHi = BACK;
        n_cell_faces = 6;
#endif

    lim     =   (xHiLimit - xLoLimit +1) * 
                (yHiLimit - yLoLimit +1) * 
                (zHiLimit - zLoLimit +1) * n_cell_faces;
<FONT COLOR="570BA3">/*__________________________________
*  Allocate memory for the dummy array
*___________________________________*/</FONT>                
    x2= dvector(0, lim ); 

<FONT COLOR="570BA3">/*__________________________________
* Fill the dummy array
*___________________________________*/</FONT>    
    for( m = 1; m &lt;= nMaterials; m++)
    { 
        for(k = zLoLimit; k &lt;= zHiLimit ; k++)
        {
            for(j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for(i = xLoLimit; i &lt;= xHiLimit; i++)
                {
                    for(f = faceLo; f &lt;=faceHi; f++)
                    {
                         x2[counter]= *data_array[i][j][k][f][m];
                     }
                }
            }
        }
    }
<FONT COLOR="570BA3">/*__________________________________
* Print debugging if requested
*___________________________________*/</FONT> 
#if switchDebug_output_FC_MM
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        DUMPARRAYTECPLOT_FC_MM\n");
    fprintf(stderr,"****************************************************************************\n");

    printData_FC_MF(   xLoLimit,       yLoLimit,       zLoLimit,
                       xHiLimit,       yHiLimit,       zHiLimit,
                       "dumpArrayTecplot_FC_MM",     "", data_array, m);
#endif 

<FONT COLOR="570BA3">/*__________________________________
* Write out the field data to the open
* tecplot file
*___________________________________*/</FONT>
    III = counter; 
     I   = TECDAT(&amp;III,&amp;x2[1],&amp;DIsDouble);
<FONT COLOR="570BA3">/*__________________________________
* deallocate the memory
*___________________________________*/</FONT>
    free_dvector(x2, 0, lim );
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    I = I;
    
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="tecplot_CC">tecplot_CC</A>  TECPLOT: controlling function for dumping tecplot files.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_CC.c
 Filename: output_CC.c
 
 Purpose:
   Write a binary file of all of the cell-centered variables
   that can be read by tecplot
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 
 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#tecplot_CC">tecplot_CC</A>

        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  ***x_CC,                <FONT COLOR="570BA3">/* x-coordinate of cell center      (INPUT) */</FONT>
        double  ***y_CC,                <FONT COLOR="570BA3">/* y-coordinate of cell center      (INPUT) */</FONT>
        double  ***z_CC,                <FONT COLOR="570BA3">/* z-coordinate of cell center      (INPUT) */</FONT>
        double  ****uvel_CC,            <FONT COLOR="570BA3">/* u-cell-centered velocity         (INPUT) */</FONT>
        double  ****vvel_CC,            <FONT COLOR="570BA3">/*  v-cell-centered velocity        (INPUT) */</FONT>
        double  ****wvel_CC,            <FONT COLOR="570BA3">/* w cell-centered velocity         (INPUT) */</FONT>
        double  ****Press_CC,           <FONT COLOR="570BA3">/* Cell-centered pressure           (INPUT) */</FONT>
        double  ****Temp_CC,            <FONT COLOR="570BA3">/* Cell-centered Temperature        (INPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  ****scalar1_CC,         <FONT COLOR="570BA3">/* Cell-centered scalars            (INPUT) */</FONT>
        double  ****scalar2_CC,
        double  ****scalar3_CC,
        int     fileNum,                <FONT COLOR="570BA3">/* num to add to the filename       (INPUT) */</FONT>
        char    output_file_basename[],
                                        <FONT COLOR="570BA3">/* Description to put in the filename(INPUT)*/</FONT>
        char    title[],                <FONT COLOR="570BA3">/* title to put on plots            (INPUT) */</FONT>
        int     nMaterials          )   <FONT COLOR="570BA3">/* number of materials              (INPUT) */</FONT>
{
<FONT COLOR="570BA3">/*__________________________________
*   Local variables
*___________________________________*/</FONT>    
    char    fileName[20], 
            extension[] = ".plt",
            num[5];
    
    int     Debug, 
            I,                                                            
            DIsDouble, 
            VIsDouble,
            xHi, 
            yHi, 
            zHi;
        
<FONT COLOR="570BA3">/*__________________________________
* Define local variables
*___________________________________*/</FONT>
     Debug       = 0;
#if (switchDebug_output_CC || switchDebug_output_CC_MM)
     Debug       = 1;                    <FONT COLOR="570BA3">/* 1= debug, 0 = no debugging       */</FONT>
#endif
     VIsDouble   = 1;                   <FONT COLOR="570BA3">/* Double precision =1              */</FONT>
     DIsDouble   = 1;                   <FONT COLOR="570BA3">/* Double precision =1              */</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
* Main code
* First put together a file name, then open the file
*_______________________________________________________________________*/</FONT>
    <FONT COLOR="570BA3">/* strcpy(fileName,"./Results/"); */</FONT>
    sprintf(num,"%03d",fileNum);
    strcat(fileName,num);
    strcat(fileName,output_file_basename);
    strcat(fileName,"_CC");
    strcat(fileName,extension);           
    I = TECINI(title,
             "X Y Z T P RHO U V W",
             fileName,
             ".",
             &amp;Debug,
             &amp;VIsDouble);
 <FONT COLOR="570BA3">/*__________________________________
 * Write the zone header information
 *___________________________________*/</FONT>
    xHi = xHiLimit - xLoLimit + 1;
    yHi = yHiLimit - yLoLimit + 1;
    zHi = zHiLimit - zLoLimit + 1; 
          
    I = TECZNE("Cell-Centered Data",
             &amp;xHi,
             &amp;yHi,
             &amp;zHi,
             "BLOCK",
             NULL);

<FONT COLOR="570BA3">/*__________________________________
* Write out the Cell-center coordinates
*___________________________________*/</FONT>
    <A href="#dumpArrayTecplotCC">dumpArrayTecplotCC</A>        xLoLimit,       yLoLimit,   zLoLimit,
                               xHiLimit,       yHiLimit,   zHiLimit,
                               x_CC );
 
    <A href="#dumpArrayTecplotCC">dumpArrayTecplotCC</A>        xLoLimit,       yLoLimit,   zLoLimit,
                               xHiLimit,       yHiLimit,   zHiLimit,
                               y_CC );
 
    <A href="#dumpArrayTecplotCC">dumpArrayTecplotCC</A>        xLoLimit,       yLoLimit,   zLoLimit,
                               xHiLimit,       yHiLimit,   zHiLimit,
                               z_CC );
<FONT COLOR="570BA3">/*__________________________________
* Write out the Cell-center temperature
* pressure and density
*___________________________________*/</FONT>
    <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>     xLoLimit,        yLoLimit,   zLoLimit,
                               xHiLimit,        yHiLimit,   zHiLimit,
                               Temp_CC,          nMaterials);
                            
    <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>     xLoLimit,        yLoLimit,   zLoLimit,
                               xHiLimit,        yHiLimit,   zHiLimit,
                               Press_CC ,       nMaterials);
                                
    <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>     xLoLimit,        yLoLimit,   zLoLimit,
                               xHiLimit,        yHiLimit,   zHiLimit,
                               rho_CC,          nMaterials );
<FONT COLOR="570BA3">/*__________________________________
* Write out the Cell-center velocities
*___________________________________*/</FONT>
    <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>     xLoLimit,        yLoLimit,   zLoLimit,
                               xHiLimit,        yHiLimit,   zHiLimit,
                               uvel_CC,         nMaterials );
                            
    <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>     xLoLimit,        yLoLimit,   zLoLimit,
                               xHiLimit,        yHiLimit,   zHiLimit,
                               vvel_CC,         nMaterials );
                                
    <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>     xLoLimit,        yLoLimit,   zLoLimit,
                               xHiLimit,        yHiLimit,   zHiLimit,
                               wvel_CC,         nMaterials ); 
<FONT COLOR="570BA3">/*__________________________________
* close file
*___________________________________*/</FONT>
    I = TECEND();
    if (I == -1)
        <A href="#Message">Message</A>1,"ERROR: <A href="#tecplot_CC">tecplot_CC</A>)","There was a problem detected while writing out ",
       "the tecplot files");
         
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                       Wrote Tecplot file %s\n",fileName);
    fprintf(stderr,"****************************************************************************\n");
    
#if switchDebug_output_CC
        fprintf(stderr,"\n Exiting tecplotCC\n");
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks
*___________________________________*/</FONT>
    QUITE_FULLWARN(scalar1_CC[0][0][0][1]);     QUITE_FULLWARN(scalar2_CC[0][0][0][1]);
    QUITE_FULLWARN(scalar3_CC[0][0][0][1]);
    DIsDouble = DIsDouble;                      I = I;
 }
    
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="dumpArrayTecplotCC">dumpArrayTecplotCC</A>  TECPLOT: Write a cell-centered,single material, array to a tecplot file.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_CC.c
 Filename: output_CC.c
 Purpose:
   copy a cell-centered array to a dummy array that tecplot can read and
   then dump it to the tecplot file.  Note that this only works for single
   fluid arrays, NOT, multifluid.  
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    
 Prerequisites:  The functions TECINI and TECZNE must have been previously
 called.
 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#dumpArrayTecplotCC">dumpArrayTecplotCC</A> 
            int     xLoLimit,           <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
            int     yLoLimit,           <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
            int     zLoLimit,           <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
            int     xHiLimit,           <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
            int     yHiLimit,           <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
            int     zHiLimit,           <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
 
            double  ***data_array )     <FONT COLOR="570BA3">/* array to dump to file            (INPUT) */</FONT>
{
    int     i,j,k,
            xlim,ylim,zlim,          <FONT COLOR="570BA3">/* temp array limits                   */</FONT>
            I,
            III,                     <FONT COLOR="570BA3">/* number of values in that array      */</FONT>
            DIsDouble   = 1,         <FONT COLOR="570BA3">/* Array is double precision =1        */</FONT>
            counter     = 0;
    double  ***x2; 
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Allocate memory for the dummy array and write the data to it 
*_______________________________________________________________________*/</FONT>  
    zlim = zHiLimit - zLoLimit ;
    ylim = yHiLimit - yLoLimit ;
    xlim = xHiLimit - xLoLimit;                 
    x2= darray_3d(0, zlim, 0, ylim, 0, xlim ); 
    
    for(k = 0; k &lt;= zlim; k++)
    {
        for(j = 0; j &lt;= ylim; j++)
        {
            for(i = 0; i &lt;= xlim; i++)
            {
                counter = counter + 1;
                 x2[k][j][i]= data_array[xLoLimit+i][yLoLimit+j][zLoLimit+k];
            }
        }
    }   
<FONT COLOR="570BA3">/*__________________________________
* Write out the field data to the open
* tecplot file
*___________________________________*/</FONT>
    III = counter; 
     I  = TECDAT(&amp;III,&amp;x2[0][0][0],&amp;DIsDouble);
<FONT COLOR="570BA3">/*__________________________________
* deallocate the memory
*___________________________________*/</FONT>
    free_darray_3d(x2,0, zlim, 0, ylim, 0, xlim );
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING
*_______________________________________________________________________*/</FONT>    
#if switchDebug_output_CC  
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        DUMPARRAYTECPLOTCC\n");
    fprintf(stderr,"****************************************************************************\n");
           
     fprintf(stderr,"\n");
     for(k = 0; k &lt;= zlim; k++)
     {
            for(j = 0; j &lt;= ylim; j++)
            {
                for(i = 0; i &lt;= xlim; i++)
                { 
                 fprintf(stderr,"[%d][%d][%d]=%lg  ",k,j,i,x2[k][j][i]); 
                }
                fprintf(stderr,"\n");
            }
            fprintf(stderr,"\n");
        }
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks is a way that
*   is compiler independent
*___________________________________*/</FONT>
    I = I;    

}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A>  TECPLOT: write a cell-centered, multimaterial array to a tecplot files.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_CC.c
 Filename: output_CC.c
 Purpose:
   copy a cell-centered array to a dummy array that tecplot can read and
   then dump it to the tecplot file.  Note that this works for multiple fluids.  
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       02/22/99    

 Prerequisites:  The functions TECINI and TECZNE must have been previously
 called.
 ---------------------------------------------------------------------  */</FONT>      

    void <A href="#dumpArrayTecplotCC_MM">dumpArrayTecplotCC_MM</A> 
            int     xLoLimit,           <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
            int     yLoLimit,           <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
            int     zLoLimit,           <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
            int     xHiLimit,           <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
            int     yHiLimit,           <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
            int     zHiLimit,           <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
            double  ****data_array,     <FONT COLOR="570BA3">/* array to dump to file            (INPUT) */</FONT>
            int     nMaterials)         <FONT COLOR="570BA3">/* number of materials              */</FONT>     
{
    int     i,j,k,m,                
            xlim,ylim,zlim,          <FONT COLOR="570BA3">/* temp array limits                   */</FONT>
            I,
            III,                     <FONT COLOR="570BA3">/* number of values in that array      */</FONT>
            DIsDouble   = 1,         <FONT COLOR="570BA3">/* Array is double precision =1        */</FONT>
            counter     = 0;
    double  ***x2; 
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Allocate memory for the dummy array and write the data to it 
*_______________________________________________________________________*/</FONT>  
    zlim = zHiLimit - zLoLimit ;
    ylim = yHiLimit - yLoLimit ;
    xlim = xHiLimit - xLoLimit;                 
    x2= darray_3d(0, zlim, 0, ylim, 0, xlim ); 
    
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for(k = 0; k &lt;= zlim; k++)
        {
            for(j = 0; j &lt;= ylim; j++)
            {
                for(i = 0; i &lt;= xlim; i++)
                {
                    counter = counter + 1;
                     x2[k][j][i]= data_array[xLoLimit+i][yLoLimit+j][zLoLimit+k][m];
                }
            }
        }
    }

<FONT COLOR="570BA3">/*__________________________________
* Write out the field data to the open
* tecplot file
*___________________________________*/</FONT>
    III  = counter; 
     I   = TECDAT(&amp;III,&amp;x2[0][0][0],&amp;DIsDouble);
<FONT COLOR="570BA3">/*__________________________________
* deallocate the memory
*___________________________________*/</FONT>
    free_darray_3d(x2,0, zlim, 0, ylim, 0, xlim );
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING
*_______________________________________________________________________*/</FONT>    
#if(switchDebug_output_CC_MM )
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        DUMPARRAYTECPLOTCC_MM\n");
    fprintf(stderr,"****************************************************************************\n");
              
    fprintf(stderr,"\n");
     for(k = 0; k &lt;= zlim; k++)
     {
         for(j = 0; j &lt;= ylim; j++)
         {
             for(i = 0; i &lt;= xlim; i++)
             {
              fprintf(stderr,"[%d][%d][%d]=%lg  ",k,j,i,x2[k][j][i]);
             }
             fprintf(stderr,"\n");
         }
         fprintf(stderr,"\n");
    }
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks is a way that
*   is compiler independent
*___________________________________*/</FONT>
    I = I;       
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="Is_it_time_to_write_output">Is_it_time_to_write_output</A>  OUTPUT: test to see if it is time to dump an output file or plot to the screen.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: output_misc.c
 Filename: output_misc.c
 Purpose:
   Test to see if it is time to dump an output file or plot to the screen.
   If it is then return YES if not then return NO.  A environmental variable
   is written telling whether or not to write the file. 
   
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       10/12/99    
 
 ---------------------------------------------------------------------  */</FONT> 
 int <A href="#Is_it_time_to_write_output">Is_it_time_to_write_output</A>
        double  t,                      <FONT COLOR="570BA3">/* current time                     */</FONT>
        double  *t_output_vars  )       <FONT COLOR="570BA3">/* array holding output timing info */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[1] = t_initial     */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[2] = t final       */</FONT>
                                        <FONT COLOR="570BA3">/* t_output_vars[3] = delta t       */</FONT>                                
{
    static double   told;
    static int      first_time_through;
    
    first_time_through ++; 
<FONT COLOR="570BA3">/*__________________________________
* Do this only the first time through
*___________________________________*/</FONT>
     if( t &gt;= t_output_vars[1] &amp;&amp; 
         t &lt;= t_output_vars[2] &amp;&amp;
         first_time_through == 1  )
    {
        told = t;
        putenv("SHOULD_I_WRITE_OUTPUT=1");
        return YES;
    }
    

<FONT COLOR="570BA3">/*__________________________________
*   For all other passes through routine
*   Add epsilon to the difference of t - told
*   because of roundoff error.
*___________________________________*/</FONT>   
    if( t &gt;= t_output_vars[1] &amp;&amp; 
        t &lt;= t_output_vars[2] &amp;&amp;
         ((fabs(t - told) + EPSILON ) &gt;= t_output_vars[3]) &amp;&amp;
        first_time_through != 1  )
    {
        told = t;
        putenv("SHOULD_I_WRITE_OUTPUT=1");
        return YES;
    }
    else
    {
        putenv("SHOULD_I_WRITE_OUTPUT=-9");
        return NO;
    } 
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="accumulate_energy_source_sinks">accumulate_energy_source_sinks</A>  SOURCE: Step 4, Accumulate all of the energy source terms.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: energy.c
 Filename: energy.c
 
 Computational Domain:
    The energy sources are accumulated at the cell-center of each
    cell of the domain.
    
Ghostcell data dependency: 
    None

 Purpose:   This function accumulates all of the sources/sinks of energy
            which is added to the current value for the energy to form
            the Lagrangian energy  
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       10/22/99 

 Currently the kinetic energy isn't 
 included.
 
 This is the routine where you would add additional sources/sinks of energy
                                 
 ---------------------------------------------------------------------  */</FONT>

void <A href="#accumulate_energy_source_sinks">accumulate_energy_source_sinks</A>
    int         xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
    int         yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
    int         zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
    int         xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
    int         yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
    int         zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
    double      delt,                   <FONT COLOR="570BA3">/* time increment                   (INPUT) */</FONT>
    double      delX,                   <FONT COLOR="570BA3">/* cell spacing                     (INPUT) */</FONT>
    double      delY,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      delZ,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      *grav,                  <FONT COLOR="570BA3">/* gravity (dir)                    (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* 1 = x, 2 = y, 3 = z              (INPUT) */</FONT>
    double      ****mass_CC,            <FONT COLOR="570BA3">/* cell-centered mass               (INPUT) */</FONT>
    double      ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
    double      ****press_CC,           <FONT COLOR="570BA3">/* Cell-center pressure             (INPUT) */</FONT>
    double      ****delPress_CC,        <FONT COLOR="570BA3">/* Cell-centered change in press.   (INPUT) */</FONT>
    double      ****Temp_CC,            <FONT COLOR="570BA3">/* Cell-centered Temperature        (INPUT) */</FONT>
    double      ****cv_CC,              <FONT COLOR="570BA3">/* Extra varialble for now          (INPUT) */</FONT>
    double      ****speedSound,         <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) (INPUT) */</FONT>
    double      ****uvel_CC,            <FONT COLOR="570BA3">/* cell-centered velocities         (INPUT) */</FONT>
    double      ****vvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****wvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****div_velFC_CC,       <FONT COLOR="570BA3">/* divergence of face centered vel. (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* that lives at the CC                     */</FONT>
    double      ****int_eng_source,     <FONT COLOR="570BA3">/* internal energy source/sink      (OUPUT) */</FONT>
    int         nMaterials   )
{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>

    double 
            A,B,C,                      <FONT COLOR="570BA3">/* terms in the equations           */</FONT>
            dummy,
            int_eng_source_tmp,         <FONT COLOR="570BA3">/* temporary variables that make    */</FONT>         
            switch_eng;                 <FONT COLOR="570BA3">/* = 1 calculate, =0 Don't calc.    */</FONT>  

            
    char    should_I_write_output;
    
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_accumulate_energy_source_sinks
    #include "plot_declare_vars.h"   
#endif
<FONT COLOR="570BA3">/*__________________________________
*   HARDWIRE FOR NOW amd initialize 
*   variables
*___________________________________*/</FONT>
    m           = nMaterials;
    dummy       = 0.0;
    switch_eng  = 1.0;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Calculate the terms in the 
*   right hand side of the energy eq.
*   This is where you calculate all of the
*   the additional sources/sinks of energy
*___________________________________*/</FONT>


<FONT COLOR="570BA3">/*__________________________________
*   Now accumulate the different contributions
*___________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {
                    <FONT COLOR="570BA3">/*__________________________________
                    * contribution from pressure
                    *___________________________________*/</FONT>  
                    int_eng_source_tmp          =   -delt * press_CC[i][j][k][m] * div_velFC_CC[i][j][k][m];
 
                     int_eng_source[i][j][k][m]  =   switch_eng * int_eng_source_tmp;

                }
            }
        }
    }

<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION   
*_______________________________________________________________________*/</FONT>
#if switchDebug_accumulate_energy_source_sinks
    should_I_write_output = *getenv("SHOULD_I_WRITE_OUTPUT");
    if ( should_I_write_output == '1')
    {
         #define switchInclude_accumulate_energy_source_sinks 1
         #include "debugcode.i"
         #undef switchInclude_accumulate_enegy_source_sinks
    }
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    QUITE_FULLWARN(delX);                   QUITE_FULLWARN(delY);
    QUITE_FULLWARN(delZ);
    QUITE_FULLWARN(delPress_CC[0][0][0][1]);                  
    QUITE_FULLWARN(mass_CC[0][0][0][1]);    QUITE_FULLWARN(speedSound[0][0][0][1]);
    QUITE_FULLWARN(rho_CC[0][0][0][1]);     QUITE_FULLWARN(Temp_CC[0][0][0][1]);
    QUITE_FULLWARN(cv_CC[0][0][0][1]);      QUITE_FULLWARN(grav[1]);
    QUITE_FULLWARN(uvel_CC[0][0][0][1]);    QUITE_FULLWARN(vvel_CC[0][0][0][1]);
    QUITE_FULLWARN(wvel_CC[0][0][0][1]);    QUITE_FULLWARN(nMaterials);
    should_I_write_output = should_I_write_output; 
    A        =   A;
    B        =   B;
    C        =   C;
    dummy    =   dummy;   
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="accumulate_momentum_source_sinks">accumulate_momentum_source_sinks</A>  SOURCE: Step 4, Accumulate all of the momentum source terms.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: momentum.c
 Filename: momentum.c
 Purpose:   This function accumulates all of the sources/sinks of momentum
            which is added to the current value for the momentum to form
            the Lagrangian momentum
            
 Computational Domain:
    For the pressure source term the face-centered pressure is needed from 
    all of the surrounding faces. 
    
 Ghostcell data dependency: 
    None    
   
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       10/13/99 
                                   
 ---------------------------------------------------------------------  */</FONT>

void <A href="#accumulate_momentum_source_sinks">accumulate_momentum_source_sinks</A>
    int         xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
    int         yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
    int         zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
    int         xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
    int         yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
    int         zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
    double      delt,                   <FONT COLOR="570BA3">/* time increment                   (INPUT) */</FONT>
    double      delX,                   <FONT COLOR="570BA3">/* cell spacing                     (INPUT) */</FONT>
    double      delY,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      delZ,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      *grav,                  <FONT COLOR="570BA3">/* gravity (dir)              (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* 1 = x, 2 = y, 3 = z              */</FONT>
    double      ****mass_CC,            <FONT COLOR="570BA3">/* cell-centered mass               (INPUT) */</FONT>
    double      ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
    double      ******press_FC,         <FONT COLOR="570BA3">/* Face-center pressure             (INPUT) */</FONT>
    double      ****Temp_CC,            <FONT COLOR="570BA3">/* Cell-centered Temperature        (INPUT) */</FONT>
    double      ****cv_CC,              <FONT COLOR="570BA3">/* Extra variable for now           (INPUT) */</FONT>
    double      ****uvel_CC,            <FONT COLOR="570BA3">/* cell-centered velocities         (INPUT) */</FONT>
    double      ****vvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****wvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ******tau_X_FC,         <FONT COLOR="570BA3">/* face-centered shear stress X-dir (OUTPUT)*/</FONT>
    double      ******tau_Y_FC,         <FONT COLOR="570BA3">/* face-centered shear stress Y-dir (OUTPUT)*/</FONT>
    double      ******tau_Z_FC,         <FONT COLOR="570BA3">/* face-centered shear stress Z-dir (OUTPUT)*/</FONT> 
    double      ****viscosity_CC,       <FONT COLOR="570BA3">/* cell centered viscosity          (INPUT) */</FONT>         
    double      ****xmom_source,        <FONT COLOR="570BA3">/* accumlated source/sink of momentum(OUPUT)*/</FONT>
    double      ****ymom_source,        <FONT COLOR="570BA3">/*          ---//---                (OUPUT) */</FONT>
    double      ****zmom_source,        <FONT COLOR="570BA3">/*          ---//---                (OUPUT) */</FONT>
    int         nMaterials   )
                                                          
{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>

    double  pressure_source,
            viscous_source,
            dummy,
            xmom_source_temp,           <FONT COLOR="570BA3">/* temporary variables that make    */</FONT>
            ymom_source_temp,           <FONT COLOR="570BA3">/* debugging easier                 */</FONT>
            zmom_source_temp,          
            switch_x,                   <FONT COLOR="570BA3">/* = 1 calculate, =0 Don't calc.    */</FONT>
            switch_y,                   <FONT COLOR="570BA3">/*          ---//---                */</FONT>
            switch_z;                   <FONT COLOR="570BA3">/*          ---//---                */</FONT>
            
    char    should_I_write_output;
              
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_accumulate_momentum_source_sinks
    #include "plot_declare_vars.h"   
#endif
<FONT COLOR="570BA3">/*__________________________________
*   initialize variables
*___________________________________*/</FONT>
    dummy   =0.0;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    
<FONT COLOR="570BA3">/*__________________________________
*  Depending on the dimensions of the
*   problem set some switches
*___________________________________*/</FONT>
#if(N_DIMENSIONS == 1)
    delZ        = 1.0;
    switch_x    = 1.0;
    switch_y    = 0.0;
    switch_z    = 0.0;
#endif
#if(N_DIMENSIONS == 2)
    delZ        = 1.0;
    switch_x    = 1.0;
    switch_y    = 1.0;
    switch_z    = 0.0;
#endif
#if(N_DIMENSIONS == 3)
    delZ        = 1.0;
    switch_x    = 1.0;
    switch_y    = 1.0;
    switch_z    = 1.0;
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Call the function that calculate
*   the viscous component
*   need to be written
*___________________________________*/</FONT>
#if switch_step4_stress_source_OnOff
    <A href="#shear_stress_Xdir">shear_stress_Xdir</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        viscosity_CC,   tau_X_FC,       nMaterials   );
                        
   <A href="#shear_stress_Ydir">shear_stress_Ydir</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        viscosity_CC,   tau_Y_FC,       nMaterials   );
    #if(N_DIMENSIONS == 3)                        
   <A href="#shear_stress_Zdir">shear_stress_Zdir</A>
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        uvel_CC,        vvel_CC,        wvel_CC,
                        viscosity_CC,   tau_Z_FC,       nMaterials   );
    #endif
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Now accumulate the different contributions
*___________________________________*/</FONT>
    for (m = 1; m &lt;= nMaterials; m++)
    { 
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {
                    <FONT COLOR="570BA3">/*__________________________________
                    *   x-momentum
                    *___________________________________*/</FONT>
                    pressure_source = *press_FC[i][j][k][RIGHT][m] - *press_FC[i][j][k][LEFT][m];

                    viscous_source  = *tau_X_FC[i][j][k][RIGHT][m] - *tau_X_FC[i][j][k][LEFT][m]
                                    + *tau_X_FC[i][j][k][TOP][m]   - *tau_X_FC[i][j][k][BOTTOM][m];
                    xmom_source_temp        =   delt * dummy - 
                                                delt * delY * delZ * pressure_source +
                                                delt * mass_CC[i][j][k][m] * grav[XDIR];
                    xmom_source[i][j][k][m] =   switch_x * xmom_source_temp;
                    <FONT COLOR="570BA3">/*__________________________________
                    *   y-momentum
                    *___________________________________*/</FONT>                             
                    pressure_source = *press_FC[i][j][k][TOP][m] - *press_FC[i][j][k][BOTTOM][m];

                    viscous_source  = *tau_Y_FC[i][j][k][RIGHT][m] - *tau_Y_FC[i][j][k][LEFT][m]
                                    + *tau_Y_FC[i][j][k][TOP][m]   - *tau_Y_FC[i][j][k][BOTTOM][m];                          
                    ymom_source_temp        =   delt * dummy - 
                                                delt * delX * delZ * pressure_source +
                                                delt * mass_CC[i][j][k][m] *grav[YDIR];

                    ymom_source[i][j][k][m] =   switch_y * ymom_source_temp;
                    <FONT COLOR="570BA3">/*__________________________________
                    *   z-momentum
                    *___________________________________*/</FONT>                            
                    pressure_source = *press_FC[i][j][k][FRONT][m] - *press_FC[i][j][k][BACK][m];  

                    viscous_source  = *tau_Z_FC[i][j][k][RIGHT][m] - *tau_Z_FC[i][j][k][LEFT][m]
                                    + *tau_Z_FC[i][j][k][TOP][m]   - *tau_Z_FC[i][j][k][BOTTOM][m]; 

                    zmom_source_temp        =   delt * dummy - 
                                                delt * delX * delY * pressure_source + 
                                                delt * mass_CC[i][j][k][m] *grav[ZDIR]; 

                    zmom_source[i][j][k][m] =   switch_z * zmom_source_temp;
                }
            }
        }
    }

<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="shear_stress_Xdir">shear_stress_Xdir</A>  SOURCE: Step 4,Compute the x-component of the shear stress</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: shear_stress.c
 Filename: shear_stress.c
 Purpose:   This function computes the x-component of the shear stress
            tau_xx, ta_yx, tau_zx for the left, right, top, bottom
            front and back faces.
            
 Computational Domain:
            The shear stress is computed on every face and in every cell 
            inside of the domain.
            
 Ghostcell data dependency: 
            This routine uses a single layer of ghostcells to compute the 
            viscosity and and edge velocities  
   
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/18/00 
                                   
 Implementation Note:
            find_transport_property_FC
            find_edge_vel__edge_is_parallel_w_(*)_axis 
            are inline functions.

Note currently I comput the shear stress for each face of the cell
I only need to do three of the faces, not all 6, with the pointers
equated
 ---------------------------------------------------------------------  */</FONT>
void <A href="#shear_stress_Xdir">shear_stress_Xdir</A>
    int         xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
    int         yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
    int         zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
    int         xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
    int         yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
    int         zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
    double      delX,                   <FONT COLOR="570BA3">/* cell spacing                     (INPUT) */</FONT>
    double      delY,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      delZ,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****uvel_CC,            <FONT COLOR="570BA3">/* cell-centered velocities         (INPUT) */</FONT>
    double      ****vvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****wvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****viscosity_CC,       <FONT COLOR="570BA3">/* cell centered viscosity          (INPUT) */</FONT>
    double      ******tau_X_FC,         <FONT COLOR="570BA3">/* face-centered shearstress        (OUTPUT)*/</FONT>
    int         nMaterials   )
                                                         
{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>
    double  *viscosity_FC,               <FONT COLOR="570BA3">/* effective viscosity at the face  */</FONT>
            term1,                      <FONT COLOR="570BA3">/* temporary terms                  */</FONT>
            term2,
            grad_1,
            grad_2;
            
    double  vvel_ED_top_right_z,        <FONT COLOR="570BA3">/* edge velocities                  */</FONT>        
            vvel_ED_top_left_z,
            vvel_ED_bottom_right_z,
            vvel_ED_bottom_left_z,
            wvel_ED_front_right_y,
            wvel_ED_front_left_y,
            wvel_ED_back_right_y,
            wvel_ED_back_left_y;
                                  
    double  *div_vel_FC;                <FONT COLOR="570BA3">/* face-centered divergenc of the   */</FONT> 
                                        <FONT COLOR="570BA3">/* velocity                         */</FONT>                
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_shear_stress_Xdir
    #include "plot_declare_vars.h"   
#endif
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
*   Allocate memory, initialize variables
*   
*___________________________________*/</FONT>
    viscosity_FC    = dvector(1, N_CELL_FACES);
    div_vel_FC      = dvector(1, N_CELL_FACES);
<FONT COLOR="570BA3">/*__________________________________
*   Now accumulate the different contributions
*___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {

                    <FONT COLOR="570BA3">/*__________________________________
                    * Calculate the viscosity at the face-centers
                    * and the velocity at edge on the cell
                    * These are inline functions defined 
                    * in inline.h
                    *___________________________________*/</FONT>
                    <A href="#find_transport_property_FC">find_transport_property_FC</A>i, j, k, m, viscosity_CC, viscosity_FC);

                    vvel_ED_top_right_z     = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i,  j,  k,  m);
                    vvel_ED_top_left_z      = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i-1,j,  k,  m);
                    vvel_ED_bottom_right_z  = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i,  j-1,k,  m);
                    vvel_ED_bottom_left_z   = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i-1,j-1,k,  m);

                    wvel_ED_front_right_y   = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>wvel_CC, i,  j,  k,  m);
                    wvel_ED_front_left_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>wvel_CC, i-1,j,  k,  m);
                    wvel_ED_back_right_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>wvel_CC, i,  j,  k-1,m);
                    wvel_ED_back_left_y     = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>wvel_CC, i-1,j,  k-1,m);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Compute the term due to compressibility
                    *___________________________________*/</FONT>
                    <A href="#divergence_of_velocity_for_tau_terms_FC">divergence_of_velocity_for_tau_terms_FC</A>
                                i,          j,          k,
                                delX,       delY,       delZ,                        
                                uvel_CC,    vvel_CC,    wvel_CC,
                                div_vel_FC, m);             
                    <FONT COLOR="570BA3">/*__________________________________
                    *  Left Face
                    *   tau_XX
                    *___________________________________*/</FONT>
                    term1           = 2.0       * viscosity_FC[LEFT] * (uvel_CC[i][j][k][m] - uvel_CC[i-1][j][k][m])/delX;
                    term2           = (2.0/3.0) * viscosity_FC[LEFT] * div_vel_FC[LEFT];

                    *tau_X_FC[i][j][k][LEFT][m] =  term1 - term2;

                    <FONT COLOR="570BA3">/*__________________________________
                    *  right Face
                    *   tau_XX
                    *___________________________________*/</FONT>       
                    term1           = 2.0       * viscosity_FC[RIGHT] * (uvel_CC[i+1][j][k][m] - uvel_CC[i][j][k][m])/delX;
                    term2           = (2.0/3.0) * viscosity_FC[RIGHT] * div_vel_FC[RIGHT];

                    *tau_X_FC[i][j][k][RIGHT][m] =  term1 - term2;               

                    <FONT COLOR="570BA3">/*__________________________________
                    *   Top Face
                    *   tau_YX
                    *___________________________________*/</FONT>  
                    grad_1          = (uvel_CC[i][j+1][k][m]    - uvel_CC[i][j][k][m])  /delY;
                    grad_2          = (vvel_ED_top_right_z      - vvel_ED_top_left_z)   /delX;

                    *tau_X_FC[i][j][k][TOP][m]   = viscosity_FC[TOP] * (grad_1 + grad_2);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Bottom Face
                    *   tau_YX
                    *___________________________________*/</FONT> 
                    grad_1          = (uvel_CC[i][j][k][m]      - uvel_CC[i][j-1][k][m])/delY;
                    grad_2          = (vvel_ED_bottom_right_z   - vvel_ED_bottom_left_z)/delX;

                    *tau_X_FC[i][j][k][BOTTOM][m]   = viscosity_FC[BOTTOM] * (grad_1 + grad_2);

    #if (N_DIMENSIONS == 3)                
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Front Face
                    *   tau_ZX
                    *___________________________________*/</FONT>
                    grad_1          = (uvel_CC[i][j][k+1][m]    - uvel_CC[i][j][k][m])  /delZ;
                    grad_2          = (wvel_ED_front_right_y    - wvel_ED_front_left_y) /delX;

                    *tau_X_FC[i][j][k][FRONT][m]   = viscosity_FC[FRONT] * (grad_1 + grad_2);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Back Face
                    *   tau_ZX
                    *___________________________________*/</FONT>
                    grad_1          = (uvel_CC[i][j][k][m]      - uvel_CC[i][j][k-1][m])/delZ;
                    grad_2          = (wvel_ED_back_right_y     - wvel_ED_back_left_y)  /delX;

                    *tau_X_FC[i][j][k][BACK][m]   = viscosity_FC[BACK] * (grad_1 + grad_2);
    #endif
                }
            }
        }
    }

<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION   
*_______________________________________________________________________*/</FONT>
#if switchDebug_shear_stress_Xdir
     #define switchInclude_shear_stress_Xdir 1
     #include "debugcode.i"
     #undef switchInclude_shear_stress_Xdir
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Free the local memory
*___________________________________*/</FONT>
    free_dvector( div_vel_FC,  1, N_CELL_FACES);
    free_dvector(viscosity_FC, 1, N_CELL_FACES);
<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    delZ                    = delZ;
    wvel_ED_front_right_y   = wvel_ED_front_right_y;  
    wvel_ED_front_left_y    = wvel_ED_front_left_y;   
    wvel_ED_back_right_y    = wvel_ED_back_right_y;
    wvel_ED_back_left_y     = wvel_ED_back_left_y;                  
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="shear_stress_Ydir">shear_stress_Ydir</A>  SOURCE: Step 4,Compute the x-component of the shear stress</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: shear_stress.c
 Filename: shear_stress.c
 Purpose:   This function computes the y-component of the shear stress
            tau_xy, ta_yy, tau_zy for the left, right, top, bottom
            front and back faces.
            
 Computational Domain:
            The shear stress is computed on every face and in every cell 
            inside of the domain.
            
 Ghostcell data dependency: 
            This routine uses a single layer of ghostcells to compute the 
            viscosity and and edge velocities  
   
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/18/00 
                                   
 Implementation Note:
            find_transport_property_FC
            find_edge_vel__edge_is_parallel_w_(*)_axis 
            are inline functions.

Note currently I comput the shear stress for each face of the cell
I only need to do three of the faces, not all 6, with the pointers
equated
 ---------------------------------------------------------------------  */</FONT>
void <A href="#shear_stress_Ydir">shear_stress_Ydir</A>
    int         xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
    int         yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
    int         zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
    int         xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
    int         yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
    int         zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
    double      delX,                   <FONT COLOR="570BA3">/* cell spacing                     (INPUT) */</FONT>
    double      delY,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      delZ,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****uvel_CC,            <FONT COLOR="570BA3">/* cell-centered velocities         (INPUT) */</FONT>
    double      ****vvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****wvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****viscosity_CC,       <FONT COLOR="570BA3">/* cell centered viscosity          (INPUT) */</FONT>
    double      ******tau_Y_FC,         <FONT COLOR="570BA3">/* face-centered shearstress        (OUTPUT)*/</FONT>
    int         nMaterials   )
                                                         
{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>
    double  *viscosity_FC,               <FONT COLOR="570BA3">/* effective viscosity at the face  */</FONT>
            term1,                      <FONT COLOR="570BA3">/* temporary terms                  */</FONT>
            term2,
            grad_1,
            grad_2;
            
    double uvel_ED_right_top_z,         <FONT COLOR="570BA3">/* edge velocities                  */</FONT>
           uvel_ED_left_top_z,
           uvel_ED_right_bottom_z,
           uvel_ED_left_bottom_z,
           wvel_ED_front_top_x,
           wvel_ED_front_bottom_x,
           wvel_ED_back_top_x,
           wvel_ED_back_bottom_x;
                                  
    double  *div_vel_FC;                <FONT COLOR="570BA3">/* face-centered divergenc of the   */</FONT> 
                                        <FONT COLOR="570BA3">/* velocity                         */</FONT>                
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_shear_stress_Ydir
    #include "plot_declare_vars.h"   
#endif
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
*   Allocate memory, initialize variables
*   
*___________________________________*/</FONT>
    viscosity_FC    = dvector(1, N_CELL_FACES);
    div_vel_FC      = dvector(1, N_CELL_FACES);
<FONT COLOR="570BA3">/*__________________________________
*   Now accumulate the different contributions
*___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {

                    <FONT COLOR="570BA3">/*__________________________________
                    * Calculate the viscosity at the face-centers
                    * and the velocity at edge on the cell
                    * These are inline functions defined 
                    * in inline.h
                    *___________________________________*/</FONT>
                    <A href="#find_transport_property_FC">find_transport_property_FC</A>i, j, k, m, viscosity_CC, viscosity_FC);

                    uvel_ED_right_top_z     = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i,  j,  k,  m);
                    uvel_ED_left_top_z      = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i-1,j,  k,  m);
                    uvel_ED_right_bottom_z  = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i,  j-1,k,  m);
                    uvel_ED_left_bottom_z   = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>vvel_CC, i-1,j-1,k,  m);

                    wvel_ED_front_top_x     = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i,  j,  k,  m);
                    wvel_ED_front_bottom_x  = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i  ,j-1,k,  m);
                    wvel_ED_back_top_x      = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i,  j,  k-1,m);
                    wvel_ED_back_bottom_x   = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i  ,j-1,k-1,m);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Compute the term due to compressibility
                    *___________________________________*/</FONT>
                    <A href="#divergence_of_velocity_for_tau_terms_FC">divergence_of_velocity_for_tau_terms_FC</A>
                                i,          j,          k,
                                delX,       delY,       delZ,                        
                                uvel_CC,    vvel_CC,    wvel_CC,
                                div_vel_FC, m);             
                    <FONT COLOR="570BA3">/*__________________________________
                    *  Left Face
                    *   tau_XY
                    *___________________________________*/</FONT>
                    grad_1          = (uvel_ED_left_top_z       - uvel_ED_left_bottom_z)   /delY;
                    grad_2          = (vvel_CC[i][j][k][m]      - vvel_CC[i-1][j][k][m])    /delX;
                    *tau_Y_FC[i][j][k][LEFT][m] =  viscosity_FC[LEFT] * (grad_1 + grad_2);

                    <FONT COLOR="570BA3">/*__________________________________
                    *  right Face
                    *   tau_XY
                    *___________________________________*/</FONT>       
                    grad_1          = (uvel_ED_right_top_z      - uvel_ED_right_bottom_z)   /delY;
                    grad_2          = (vvel_CC[i+1][j][k][m]    - vvel_CC[i][j][k][m])      /delX;
                    *tau_Y_FC[i][j][k][RIGHT][m] =  viscosity_FC[RIGHT] * (grad_1 + grad_2);              

                    <FONT COLOR="570BA3">/*__________________________________
                    *   Top Face
                    *   tau_YY
                    *___________________________________*/</FONT>
                    term1           = 2.0       * viscosity_FC[TOP] * (vvel_CC[i][j+1][k][m] - vvel_CC[i][j][k][m])/delY;
                    term2           = (2.0/3.0) * viscosity_FC[TOP] * div_vel_FC[TOP];

                    *tau_Y_FC[i][j][k][TOP][m] =  term1 - term2;
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Bottom Face
                    *   tau_YY
                    *___________________________________*/</FONT> 
                    term1           = 2.0       * viscosity_FC[BOTTOM] * (vvel_CC[i][j][k][m] - vvel_CC[i][j-1][k][m])/delY;
                    term2           = (2.0/3.0) * viscosity_FC[BOTTOM] * div_vel_FC[BOTTOM];

                    *tau_Y_FC[i][j][k][BOTTOM][m] =  term1 - term2;

    #if (N_DIMENSIONS == 3)                
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Front Face
                    *   tau_ZY
                    *___________________________________*/</FONT>
                    grad_1          = (vvel_CC[i][j][k+1][m]    - vvel_CC[i][j][k][m])      /delZ;
                    grad_2          = (wvel_ED_front_top_x      - wvel_ED_front_bottom_x)   /delY2;

                    *tau_Y_FC[i][j][k][FRONT][m]   = viscosity_FC[FRONT] * (grad_1 + grad_2);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Back Face
                    *   tau_ZY
                    *___________________________________*/</FONT>
                    grad_1          = (vvel_CC[i][j][k][m]      - vvel_CC[i][j][k-1][m])    /delZ;
                    grad_2          = (wvel_ED_back_top_x       - wvel_ED_back_bottom_x)    /delY;

                    *tau_Y_FC[i][j][k][BACK][m]   = viscosity_FC[BACK] * (grad_1 + grad_2);
    #endif
                }
            }
        }
    }

<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION   
*_______________________________________________________________________*/</FONT>
#if switchDebug_shear_stress_Ydir
     #define switchInclude_shear_stress_Ydir 1
     #include "debugcode.i"
     #undef switchInclude_shear_stress_Ydir
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Free the local memory
*___________________________________*/</FONT>
    free_dvector( div_vel_FC,  1, N_CELL_FACES);
    free_dvector(viscosity_FC, 1, N_CELL_FACES);
<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    delZ                    = delZ;
    wvel_ED_front_top_x     = wvel_ED_front_top_x;  
    wvel_ED_front_bottom_x  = wvel_ED_front_bottom_x;   
    wvel_ED_back_top_x      = wvel_ED_back_top_x;
    wvel_ED_back_bottom_x   = wvel_ED_back_bottom_x;                  
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="shear_stress_Zdir">shear_stress_Zdir</A>  SOURCE: Step 4,Compute the x-component of the shear stress</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: shear_stress.c
 Filename: shear_stress.c
 Purpose:   This function computes the y-component of the shear stress
            tau_xz, ta_yz, tau_zz for the left, right, top, bottom
            front and back faces.
            
 Computational Domain:
            The shear stress is computed on every face and in every cell 
            inside of the domain.
            
 Ghostcell data dependency: 
            This routine uses a single layer of ghostcells to compute the 
            viscosity and and edge velocities  
   
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/18/00 
                                   
 Implementation Note:
            find_transport_property_FC
            find_edge_vel__edge_is_parallel_w_(*)_axis 
            are inline functions.

Note currently I comput the shear stress for each face of the cell
I only need to do three of the faces, not all 6, with the pointers
equated
 ---------------------------------------------------------------------  */</FONT>
void <A href="#shear_stress_Zdir">shear_stress_Zdir</A>
    int         xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
    int         yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
    int         zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
    int         xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
    int         yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
    int         zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT>
    double      delX,                   <FONT COLOR="570BA3">/* cell spacing                     (INPUT) */</FONT>
    double      delY,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      delZ,                   <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****uvel_CC,            <FONT COLOR="570BA3">/* cell-centered velocities         (INPUT) */</FONT>
    double      ****vvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****wvel_CC,            <FONT COLOR="570BA3">/*          ---//---                (INPUT) */</FONT>
    double      ****viscosity_CC,       <FONT COLOR="570BA3">/* cell centered viscosity          (INPUT) */</FONT>
    double      ******tau_Z_FC,         <FONT COLOR="570BA3">/* face-centered shearstress        (OUTPUT)*/</FONT>
    int         nMaterials   )
                                                         
{
    int     i, j, k, m;                 <FONT COLOR="570BA3">/* cell face locators               */</FONT>
    double  *viscosity_FC,               <FONT COLOR="570BA3">/* effective viscosity at the face  */</FONT>
            term1,                      <FONT COLOR="570BA3">/* temporary terms                  */</FONT>
            term2,
            grad_1,
            grad_2;
            
    double  uvel_ED_right_front_y,       <FONT COLOR="570BA3">/* edge velocities                  */</FONT>
            uvel_ED_left_front_y,
            uvel_ED_right_back_y,
            uvel_ED_left_back_y,
            vvel_ED_top_front_x,     
            vvel_ED_bottom_front_x,  
            vvel_ED_top_back_x,      
            vvel_ED_bottom_back_x;   
                                  
    double  *div_vel_FC;                <FONT COLOR="570BA3">/* face-centered divergenc of the   */</FONT> 
                                        <FONT COLOR="570BA3">/* velocity                         */</FONT>                
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_shear_stress_Zdir
    #include "plot_declare_vars.h"   
#endif
<FONT COLOR="570BA3">/*__________________________________
* double check inputs, 
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
<FONT COLOR="570BA3">/*__________________________________
*   Allocate memory, initialize variables
*   
*___________________________________*/</FONT>
    viscosity_FC    = dvector(1, N_CELL_FACES);
    div_vel_FC      = dvector(1, N_CELL_FACES);
    m               = nMaterials;

<FONT COLOR="570BA3">/*__________________________________
*   Now accumulate the different contributions
*___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++)
        {
            for ( j = yLoLimit; j &lt;= yHiLimit; j++)
            {
                for ( k = zLoLimit; k &lt;= zHiLimit; k++)
                {

                    <FONT COLOR="570BA3">/*__________________________________
                    * Calculate the viscosity at the face-centers
                    * and the velocity at edge on the cell
                    * These are inline functions defined 
                    * in inline.h
                    *___________________________________*/</FONT>
                    <A href="#find_transport_property_FC">find_transport_property_FC</A>i, j, k, m, viscosity_CC, viscosity_FC);

                    uvel_ED_right_front_y   = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>vvel_CC, i,  j,  k,  m);
                    uvel_ED_left_front_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>vvel_CC, i-1,j,  k,  m);
                    uvel_ED_right_back_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>vvel_CC, i,  j-1,k,  m);
                    uvel_ED_left_back_y     = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>vvel_CC, i-1,j-1,k,  m);

                    vvel_ED_top_front_x     = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i,  j,  k,  m);
                    vvel_ED_bottom_front_x  = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i  ,j-1,k,  m);
                    vvel_ED_top_back_x      = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i,  j,  k-1,m);
                    vvel_ED_bottom_back_x   = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>wvel_CC, i  ,j-1,k-1,m);
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Compute the term due to compressibility
                    *___________________________________*/</FONT>
                    <A href="#divergence_of_velocity_for_tau_terms_FC">divergence_of_velocity_for_tau_terms_FC</A>
                                i,          j,          k,
                                delX,       delY,       delZ,                        
                                uvel_CC,    vvel_CC,    wvel_CC,
                                div_vel_FC, m);             
                    <FONT COLOR="570BA3">/*__________________________________
                    *  Left Face
                    *   tau_XZ
                    *___________________________________*/</FONT>
                    grad_1          = (uvel_ED_left_front_y     - uvel_ED_left_back_y)      /delZ;
                    grad_2          = (wvel_CC[i][j][k][m]      - wvel_CC[i-1][j][k][m])    /delX;
                    *tau_Z_FC[i][j][k][LEFT][m] =  viscosity_FC[LEFT] * (grad_1 + grad_2);

                    <FONT COLOR="570BA3">/*__________________________________
                    *  right Face
                    *   tau_XZ
                    *___________________________________*/</FONT>       
                    grad_1          = (uvel_ED_right_front_y    - uvel_ED_right_back_y)     /delZ;
                    grad_2          = (wvel_CC[i+1][j][k][m]    - wvel_CC[i][j][k][m])      /delX;
                    *tau_Z_FC[i][j][k][RIGHT][m] =  viscosity_FC[RIGHT] * (grad_1 + grad_2);              

                    <FONT COLOR="570BA3">/*__________________________________
                    *   Top Face
                    *   tau_YZ
                    *___________________________________*/</FONT>
                    grad_1          = (vvel_ED_top_front_x      - vvel_ED_top_back_x)       /delZ;
                    grad_2          = (wvel_CC[i][j+1][k][m]    - wvel_CC[i][j][k][m])      /delY;
                    *tau_Z_FC[i][j][k][TOP][m] =  viscosity_FC[TOP] * (grad_1 + grad_2);     

                    *tau_Z_FC[i][j][k][TOP][m] =  term1 - term2;
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Bottom Face
                    *   tau_YZ
                    *___________________________________*/</FONT> 
                    grad_1          = (vvel_ED_bottom_front_x   - vvel_ED_bottom_back_x)     /delZ;
                    grad_2          = (wvel_CC[i][j][k][m]      - wvel_CC[i][j][k-1][m])     /delY;
                    *tau_Z_FC[i][j][k][BOTTOM][m] =  viscosity_FC[BOTTOM] * (grad_1 + grad_2);     

                    *tau_Z_FC[i][j][k][BOTTOM][m] =  term1 - term2;

    #if (N_DIMENSIONS == 3)                
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Front Face
                    *   tau_ZZ
                    *___________________________________*/</FONT>
                    term1           = 2.0       * viscosity_FC[FRONT] * (wvel_CC[i][j][k+1][m] - wvel_CC[i][j][k][m])/delZ;
                    term2           = (2.0/3.0) * viscosity_FC[FRONT] * div_vel_FC[FRONT];

                    *tau_Y_FC[i][j][k][FRONT][m] =  term1 - term2;
                    <FONT COLOR="570BA3">/*__________________________________
                    *   Back Face
                    *   tau_ZZ
                    *___________________________________*/</FONT>
                    term1           = 2.0       * viscosity_FC[BACK] * (wvel_CC[i][j][k][m] - wvel_CC[i][j][k-1][m])/delZ;
                    term2           = (2.0/3.0) * viscosity_FC[BACK] * div_vel_FC[BACK];

                    *tau_Y_FC[i][j][k][BACK][m] =  term1 - term2;
    #endif
                }
            }
        }
    }
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING SECTION   
*_______________________________________________________________________*/</FONT>
#if switchDebug_shear_stress_Zdir
     #define switchInclude_shear_stress_Zdir 1
     #include "debugcode.i"
     #undef switchInclude_shear_stress_Zdir
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Free the local memory
*___________________________________*/</FONT>
    free_dvector( div_vel_FC,  1, N_CELL_FACES);
    free_dvector(viscosity_FC, 1, N_CELL_FACES);
<FONT COLOR="570BA3">/*__________________________________
*   Quite all fullwarn compiler remarks
*___________________________________*/</FONT>
    delZ    = delZ;
    wvel_CC = wvel_CC;           
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>  SOURCE: Step 4,compute edge velocities</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: inline.h
 Filename: inline.h
 Purpose:   Compute the velocity at the edge of a cell.  The edge
            must be parallel with the x-axis.  The edge velocity is simply
            the average of the velocities in the four surrounding cell that share
            the edge.
            
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/19/00  
             
 Implementation Note:
            This function has been inlined to speed it up since it is called 
            for every cell.                            
 ---------------------------------------------------------------------  */</FONT>        
inline double <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A>
        double ****data_CC,
        int     i,
        int     j,
        int     k,
        int     m )             
{ 
    double temp;         
      temp =    0.25 * (data_CC[i][j][k][m]     + data_CC[i][j][k+1][m]  
                     +  data_CC[i][j+1][k][m]   + data_CC[i][j+1][k+1][m]);
    return temp;
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>  SOURCE: Step 4,compute edge velocities</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: inline.h
 Filename: inline.h
 Purpose:   Compute the velocity at the edge of a cell.  The edge
            must be parallel with the Y-axis.  The edge velocity is simply
            the average of the velocities in the four surrounding cell that share
            the edge.
            
 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/19/00  
             
 Implementation Note:
            This function has been inlined to speed it up since it is called 
            for every cell.                            
 ---------------------------------------------------------------------  */</FONT>        
inline double <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A>
        double ****data_CC,
        int     i,
        int     j,
        int     k,
        int     m )
{     
    double temp;
         
      temp =    0.25 * (data_CC[i][j][k][m]     + data_CC[i+1][j][k][m]
                     +  data_CC[i][j][k+1][m]   + data_CC[i+1][j][k+1][m]);
    return temp;
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>  SOURCE: Step 4,compute edge velocities</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: inline.h
 Filename: inline.h
 Purpose:   compute the velocity at the edge of the cell.  The edge
            must be parallel with the z-axis.  The edge velocity is simply
            the average of the velocities in the four surrounding cells that share
            the edge.

 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/19/00  
             
 Implementation Note:
            This function has been inlined to speed it up since it is called 
            for every cell.                            
 ---------------------------------------------------------------------  */</FONT>        
inline double <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A>
        double ****data_CC,
        int     i,
        int     j,
        int     k,
        int     m )
{
    double temp;          
      temp =  0.25 * (data_CC[i][j][k][m]     + data_CC[i+1][j][k][m]        
                   +  data_CC[i][j+1][k][m]   + data_CC[i+1][j+1][k][m]);
    return temp;
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="find_transport_property_FC">find_transport_property_FC</A>  SOURCE: Step 4,used to compute the source terms</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: inline.h
 Filename: inline.h
 Purpose:   compute the face-centered transport properties 

 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/19/00       
 Implementation Note:
 This function has been inlined to speed it up since it is called 
 for every cell.                            
 ---------------------------------------------------------------------  */</FONT>        
inline void <A href="#find_transport_property_FC">find_transport_property_FC</A>
        int     i,
        int     j,
        int     k,
        int     m,
        double ****data_CC,             <FONT COLOR="570BA3">/* cell-centered data               */</FONT>
        double *data_FC)                <FONT COLOR="570BA3">/* face-centered results            */</FONT>
{        
    <FONT COLOR="570BA3">/*__________________________________
    *   Right Face
    *___________________________________*/</FONT>   
    assert( data_CC[i][j][k][m] + data_CC[i+1][j][k][m] &gt; SMALL_NUM);           
    data_FC[RIGHT]  = (2.0 * data_CC[i][j][k][m] * data_CC[i+1][j][k][m])/
                            (data_CC[i][j][k][m] + data_CC[i+1][j][k][m]);
     <FONT COLOR="570BA3">/*__________________________________
     *  Left Face
     *___________________________________*/</FONT>     
    assert( data_CC[i][j][k][m] + data_CC[i-1][j][k][m] &gt; SMALL_NUM);          
    data_FC[LEFT]   = (2.0 * data_CC[i][j][k][m] * data_CC[i-1][j][k][m])/
                            (data_CC[i][j][k][m] + data_CC[i-1][j][k][m]);
                    
     <FONT COLOR="570BA3">/*__________________________________
     *  Top Face
     *___________________________________*/</FONT>     
    assert( data_CC[i][j][k][m] + data_CC[i][j+1][k][m] &gt; SMALL_NUM);          
    data_FC[TOP]    = (2.0 * data_CC[i][j][k][m] * data_CC[i][j+1][k][m])/
                            (data_CC[i][j][k][m] + data_CC[i][j+1][k][m]);
                    
     <FONT COLOR="570BA3">/*__________________________________
     *  Bottom Face
     *___________________________________*/</FONT>     
    assert( data_CC[i][j][k][m] + data_CC[i][j-1][k][m] &gt; SMALL_NUM);          
    data_FC[BOTTOM] = (2.0 * data_CC[i][j][k][m] * data_CC[i][j-1][k][m])/
                            (data_CC[i][j][k][m] + data_CC[i][j-1][k][m]);
#if(N_DIMENSIONS == 3)
     <FONT COLOR="570BA3">/*__________________________________
     *  Front Face
     *___________________________________*/</FONT>     
    assert( data_CC[i][j][k][m] + data_CC[i][j][k+1][m] &gt; SMALL_NUM);          
    data_FC[FRONT]  = (2.0 * data_CC[i][j][k][m] * data_CC[i][j][k+1][m])/
                            (data_CC[i][j][k][m] + data_CC[i][j][k+1][m]);
                    
     <FONT COLOR="570BA3">/*__________________________________
     *  Back Face
     *___________________________________*/</FONT>     
    assert( data_CC[i][j][k][m] + data_CC[i][j][k-1][m] &gt; SMALL_NUM);          
    data_FC[BACK]   = (2.0 * data_CC[i][j][k][m] * data_CC[i][j][k-1][m])/
                            (data_CC[i][j][k][m] + data_CC[i][j][k-1][m]);
#endif
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="divergence_of_velocity_for_tau_terms_FC">divergence_of_velocity_for_tau_terms_FC</A>  SOURCE: Step 4,used to compute the viscous source terms</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: inline.h
 Filename: inline.h
 Purpose:   compute the face-centered transport properties 

 Version       Programmer         Date       Description                      
     -------   ----------         ----       -----------                 
        1.0     Todd Harman       1/19/00       
 Implementation Note:
 This function has been inlined to speed it up since it is called 
 for every cell.                            
 ---------------------------------------------------------------------  */</FONT>        
inline void <A href="#divergence_of_velocity_for_tau_terms_FC">divergence_of_velocity_for_tau_terms_FC</A>
        int     i,
        int     j,
        int     k,
        double delX,                        <FONT COLOR="570BA3">/* Cell width                       */</FONT>
        double delY,                        <FONT COLOR="570BA3">/* Cell Width in the y dir          */</FONT>
        double delZ,                        <FONT COLOR="570BA3">/* Cell width in the z dir          */</FONT>
        double ****uvel_CC,                 <FONT COLOR="570BA3">/* cell-centered velocity in the    */</FONT>
        double ****vvel_CC,                 <FONT COLOR="570BA3">/* x, y and z directions            */</FONT>
        double ****wvel_CC,
        double *div_vel_FC,                 <FONT COLOR="570BA3">/* face-centered results            */</FONT>
        int     m)
{
   double   term1, term2, term3,
            uvel_ED_top_right_z     = 0.0,         <FONT COLOR="570BA3">/* edge velocities                  */</FONT>
            uvel_ED_top_left_z      = 0.0,
            uvel_ED_bottom_right_z  = 0.0,
            uvel_ED_bottom_left_z   = 0.0,
 
            uvel_ED_front_right_y   = 0.0,
            uvel_ED_front_left_y    = 0.0,
            uvel_ED_back_right_y    = 0.0,
            uvel_ED_back_left_y     = 0.0,
 
            vvel_ED_right_top_z     = 0.0,
            vvel_ED_left_top_z      = 0.0,
            vvel_ED_right_bottom_z  = 0.0,
            vvel_ED_left_bottom_z   = 0.0,

            vvel_ED_back_top_x      = 0.0,
            vvel_ED_back_bottom_x   = 0.0,
            vvel_ED_front_top_x     = 0.0,
            vvel_ED_front_bottom_x  = 0.0,

            wvel_ED_right_front_y   = 0.0,
            wvel_ED_left_front_y    = 0.0,
            wvel_ED_right_back_y    = 0.0,
            wvel_ED_left_back_y     = 0.0,

            wvel_ED_top_front_x     = 0.0,
            wvel_ED_top_back_x      = 0.0,
            wvel_ED_bottom_front_x  = 0.0,
            wvel_ED_bottom_back_x   = 0.0;
<FONT COLOR="570BA3">/*__________________________________
*   bullet proofing
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 2 )
    assert( delX &gt; SMALL_NUM &amp;&amp; delY &gt; SMALL_NUM);
    delZ = 1.0;
#endif    
#if N_DIMENSIONS == 3
    assert( delZ &gt; SMALL_NUM )
#endif
<FONT COLOR="570BA3">/*______________________________________________________________________
*   First compute all of the edge velocities.  The edge velocity is simply
*   the average of the velocities in the four surrounding cell that share
*   the edge. 
*_______________________________________________________________________*/</FONT> 

    uvel_ED_top_right_z     = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> uvel_CC, i,  j,  k,  m);
    uvel_ED_top_left_z      = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> uvel_CC, i-1,j,  k,  m);
    uvel_ED_bottom_right_z  = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> uvel_CC, i,  j-1,k,  m);
    uvel_ED_bottom_left_z   = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> uvel_CC, i-1,j-1,k,  m);
    
    uvel_ED_front_right_y   = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> uvel_CC, i,  j,  k,  m);
    uvel_ED_front_left_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> uvel_CC, i-1,j,  k,  m);
    uvel_ED_back_right_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> uvel_CC, i,  j,  k-1,m);
    uvel_ED_back_left_y     = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> uvel_CC, i-1,j,  k-1,m);
       
    vvel_ED_right_top_z     = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A> vvel_CC, i,  j,  k,  m);
    vvel_ED_left_top_z      = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A> vvel_CC, i-1,j,  k,  m);
    vvel_ED_right_bottom_z  = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A> vvel_CC, i,  j-1,k,  m);
    vvel_ED_left_bottom_z   = <A href="#find_edge_vel__edge_is_parallel_w_Z_axis">find_edge_vel__edge_is_parallel_w_Z_axis</A> vvel_CC, i-1,j-1,k,  m);

    vvel_ED_back_top_x      = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> vvel_CC, i,  j,  k-1,m);
    vvel_ED_back_bottom_x   = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> vvel_CC, i,  j-1,k-1,m);
    vvel_ED_front_top_x     = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> vvel_CC, i,  j,  k,  m);
    vvel_ED_front_bottom_x  = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> vvel_CC, i,  j-1,k,  m);
    
    wvel_ED_right_front_y   = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> wvel_CC, i,  j,  k,  m);
    wvel_ED_left_front_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> wvel_CC, i-1,j,  k,  m);
    wvel_ED_right_back_y    = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> wvel_CC, i,  j,  k-1,m);
    wvel_ED_left_back_y     = <A href="#find_edge_vel__edge_is_parallel_w_Y_axis">find_edge_vel__edge_is_parallel_w_Y_axis</A> wvel_CC, i-1,j,  k-1,m); 
    
    wvel_ED_top_front_x     = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> wvel_CC, i,  j,  k,  m);
    wvel_ED_top_back_x      = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> wvel_CC, i,  j,  k-1,m);
    wvel_ED_bottom_front_x  = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> wvel_CC, i,  j-1,k,  m);
    wvel_ED_bottom_back_x   = <A href="#find_edge_vel__edge_is_parallel_w_X_axis">find_edge_vel__edge_is_parallel_w_X_axis</A> wvel_CC, i  ,j-1,k-1,m);


    <FONT COLOR="570BA3">/*__________________________________
    *   Right Face
    *___________________________________*/</FONT>   
    term1 = (uvel_CC[i+1][j][k][m]  - uvel_CC[i][j][k][m] )     /delX; 
    term2 = (vvel_ED_right_top_z    - vvel_ED_right_bottom_z )  /delY;         
    term3 = (wvel_ED_right_front_y  - wvel_ED_right_back_y )    /delZ; 
    div_vel_FC[RIGHT]  =   term1 + term2 + term3;
    
    <FONT COLOR="570BA3">/*__________________________________
    *  Left Face
    *___________________________________*/</FONT>
    term1 = (uvel_CC[i][j][k][m]    - uvel_CC[i-1][j][k][m] )   /delX; 
    term2 = (vvel_ED_left_top_z     - vvel_ED_left_bottom_z )   /delY;         
    term3 = (wvel_ED_left_front_y   - wvel_ED_left_back_y )     /delZ; 
    div_vel_FC[LEFT]  =   term1 + term2 + term3;
                    
     <FONT COLOR="570BA3">/*__________________________________
     *  Top Face
     *___________________________________*/</FONT>     
    term1 = (uvel_ED_top_right_z    - uvel_ED_top_left_z )      /delX; 
    term2 = (vvel_CC[i][j+1][k][m]  - vvel_CC[i][j][k][m] )     /delY;         
    term3 = (wvel_ED_top_front_x    - wvel_ED_top_back_x )      /delZ; 
    div_vel_FC[TOP]  =   term1 + term2 + term3;
                
     <FONT COLOR="570BA3">/*__________________________________
     *  Bottom Face
     *___________________________________*/</FONT> 
    term1 = (uvel_ED_bottom_right_z - uvel_ED_bottom_left_z )   /delX; 
    term2 = (vvel_CC[i][j][k][m]    - vvel_CC[i][j-1][k][m] )   /delY;         
    term3 = (wvel_ED_bottom_front_x - wvel_ED_bottom_back_x )   /delZ; 
    div_vel_FC[BOTTOM]  =   term1 + term2 + term3;
    
     <FONT COLOR="570BA3">/*__________________________________
     *  Front Face
     *___________________________________*/</FONT>   
#if(N_DIMENSIONS == 3)  
    term1 = (uvel_ED_front_right_y  - uvel_ED_front_left_y  )    /delX; 
    term2 = (vvel_ED_front_top_x    - vvel_ED_front_bottom_x )  /delY;         
    term3 = (wvel_CC[i][j][k+1]     - wvel_CC[i][j][k])         /delZ; 
    div_vel_FC[FRONT]  =   term1 + term2 + term3;                    

     <FONT COLOR="570BA3">/*__________________________________
     *  Back Face
     *___________________________________*/</FONT>     
    term1 = (uvel_ED_back_right_y  - uvel_ED_back_left_y )      /delX; 
    term2 = (vvel_ED_back_top_x    - vvel_ED_back_bottom_x )    /delY;         
    term3 = (wvel_CC[i][j][k]      - wvel_CC[i][j][k-1])        /delZ; 
    div_vel_FC[BACK]  =   term1 + term2 + term3;                    

#endif
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn compiler remarks
*___________________________________*/</FONT>
    uvel_ED_front_right_y   = uvel_ED_front_right_y;    uvel_ED_front_left_y  = uvel_ED_front_left_y;
    uvel_ED_back_right_y    = uvel_ED_back_right_y;     uvel_ED_back_left_y   = uvel_ED_back_left_y;
    vvel_ED_back_top_x      = vvel_ED_back_top_x;       vvel_ED_back_bottom_x = vvel_ED_back_bottom_x;
    vvel_ED_front_top_x     = vvel_ED_front_top_x;      vvel_ED_front_bottom_x=vvel_ED_front_bottom_x;
}
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="initialize_darray_4d">initialize_darray_4d</A>  DEBUG: Initialized a 4D array to a constant or a specified gradient.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: initializd_variables.c
 Filename: initializd_variables.c

 Purpose:  Initialize an multimaterial array to the value of Constant.  This routine 
 also allows the user to specify a imposed gradient with the switch grad_dir.
 During the initialization the ghostcells surrounding the domain are included.
 This routine is used in testing functions.  
 
 This function is mainly used in debugging

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/18/99   Written   

 --------------------------------------------------------------------- */</FONT>

void  <A href="#initialize_darray_4d">initialize_darray_4d</A> 
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  ****data_array,             <FONT COLOR="570BA3">/* data(x,y,z,material                      (IN/OUT)*/</FONT>                   
    int     m,                          <FONT COLOR="570BA3">/* material index                           */</FONT>
    double  constant,                   <FONT COLOR="570BA3">/* value to initialize the array to (INPUT) */</FONT>
    int     switch_funct,               <FONT COLOR="570BA3">/* Switch that specifies which user function*/</FONT>
                                        <FONT COLOR="570BA3">/* = 0 data = constant                      */</FONT>
                                        <FONT COLOR="570BA3">/* = 1 data = constant + x                  */</FONT>
                                        <FONT COLOR="570BA3">/* = 2 data = constant + y                  */</FONT>
                                        <FONT COLOR="570BA3">/* = 3 data = constant + z                  */</FONT>
                                        <FONT COLOR="570BA3">/* = 4 data = see macros.h                  */</FONT>
    int     flag_GC )                   <FONT COLOR="570BA3">/* = 1 if you want to include ghost (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* = 0 don't want to include ghostcells     */</FONT>

{                                   
    int i, j, k,                    
    xLo, xHi,
    yLo, yHi,
    zLo, zHi;
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Calculate th loop indices including the surrounding ghost cells
*_______________________________________________________________________*/</FONT>

    if (flag_GC == 1)
    {
        xLo = GC_LO(xLoLimit);
        xHi = GC_HI(xHiLimit);
        yLo = GC_LO(yLoLimit);
        yHi = GC_HI(yHiLimit);
        zLo = GC_LO(zLoLimit);
        zHi = GC_HI(zHiLimit); 
    }
    
    if (flag_GC != 1 )
    {    
        xLo = xLoLimit;
        xHi = xHiLimit;
        yLo = yLoLimit;
        yHi = yHiLimit;
        zLo = zLoLimit;
        zHi = zHiLimit; 
    }
  

    assert ( xLo &gt;= 0 &amp;&amp; xHi &lt;= X_MAX_LIM);
    assert ( yLo &gt;= 0 &amp;&amp; yHi &lt;= Y_MAX_LIM);
    assert ( zLo &gt;= 0 &amp;&amp; zHi &lt;= Z_MAX_LIM);
      
<FONT COLOR="570BA3">/*__________________________________
*   Now impose gradient
*___________________________________*/</FONT>            
    for(i = xLo; i &lt;= xHi; i++)
    {
        for(j = yLo; j &lt;= yHi; j++)
        {
             for(k = zLo; k &lt;= zHi; k++)
            {
                    
                data_array[i][j][k][m] = USR_FUNCTION(switch_funct,i,j,k,constant);

            }
        }
    }


 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="initialize_darray_3d">initialize_darray_3d</A>  DEBUG: Initialized a 3D array to a constant or a specified gradient.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: initialize_variables.c
 Filename: initialize_variables.c
 
 Purpose:  Initialize an singlematerial array to the value of Constant.  This routine 
 also allows the user to specify a imposed gradient with the switch grad_dir.
 During the initialization the ghostcells surrounding the domain are included.
 This routine is used in testing functions.

 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/18/99   Written   

 --------------------------------------------------------------------- */</FONT>

void    <A href="#initialize_darray_3d">initialize_darray_3d</A>                    
    int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
    int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
    int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
    int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
    int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
    int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
    double  ***data_array,              <FONT COLOR="570BA3">/* array to monkey with             (IN/OUT)*/</FONT> 
    double  constant,                   <FONT COLOR="570BA3">/* value to initialize the array to (INPUT) */</FONT>
    int     switch_funct,               <FONT COLOR="570BA3">/* Switch that specifies which user function*/</FONT>
                                        <FONT COLOR="570BA3">/* = 0 data = constant                      */</FONT>
                                        <FONT COLOR="570BA3">/* = 1 data = constant + x                  */</FONT>
                                        <FONT COLOR="570BA3">/* = 2 data = constant + y                  */</FONT>
                                        <FONT COLOR="570BA3">/* = 3 data = constant + z                  */</FONT>
                                        <FONT COLOR="570BA3">/* = 4 data = see macros.h                  */</FONT>    
    int     flag_GC )                   <FONT COLOR="570BA3">/* = 1 if you want to include ghost (INPUT) */</FONT>
                                        <FONT COLOR="570BA3">/* = 0 don't want to include ghostcells     */</FONT>
{ 
    int i, j, k,
    xLo, xHi,
    yLo, yHi,
    zLo, zHi;
<FONT COLOR="570BA3">/*START_DOC*/</FONT>
<FONT COLOR="570BA3">/*______________________________________________________________________
*  Calculate th loop indices including the surrounding ghost cells
*_______________________________________________________________________*/</FONT>

    if (flag_GC == 1)
    {
        xLo = GC_LO(xLoLimit);
        xHi = GC_HI(xHiLimit);
        yLo = GC_LO(yLoLimit);
        yHi = GC_HI(yHiLimit);
        zLo = GC_LO(zLoLimit);
        zHi = GC_HI(zHiLimit); 
    }
    
    if (flag_GC != 1 )
    {    
        xLo = xLoLimit;
        xHi = xHiLimit;
        yLo = yLoLimit;
        yHi = yHiLimit;
        zLo = zLoLimit;
        zHi = zHiLimit; 
    }

    assert ( xLo &gt;= 0 &amp;&amp; xHi &lt;= X_MAX_LIM);
    assert ( yLo &gt;= 0 &amp;&amp; yHi &lt;= Y_MAX_LIM);
    assert ( zLo &gt;= 0 &amp;&amp; zHi &lt;= Z_MAX_LIM);   
      
<FONT COLOR="570BA3">/* ______________________________
  Now print the string
  print a new line if the returnchar
   is found.
______________________________  */</FONT>                

    for(k = zLo; k &lt;= zHi; k++)
    {
        for(j = yLo; j &lt;= yHi; j++)
        {
            for(i = xLo; i &lt;= xHi; i++)
            {
                data_array[i][j][k] = USR_FUNCTION(switch_funct,i,j,k,constant);
            }
        }
    }   
 }
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="explicit_delPress">explicit_delPress</A>  PRESSURE: Step 2, compute the change in pressure, explicitly</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: explicit_delPress.c
 Filename: explicit_delPress.c
 Purpose:
   This function calculates the change in pressure explicitly.  Basically it just 
   solves the pressure equation once.
 Note:  Units of delpress are [Pa]
 
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       03/10/00    
 ---------------------------------------------------------------------  */</FONT>
void explicit_delPress
             (  
        int     xLoLimit,               <FONT COLOR="570BA3">/* x-array Lower Interior Nodes     */</FONT>
        int     yLoLimit,               <FONT COLOR="570BA3">/* y-array Lower Interior Nodes     */</FONT>
        int     zLoLimit,               <FONT COLOR="570BA3">/* z-array Lower Interior Nodes     */</FONT>
        int     xHiLimit,               <FONT COLOR="570BA3">/* x-array Upper Interior Nodes     */</FONT>
        int     yHiLimit,               <FONT COLOR="570BA3">/* y-array Upper Interior Nodes     */</FONT>
        int     zHiLimit,               <FONT COLOR="570BA3">/* z-array Upper Interior Nodes     */</FONT> 
        double  delX,                   <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                   <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                   <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
        double  ****div_velFC_CC,       <FONT COLOR="570BA3">/* divergence of face cented vel at (INPUT) */</FONT>
        double  ****delPress_CC,        <FONT COLOR="570BA3">/* Change in the cell-centered press(INPUT) */</FONT>
        double  ****press_CC,           <FONT COLOR="570BA3">/* Cell-center pressure             (INPUT) */</FONT>
        double  ****rho_CC,             <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  delt,                   <FONT COLOR="570BA3">/* delta t                          (INPUT) */</FONT>
        double  ****speedSound,         <FONT COLOR="570BA3">/* speed of Sound(x,y,z,material    (INPUT) */</FONT>
        int     nMaterials )  
    
{
    int         i, j, k, m;

    double      vol, coeff;
<FONT COLOR="570BA3">/*__________________________________
* double check inputs
* and allocat some memory
*___________________________________*/</FONT>
    assert ( xLoLimit &gt;= 0 &amp;&amp; xHiLimit &lt;= X_MAX_LIM);
    assert ( yLoLimit &gt;= 0 &amp;&amp; yHiLimit &lt;= Y_MAX_LIM);
    assert ( zLoLimit &gt;= 0 &amp;&amp; zHiLimit &lt;= Z_MAX_LIM);
    <FONT COLOR="570BA3">/*__________________________________
    *   Now compute the pressure and
    *   change in pressure
    *___________________________________*/</FONT>
    for ( m = 1; m &lt;= nMaterials; m++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            {
                for ( i = xLoLimit; i &lt;= xHiLimit; i++)
                { 
                    vol     = delX * delY * delZ; 
                    coeff   = delt * rho_CC[i][j][k][m] * pow(speedSound[i][j][k][m],2) / vol;

                    delPress_CC[i][j][k][m] = -coeff * div_velFC_CC[i][j][k][m]; 

                    press_CC[i][j][k][m]    = press_CC[i][j][k][m] + delPress_CC[i][j][k][m];
                }
            }
        }
    }
 
    
<FONT COLOR="570BA3">/*______________________________________________________________________
*   DEBUGGING
*_______________________________________________________________________*/</FONT>
#if switchDebug_explicit_delPress
    fprintf(stderr,"****************************************************************************\n");
    fprintf(stderr,"                        explicit_delPress\n");
    fprintf(stderr,"****************************************************************************\n");
   
                       
    <A href="#printData_4d">printData_4d</A>       xLo,                yLo,            zLo,
                        xHi,                yHi,            zHi,
                        m,                  m,
                       "explicit_delPress",     
                       "Press_CC",          press_CC);
                       
    <A href="#printData_4d">printData_4d</A>       xLo,                yLo,            zLo,
                        xHi,                yHi,            zHi,
                        m,                  m,
                       "explicit_delPress",     
                       "delPress_CC",       delPress_CC);
   fprintf(stderr,"****************************************************************************\n");
    
    fprintf(stderr,"press return to continue\n");
    getchar();
#endif
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="compute_delta_Press_Using_PCGMG">compute_delta_Press_Using_PCGMG</A>  PRESS: main driver for computing delta_pressure.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: pressure_PCG.c
 Filename: pressure_PCG.c
 Purpose:  
    To be filled in
    
 Computational Domain:          Interior cells 
 Ghostcell data dependency:     

 References:
             
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/17/99
 ---------------------------------------------------------------------  */</FONT>

 void   <A href="#compute_delta_Press_Using_PCGMG">compute_delta_Press_Using_PCGMG</A>
        int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                       <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                       <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                       <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
        double  delt,
        double  ****rho_CC,                 <FONT COLOR="570BA3">/* Cell-centered density            */</FONT>
        double  ****speedSound,             <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) */</FONT>
            <FONT COLOR="570BA3">/*------to be treated as pointers---*/</FONT>
                                            <FONT COLOR="570BA3">/*______(x,y,z,face, material)______*/</FONT>
        double  ******uvel_FC,              <FONT COLOR="570BA3">/* u-face-centered velocity         */</FONT>
        double  ******vvel_FC,              <FONT COLOR="570BA3">/* *v-face-centered velocity        */</FONT>
        double  ******wvel_FC,              <FONT COLOR="570BA3">/* w face-centered velocity         */</FONT>
        double  ****delPress_CC,            <FONT COLOR="570BA3">/* change in delta p                */</FONT>
        double  ****press_CC,
        int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (INPUT) */</FONT>
                                            <FONT COLOR="570BA3">/* types of boundary conditions             */</FONT>
                                            <FONT COLOR="570BA3">/* BC_types[wall][variable]=type            */</FONT>
        int     nMaterials)
 {
    static int    initialized=0;        <FONT COLOR="570BA3">/* Flag for initializing Petsc      */</FONT>
    char*         args[2];
    char**        argv;
    int           argc=0;
    
    Scalar        *array;    
    
  UserCtx userctx;
    int           ierr, m, n, i, j, k, N, index, its, mat;
    double        enorm;
    Scalar        hx, hy, x, y, v, MINUSONE = -1.0;
    Vec           error, solution;

    KSP          kspctx;                <FONT COLOR="570BA3">/* Krylov subspace method context       */</FONT>    
<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if switchDebug_pressure_PCG 
    double
                ***plot_1,              <FONT COLOR="570BA3">/* testing array                        */</FONT>      
                ***plot_2,              <FONT COLOR="570BA3">/* testing array                        */</FONT>
                ***plot_3,              <FONT COLOR="570BA3">/* testing array                        */</FONT>      
                ***plot_4,              <FONT COLOR="570BA3">/* testing array                        */</FONT> 
                ***plot_5,              <FONT COLOR="570BA3">/* testing array                        */</FONT> 
                ***plot_6;
    Scalar      *array_1,               <FONT COLOR="570BA3">/* used to convert from petsc to        */</FONT>
                *array_2,               <FONT COLOR="570BA3">/* to my data arrays for plotting only*/</FONT>
                *array_3,
                *array_4,
                *array_5,
                *array_6;
                       
    #include "plot_declare_vars.h" 
    plot_1  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);    
    plot_2  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
    plot_3  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);    
    plot_4  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
    plot_5  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM); 
    plot_6  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
 
#endif
<FONT COLOR="570BA3">/*______________________________________________________________________
*   initialize variables and allocate some temp memory
*_______________________________________________________________________*/</FONT>
    mat = 1;
    m   = xHiLimit - xLoLimit + 1;
    n   = yHiLimit - yLoLimit + 1;
    N   = m*n;
<FONT COLOR="570BA3">/*__________________________________
*   Initialize the PETSC libraries
*   Do this only once
*___________________________________*/</FONT> 
  if(!initialized)
  {
     PetscInitialize(&amp;argc, &amp;argv, PETSC_NULL, PETSC_NULL); 

     initialized= 1;
  }
<FONT COLOR="570BA3">/*__________________________________
*   Initialize the solver and compute
*   the stencil matrix
*___________________________________*/</FONT>
    ierr = <A href="#initializeLinearSolver">initializeLinearSolver</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,                 
                        delt,           rho_CC,         speedSound,       
                        BC_types,       nMaterials,     &amp;userctx);                          CHKERRA(ierr);
                        
<FONT COLOR="570BA3">/*__________________________________
* Calculate the rhs
*___________________________________*/</FONT>
    <A href="#calc_delPress_RHS">calc_delPress_RHS</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,               
                        uvel_FC,        vvel_FC,        wvel_FC,
                        &amp;userctx,       &amp;solution,     
                        nMaterials);

<FONT COLOR="570BA3">/*__________________________________
*   Solve the system
*___________________________________*/</FONT>     
    ierr = SLESGetKSP(userctx.sles,&amp;kspctx);                                                CHKERRA(ierr);
     ierr = KSPSetTolerances(kspctx,RELATIVE_TOLERANCE,
                                    ABSOLUTE_TOLERANCE, DIV_TOLERANCE, MAX_ITERATION);        CHKERRA(ierr);

    ierr = SLESSolve(userctx.sles, userctx.b, userctx.x, &amp;its);                             CHKERRQ(ierr);
  
<FONT COLOR="570BA3">/*__________________________________
*   Compute error using test code
*___________________________________*/</FONT>
#if switchDebug_pcgmg_test
    #define switchInclude_compute_error 1
    #include "testcode_PressureSolve.i"
    #undef switchInclude_compute_error
#endif 

<FONT COLOR="570BA3">/*__________________________________
*   Now extract the values of delPress
*   from PETSC
*___________________________________*/</FONT>
    mat = 1;
    ierr = VecGetArray(userctx.x,&amp;array);                                                   CHKERRA(ierr);


    for ( k = zLoLimit; k &lt;= zHiLimit; k++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( i = xLoLimit; i &lt;= xHiLimit; i++)
            { 
            <FONT COLOR="570BA3">/*__________________________________
            * map a 3d array to a 1d vector
            *___________________________________*/</FONT>
            index = (i-xLoLimit) + (j-yLoLimit)*(xHiLimit-xLoLimit+1);                  <FONT COLOR="570BA3">/* 2D       */</FONT>
            <FONT COLOR="570BA3">/* index = index + (k - zLoLimit)*(xHiLimit-xLoLimit+1)*(yHiLimit-yLoLimit+1); */</FONT> <FONT COLOR="570BA3">/* 3D       */</FONT> 
            
            delPress_CC[i][j][k][mat]   = array[index];
            press_CC[i][j][k][mat]      = press_CC[i][j][k][mat]    + array[index];
             
            }
        }
    }
    ierr = VecRestoreArray(userctx.x,&amp;array);                                               CHKERRA(ierr);

<FONT COLOR="570BA3">/*__________________________________
*   Plotting section
*___________________________________*/</FONT> 
#if switchDebug_pressure_PCG
         #define switchInclude_pressure_PCG 1
         #include "debugcode.i"
         free_darray_3d( plot_1,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_2,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_3,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_4,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_5,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_6,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         #undef switchInclude_pressure_PCG
#endif
<FONT COLOR="570BA3">/*__________________________________
*   Deallocate memory
*___________________________________*/</FONT>
#if switchDebug_pcgmg_test
    PetscFree(solution);
    PetscFree(error);
#endif

    ierr = FinalizeLinearSolver(&amp;userctx);                                                  CHKERRA(ierr);
 <FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    delX= delX;        
    delY= delY;        
    delZ= delZ; 
    ierr= ierr;
    hx  = hx;
    hy  = hy;
    x   = x;
    y   = y;
    v   = v;
    N   = N;
    args[1]= args[1];
    zLoLimit= zLoLimit;                    
    zHiLimit= zHiLimit;
    enorm   = enorm;
    error   = error;
    MINUSONE = MINUSONE;   
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="initializeLinearSolver">initializeLinearSolver</A>  PRESS: to be filled in</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: pressure_PCG.c
 Filename: pressure_PCG.c
 Purpose:  
    To be filled in
    
 Computational Domain:          Interior cells 
 Ghostcell data dependency:     

 References:
             
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/30/99
 ---------------------------------------------------------------------  */</FONT>
int <A href="#initializeLinearSolver">initializeLinearSolver</A>
        int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                       <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                       <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                       <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
        double  delt,
        double  ****rho_CC,                 <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  ****speedSound,             <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) (INPUT) */</FONT>
        int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (INPUT) */</FONT>
                                            <FONT COLOR="570BA3">/* types of boundary conditions             */</FONT>
                                            <FONT COLOR="570BA3">/* BC_types[wall][variable]=type            */</FONT>
        int     nMaterials,
        UserCtx *userctx)
{
    int m, n, N, flg, ierr;
    Mat *A = &amp;(userctx-&gt;A);
    stencilMatrix* stencil = &amp;(userctx-&gt;stencil);
    PC pc;
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Initialize variables
*_______________________________________________________________________*/</FONT>
    m = xHiLimit - xLoLimit + 1;
    n = yHiLimit - yLoLimit + 1; 
    userctx-&gt;m   = m;
    userctx-&gt;n   = n;
    userctx-&gt;hx2 = m*m;
    userctx-&gt;hy2 = n*n; 
    N            = m*n;

    <FONT COLOR="570BA3">/*__________________________________
    *   Create the vectors for
    *   the solution and the source
    *___________________________________*/</FONT>
    ierr = VecCreateSeq(PETSC_COMM_SELF, N, &amp;userctx-&gt;b);                                   CHKERRQ(ierr);
    ierr = VecDuplicate(userctx-&gt;b, &amp;userctx-&gt;x);                                           CHKERRQ(ierr);

    <FONT COLOR="570BA3">/*__________________________________
    *   Create the solver
    *___________________________________*/</FONT>
    ierr = SLESCreate(PETSC_COMM_SELF, &amp;userctx-&gt;sles);                                     CHKERRQ(ierr);
    
    <FONT COLOR="570BA3">/*__________________________________
    *   Initialize the stencilMatrix
    *   The BC_types array will be used to
    *   determine which typ of BC to implement
    *___________________________________*/</FONT>
    <A href="#calc_delPress_Stencil_Weights_Dirichlet">calc_delPress_Stencil_Weights_Dirichlet</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,
                        delt,           BC_types,
                        rho_CC,         speedSound,       
                        nMaterials,     stencil,        A);
                        
    <A href="#calc_delPress_Stencil_Weights_Neuman">calc_delPress_Stencil_Weights_Neuman</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,             
                        delX,           delY,           delZ,                
                        delt,           BC_types, 
                        rho_CC,         speedSound,     nMaterials,     
                        stencil,        A);
   
                        
<FONT COLOR="570BA3">/*______________________________________________________________________
*           REGISTER PHASE 
*   Register the stencil Matrix with the solver 
*   Eventually move this to a function outside the main loop
*_______________________________________________________________________*/</FONT>
    ierr = SLESSetOperators(userctx-&gt;sles, *A, *A, SAME_NONZERO_PATTERN);                   CHKERRQ(ierr);

    <FONT COLOR="570BA3">/*__________________________________
    *   Register the 
    *   MultigridPreconditioner with the solver
    *___________________________________*/</FONT>
    ierr = SLESGetPC(userctx-&gt;sles, &amp;pc);                                                   CHKERRQ(ierr);
    ierr = PCSetType(pc, PCSHELL);                                                          CHKERRQ(ierr);

    ierr = MultigridPreconditionerCreate( &amp;(userctx-&gt;MGshell) );                            CHKERRA(ierr);
    userctx-&gt;MGshell-&gt;m = m;
    userctx-&gt;MGshell-&gt;n = n;
    ierr = OptionsHasName(PETSC_NULL, "-levels", &amp;flg);                                     CHKERRA(ierr);
  
    if ( flg ) 
    {
        ierr = OptionsGetInt(PETSC_NULL, "-levels", &amp;(userctx-&gt;MGshell-&gt;mgLevels), &amp;flg);   CHKERRQ(ierr);
    }
  
    ierr = PCShellSetApply(pc, MultigridPreconditionerApply, (void*) userctx-&gt;MGshell );    CHKERRA(ierr);
                            
    ierr = MultigridPreconditionerSetUp( userctx-&gt;MGshell, *A, userctx-&gt;x );                CHKERRQ(ierr); 
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    ierr = ierr;
  return 0;
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="finalizeLinearSolver">finalizeLinearSolver</A>  PRESS: Deallocate memory used by Petsc</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: pressure_PCG.c
 Filename: pressure_PCG.c
 Purpose:  
    To be filled in 
             
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/30/99
 ---------------------------------------------------------------------  */</FONT>
int FinalizeLinearSolver(UserCtx *userctx)
{
  int ierr;
<FONT COLOR="570BA3">/*__________________________________
*   Deallocate memory
*___________________________________*/</FONT>
  ierr = SLESDestroy(userctx-&gt;sles);                                                        CHKERRQ(ierr);
  ierr = VecDestroy(userctx-&gt;x);                                                            CHKERRQ(ierr);
  ierr = VecDestroy(userctx-&gt;b);                                                            CHKERRQ(ierr);  
  ierr = MatDestroy(userctx-&gt;A);                                                            CHKERRQ(ierr);
  ierr = MultigridPreconditionerDestroy(userctx-&gt;MGshell);                                  CHKERRQ(ierr);
  ierr = ierr;
  return 0;
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="calc_delPress_Stencil_Weights_Neuman">calc_delPress_Stencil_Weights_Neuman</A>  PRESS: </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: ComputeStencilWeights.c
 Filename: ComputeStencilWeights.c
 Purpose:   
            Compute the stencil weights 
    To be filled in
    
 Computational Domain:          Interior cells 
 Ghostcell data dependency:     

 References:
             
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/30/99
 ---------------------------------------------------------------------  */</FONT>
void <A href="#calc_delPress_Stencil_Weights_Neuman">calc_delPress_Stencil_Weights_Neuman</A>
        int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                       
        double  delY,                       
        double  delZ,                       
        double  delt,
        int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (INPUT) */</FONT>
                                            <FONT COLOR="570BA3">/* types of boundary conditions     (INPUT) */</FONT>
                                            <FONT COLOR="570BA3">/* BC_types[wall][variable]=type    (INPUT) */</FONT>        
        double  ****rho_CC,                 <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  ****speedSound,             <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) (INPUT) */</FONT>
        int     nMaterials,                 <FONT COLOR="570BA3">/* number of materials              (INPUT) */</FONT>
        stencilMatrix* stencil,             <FONT COLOR="570BA3">/* stencil                          (OUTPUT)*/</FONT>
        Mat*    A)
{
    int         i,  j,  k,  indx,   mat;
    int         n,  m,  N,  ierr,   should_I_leave;
    int         wall,   wallLo,     wallHi;
    double      beta_n,                     <FONT COLOR="570BA3">/* temporary Variables              */</FONT>
                beta_s, 
                beta_e, 
                beta_w, 
                beta_p;
                
    Scalar      an,                         <FONT COLOR="570BA3">/* stencil coefficients             */</FONT>
                as, 
                ae, 
                aw, 
                ap; 
    void *ctx = (void*) stencil;
    Scalar  hx, hy;
    
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif    
<FONT COLOR="570BA3">/*__________________________________
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(BC_types[wall][DELPRESS][m] == NEUMANN ) should_I_leave = NO;
        }
    }
    if (should_I_leave == YES) return;
<FONT COLOR="570BA3">/*__________________________________
*   initialize variables
*___________________________________*/</FONT>
    m   = xHiLimit - xLoLimit + 1;
    n   = yHiLimit - yLoLimit + 1; 
    N   = m * n;   
    hx  = 1.0/m, 
    hy  = 1.0/n;
    
    hx  = delX;
    hy  = delY;    
<FONT COLOR="570BA3">/*__________________________________
*   Create the StencilMatrix Object
*___________________________________*/</FONT> 
  stencil   = (stencilMatrix*) ctx;
  ierr      = MatCreateShell( PETSC_COMM_SELF, N, N, N, N, ctx, A );                        CHKERRQ(ierr);
  ierr      = MatShellSetOperation( *A, MATOP_MULT, (void*) stencilMult );                  CHKERRQ(ierr);

<FONT COLOR="570BA3">/*__________________________________
*    Define stencil structure member data.
*___________________________________*/</FONT>
  stencil-&gt;m = m;
  stencil-&gt;n = n;

  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;ap) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;ae) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;aw) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;an) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;as) );                                CHKERRQ(ierr);
  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Set the stencil values Neuman Boundary Conditions
*_______________________________________________________________________*/</FONT>
    indx = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   HARDWIRE THE K AND M FOR NOW
    *___________________________________*/</FONT>
    k   = 1;
    mat = nMaterials;
    
    for ( j = yLoLimit; j &lt;= yHiLimit; j++) 
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++) 
        {                     
            beta_n = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i][j+1][k][mat] );
            beta_s = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i][j-1][k][mat] );
            beta_e = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i+1][j][k][mat] );
            beta_w = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i-1][j][k][mat] );
            beta_p = delX * delY/(rho_CC[i][j][k][mat] * delt * pow(speedSound[i][j][k][mat],2) );
            
<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
#if switchDebug_pcgmg_test        
            beta_n = 1.0;
            beta_s = 1.0;
            beta_e = 1.0;
            beta_w = 1.0;
            beta_p = 0.0;
#endif
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
    
            ae = -(hy/hx) * beta_e;
            aw = -(hy/hx) * beta_w;
            an = -(hx/hy) * beta_n;
            as = -(hx/hy) * beta_s;                    
            ap =   beta_p - (ae+aw+an+as);              <FONT COLOR="570BA3">/* center; conservative! */</FONT>

            <FONT COLOR="570BA3">/*__________________________________
            * Neuman Boundary conditions
            *___________________________________*/</FONT>
            if ( i == xLoLimit )                <FONT COLOR="570BA3">/* Left Side        */</FONT>
            {
               aw = hy * beta_w;
               ap = beta_p - (ae + an + as);
            }
            else if ( i == xHiLimit )           <FONT COLOR="570BA3">/* Right Side        */</FONT>
            {
               ae = hy * beta_e;
               ap = beta_p - (aw+an + as);
            }
            if ( j == yLoLimit )                <FONT COLOR="570BA3">/* Bottom           */</FONT>
            {
               as = hx * beta_s;
               ap = beta_p -(ae + aw + an);
            }
            else if ( j == yHiLimit )           <FONT COLOR="570BA3">/* Top              */</FONT>
            {
               an = hx * beta_n;
               ap = beta_p - (ae + aw + as);
            }
            <FONT COLOR="570BA3">/*__________________________________
            * Take care of the corner cells
            *___________________________________*/</FONT>
            if ( i == xLoLimit &amp;&amp; j == yLoLimit )       <FONT COLOR="570BA3">/* Lower Left Corner */</FONT>
            {
               ap = beta_p - (ae + an);
               as = hx * beta_s;
               aw = hy * beta_w;
            }
            else if ( i == xLoLimit &amp;&amp; j == yHiLimit )  <FONT COLOR="570BA3">/* Upper Left Corner */</FONT>
            {
               ap = beta_p - (ae + as);
               an = hx * beta_n;
               aw = hy * beta_w;
            }
            else  if ( i == xHiLimit &amp;&amp; j == yLoLimit )   <FONT COLOR="570BA3">/* Lower Right Corner */</FONT>
            {
               ap = beta_p - (aw + an);
               as = hx * beta_s;
               ae = hy * beta_e;
            }
            else if ( i == xHiLimit &amp;&amp; j == yHiLimit )  <FONT COLOR="570BA3">/* Upper Right Corner */</FONT>
            {
               ap = beta_p - (aw + as);
               an = hx * beta_n;
               ae = hy * beta_e;
            }
            <FONT COLOR="570BA3">/*__________________________________
            * Finally set the stencil
            *___________________________________*/</FONT>
            VecSetValue( stencil-&gt;ap, indx, ap, INSERT_VALUES );
            VecSetValue( stencil-&gt;ae, indx, ae, INSERT_VALUES );
            VecSetValue( stencil-&gt;aw, indx, aw, INSERT_VALUES );
            VecSetValue( stencil-&gt;an, indx, an, INSERT_VALUES );
            VecSetValue( stencil-&gt;as, indx, as, INSERT_VALUES );
            indx++;
        }
    }  

<FONT COLOR="570BA3">/*__________________________________
*   For testing and debugging
*___________________________________*/</FONT>  
#if switchDebug_pcgmg_test
    #define switchInclude_stencil_test_code 1
    #include "testcode_PressureSolve.i"
    #undef switchInclude_stencil_test_code
#endif 
<FONT COLOR="570BA3">/*__________________________________
*   Assemble the matrix
*___________________________________*/</FONT>
  ierr = MatAssemblyBegin(*A, MAT_FINAL_ASSEMBLY);                                          CHKERRQ(ierr);
  ierr = MatAssemblyEnd(*A, MAT_FINAL_ASSEMBLY);                                            CHKERRQ(ierr);

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>  
    delZ = delZ;        zLoLimit = zLoLimit;        zHiLimit = zHiLimit;        ierr = ierr;
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="calc_delPress_Stencil_Weights_Dirichlet">calc_delPress_Stencil_Weights_Dirichlet</A>  PRESS: </FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: ComputeStencilWeights.c
 Filename: ComputeStencilWeights.c
 Purpose:   
            Compute the stencil weights 
    To be filled in
    
 Computational Domain:          Interior cells 
 Ghostcell data dependency:     

 References:
             
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/30/99
 ---------------------------------------------------------------------  */</FONT>
void <A href="#calc_delPress_Stencil_Weights_Dirichlet">calc_delPress_Stencil_Weights_Dirichlet</A>
        int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                       
        double  delY,                       
        double  delZ,                       
        double  delt,
        int     ***BC_types,                <FONT COLOR="570BA3">/* array containing the different   (INPUT) */</FONT>
                                            <FONT COLOR="570BA3">/* types of boundary conditions     (INPUT) */</FONT>
                                            <FONT COLOR="570BA3">/* BC_types[wall][variable]=type    (INPUT) */</FONT>
        double  ****rho_CC,                 <FONT COLOR="570BA3">/* Cell-centered density            (INPUT) */</FONT>
        double  ****speedSound,             <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) (INPUT) */</FONT>
        int     nMaterials,
        stencilMatrix* stencil,
        Mat*    A)
{
    int         i,  j,  k,  indx,   mat;
    int         n,  m,  N,  ierr,   should_I_leave;
    int         wall,   wallLo,     wallHi;
    double      beta_n, 
                beta_s, 
                beta_e, 
                beta_w, 
                beta_p;
    Scalar      an, 
                as, 
                ae, 
                aw, 
                ap; 
    void *ctx = (void*) stencil;
    Scalar  hx, hy;
<FONT COLOR="570BA3">/*__________________________________
*   Determine the looping indices
*   for multidimensional problems
*___________________________________*/</FONT>
#if (N_DIMENSIONS == 1)  
        wallLo = LEFT;  wallHi = RIGHT;
#endif

#if (N_DIMENSIONS == 2) 
        wallLo = TOP;   wallHi = LEFT;
#endif
#if (N_DIMENSIONS == 3) 
        wallLo = TOP;   wallHi = BACK;
#endif      
<FONT COLOR="570BA3">/*__________________________________
*   Test to see if you should be in this function
*___________________________________*/</FONT>
    should_I_leave = YES;
    for(m = 1; m &lt;= nMaterials; m++)
    {
        for( wall = wallLo; wall &lt;= wallHi; wall ++)
        {
            if(BC_types[wall][DELPRESS][m] == DIRICHLET ) should_I_leave = NO;
           
        }
    }
    if (should_I_leave == YES) return;
<FONT COLOR="570BA3">/*__________________________________
*   initialize variables
*___________________________________*/</FONT>
    m   = xHiLimit - xLoLimit + 1;
    n   = yHiLimit - yLoLimit + 1; 
    N   = m * n;   
    hx  = 1.0/m, 
    hy  = 1.0/n;    
    
    hx  = delX;
    hy  = delY; 
<FONT COLOR="570BA3">/*__________________________________
*   Create the StencilMatrix Object
*___________________________________*/</FONT> 
  stencil   = (stencilMatrix*) ctx;
  ierr      = MatCreateShell( PETSC_COMM_SELF, N, N, N, N, ctx, A );                        CHKERRQ(ierr);
  ierr      = MatShellSetOperation( *A, MATOP_MULT, (void*) stencilMult );                  CHKERRQ(ierr);

<FONT COLOR="570BA3">/*__________________________________
*    Define stencil structure member data.
*___________________________________*/</FONT>
  stencil-&gt;m = m;
  stencil-&gt;n = n;

  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;ap) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;ae) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;aw) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;an) );                                CHKERRQ(ierr);
  ierr = VecCreateSeq( PETSC_COMM_SELF, N, &amp;(stencil-&gt;as) );                                CHKERRQ(ierr);
  
<FONT COLOR="570BA3">/*______________________________________________________________________
*   Set the stencil values Dirichlet Boundary Conditions
*_______________________________________________________________________*/</FONT>

    indx = 0;
    <FONT COLOR="570BA3">/*__________________________________
    *   HARDWIRE THE K AND M FOR NOW
    *___________________________________*/</FONT>
    k   = 1;
    mat = nMaterials;
    for ( j = yLoLimit; j &lt;= yHiLimit; j++) 
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++) 
        {
        
            beta_n = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i][j+1][k][mat] );
            beta_s = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i][j-1][k][mat] );
            beta_e = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i+1][j][k][mat] );
            beta_w = delt * 2.0/( rho_CC[i][j][k][mat] + rho_CC[i-1][j][k][mat] );
            beta_p = delX * delY/(rho_CC[i][j][k][mat] * delt * pow(speedSound[i][j][k][mat],2) );
            

<FONT COLOR="570BA3">/*`==========TESTING==========*/</FONT> 
#if switchDebug_pcgmg_test
            beta_n = 1.0;
            beta_s = 1.0;
            beta_e = 1.0;
            beta_w = 1.0;
            beta_p = 0.0;
#endif
 <FONT COLOR="570BA3">/*==========TESTING==========`*/</FONT>
    
            ae =  -(hy/hx) * beta_e;
            aw =  -(hy/hx) * beta_w;
            an =  -(hx/hy) * beta_n;
            as =  -(hx/hy) * beta_s;
            ap =   beta_p - (ae+aw+an+as);              <FONT COLOR="570BA3">/* center; conservative! */</FONT>
      
            <FONT COLOR="570BA3">/*__________________________________
            * Dirichlet Boundary conditions
            *___________________________________*/</FONT>
            if ( i == xLoLimit)                     <FONT COLOR="570BA3">/* Left Side        */</FONT>
            {
                aw  = -(8.0/3.0) * (hy/hx) * beta_w;
                ae  = -(hy/hx)   * ( (1.0/3.0)*beta_w + beta_e  );
            } 
            else if ( i == xHiLimit )              <FONT COLOR="570BA3">/* right Side        */</FONT> 
            {
                ae  = -(8.0/3.0) * (hy/hx) * beta_e;
                aw  = -(hy/hx)   * ( (1.0/3.0)*beta_e + beta_w);
            }  
            if ( j == yLoLimit )                     <FONT COLOR="570BA3">/* Bottom           */</FONT>
            { 
                as  = -(8.0/3.0) * (hy/hx) * beta_s;
                an  = -(hy/hx)   * ( (1.0/3.0)*beta_s + beta_n);

            } 
            else if ( j == yHiLimit )              <FONT COLOR="570BA3">/* Top              */</FONT> 
            {
                an  = -(8.0/3.0) * (hy/hx)* beta_n;
                as  = -hy/hx     * ( (1.0/3.0)*beta_n + beta_s);
            }
            <FONT COLOR="570BA3">/*__________________________________
            * Take care of the corner cells
            *___________________________________*/</FONT>
            if ( i == xLoLimit &amp;&amp; j == yLoLimit )       <FONT COLOR="570BA3">/* Lower Left Corner */</FONT>
            {               
                as  = -(8.0/3.0) * (hy/hx) * beta_s;
                an  = -(hy/hx)   * ((1.0/3.0)*beta_s + beta_n);
               
                aw  = -(8.0/3.0) * (hy/hx) * beta_w;
                ae  = -hy/hx     * (beta_e + (1.0/3.0)*beta_w);
            } 
            else if ( i == xLoLimit &amp;&amp; j == yHiLimit )  <FONT COLOR="570BA3">/* Upper Left Corner */</FONT>
            {                
                as  = -(hy/hx)   * ((1.0/3.0)*beta_n + beta_s);
                an  = -(8.0/3.0) * (hy/hx) * beta_n;
               
                aw  = -(8.0/3.0) * (hy/hx) * beta_w;
                ae  = -hy/hx     * (beta_e + (1.0/3.0)*beta_w);
            } 
            else  if ( i == xHiLimit &amp;&amp; j == yLoLimit )   <FONT COLOR="570BA3">/* Lower Right Corner */</FONT>
            {
                as  = -(8.0/3.0) * (hy/hx) * beta_s;
                an  = -hy/hx     * ((1.0/3.0)*beta_s + beta_n);

                aw  = -hy/hx     * ((1.0/3.0)*beta_e  + beta_w);
                ae  = -(8.0/3.0) * (hy/hx) * beta_e;

            } 
            else if ( i == xHiLimit &amp;&amp; j == yHiLimit )  <FONT COLOR="570BA3">/* Upper Right Corner */</FONT>
            {
                as  = -(hy/hx)   * ((1.0/3.0)*beta_n + beta_s);
                an  = -(8.0/3.0) * (hy/hx) * beta_n;

                aw  = -(hy/hx)   * ((1.0/3.0)*beta_e + beta_w);
                ae  = -(8.0/3.0) * (hy/hx) * beta_w;
            }
            <FONT COLOR="570BA3">/*__________________________________
            * Finally set the stencil
            *___________________________________*/</FONT>
            VecSetValue( stencil-&gt;ap, indx, ap, INSERT_VALUES ); 
            VecSetValue( stencil-&gt;ae, indx, ae, INSERT_VALUES ); 
            VecSetValue( stencil-&gt;aw, indx, aw, INSERT_VALUES ); 
            VecSetValue( stencil-&gt;an, indx, an, INSERT_VALUES ); 
            VecSetValue( stencil-&gt;as, indx, as, INSERT_VALUES ); 
            indx++;
    }
  }
<FONT COLOR="570BA3">/*__________________________________
*   Testing
*___________________________________*/</FONT>  
#if switchDebug_pcgmg_test
    #define switchInclude_stencil_test_code 1
    #include "testcode_PressureSolve.i"
    #undef switchInclude_stencil_test_code
#endif 
<FONT COLOR="570BA3">/*__________________________________
*   Assemble the matrix
*___________________________________*/</FONT>
  ierr = MatAssemblyBegin(*A, MAT_FINAL_ASSEMBLY);                                          CHKERRQ(ierr);
  ierr = MatAssemblyEnd(*A, MAT_FINAL_ASSEMBLY);                                            CHKERRQ(ierr);
<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>  
    delZ = delZ;        zLoLimit = zLoLimit;        zHiLimit = zHiLimit;        ierr = ierr;
<PRE>
<A HREF="#topofpage">back to the top</A>

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="calc_delPress_RHS">calc_delPress_RHS</A>  PRESS: Computes the RHS of the delPress eq.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
<PRE> Filename: computeSource.c
 Filename: computeSource.c
 Purpose:  
    To be filled in
    
 References:
             
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       12/30/99
 ---------------------------------------------------------------------  */</FONT>
void <A href="#calc_delPress_RHS">calc_delPress_RHS</A>
        int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                       <FONT COLOR="570BA3">/* distance/cell, xdir              (INPUT) */</FONT>
        double  delY,                       <FONT COLOR="570BA3">/* distance/cell, ydir              (INPUT) */</FONT>
        double  delZ,                       <FONT COLOR="570BA3">/* distance/cell, zdir              (INPUT) */</FONT>
            <FONT COLOR="570BA3">/*------to be treated as pointers---*/</FONT>
                                            <FONT COLOR="570BA3">/*______(x,y,z,face, material)______*/</FONT>
        double  ******uvel_FC,              <FONT COLOR="570BA3">/* u-face-centered velocity         */</FONT>
        double  ******vvel_FC,              <FONT COLOR="570BA3">/* *v-face-centered velocity        */</FONT>
        double  ******wvel_FC,              <FONT COLOR="570BA3">/* w face-centered velocity         */</FONT>
        UserCtx *userctx,
        Vec     *solution,                  
        int     nMaterials)
{
    int           i, j, k, indx, mat;
    int           m, n, N, ierr;
    Scalar        div_vel_FC;               <FONT COLOR="570BA3">/* divergence of (*)vel_FC          */</FONT>
<FONT COLOR="570BA3">/*__________________________________
*   Need by the test code
*___________________________________*/</FONT>
    Scalar      hx, hy, x, y, v;
<FONT COLOR="570BA3">/*__________________________________
*   Initialize variables
*___________________________________*/</FONT>
    mat = nMaterials;
    m   = xHiLimit - xLoLimit + 1;
    n   = yHiLimit - yLoLimit + 1;
    indx= 0;
    N   = m*n; 
<FONT COLOR="570BA3">/*___________________________________________________________
*   Compute the div_vel_FC terms
*_______________________________________________________________________*/</FONT>
    k     = 1;
    for ( j = yLoLimit; j &lt;= yHiLimit; j++) 
    {
        for ( i = xLoLimit; i &lt;= xHiLimit; i++) 
        { 
            div_vel_FC =                *uvel_FC[i][j][k][mat][RIGHT] - *uvel_FC[i][j][k][mat][LEFT];
            div_vel_FC = div_vel_FC +   *vvel_FC[i][j][k][mat][TOP]   - *vvel_FC[i][j][k][mat][BOTTOM];
            div_vel_FC = -delX * delY * div_vel_FC;
            VecSetValue( userctx-&gt;b, indx, div_vel_FC, INSERT_VALUES );
            indx++;
        }
    }
    
<FONT COLOR="570BA3">/*__________________________________
*   For testing and debugging
*   Compute the RHS b[] and solution
*___________________________________*/</FONT>  
#if switchDebug_pcgmg_test
    #define switchInclude_source_test_code 1
    #include "testcode_PressureSolve.i"
    #undef switchInclude_source_test_code
#endif

 <FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>

    delZ        = delZ; 
    zLoLimit    = zLoLimit;
    zHiLimit    = zHiLimit;
    hx          = hx; 
    hy          = hy; 
    x           = x;
    y           = y;
    v           = v;  
    ierr        = ierr;
    N           = N;
    solution[1] = solution[1];
   *wvel_FC[0][0][0][1][1] = *wvel_FC[0][0][0][1][1];      
}
<FONT COLOR="570BA3">/* 
 ======================================================================*/</FONT>
#include &lt;math.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include "nrutil+.h"
#include "parameters.h"
#include "functionDeclare.h"
#include "switches.h"
#include "macros.h"

<FONT COLOR="570BA3">/*---------------------------------------------------------------------  

<HR>
<B><FONT SIZE=3 FACE="arial"><A NAME="press_eq_residual">press_eq_residual</A>  PRESS: compute the residual of the pressure eq.</FONT></B>
<A HREF="uintah_cfd_v2.pdf">Go to the blueprint</A>
 Purpose:  
    This function sums the residual of the pressure equation for each
    interior cell.  Based on this residual the compute_delta_Press_Using_PCGMG
    may have to be called again to beat the residual down.
    
 History:
    Version   Programmer         Date       Description
    -------   ----------         ----       -----------
       1.0     Todd Harman       1/11/00
 ---------------------------------------------------------------------  */</FONT>

 void   <A href="#press_eq_residual">press_eq_residual</A>
        int     xLoLimit,                   <FONT COLOR="570BA3">/* x-array lower limit              */</FONT>
        int     yLoLimit,                   <FONT COLOR="570BA3">/* y-array lower limit              */</FONT>
        int     zLoLimit,                   <FONT COLOR="570BA3">/* z-array lower limit              */</FONT>
        int     xHiLimit,                   <FONT COLOR="570BA3">/* x-array upper limit              */</FONT>
        int     yHiLimit,                   <FONT COLOR="570BA3">/* y-array upper limit              */</FONT>
        int     zHiLimit,                   <FONT COLOR="570BA3">/* z-array upper limit              */</FONT>
        double  delX,                       <FONT COLOR="570BA3">/* Cell Width                       */</FONT>
        double  delY,                       <FONT COLOR="570BA3">/* Cell width y dir.                */</FONT>
        double  delZ,                       <FONT COLOR="570BA3">/* cell width z dir.                */</FONT>
        double  delt,                       <FONT COLOR="570BA3">/* delta time                       */</FONT>
        double  ****rho_CC,                 <FONT COLOR="570BA3">/* Cell-centered density            */</FONT>
        double  ****speedSound,             <FONT COLOR="570BA3">/* speed of sound (x,y,z, material) */</FONT>
            <FONT COLOR="570BA3">/*------to be treated as pointers---*/</FONT>
                                            <FONT COLOR="570BA3">/*______(x,y,z,face, material)______*/</FONT>
        double  ******uvel_FC,              <FONT COLOR="570BA3">/* u-face-centered velocity         */</FONT>
        double  ******vvel_FC,              <FONT COLOR="570BA3">/* *v-face-centered velocity        */</FONT>
        double  ******wvel_FC,              <FONT COLOR="570BA3">/* w face-centered velocity         */</FONT>
        double  ****delPress_CC,            <FONT COLOR="570BA3">/* change in delta p                */</FONT>
        double  ****press_CC,               <FONT COLOR="570BA3">/* cell-centered pressure           */</FONT>
        double  *residual,
        int     nMaterials)
{
    int         i,j,k,m;
    double      RHS, vol,
                delPress_dt,                <FONT COLOR="570BA3">/* delPress/dt                      */</FONT>
                ****div_vel_FC,             <FONT COLOR="570BA3">/* array containing the divergence  */</FONT>
                sum, 
                coeff;     
    char    should_I_write_output;

<FONT COLOR="570BA3">/*__________________________________
*   Plotting variables
*___________________________________*/</FONT>
#if (switchDebug_press_eq_residual == 1 || switchDebug_press_eq_residual == 2)
    double      ***plot_1,***plot_2, ***plot_3;             
    #include "plot_declare_vars.h"            
    plot_1  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);    
    plot_2  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
    plot_3  = darray_3d(0, X_MAX_LIM,   0, Y_MAX_LIM, 0, Z_MAX_LIM);
    <A href="#zero_arrays_3d">zero_arrays_3d</A>
                        xLoLimit,       yLoLimit,       zLoLimit,             
                        xHiLimit,       yHiLimit,       zHiLimit,
                         3,             
                        plot_1,         plot_2,         plot_3);
#endif

    div_vel_FC= darray_4d(0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);

<FONT COLOR="570BA3">/*__________________________________
*   Compute the divergence of the
*   face centered velocity field
*___________________________________*/</FONT>                
    m = nMaterials;     <FONT COLOR="570BA3">/* HARDWIRE FOR NOW*/</FONT>
    
    <A href="#divergence_of_face_centered_velocity">divergence_of_face_centered_velocity</A>  
                        xLoLimit,       yLoLimit,       zLoLimit,
                        xHiLimit,       yHiLimit,       zHiLimit,
                        delX,           delY,           delZ,
                        uvel_FC,        vvel_FC,        wvel_FC,
                        div_vel_FC,     nMaterials);
                        
    <FONT COLOR="570BA3">/*__________________________________
    *   Now compare the LHS to the RHS
    *___________________________________*/</FONT>                        
    for ( i = xLoLimit; i &lt;= xHiLimit; i++)
    {
        for ( j = yLoLimit; j &lt;= yHiLimit; j++)
        {
            for ( k = zLoLimit; k &lt;= zHiLimit; k++)
            { 
                vol             = delX * delY * delZ;
                coeff           = pow(speedSound[i][j][k][m],2) * rho_CC[i][j][k][m];
                RHS             = -(coeff * div_vel_FC[i][j][k][m]) * (delt/vol);
                
                delPress_dt     = delPress_CC[i][j][k][m];
                sum             = fabs(delPress_dt - RHS);
                *residual       = DMAX(*residual, sum);
           
                <FONT COLOR="570BA3">/*__________________________________
                * Now define some plotting stuff
                *___________________________________*/</FONT>     
#if (switchDebug_press_eq_residual == 1 || switchDebug_press_eq_residual == 2)
                plot_1[i][j][k] = RHS;
                plot_2[i][j][k] = delPress_dt;
                plot_3[i][j][k] = delPress_dt - RHS; 
#endif               
            }
        }
    }
    fprintf(stderr,"delta press_CC residual %f\n",  *residual);

<FONT COLOR="570BA3">/*______________________________________________________________________
*   Plotting Section
*_______________________________________________________________________*/</FONT>
#if (switchDebug_press_eq_residual == 1 || switchDebug_press_eq_residual == 2)
    should_I_write_output = *getenv("SHOULD_I_WRITE_OUTPUT");
    if ( should_I_write_output == '1')
    {
         #define switchInclude_press_eq_residual 1
         #include "debugcode.i"
         #undef switchInclude_press_eq_residual
    }
         free_darray_3d( plot_1,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_2,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
         free_darray_3d( plot_3,0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM);
#endif

<FONT COLOR="570BA3">/*__________________________________
*   Deallocate memory
*___________________________________*/</FONT>
   free_darray_4d(div_vel_FC, 0, X_MAX_LIM, 0, Y_MAX_LIM, 0, Z_MAX_LIM, 1, N_MATERIAL);

<FONT COLOR="570BA3">/*__________________________________
*   Quite fullwarn remarks in a way that
*   is compiler independent
*___________________________________*/</FONT>
    QUITE_FULLWARN(press_CC[1][1][1][1]);       QUITE_FULLWARN(*wvel_FC[1][1][1][1][1]); 
    delZ = delZ;    
    should_I_write_output = should_I_write_output; 
}    
<HR>
</BODY></HTML>

