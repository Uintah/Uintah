/*
  The contents of this file are subject to the University of Utah Public
  License (the "License"); you may not use this file except in compliance
  with the License.
  
  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.
  
  The Original Source Code is SCIRun, released March 12, 2001.
  
  The Original Source Code was developed by the University of Utah.
  Portions created by UNIVERSITY are Copyright (C) 2001, 1994 
  University of Utah. All Rights Reserved.
*/


#include <sci_config.h>
#include "Spec.h"
#include "SymbolTable.h"
#if HAVE_SYS_UUID_H
extern "C" { // SGI uuid.h doesn't have this, so we need extern C here
#include <sys/uuid.h>
}
#define UUID_CREATE
#else
#if HAVE_UUID_UUID_H
extern "C" { // Linux uuid.h doesn't have this, so we need extern C here
#include <uuid/uuid.h>
}
#define UUID_GENERATE
#else
#error We need either sys/uuid.h or uuid/uuid.h
#endif
#endif

#include <algorithm>
#include <iostream>
#include <map>
#include <sstream>

#include <stdio.h>
using namespace std;
extern bool doing_cia;

#ifdef OLD_STUFF
static string handle_class = "\
class @ {\n\
  @_interface* ptr;\n\
public:\n\
  static const ::PIDL::TypeInfo* _getTypeInfo();\n\
  typedef @_interface interfacetype;\n\
  inline @()\n\
  {\n\
    ptr=0;\n\
  }\n\
  inline @(@_interface* ptr)\n\
    : ptr(ptr)\n\
  {\n\
    if(ptr)\n\
      ptr->_addReference();\n\
  }\n\
  inline ~@()\n\
  {\n\
    if(ptr)\n\
      ptr->_deleteReference();\n\
  }\n\
  inline @(const @& copy)\n\
    : ptr(copy.ptr)\n\
  {\n\
    if(ptr)\n\
      ptr->_addReference();\n\
  }\n\
  inline @& operator=(const @& copy)\n\
  {\n\
    if(&copy != this){\n\
      if(ptr)\n\
        ptr->_deleteReference();\n\
        if(copy.ptr)\n\
          copy.ptr->_addReference();\n\
    }\n\
    ptr=copy.ptr;\n\
    return *this;\n\
  }\n\
  inline @_interface* getPointer() const\n\
  {\n\
    return ptr;\n\
  }\n\
  inline @_interface* operator->() const\n\
  {\n\
    return ptr;\n\
  }\n\
  inline operator bool() const\n\
  {\n\
    return ptr != 0;\n\
  }\n\
  inline operator ::PIDL::Object() const\n\
  {\n\
    return ptr;\n\
  }\n\
";
#endif

struct Leader {
};
static Leader leader2;

struct SState : public std::ostringstream {
  std::string leader;
  SymbolTable* currentPackage;
  EmitState*e;
  SState(EmitState* e) : e(e) {
    currentPackage=0;
    leader="";
  }
  void begin_namespace(SymbolTable*);
  void close_namespace();
  void recursive_begin_namespace(SymbolTable*);

  std::string push_leader() {
    string oldleader=leader;
    leader+="  ";
    return oldleader;
  }
  void pop_leader(const std::string& oldleader) {
    leader=oldleader;
  }

  friend std::ostream& operator<<( ostream& out, const Leader& );

};

std::ostream& operator<<( SState& out, const Leader& ) {
  out << out.leader;
  return out;
}


struct EmitState {
  int instanceNum;
  int handlerNum;
  EmitState();

  SState fwd;
  SState decl;
  SState out;
  SState proxy;
};

EmitState::EmitState()
  : fwd(this), decl(this), out(this), proxy(this)
{
  instanceNum=0;
  handlerNum=0;
}

void SpecificationList::emit(std::ostream& out, std::ostream& hdr,
			     const std::string& hname) const
{
  EmitState e;
  // Emit code for each definition
  globals->emit(e);
  e.fwd.close_namespace();
  e.decl.close_namespace();
  e.out.close_namespace();
  e.proxy.close_namespace();

  hdr << "/*\n";
  hdr << " * This code was automatically generated by sidl,\n";
  hdr << " * do not edit directly!\n";
  hdr << " */\n";
  hdr << "\n";
  string ifname(hname);
  replace(ifname.begin(), ifname.end(), '/', '_');
  replace(ifname.begin(), ifname.end(), '.', '_');
  hdr << "#ifndef _sidl_generated_" << ifname << '\n';
  hdr << "#define _sidl_generated_" << ifname << '\n';
  hdr << "\n";
  hdr << "#include <Core/CCA/Component/PIDL/Object.h>\n";
  hdr << "#include <Core/CCA/Component/PIDL/pidl_cast.h>\n";
  hdr << "#include <Core/CCA/Component/CIA/CIA_sidl.h>\n";
  hdr << "#include <Core/CCA/Component/CIA/array.h>\n";
  hdr << "#include <Core/CCA/Component/CIA/string.h>\n";
  //hdr << "#include <CCALib/SmartPointer.h>\n";
  hdr << "#include <Core/CCA/SmartPointer.h>\n";
  hdr << "#include <complex>\n";
  hdr << "\n";
  hdr << e.fwd.str();
  hdr << e.decl.str();
  hdr << "\n#endif\n\n";

  // Emit #includes
  out << "/*\n";
  out << " * This code was automatically generated by sidl,\n";
  out << " * do not edit directly!\n";
  out << " */\n";
  out << "\n";
  out << "#include \"" << hname << "\"\n";
  out << "#include <Core/Exceptions/InternalError.h>\n";
  out << "#include <Core/CCA/Component/PIDL/GlobusError.h>\n";
  out << "#include <Core/CCA/Component/PIDL/Object_proxy.h>\n";
  out << "#include <Core/CCA/Component/PIDL/ProxyBase.h>\n";
  out << "#include <Core/CCA/Component/PIDL/ReplyEP.h>\n";
  out << "#include <Core/CCA/Component/PIDL/Reference.h>\n";
  out << "#include <Core/CCA/Component/PIDL/ServerContext.h>\n";
  out << "#include <Core/CCA/Component/PIDL/TypeInfo.h>\n";
  out << "#include <Core/CCA/Component/PIDL/TypeInfo_internal.h>\n";
  out << "#include <Core/Util/NotFinished.h>\n";
  out << "#include <Core/Thread/Thread.h>\n";
  out << "#include <iostream>\n";
  out << "#include <globus_nexus.h>\n";
  out << "\n";
  out << e.proxy.str();
  out << e.out.str();
}

void SymbolTable::emit(EmitState& e) const
{
  for(map<string, Symbol*>::const_iterator iter=symbols.begin();
      iter != symbols.end();iter++){
    iter->second->emit(e);
  }
}

void Symbol::emit(EmitState& e)
{
  switch(type){
  case PackageType:
    definition->getSymbolTable()->emit(e);
    break;
  case InterfaceType:
  case ClassType:
  case EnumType:
    definition->emit(e);
    break;
  case MethodType:
    cerr << "Symbol::emit called for a method!\n";
    exit(1);
  case EnumeratorType:
    // Nothing - gets emitted with the enum
    break;
  }
  emitted_forward=true;
}

void Symbol::emit_forward(EmitState& e)
{
  if(emitted_forward)
    return;
  switch(type){
  case PackageType:
    cerr << "Why is emit forward being called for a package?\n";
    exit(1);
  case InterfaceType:
  case ClassType:
    if(definition->emitted_declaration){
      emitted_forward=true;
      return;
    }
    e.fwd.begin_namespace(symtab);
    e.fwd << leader2 << "class " << name << ";\n";
    break;
  case EnumType:
    if(definition->emitted_declaration){
      emitted_forward=true;
      return;
    }
    definition->emit(e);
    break;
  case MethodType:
    cerr << "Symbol::emit_forward called for a method!\n";
    exit(1);
  case EnumeratorType:
    cerr << "Symbol::emit_forward called for an enumerator!\n";
    exit(1);
  }
  emitted_forward=true;
}	

void Package::emit(EmitState&)
{
  cerr << "Package::emit should not be called...\n";
  exit(1);
}

void SState::begin_namespace(SymbolTable* stab)
{
  if(currentPackage == stab)
    return;
  // Close off previous namespace...
  close_namespace();

  // Open new namespace...
  recursive_begin_namespace(stab);
  currentPackage=stab;
}

void SState::close_namespace()
{
  if(currentPackage){
    while(currentPackage->getParent()){
      for(SymbolTable* p=currentPackage->getParent();
	  p->getParent()!=0;
	  p=p->getParent())
	{
	  *this << "  ";
	}
      *this << "} // End namespace " << currentPackage->getName() <<'\n';
      currentPackage=currentPackage->getParent();
    }
    *this << "\n";
  }
  leader="";
}

void SState::recursive_begin_namespace(SymbolTable* stab)
{
  SymbolTable* parent=stab->getParent();
  if(parent){
    recursive_begin_namespace(parent);
    *this << leader << "namespace " << stab->getName() << " {\n";
    push_leader();
  }
}

bool CI::iam_class()
{
  bool iam=false;
  if(dynamic_cast<Class*>(this))
    iam=true;
  return iam;
}

void CI::emit(EmitState& e)
{
  if(emitted_declaration)
    return;
  // Emit parent classes...
  if(parentclass)
    parentclass->emit(e);
  for(std::vector<Interface*>::iterator iter=parent_ifaces.begin();
      iter != parent_ifaces.end(); iter++){
    (*iter)->emit(e);
  }
  
  emit_proxyclass(e);
  emitted_declaration=true;
  if(!do_emit)
    return;
  
  emitted_declaration=true;
  emit_header(e);

  e.instanceNum++;

  // Emit handler functions
  emit_handlers(e);

  // Emit handler table
  emit_handler_table(e);

  emit_interface(e);
  emit_typeinfo(e);
  emit_proxy(e);
}

void CI::emit_typeinfo(EmitState& e)
{
  std::string fn=cppfullname(0);

  char* uuid_str;
  uuid_t uuid;
#ifdef UUID_CREATE
  uint_t status;
  uuid_create(&uuid, &status);
  if(status != uuid_s_ok){
    cerr << "Error creating uuid!\n";
    exit(1);
  }

  uuid_to_string(&uuid, &uuid_str, &status);
  if(status != uuid_s_ok){
    cerr << "Error creating uuid string!\n";
    exit(1);
  }
#endif
#ifdef UUID_GENERATE
  uuid_str = (char*)malloc(64*sizeof(char));
  uuid_generate( uuid );
  uuid_unparse(uuid, uuid_str);
#endif
  e.out << "const ::PIDL::TypeInfo* " << fn << "::_static_getTypeInfo()\n";
  e.out << "{\n";
  e.out << "  static ::PIDL::TypeInfo* ti=0;\n";
  e.out << "  if(!ti){\n";
  e.out << "    ::PIDL::TypeInfo_internal* tii=\n";
 

  e.out << "       new ::PIDL::TypeInfo_internal(\"" 
	<< cppfullname(0) << "\", \"" << uuid_str << "\",\n";

  e.out << "                                      _handler_table" << e.instanceNum << ",\n";
  e.out << "                                      sizeof(_handler_table" << e.instanceNum << ")/sizeof(globus_nexus_handler_t),\n";
  e.out << "                                      &::" << fn << "_proxy::create_proxy);\n\n";
  SymbolTable* localScope=symbols->getParent();
  if(parentclass)
    e.out << "    tii->add_parentclass(" << parentclass->cppfullname(localScope) << "::_static_getTypeInfo(), " << parentclass->vtable_base << ");\n";
  for(vector<Interface*>::iterator iter=parent_ifaces.begin();
      iter != parent_ifaces.end(); iter++){
    e.out << "    tii->add_parentiface(" << (*iter)->cppfullname(localScope) << "::_static_getTypeInfo(), " << (*iter)->vtable_base << ");\n";
  }
  e.out << "    ti=new ::PIDL::TypeInfo(tii);\n";
  e.out << "  }\n";
  e.out << "  return ti;\n";
  e.out << "}\n\n";
  e.out << "const ::PIDL::TypeInfo* " << fn << "::_virtual_getTypeInfo() const\n";
  e.out << "{\n";
  e.out << "  return _static_getTypeInfo();\n";
  e.out << "}\n\n";

  free(uuid_str);
}

void CI::emit_handlers(EmitState& e)
{
  // Emit isa handler...
  e.out << "// methods from " << name << " " << curfile << ":" << lineno << "\n\n";
  e.out << "// isa handler\n";
  isaHandler=++e.handlerNum;
  e.out << "static void _handler" << isaHandler << "(globus_nexus_endpoint_t* _ep,\n";
  e.out << "                      globus_nexus_buffer_t* _recvbuff, globus_bool_t)\n";
  e.out << "{\n";
  e.out << "  int classname_size;\n";
  e.out << "  globus_nexus_get_int(_recvbuff, &classname_size, 1);\n";
  e.out << "  char* classname=new char[classname_size+1];\n";
  e.out << "  globus_nexus_get_char(_recvbuff, classname, classname_size);\n";
  e.out << "  classname[classname_size]=0;\n";
  e.out << "  int uuid_size;\n";
  e.out << "  globus_nexus_get_int(_recvbuff, &uuid_size, 1);\n";
  e.out << "  char* uuid=new char[uuid_size+1];\n";
  e.out << "  globus_nexus_get_char(_recvbuff, uuid, uuid_size);\n";
  e.out << "  uuid[uuid_size]=0;\n";
  e.out << "  globus_nexus_startpoint_t _sp;\n";
  e.out << "  int _addRef;\n";
  e.out << "  globus_nexus_get_int(_recvbuff, &_addRef, 1);\n";
  e.out << "  if(int _gerr=globus_nexus_get_startpoint(_recvbuff, &_sp, 1))\n";
  e.out << "    throw ::PIDL::GlobusError(\"get_startpoint\", _gerr);\n";
  e.out << "  if(int _gerr=globus_nexus_buffer_destroy(_recvbuff))\n";
  e.out << "    throw ::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
  e.out << "  const ::PIDL::TypeInfo* ti=" << cppfullname(0) << "::_static_getTypeInfo();\n";
  e.out << "  int result=ti->isa(classname, uuid);\n";
  e.out << "  delete[] classname;\n";
  e.out << "  delete[] uuid;\n";
  e.out << "  int flag;\n";
  e.out << "  if(result == ::PIDL::TypeInfo::vtable_invalid) {\n";
  e.out << "    flag=0;\n";
  e.out << "  } else {\n";
  e.out << "    flag=1;\n";
  e.out << "    if(_addRef){\n";
  e.out << "      void* _v=globus_nexus_endpoint_get_user_pointer(_ep);\n";
  e.out << "      ::PIDL::ServerContext* _sc=static_cast< ::PIDL::ServerContext*>(_v);\n";
  e.out << "      _sc->d_objptr->addReference();\n";
  e.out << "    }\n";
  e.out << "  }\n";
  e.out << "  globus_nexus_buffer_t sendbuff;\n";
  e.out << "  int rsize=globus_nexus_sizeof_int(2);\n";
  e.out << "  if(int gerr=globus_nexus_buffer_init(&sendbuff, rsize, 0))\n";
  e.out << "    throw ::PIDL::GlobusError(\"buffer_init\", gerr);\n";
  e.out << "  globus_nexus_put_int(&sendbuff, &flag, 1);\n";
  e.out << "  globus_nexus_put_int(&sendbuff, &result, 1);\n";
  e.out << "  if(int _gerr=globus_nexus_send_rsr(&sendbuff, &_sp, 0, GLOBUS_TRUE, GLOBUS_FALSE))\n";
  e.out << "    throw ::PIDL::GlobusError(\"send_rsr\", _gerr);\n";
  e.out << "  if(int _gerr=globus_nexus_startpoint_eventually_destroy(&_sp, GLOBUS_FALSE, 30))\n";
  e.out << "    throw ::PIDL::GlobusError(\"startpoint_eventually_destroy\", _gerr);\n";
  e.out << "}\n\n";

  // Emit delete reference handler...
  e.out << "// methods from " << name << " " << curfile << ":" << lineno << "\n\n";
  e.out << "// delete reference handler\n";
  deleteReferenceHandler=++e.handlerNum;
  e.out << "static void _handler" << deleteReferenceHandler << "(globus_nexus_endpoint_t* _ep,\n";
  e.out << "                      globus_nexus_buffer_t* _recvbuff, globus_bool_t)\n";
  e.out << "{\n";
  e.out << "  if(int _gerr=globus_nexus_buffer_destroy(_recvbuff))\n";
  e.out << "    throw ::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
  e.out << "  void* _v=globus_nexus_endpoint_get_user_pointer(_ep);\n";
  e.out << "  ::PIDL::ServerContext* _sc=static_cast< ::PIDL::ServerContext*>(_v);\n";
  e.out << "  _sc->d_objptr->deleteReference();\n";
  e.out << "}\n\n";

  // Emit method handlers...
  std::vector<Method*> vtab;
  gatherVtable(vtab, false);
  int handlerOff=0;
  for(vector<Method*>::const_iterator iter=vtab.begin();
      iter != vtab.end();iter++){
    Method* m=*iter;
    e.handlerNum++;
    m->handlerNum=e.handlerNum;
    m->handlerOff=handlerOff++;
    m->emit_handler(e, this);
  }
}

void CI::emit_recursive_vtable_comment(EmitState& e, bool top)
{
  e.out << "  // " << (top?"":"and ") << (iam_class()?"class ":"interface ") << name << "\n";
  if(parentclass)
    parentclass->emit_recursive_vtable_comment(e, false);
  
  for(vector<Interface*>::const_iterator iter=parent_ifaces.begin();
      iter != parent_ifaces.end(); iter++){
    (*iter)->emit_recursive_vtable_comment(e, false);
  }
}

bool CI::singly_inherited() const
{
  // A class is singly inherited if it has one parent class,
  // or one parent interface, and it's parent is singly_inherited
  if((parentclass && parent_ifaces.size() > 0)
     || parent_ifaces.size()>1)
    return false;
  if(parentclass){
    if(!parentclass->singly_inherited())
      return false;
  } else if(parent_ifaces.size()>0){
    // First element...
    if(!(*parent_ifaces.begin())->singly_inherited())
      return false;
  }
  return true;
}

void CI::emit_handler_table_body(EmitState& e, int& vtable_base, bool top)
{
  bool single=singly_inherited();
  if(single)
    emit_recursive_vtable_comment(e, true);
  else
    e.out << "  // " << (iam_class()?"class ":"interface ") << name << "\n";
  e.out << "  // vtable_base = " << vtable_base << '\n';
  std::vector<Method*> vtab;
  gatherVtable(vtab, false);
  for(vector<Method*>::const_iterator iter=vtab.begin();
      iter != vtab.end();iter++){
    if(iter != vtab.begin())
      e.out << ",\n";
    Method* m=*iter;
    m->emit_comment(e, "  ", false);
    e.out << "  {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, _handler" << m->handlerNum << "}";
  } 
  e.out << ",\n    // Red zone\n";    
  e.out << "  {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, 0},\n";

  if(single){
    if(top){
      if(parentclass)
	parentclass->vtable_base=vtable_base;
      for(vector<Interface*>::iterator iter=parent_ifaces.begin();
	  iter != parent_ifaces.end(); iter++){
	(*iter)->vtable_base=vtable_base;
      }
    }
    vtable_base+=vtab.size()+1;
    return;
  }
  // For each parent, emit the handler table...
  vtable_base+=vtab.size()+1;
  if(parentclass){
    if(top)
      parentclass->vtable_base=vtable_base;
    parentclass->emit_handler_table_body(e, vtable_base, false);
  }
  for(vector<Interface*>::iterator iter=parent_ifaces.begin();
      iter != parent_ifaces.end(); iter++){
    if(top)
      (*iter)->vtable_base=vtable_base;
    (*iter)->emit_handler_table_body(e, vtable_base, false);
  }
}

void CI::emit_handler_table(EmitState& e)
{
  e.out << "// handler table for " << (iam_class()?"class ":"interface ") << name << "\n";
  e.out << "//" << curfile << ":" << lineno << "\n\n";
  e.out << "static globus_nexus_handler_t _handler_table" << e.instanceNum << "[] =\n";
  e.out << "{\n";
  e.out << "  {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, _handler" << isaHandler << "},\n";
  e.out << "  {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, _handler" << deleteReferenceHandler << "},\n";
  e.out << "  {GLOBUS_NEXUS_HANDLER_TYPE_THREADED, 0},\n";
  int vtable_base=3;
  
  emit_handler_table_body(e, vtable_base, true);
  
  e.out << "\n}; // vtable_size=" << vtable_base << "\n\n";
}

bool Method::reply_required() const
{
  return true; // For now
}

string Method::get_classname() const
{
  string n;
  if(myclass)
    n=myclass->cppfullname(0);
  else if(myinterface)
    n=myinterface->cppfullname(0);
  else {
    cerr << "ERROR: Method does not have an associated class or interface\n";
    exit(1);
  }
  return n;
}

void Method::emit_comment(EmitState& e, const std::string& leader,
			  bool print_filename) const
{
  if(print_filename)
    e.out << leader << "// from " << curfile << ":" << lineno << '\n';
  e.out << leader << "// " << fullsignature() << '\n';
}

void Method::emit_prototype(SState& out, Context ctx,
			    SymbolTable* localScope) const
{
  out << leader2 << "// " << fullsignature() << '\n';
  out << leader2 << "virtual ";
  return_type->emit_prototype(out, Type::ReturnType, localScope);
  out << " " << name << "(";
  std::vector<Argument*>& list=args->getList();
  int c=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    if(c++>0)
      out << ", ";
    Argument* arg=*iter;
    arg->emit_prototype(out, localScope);
  }
  out << ")";
  if(ctx == PureVirtual && !doing_cia)
    out << "=0";
  out << ";\n";
}

void Method::emit_prototype_defin(EmitState& e, const std::string& prefix,
				  SymbolTable* localScope) const
{
  e.out << "// " << fullsignature() << '\n';
  return_type->emit_prototype(e.out, Type::ReturnType, 0);
  e.out << " " << prefix << name << "(";
  std::vector<Argument*>& list=args->getList();
  int c=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    if(c++>0)
      e.out << ", ";
    Argument* arg=*iter;
    std::ostringstream argname;
    argname << "_arg" << c;
    arg->emit_prototype_defin(e.out, argname.str(), localScope);
  }
  e.out << ")";
}

void Method::emit_handler(EmitState& e, CI* emit_class) const
{
  // Server-side handlers
  emit_comment(e, "", true);
  e.out << "static void _handler" << e.handlerNum << "(globus_nexus_endpoint_t* _ep,\n";
  e.out << "                      globus_nexus_buffer_t* _recvbuff, globus_bool_t)\n";
  e.out << "{\n";

  string oldleader=e.out.push_leader();
  std::vector<Argument*>& list=args->getList();
  int argNum=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    argNum++;
    Argument* arg=*iter;
    if(arg->getMode() != Argument::Out) {
      std::ostringstream argname;
      argname << "_arg" << argNum;
      arg->emit_unmarshal(e, argname.str(), "1", "_recvbuff", true);
    }
  }

  // If we are sending a reply, unmarshal the startpoint
  e.out << "\n";
  if(reply_required()){
    e.out << "  globus_nexus_startpoint_t _sp;\n";
    e.out << "  if(int _gerr=globus_nexus_get_startpoint(_recvbuff, &_sp, 1))\n";
    e.out << "    throw ::PIDL::GlobusError(\"get_startpoint\", _gerr);\n";
  }
  // Destroy the buffer...
  e.out << "  if(int _gerr=globus_nexus_buffer_destroy(_recvbuff))\n";
  e.out << "    throw ::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
  e.out << "  void* _v=globus_nexus_endpoint_get_user_pointer(_ep);\n";
  string myclass=emit_class->cppfullname(0);
  e.out << "  ::PIDL::ServerContext* _sc=static_cast< ::PIDL::ServerContext*>(_v);\n";
  e.out << "  " << myclass << "* _obj=static_cast< " << myclass << "*>(_sc->d_ptr);\n";
  e.out << "\n";

  // Declare out arguments...
  argNum=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    argNum++;
    Argument* arg=*iter;
    if(arg->getMode() == Argument::Out) {
      std::ostringstream argname;
      argname << "_arg" << argNum;
      arg->emit_declaration(e, argname.str());
    }
  }
  e.out.pop_leader(oldleader);

  e.out << "  // Call the method\n";
  // Call the method...
  e.out << "  ";
  if(return_type){
    if(!return_type->isvoid()){
      return_type->emit_rettype(e, "_ret");
      e.out << " = ";
    }
  }
  e.out << "_obj->" << name << "(";
  argNum=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    if(argNum > 0)
      e.out << ", ";
    argNum++;
    e.out << "_arg" << argNum;
  }
  e.out << ");\n";

  // Clean up in arguments
  if(reply_required()){
    // Set up startpoints for any objects...
    e.out << "  // Size the reply...\n";
    e.out << "  unsigned long _rsize=globus_nexus_sizeof_int(1);\n";
    string oldleader=e.out.push_leader();
    if(return_type){
      if(!return_type->isvoid()){
	return_type->emit_marshalsize(e, "_ret", "_rsize", "1");
      }
    }
    argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
      argNum++;
      Argument* arg=*iter;
      if(arg->getMode() != Argument::In) {
	std::ostringstream argname;
	argname << "_arg" << argNum;
	arg->emit_marshalsize(e, argname.str(), "_rsize", "1");
      }
    }
    e.out << "  globus_nexus_buffer_t _sendbuff;\n";
    e.out << "  if(int _gerr=globus_nexus_buffer_init(&_sendbuff, _rsize, 0))\n";
    e.out << "    throw ::PIDL::GlobusError(\"buffer_init\", _gerr);\n";
    e.out << "  int _flag=0;\n";
    e.out << "  globus_nexus_put_int(&_sendbuff, &_flag, 1);\n";
    if(return_type){
      if(!return_type->isvoid()){
	e.out << "  // Marshal return value\n";
	return_type->emit_marshal(e, "_ret", "1", "&_sendbuff", true);
      }
    }
    if(list.size() != 0)
      e.out << "  // Marshal arguments\n";
    argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
      argNum++;
      Argument* arg=*iter;
      if(arg->getMode() != Argument::In) {
	std::ostringstream argname;
	argname << "_arg" << argNum;
	arg->emit_marshal(e, argname.str(), "1", "&_sendbuff", true);
      }
    }
    e.out.pop_leader(oldleader);

    e.out << "  // Send the reply...\n";
    int reply_handler_id=0; // Always 0
    e.out << "  if(int _gerr=globus_nexus_send_rsr(&_sendbuff, &_sp, " << reply_handler_id << ", GLOBUS_TRUE, GLOBUS_FALSE))\n";
    e.out << "    throw ::PIDL::GlobusError(\"send_rsr\", _gerr);\n";
    e.out << "  if(int _gerr=globus_nexus_startpoint_eventually_destroy(&_sp, GLOBUS_FALSE, 30))\n";
    e.out << "    throw ::PIDL::GlobusError(\"startpoint_eventually_destroy\", _gerr);\n";
  }
  // Clean up inout and out arguments
    
  e.out << "}\n\n";
}

class output_sub {
  SState& out;
  std::string classname;
public:
  output_sub(SState& out, const std::string& classname)
    : out(out), classname(classname) {}
  void operator()(char x) {
    if(x=='@')
      out << classname;
    else if(x=='\n')
      out << '\n' << out.leader;
    else
      out << x;
  }
};

void CI::emit_proxyclass(EmitState& e)
{
  e.proxy.begin_namespace(symbols->getParent());

  // Proxy
  std::string pname=name+"_proxy";

  e.proxy << leader2 << "class " << pname << " : public ::PIDL::ProxyBase, public " << name << " {\n";
  e.proxy << leader2 << "public:\n";
  e.proxy << leader2 << "  " << pname << "(const ::PIDL::Reference&);\n";
  std::string oldleader=e.proxy.push_leader();
  std::vector<Method*> vtab;
  gatherVtable(vtab, false);

  for(vector<Method*>::const_iterator iter=vtab.begin();
      iter != vtab.end();iter++){
    e.proxy << '\n';
    Method* m=*iter;
    m->emit_prototype(e.proxy, Method::Normal, symbols->getParent());
  }
  e.proxy.pop_leader(oldleader);
  e.proxy << leader2 << "protected:\n";
  e.proxy << leader2 << "  virtual ~" << pname << "();\n";
  e.proxy << leader2 << "private:\n";
  e.proxy << leader2 << "  virtual void _getReference(::PIDL::Reference&, bool copy) const;\n";
  e.proxy << leader2 << "  friend const ::PIDL::TypeInfo* " << name << "::_static_getTypeInfo();\n";
  e.proxy << leader2 << "  static ::PIDL::Object* create_proxy(const ::PIDL::Reference&);\n";
  e.proxy << leader2 << "  " << pname << "(const " << pname << "&);\n";
  e.proxy << leader2 << "  " << pname << "& operator=(const " << pname << "&);\n";
  e.proxy << leader2 << "};\n\n";
  e.proxy.close_namespace();
}

void CI::emit_header(EmitState& e)
{
  e.decl.begin_namespace(symbols->getParent());
  
  std::vector<Method*>& mymethods=myMethods();

  // interface
  e.decl << leader2 << "class " << name << " : ";

  // Parents
  bool haveone=false;
  if(parentclass){
    e.decl << "public " << parentclass->cppfullname(e.decl.currentPackage);
    haveone=true;
  }
  for(vector<Interface*>::iterator iter=parent_ifaces.begin();
      iter != parent_ifaces.end(); iter++){
    if(!haveone){
      haveone=true;
    } else {
      e.decl << ", ";
    }
    e.decl << "virtual public " << (*iter)->cppfullname(e.decl.currentPackage);
  }
  if(!haveone)
    e.decl << "virtual public ::PIDL::Object";
  e.decl << " {\n";
  e.decl << leader2 << "public:\n";
  
  // The smart pointer class
  e.decl << leader2 << "  typedef CCALib::SmartPointer<" << name << "> pointer;\n";

  // The interace class body
  e.decl << leader2 << "  virtual ~" << name << "();\n";
  std::string oldleader=e.decl.push_leader();
  for(vector<Method*>::const_iterator iter=mymethods.begin();
      iter != mymethods.end();iter++){
    e.decl << '\n';
    Method* m=*iter;
    m->emit_prototype(e.decl, Method::PureVirtual, symbols->getParent());
  }
  e.decl.pop_leader(oldleader);
  // The type signature method...
  e.decl << leader2 << "  virtual const ::PIDL::TypeInfo* _virtual_getTypeInfo() const;\n";
  e.decl << leader2 << "  static const ::PIDL::TypeInfo* _static_getTypeInfo();\n";
  e.decl << leader2 << "protected:\n";
  e.decl << leader2 << "  " << name << "(bool initServer=true);\n";
  e.decl << leader2 << "private:\n";
  e.decl << leader2 << "  " << name << "(const " << name << "&);\n";
  e.decl << leader2 << "  " << name << "& operator=(const " << name << "&);\n";
  e.decl << leader2 << "};\n\n";

#ifdef OLDSTUFF
  for_each(handle_class.begin(), handle_class.end(), output_sub(e.decl, name));
  e.decl << "  // Conversion operations\n";
  // Emit an operator() for each parent class and interface...
  vector<CI*> parents;
  gatherParents(parents);
  for(std::vector<CI*>::iterator iter=parents.begin();
      iter != parents.end(); iter++){
    if(*iter != this){
      e.decl << leader2 << "  inline operator " << (*iter)->cppfullname(e.decl.currentPackage) << "() const\n";
      e.decl << leader2 << "  {\n";
      e.decl << leader2 << "    return ptr;\n";
      e.decl << leader2 << "  }\n";
      e.decl << "\n";
    }
  }
  e.decl << leader2 << "};\n\n";
#endif
}

void CI::emit_interface(EmitState& e)
{
  std::string fn=cppfullname(0);
  std::string cn=cppclassname();
  e.out << fn << "::" << cn << "(bool initServer)\n";
  if(parent_ifaces.size() != 0 || parentclass)
    e.out << " : ";
  SymbolTable* localScope=symbols->getParent();
  if(parentclass)
    e.out << parentclass->cppfullname(localScope) << "(false)";
  if(parent_ifaces.size() > 0){
    vector<Interface*> parents;
    gatherParentInterfaces(parents);
    for(vector<Interface*>::iterator iter=parents.begin();
	iter != parents.end(); iter++){
      if(*iter != this){
	if(parentclass || iter != parents.begin())
	  e.out << ",\n   ";
	e.out << (*iter)->cppfullname(localScope) << "(false)";
      }
    }
  }
  e.out << "\n{\n";
  e.out << "  if(initServer)\n";
  e.out << "    initializeServer(" << cppfullname(0) << "::_static_getTypeInfo(), this);\n";
  e.out << "}\n\n";

  e.out << fn << "::~" << cn << "()\n";
  e.out << "{\n";
  e.out << "}\n\n";
}

void CI::emit_proxy(EmitState& e)
{
  std::string fn=cppfullname(0)+"_proxy";
  if(fn[0] == ':' && fn[1] == ':')
    fn=fn.substr(2);
  std::string cn=cppclassname()+"_proxy";
  e.out << fn << "::" << cn << "(const ::PIDL::Reference& _ref) :\n";
  SymbolTable* localScope=symbols->getParent();
  
  e.out << "::PIDL::ProxyBase(_ref),";

  e.out << cppfullname(localScope) << "(false)";
  vector<Interface*> parents;
  gatherParentInterfaces(parents);
  for(vector<Interface*>::iterator iter=parents.begin();
      iter != parents.end(); iter++){
    e.out  << ",\n   "<< (*iter)->cppfullname(localScope) << "(false)";
  }
  e.out << "\n";
  e.out << "{\n";
  e.out << "}\n\n";
  e.out << fn << "::~" << cn << "()\n";
  e.out << "{\n";
  e.out << "}\n\n";
  e.out << "void " << fn << "::_getReference(::PIDL::Reference& ref, bool copy) const\n";
  e.out << "{\n";
  e.out << "  _proxyGetReference(ref, copy);\n";
  e.out << "}\n\n";
  e.out << "::PIDL::Object* " << fn << "::create_proxy(const ::PIDL::Reference& ref)\n";
  e.out << "{\n";
  e.out << "  return new " << cn << "(ref);\n";
  e.out << "}\n\n";
  
  std::vector<Method*> vtab;
  gatherVtable(vtab, false);
  for(vector<Method*>::const_iterator iter=vtab.begin();
      iter != vtab.end();iter++){
    e.out << '\n';
    Method* m=*iter;
    m->emit_proxy(e, fn, localScope);
  }
}

void Method::emit_proxy(EmitState& e, const string& fn,
			SymbolTable* localScope) const
{
  emit_prototype_defin(e, fn+"::", localScope);
  e.out << "\n{\n";
  if(reply_required())
    e.out << "  ::PIDL::ReplyEP* _reply=::PIDL::ReplyEP::acquire();\n";
  e.out << "  globus_nexus_startpoint_t _sp;\n";
  e.out << "  _reply->get_startpoint_copy(&_sp);\n\n";
  std::vector<Argument*>& list=args->getList();
  e.out << "  // Size the buffer\n";
  e.out << "  int _size=";
  if(reply_required())
    e.out << "globus_nexus_sizeof_startpoint(&_sp, 1);\n";
  else
    e.out << "0;\n";
  string oldleader=e.out.push_leader();
  int argNum=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    argNum++;
    Argument* arg=*iter;
    if(arg->getMode() != Argument::Out) {
      std::ostringstream argname;
      argname << "_arg" << argNum;
      arg->emit_marshalsize(e, argname.str(), "_size", "1");
    }
  }
  e.out << "  globus_nexus_buffer_t _buffer;\n";
  e.out << "  if(int _gerr=globus_nexus_buffer_init(&_buffer, _size, 0))\n";
  e.out << "    throw ::PIDL::GlobusError(\"buffer_init\", _gerr);\n";
  if(list.size() != 0)
    e.out << "  // Marshal the arguments\n";
  argNum=0;
  for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
    argNum++;
    Argument* arg=*iter;
    if(arg->getMode() != Argument::Out) {
      std::ostringstream argname;
      argname << "_arg" << argNum;
      arg->emit_marshal(e, argname.str(), "1", "&_buffer", true);
    }
  }
  e.out.pop_leader(oldleader);

  if(reply_required()){
    e.out << "  // Marshal the reply startpoint\n";
    e.out << "  globus_nexus_put_startpoint_transfer(&_buffer, &_sp, 1);\n";
  }
  e.out << "  // Send the message\n";
  e.out << "  ::PIDL::Reference _ref;\n";
  e.out << "  _proxyGetReference(_ref, false);\n";
  e.out << "  int _handler=_ref.getVtableBase()+" << handlerOff << ";\n";
  e.out << "  if(int _gerr=globus_nexus_send_rsr(&_buffer, &_ref.d_sp,\n";
  e.out << "                                     _handler, GLOBUS_TRUE, GLOBUS_FALSE))\n";
  e.out << "    throw ::PIDL::GlobusError(\"send_rsr\", _gerr);\n";
  if(reply_required()){
    e.out << "  globus_nexus_buffer_t _recvbuff=_reply->wait();\n";
    //... emit unmarshal...;
    e.out << "  int _flag;\n";
    e.out << "  globus_nexus_get_int(&_recvbuff, &_flag, 1);\n";
    e.out << "  if(_flag != 0)\n";
    e.out << "    NOT_FINISHED(\"Exceptions not implemented\");\n";
    string oldleader=e.out.push_leader();
    if(return_type){
      if(!return_type->isvoid()){
	e.out << "  // Unmarshal the return value\n";
	return_type->emit_unmarshal(e, "_ret", "1", "&_recvbuff", true);
      }
    }
    if(list.size() != 0)
      e.out << "  // Unmarshal the return arguments\n";
    argNum=0;
    for(vector<Argument*>::const_iterator iter=list.begin();iter != list.end();iter++){
      argNum++;
      Argument* arg=*iter;
      if(arg->getMode() != Argument::In) {
	std::ostringstream argname;
	argname << "_arg" << argNum;
	arg->emit_unmarshal(e, argname.str(), "1", "&_recvbuff", false);
      }
    }
    e.out.pop_leader(oldleader);
    e.out << "  ::PIDL::ReplyEP::release(_reply);\n";
    e.out << "  if(int _gerr=globus_nexus_buffer_destroy(&_recvbuff))\n";
    e.out << "    throw ::PIDL::GlobusError(\"buffer_destroy\", _gerr);\n";
    if(return_type){
      if(!return_type->isvoid()){
	e.out << "  return _ret;\n";
      }
    }
  }
  e.out << "}\n";
}

void Argument::emit_unmarshal(EmitState& e, const string& arg,
			      const string& qty,
			      const string& bufname,
			      bool declare) const
{
  e.out << "  // " << arg << ": " << fullsignature() << "\n";
  type->emit_unmarshal(e, arg, qty, bufname, declare);
}

void Argument::emit_marshalsize(EmitState& e, const string& arg,
				const string& sizevar,
				const string& qty) const
{
  type->emit_marshalsize(e, arg, sizevar, qty);
}

void Argument::emit_declaration(EmitState& e, const string& arg) const
{
  type->emit_declaration(e, arg);
}

void Argument::emit_marshal(EmitState& e, const string& arg,
			    const string& qty,
			    const string& bufname, bool top) const
{
  type->emit_marshal(e, arg, qty, bufname, top);
}

void Argument::emit_prototype(SState& out, SymbolTable* localScope) const
{
  Type::ArgContext ctx;
  switch(mode){
  case In:
    ctx=Type::ArgIn;
    break;
  case Out:
    ctx=Type::ArgOut;
    break;
  case InOut:
    ctx=Type::ArgInOut;
    break;
  }
  type->emit_prototype(out, ctx, localScope);
  if(id != "" && id != "this")
    out << " " << id;
}

void Argument::emit_prototype_defin(SState& out, const std::string& arg,
				    SymbolTable* localScope) const
{
  Type::ArgContext ctx;
  switch(mode){
  case In:
    ctx=Type::ArgIn;
    break;
  case Out:
    ctx=Type::ArgOut;
    break;
  case InOut:
    ctx=Type::ArgInOut;
    break;
  }
  type->emit_prototype(out, ctx, localScope);
  out << " " << arg;
}

void ArrayType::emit_unmarshal(EmitState& e, const string& arg,
			       const string& qty,
			       const string& bufname,
			       bool declare) const
{
  if(qty != "1"){
    cerr << "ArrayType::emit_unmarshall, qty != 1: " << qty << '\n';
    exit(1);
  }
  e.out << leader2 << "int " << arg << "_dim[" << dim << "];\n";
  e.out << leader2 << "globus_nexus_get_int(" << bufname << ", &" << arg << "_dim[0], " << dim << ");\n";
  if(declare){
    e.out << leader2 << cppfullname(0) << " " << arg << "(";
  } else {
    e.out << leader2 << arg << ".resize(";
  }
  for(int i=0;i<dim;i++){
    if(i != 0)
      e.out << ", ";
    e.out << arg << "_dim[" << i << "]";
  }
  e.out << ");\n";
  if(subtype->array_use_pointer()){
    string pname=arg+"_uptr";
    string sizename=arg+"_totalsize";
    e.out << leader2 << "int " << sizename << "=";
    for(int i=0;i<dim;i++){
      if(i != 0)
	e.out << "*";
      e.out << arg << "_dim[" << i << "]";
    }
    e.out << ";\n";
    e.out << leader2 << cppfullname(0) << "::pointer " << pname << "=const_cast< " << cppfullname(0) << "::pointer>(&" << arg << "[0]);\n";
    subtype->emit_unmarshal(e, pname, sizename, bufname, false);
  } else {
    string pname=arg+"_iter";
    e.out << leader2 << "for(" << cppfullname(0) << "::iterator " << pname << "=" << arg << ".begin();";
    e.out << pname << " != " << arg << ".end(); " << pname << "++){\n";
    string oldleader=e.out.push_leader();
    e.out << leader2 << cppfullname(0) << "::reference " << arg << "_el = *" << pname << ";\n";
    subtype->emit_unmarshal(e, arg+"_el", "1", bufname, false);
    e.out.pop_leader(oldleader);
    e.out << leader2 << "}\n";
  }
}

void ArrayType::emit_marshalsize(EmitState& e, const string& arg,
				 const string& sizevar,
				 const string& /* qty */) const
{
  e.out << leader2 << sizevar << " += globus_nexus_sizeof_int(" << dim << "); // array dims\n";
  if(subtype->uniformsize()){
    string sizename=arg+"_mtotalsize";
    if(dim == 1){
      e.out << leader2 << "int " << sizename << "=" << arg << ".size();\n";
    } else {
      string dimname=arg+"_mdim";
      e.out << leader2 << "int " << dimname << "[" << dim << "];\n";
      for(int i=0;i<dim;i++)
	e.out << leader2 << dimname << "[" << i << "]=" << arg << ".size" << i+1 << "();\n";
      e.out << leader2 << "int " << sizename << "=" << dimname << "[0]";
      for(int i=1;i<dim;i++)
	e.out << "*" << dimname << "[" << i << "]";
      e.out << ";\n";
    }
    subtype->emit_marshalsize(e, "", sizevar, arg+"_mtotalsize");
  } else {
    string pname=arg+"_iter";
    e.out << leader2 << "for(" << cppfullname(0) << "::const_iterator " << pname << "=" << arg << ".begin();";
    e.out << pname << " != " << arg << ".end(); " << pname << "++){\n";
    string oldleader=e.out.push_leader();
    e.out << leader2 << cppfullname(0) << "::const_reference " << arg << "_el = *" << pname << ";\n";
    subtype->emit_marshalsize(e, arg+"_el", sizevar, "1");
    e.out.pop_leader(oldleader);
    e.out << leader2 << "}\n";
  }
}

void ArrayType::emit_declaration(EmitState& e, const string& arg) const
{
  e.out << leader2 << cppfullname(0) << " " << arg << ";\n";
}

bool ArrayType::array_use_pointer() const
{
  return false; // Always use iterator for array of array
}

bool ArrayType::uniformsize() const
{
  return false;
}

void ArrayType::emit_marshal(EmitState& e, const string& arg,
			     const string& qty,
			     const std::string& bufname, bool top) const
{
  string pname;
  if(subtype->array_use_pointer()){
    pname=arg+"_mptr";
    e.out << leader2 << cppfullname(0) << "::pointer " << pname << "=const_cast< " << cppfullname(0) << "::pointer>(&" << arg << "[0]);\n";
  } else {
    pname=arg+"_iter";
  }
  string sizename=arg+"_mtotalsize";
  string dimname=arg+"_mdim";
  if(!top || !subtype->uniformsize()){
    if(dim == 1){
      e.out << leader2 << "int " << sizename << "=" << arg << ".size();\n";
    } else {
      e.out << leader2 << "int " << dimname << "[" << dim << "];\n";
      for(int i=0;i<dim;i++)
	e.out << leader2 << dimname << "[" << i << "]=" << arg << ".size" << i+1 << "();\n";
      e.out << leader2 << "int " << sizename << "=" << dimname << "[0]";
      for(int i=1;i<dim;i++)
	e.out << "*" << dimname << "[" << i << "]";
      e.out << ";\n";
    }
  }
  if(dim == 1){
    e.out << leader2 << "globus_nexus_put_int(" << bufname << ", &" << sizename << ", 1);\n";
  } else {
    e.out << leader2 << "globus_nexus_put_int(" << bufname << ", &" << dimname << "[0], " << dim << ");\n";
  }

  if(subtype->array_use_pointer()){
    subtype->emit_marshal(e, pname, sizename, bufname, false);
  } else {
    e.out << leader2 << "for(" << cppfullname(0) << "::const_iterator " << pname << "=" << arg << ".begin();";
    e.out << pname << " != " << arg << ".end(); " << pname << "++){\n";
    e.out << leader2 << cppfullname(0) << "::const_reference " << arg << "_el = *" << pname << ";\n";
    string oldleader=e.out.push_leader();
    subtype->emit_marshal(e, arg+"_el", "1", bufname, false);
    e.out.pop_leader(oldleader);
    e.out << leader2 << "}\n";
  }
}

void ArrayType::emit_rettype(EmitState& e, const string& arg) const
{
  e.out << cppfullname(0) << " _ret";
}

void ArrayType::emit_prototype(SState& out, ArgContext ctx,
			       SymbolTable* localScope) const
{
  if(ctx == ArgIn){
    out << "const ";
  }
  out << cppfullname(0);
  if(ctx == ArgOut || ctx == ArgInOut || ctx == ArgIn)
    out << "&";
}

void BuiltinType::emit_unmarshal(EmitState& e, const string& arg,
				 const string& qty,
				 const string& bufname,
				 bool declare) const
{
  if(cname == "void"){
    // What?
    cerr << "Trying to unmarshal a void!\n";
    exit(1);
  } else if(cname == "bool"){
    if(qty != "1"){
      cerr << "emit_unmarshal called for bool with qty != 1:" << qty << "\n";
      exit(1);
    }
    e.out << leader2 << "globus_byte_t " << arg << "_tmp;\n";
    e.out << leader2 << "globus_nexus_get_byte(" << bufname << ", &" << arg << "_tmp, 1);\n";
    if(declare)
      e.out << leader2 << "bool ";
    e.out << arg << "=(bool)" << arg << "_tmp;\n";
  } else if(cname == "string"){
    if(qty != "1"){
      cerr << "emit_unmarshal call for bool with qty != 1:" << qty << "\n";
      exit(1);
    }
    e.out << leader2 << "int " << arg << "_length;\n";
    e.out << leader2 << "globus_nexus_get_int(" << bufname << ", &" << arg << "_length, 1);\n";
    if(declare)
      e.out << leader2 << "::std::string " << arg << "(" << arg << "_length, ' ');\n";
    else
      e.out << leader2 << arg << ".resize(" << arg << "_length);\n";
    e.out << leader2 << "globus_nexus_get_char(" << bufname << ", const_cast<char*>(" << arg << ".c_str()), " << arg << "_length);\n";
  } else if(cname == "::std::complex<float> "){
    if(qty != "1"){
      e.out << leader2 << "float* " << arg << "_in = new float[2*" << qty << "];\n";
      e.out << leader2 << "globus_nexus_get_float(" << bufname << ", " << arg << "_in, 2*" << qty << ");\n";
      if(declare){
	cerr << "Shouldn't declare arrays!\n";
	exit(1);
      }
      e.out << leader2 << "for(int _i=0;_i<" << qty << ";_i++)\n";
      e.out << leader2 << "  " << arg << "[_i]=" << cname << "(" << arg << "_in[2*_i], " << arg << "_in[2*_i+1]);\n";
      e.out << leader2 << "delete[] " << arg << "_in;\n";
    } else {
      e.out << leader2 << "float " << arg << "_in[2];\n";
      e.out << leader2 << "globus_nexus_get_float(" << bufname << ", " << arg << "_in, 2);\n";
      if(declare)
	e.out << leader2 << cname << " " << arg << "(" << arg << "_in[0], " << arg << "_in[1]);\n";
      else 
	e.out << leader2 << arg << "=complex<float>(" << arg << "_in[0], " << arg << "_in[1]);\n";
    }
  } else if(cname == "::std::complex<double> "){
    if(qty != "1"){
      e.out << leader2 << "double* " << arg << "_in = new double[2*" << qty << "];\n";
      e.out << leader2 << "globus_nexus_get_double(" << bufname << ", " << arg << "_in, 2*" << qty << ");\n";
      if(declare){
	cerr << "Shouldn't declare arrays!\n";
	exit(1);
      }
      e.out << leader2 << "for(int _i=0;_i<" << qty << ";_i++)\n";
      e.out << leader2 << "  " << arg << "[_i]=" << cname << "(" << arg << "_in[2*_i], " << arg << "_in[2*_i+1]);\n";
      e.out << leader2 << "delete[] " << arg << "_in;\n";
    } else {
      e.out << leader2 << "double " << arg << "_in[2];\n";
      e.out << leader2 << "globus_nexus_get_double(" << bufname << ", " << arg << "_in, 2);\n";
      if(declare)
	e.out << leader2 << cname << " " << arg << "(" << arg << "_in[0], " << arg << "_in[1]);\n";
      else 
	e.out << leader2 << arg << "=complex<double>(" << arg << "_in[0], " << arg << "_in[1]);\n";
    }
  } else {
    if(declare)
      e.out << leader2 << cname << " " << arg << ";\n";
    e.out << leader2 << "globus_nexus_get_" << nexusname << "(" << bufname << ", ";
    if(qty == "1")
      e.out << "&";
    e.out << arg << ", " << qty << ");\n";
  }
}

void BuiltinType::emit_marshalsize(EmitState& e, const string& arg,
				   const string& sizevar,
				   const string& qty) const
{
  if(cname == "void"){
    // What?
    cerr << "Trying to size a void!\n";
    exit(1);
  } else if(cname == "string"){
    if(qty != "1"){
      cerr << "emit_marshalsize call for string with qty != 1:" << qty << "\n";
      exit(1);
    }
    e.out << leader2 << sizevar << "+=globus_nexus_sizeof_int(1)+globus_nexus_sizeof_char(" << arg << ".length());\n";
  } else if(cname == "::std::complex<float> "){
    e.out << leader2 << sizevar << "+=globus_nexus_sizeof_float(2*" << qty << ");\n";
  } else if(cname == "::std::complex<double> "){
    e.out << leader2 << sizevar << "+=globus_nexus_sizeof_double(2*" << qty << ");\n";
  } else {
    e.out << leader2 << sizevar << "+=globus_nexus_sizeof_" << nexusname << "(" << qty << ");\n";
  }
}

void BuiltinType::emit_declaration(EmitState& e, const string& arg) const
{
  if(cname == "void"){
    // What?
    cerr << "Trying to declare a void!\n";
    exit(1);
  } else if(cname == "string"){
    e.out << leader2 << "::std::string " << arg << ";\n";
  } else {
    e.out << leader2 << cname << " " << arg << ";\n";
  }
}
	

void BuiltinType::emit_marshal(EmitState& e, const string& arg,
			       const string& qty, 
			       const string& bufname, bool/* top*/) const
{
  if(cname == "void"){
    // What?
    cerr << "Trying to unmarshal a void!\n";
    exit(1);
  } else if(cname == "bool"){
    if(qty != "1"){
      cerr << "marshal bool called with qty != 1: " << qty << '\n';
      exit(1);
    }
    e.out << leader2 << "globus_byte_t " << arg << "_tmp = " << arg << ";\n";
    e.out << leader2 << "globus_nexus_put_byte (" << bufname << ", &" << arg << "_tmp, 1);\n";
  } else if(cname == "string"){
    if(qty != "1"){
      cerr << "marshal string called with qty != 1: " << qty << '\n';
      exit(1);
    }
    e.out << leader2 << "int " << arg << "_len=" << arg << ".length();\n";
    e.out << leader2 << "globus_nexus_put_int(" << bufname << ", &" << arg << "_len, 1);\n";
    e.out << leader2 << "globus_nexus_put_char(" << bufname << ", const_cast<char*>(" << arg << ".c_str()), " << arg << "_len);\n";
  } else if(cname == "::std::complex<float> "){
    if(qty != "1"){
      e.out << leader2 << "float* " << arg << "_out = new float[2*" << qty << "];\n";
      e.out << leader2 << "for(int _i=0;_i<" << qty << ";_i++){\n";
      e.out << leader2 << "  " << arg << "_out[2*_i]=" << arg << "[_i].real();\n";
      e.out << leader2 << "  " << arg << "_out[2*_i+1]=" << arg << "[_i].imag();\n";
      e.out << leader2 << "}\n";
      e.out << leader2 << "globus_nexus_put_float(" << bufname << ", " << arg << "_out, 2*" << qty << ");\n";
      e.out << leader2 << "delete[] " << arg << "_out;\n";
    } else {
      e.out << leader2 << "float " << arg << "_out[2];\n";
      e.out << leader2 << arg << "_out[0]=" << arg << ".real();\n";
      e.out << leader2 << arg << "_out[1]=" << arg << ".imag();\n";
      e.out << leader2 << "globus_nexus_put_float(" << bufname << ", " << arg << "_out, 2);\n";
    }
  } else if(cname == "::std::complex<double> "){
    if(qty != "1"){
      e.out << leader2 << "double* " << arg << "_out = new double[2*" << qty << "];\n";
      e.out << leader2 << "for(int _i=0;_i<" << qty << ";_i++){\n";
      e.out << leader2 << "  " << arg << "_out[2*_i]=" << arg << "[_i].real();\n";
      e.out << leader2 << "  " << arg << "_out[2*_i+1]=" << arg << "[_i].imag();\n";
      e.out << leader2 << "}\n";
      e.out << leader2 << "globus_nexus_put_double(" << bufname << ", " << arg << "_out, 2*" << qty << ");\n";
      e.out << leader2 << "delete[] " << arg << "_out;\n";
    } else {
      e.out << leader2 << "double " << arg << "_out[2];\n";
      e.out << leader2 << arg << "_out[0]=" << arg << ".real();\n";
      e.out << leader2 << arg << "_out[1]=" << arg << ".imag();\n";
      e.out << leader2 << "globus_nexus_put_double(" << bufname << ", " << arg << "_out, 2);\n";
    }
  } else {
    e.out << leader2 << "globus_nexus_put_" << nexusname << "(" << bufname << ", ";
    if(qty == "1")
      e.out << "&";
    e.out << arg << ", " << qty << ");\n";
  }
}

void BuiltinType::emit_rettype(EmitState& e, const string& arg) const
{
  if(cname == "void"){
    // Nothing
    return;
  } else if(cname == "string"){
    e.out << "::std::string " << arg;
  } else {
    e.out << cname << " " << arg;
  }
}

void BuiltinType::emit_prototype(SState& out, ArgContext ctx,
				 SymbolTable*) const
{
  if(cname == "void"){
    // Nothing
    if(ctx == ReturnType)
      out << "void";
    else {
      cerr << "Illegal void type in argument list\n";
      exit(1);
    }
  } else if(cname == "string"){
    switch(ctx){
    case ReturnType:
    case ArrayTemplate:
      out << "::std::string";
      break;
    case ArgIn:
      out << "const ::std::string&";
      break;
    case ArgOut:
    case ArgInOut:
      out << "::std::string&";
      break;
    }
  } else {
    switch(ctx){
    case ReturnType:
    case ArgIn:
    case ArrayTemplate:
      out << cname;
      break;
    case ArgOut:
    case ArgInOut:
      out << cname << "&";
      break;
    }
  }
}

bool BuiltinType::array_use_pointer() const
{
  if(cname == "string" || cname == "bool")
    return false;
  else
    return true;
}

bool BuiltinType::uniformsize() const
{
  if(cname == "string")
    return false;
  else
    return true;
}

void NamedType::emit_unmarshal(EmitState& e, const string& arg,
			       const string& qty,
			       const string& bufname,
			       bool declare) const
{
  Symbol::Type symtype = name->getSymbol()->getType();
  if(symtype == Symbol::EnumType){
    if(qty != "1"){
      cerr << "NamedType::emit_unmarshal called with qty != 1: " << qty << '\n';
      exit(1);
    }
    e.out << leader2 << "int " << arg << "_unmarshal;\n";
    e.out << leader2 << "globus_nexus_get_int(" << bufname << ", &" << arg << "_unmarshal, 1);\n";
    e.out << leader2;
    if(declare)
      e.out << name->cppfullname(0) << " ";
    e.out << arg << "=(" << name->cppfullname(0) << ")" << arg << "_unmarshal;\n";
  } else if(symtype == Symbol::ClassType || symtype == Symbol::InterfaceType){
    if(qty != "1"){
      cerr << "NamedType::emit_unmarshal called with qty != 1: " << qty << '\n';
      exit(1);
    }    
    e.out << leader2 << "int " << arg << "_vtable_base;\n";
    e.out << leader2 << "globus_nexus_get_int(" << bufname << ", &" << arg << "_vtable_base, 1);\n";
    if(declare)
      e.out << leader2 << name->cppfullname(0) << "::pointer " << arg << ";\n";
    e.out << leader2 << "if(" << arg << "_vtable_base == -1){\n";
    e.out << leader2 << "  " << arg << "=0;\n";
    e.out << leader2 << "} else {\n";
    e.out << leader2 << "  ::PIDL::Reference _ref;\n";
    e.out << leader2 << "  globus_nexus_get_startpoint(" << bufname << ", &_ref.d_sp, 1);\n";
    e.out << leader2 << "  _ref.d_vtable_base=" << arg << "_vtable_base;\n";
    e.out << leader2 << "  if(globus_nexus_startpoint_to_current_context(&_ref.d_sp)){\n";
    e.out << leader2 << "    globus_nexus_endpoint_t* _ep;\n";
    e.out << leader2 << "    if(int _gerr=globus_nexus_startpoint_get_endpoint(&_ref.d_sp, &_ep))\n";
    e.out << leader2 << "      throw ::PIDL::GlobusError(\"get_endpoint\", _gerr);\n";
    e.out << leader2 << "    void* _ptr=globus_nexus_endpoint_get_user_pointer(_ep);\n";
    e.out << leader2 << "    ::PIDL::ServerContext* _sc=static_cast< ::PIDL::ServerContext*>(_ptr);\n";
    e.out << leader2 << "    " << arg << "=dynamic_cast< " << name->cppfullname(0) << "*>(_sc->d_objptr);\n";
    e.out << leader2 << "    if(int _gerr=globus_nexus_startpoint_destroy(&_ref.d_sp))\n";
    e.out << leader2 << "      throw ::PIDL::GlobusError(\"startpoint_destroy\", _gerr);\n";
    e.out << leader2 << "  } else {\n";
    e.out << leader2 << "    " << arg << "=new " << name->cppfullname(0) << "_proxy(_ref);\n";
    e.out << leader2 << "  }\n";
    e.out << leader2 << "}\n";
  }
}

void NamedType::emit_marshalsize(EmitState& e, const string& arg,
				 const string& sizevar,
				 const string& qty) const
{
  Symbol::Type symtype = name->getSymbol()->getType();
  if(symtype == Symbol::EnumType){
    e.out << leader2 << sizevar << "+=globus_nexus_sizeof_int(1);\n";
  } else if(symtype == Symbol::ClassType || symtype == Symbol::InterfaceType){
    if(qty != "1"){
      cerr << "NamedType::emit_marshalsize called with qty != 1: " << qty << '\n';
      exit(1);
    }
    e.out << leader2 << "::PIDL::Reference " << arg << "_ref;\n";
    e.out << leader2 << "if(!" << arg << ".isNull()){\n";
    e.out << leader2 << "  " << arg << "->addReference();\n";
    e.out << leader2 << "  " << arg << "->_getReference(" << arg << "_ref, true);\n";
    e.out << leader2 << "}\n";
    e.out << leader2 << sizevar << "+=globus_nexus_sizeof_int(1)+(";
    e.out << arg << ".isNull()?0:globus_nexus_sizeof_startpoint(&" << arg << "_ref.d_sp, 1));\n";
  } else {
    cerr << "Emit marshalsize shouldn't be called for packages/methods\n";
    exit(1);
  }
}

void NamedType::emit_declaration(EmitState& e, const string& arg) const
{
  e.out << leader2 << cppfullname(0) << " " << arg << ";\n";
}

void NamedType::emit_marshal(EmitState& e, const string& arg,
			     const string& qty,
			     const string& bufname, bool /*top*/) const
{
  Symbol::Type symtype = name->getSymbol()->getType();
  if(symtype == Symbol::EnumType){
    if(qty != "1"){
      cerr << "NamedType::emit_marshal called with qty != 1: " << qty << '\n';
      exit(1);
    }
    e.out << leader2 << "int " << arg << "_marshal = (int)" << arg << ";\n";
    e.out << leader2 << "globus_nexus_put_int(" << bufname << ", &" << arg << "_marshal, 1);\n";
  } else if(symtype == Symbol::ClassType || symtype == Symbol::InterfaceType){
    if(qty != "1"){
      cerr << "NamedType::emit_marshal called with qty != 1: " << qty << '\n';
      exit(1);
    }
    e.out << leader2 << "if(!" << arg << ".isNull()){\n";
    e.out << leader2 << "  const ::PIDL::TypeInfo* _dt=" << arg << "->_virtual_getTypeInfo();\n";
    e.out << leader2 << "  const ::PIDL::TypeInfo* _bt=" << name->cppfullname(0) << "::_static_getTypeInfo();\n";
    e.out << leader2 << "  int _vtable_offset=_dt->computeVtableOffset(_bt);\n";
    e.out << leader2 << "  ::PIDL::Reference " << arg << "_ref;\n";
    e.out << leader2 << "  " << arg << "->_getReference(" << arg << "_ref, true);\n";
    e.out << leader2 << "  int _vtable_base=" << arg << "_ref.getVtableBase()+_vtable_offset;\n";
    e.out << leader2 << "  globus_nexus_put_int(" << bufname << ", &_vtable_base, 1);\n";
    e.out << leader2 << "  globus_nexus_put_startpoint_transfer(" << bufname << ", &" << arg << "_ref.d_sp, 1);\n";
    e.out << leader2 << "} else {\n";
    e.out << leader2 << "  int _vtable_base=-1; // Null ptr\n";
    e.out << leader2 << "  globus_nexus_put_int(" << bufname << ", &_vtable_base, 1);\n";
    e.out << leader2 << "}\n";
  } else {
    cerr << "Emit marshal shouldn't be called for packages/methods\n";
    exit(1);
  }
}

void NamedType::emit_rettype(EmitState& e, const string& arg) const
{
  Symbol::Type symtype = name->getSymbol()->getType();
  if(symtype == Symbol::EnumType)
    e.out << name->cppfullname(0) << " " << arg;
  else
    e.out << name->cppfullname(0) << "::pointer " << arg;
}

void NamedType::emit_prototype(SState& out, ArgContext ctx,
			       SymbolTable* localScope) const
{
  // Ensure that it is forward declared...
  name->getSymbol()->emit_forward(*out.e);
  switch(ctx){
  case ReturnType:
  case ArrayTemplate:
    out << cppfullname(localScope);
    break;
  case ArgIn:
    if(name->getSymbol()->getType() == Symbol::EnumType)
      out << cppfullname(localScope);
    else
      out << "const " << cppfullname(localScope) << "&";
    break;
  case ArgOut:
  case ArgInOut:
    out << cppfullname(localScope) << "&";
    break;
  }
}

bool NamedType::array_use_pointer() const
{
  return false; // Always use iterator for array of references
}

bool NamedType::uniformsize() const
{
  return false; // Startpoints can vary in size
}

void Enum::emit(EmitState& e)
{
  if(emitted_declaration)
    return;

  e.fwd.begin_namespace(symbols->getParent());
  e.fwd << leader2 << "enum " << name << " {";
  bool first=true;
  for(std::vector<Enumerator*>::iterator iter = list.begin();
      iter != list.end(); iter++){
    (*iter)->emit(e, first);
    first=false;
  }
  e.fwd << "\n";
  e.fwd << leader2 << "};\n";
  emitted_declaration=true;
}

void Enumerator::emit(EmitState& e, bool first)
{
  if(!first)
    e.fwd << ",";
  e.fwd << "\n";
  e.fwd << leader2 << "  " << name << "=" << value;
}
