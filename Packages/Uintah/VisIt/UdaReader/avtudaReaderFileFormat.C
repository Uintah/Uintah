/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtudaReaderFileFormat.C                           //
// ************************************************************************* //

#include <avtudaReaderFileFormat.h>

#include <stdio.h>
#include <dlfcn.h>
#include <string>

#include <vtkPoints.h>
#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

using     std::string;

#define PARTICLE_INTERVAL 1


// ****************************************************************************
//  Method: avtudaReaderFileFormat constructor
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

avtudaReaderFileFormat::avtudaReaderFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1)
{
	cout << "\nIn avtudaReaderFileFormat\n";

    // INITIALIZE DATA MEMBERS
	bool fileOpened = false;
	
	folder.assign("/home/collab/sshankar/csafe_data/jp8_tuna_can_Dmin_Pmax_rel_Wmax.uda");
	// folder.assign(filename);
	// size_t found = folder.find_last_of("/");
	// folder = folder.substr(0, found);

	cout << folder << endl;
	
	libHandle = dlopen("/home/collab/sshankar/SVN/SCIRun/build/lib/libPackages_Uintah_StandAlone_tools_uda2nrrd.so", RTLD_NOW); // The dylib locn should be changed
	if (!libHandle) {
	    cerr << "The library libuda2nrrd could not be located!!!"; 
		EXCEPTION1(InvalidDBTypeException, "The library libuda2nrrd could not be located!!!");
	}

	// All possile function calls - check here

	*(void **)(&getTimeSteps) = dlsym(libHandle, "getTimeSteps");
	if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getTimeSteps could be located in the library!!!");
	}

    *(void **)(&getVarList) = dlsym(libHandle, "getVarList");
	if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getVarList could be located in the library!!!");
	}

	*(void **)(&getMaterials) = dlsym(libHandle, "getMaterials");
	if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getMaterials could be located in the library!!!");
	}

	*(void **)(&getBBox) = dlsym(libHandle, "getBBox");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getBBox could be located in the library!!!");
	}

	*(void **)(&processData) = dlsym(libHandle, "processData");
	if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function processData could be located in the library!!!");
	}    
	
	// Check to see if the file could be opened should be here
	// fileOpened should be set if the file could be opened
	fileOpened = true;
	
	// No. of timesteps
	timeSteps = *((*getTimeSteps)(folder));
	
	cout << "Out avtudaReaderFileFormat\n";
}	


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

int
avtudaReaderFileFormat::GetNTimesteps(void)
{
    return timeSteps;
}


// ****************************************************************************
//  Method: avtudaReaderFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

void
avtudaReaderFileFormat::FreeUpResources(void)
{
	dlclose(libHandle);
}


// ****************************************************************************
//  Method: avtudaReaderFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

void
avtudaReaderFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    //
    // CODE TO ADD A MESH
    //
	cout << "\nIn PopulateDatabaseMetaData\n";

	// string meshname = "mesh_variable";

	//
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    int nblocks = 1;  // <-- this must be 1 for MTSD
    int block_origin = 0;
    int spatial_dimension = 3;
    int topological_dimension;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                    spatial_dimension, topological_dimension);
    //

	// string meshname = "mesh_particle";

	//
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
	avtMeshType mt;
    avtCentering cent;
    //
    // int nblocks = 1;  // <-- this must be 1 for MTSD
    // int block_origin = 0;
    // int spatial_dimension = 3;
    // topological_dimension = 0;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                    spatial_dimension, topological_dimension);
    //

	// *(void **)(&getVarList) = dlsym(libHandle, "getVarList");
	/*if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getVarList could be located in the library!!!");
	}*/

	// *(void **)(&getMaterials) = dlsym(libHandle, "getMaterials");
	/*if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function getMaterials could be located in the library!!!");
	}*/

	// *(void **)(&getBBox) = dlsym(libHandle, "getBBox");
	/*if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getBBox could be located in the library!!!");
	}*/
	
	double* minMaxArr = (*getBBox)(folder, timeState);

	double extents[6];
	
	extents[0] = minMaxArr[0];
	extents[1] = minMaxArr[3];
	extents[2] = minMaxArr[1];
	extents[3] = minMaxArr[4];
	extents[4] = minMaxArr[2];
	extents[5] = minMaxArr[5];

	udaVars* udaVarsPtr = (*getVarList)(folder);
	udaVars& udaVarsObj = *(udaVarsPtr);

	for (int i = 0; i < udaVarsObj.size(); i++) {
	  if (udaVarsObj[i].find("p.") == string::npos) {
	    string varname = udaVarsObj[i];
		size_t found = varname.find("/");
		
		string vartype = varname.substr(found + 1);
		varname = varname.substr(0, found);
  
        varMatls* varMatlsPtr = (*getMaterials)(folder, varname, timeState);
	    varMatls& varMatlsObj = *(varMatlsPtr); 

		if (varMatlsObj.size() == 0)
		  cout << varname << " has no materials\n";
		  
	    for (int j = 0; j < varMatlsObj.size(); j++) {
			char buffer[128];
			string newVarname = varname;
			sprintf(buffer, "%d", varMatlsObj[j]);
			newVarname.append("/");
			newVarname.append(buffer);
			
			string mesh_for_this_var;
			
			mt = AVT_RECTILINEAR_MESH;
			topological_dimension = 1;
			
			if (vartype.find("NC") != string::npos) {
			  cent = AVT_NODECENT;
			  mesh_for_this_var.assign("NC"); 
			}  
			else if (vartype.find("CC") != string::npos) {  
			  cent = AVT_ZONECENT;
			  mesh_for_this_var.assign("CC"); 
			}
			else if (vartype.find("SFC") != string::npos) { // face centered variables, point mesh -> as suggested by Dav 
			  cent = AVT_NODECENT;
			  
			  if (vartype.find("SFCX") != string::npos)		
			    mesh_for_this_var.assign("SFCX");
			  else if (vartype.find("SFCY") != string::npos)		
			    mesh_for_this_var.assign("SFCY");
			  else if (vartype.find("SFCZ") != string::npos)		
			    mesh_for_this_var.assign("SFCZ");		 			  
			  
			  mt = AVT_POINT_MESH;
			  topological_dimension = 0; 
			}  
			
			mesh_for_this_var.append("mesh_");
			mesh_for_this_var.append(newVarname);

			cout << newVarname << " " << mesh_for_this_var << endl;
			
			AddMeshToMetaData(md, mesh_for_this_var, mt, extents, nblocks, block_origin,
							  spatial_dimension, topological_dimension);
			
			if (vartype.find("Vector") != string::npos) 
			  AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
            else if (vartype.find("Matrix3") != string::npos)
			  AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
			else  
			  AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
		}
	  }	
	}
	
	for (int i = 0; i < udaVarsObj.size(); i++) {
	  if (udaVarsObj[i].find("p.") != string::npos && udaVarsObj[i].find("p.x") == string::npos) {
        string varname = udaVarsObj[i];
		size_t found = varname.find("/");
		
		string vartype = varname.substr(found + 1);
		varname = varname.substr(0, found);

		varMatls* varMatlsPtr = (*getMaterials)(folder, varname, timeState);
	    varMatls& varMatlsObj = *(varMatlsPtr); 
        bool addStar = false;
	    for (int j = 0; j < varMatlsObj.size(); j++) {
			char buffer[128];
			string newVarname = varname;
			sprintf(buffer, "%d", varMatlsObj[j]);
			newVarname.append("/");
			
			if (j == 0 && addStar == false) {
			  newVarname.append("*");
			  j--;
			  addStar = true;
			}    
			else
			  newVarname.append(buffer);
			
			string mesh_for_this_var = string("mesh_particle_");
			mesh_for_this_var.append(newVarname);

			cout << newVarname << " " << mesh_for_this_var << endl;
			
			mt = AVT_POINT_MESH;
			topological_dimension = 0;
			AddMeshToMetaData(md, mesh_for_this_var, mt, extents, nblocks, block_origin,
							  spatial_dimension, topological_dimension);
			
			cent = AVT_NODECENT;

			if (vartype.find("Vector") != string::npos) 
			  AddVectorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 3); // 3 -> vector dimension
            else if (vartype.find("Matrix3") != string::npos)
			  AddTensorVarToMetaData(md, newVarname, mesh_for_this_var, cent, 9); // 9 -> tensor 
			else  
			  AddScalarVarToMetaData(md, newVarname, mesh_for_this_var, cent);
		}
	  }	
	}

	//
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
	cout << "Out PopulateDatabaseMetaData\n";
}


// ****************************************************************************
//  Method: avtudaReaderFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

vtkDataSet *
avtudaReaderFileFormat::GetMesh(int timestate, const char *meshname)
{
    // YOU MUST IMPLEMENT THIS
	// timeState is btwn 0 and timeSteps - 1

	string meshName(meshname);

	if (meshName.find("mesh_particle") == string::npos) { // volume data
		cout << "\nIn GetMesh\n";
		cout << meshName << " ";

        size_t found1 = meshName.find("_");
		size_t found2 = meshName.find("/");

		string varName = meshName.substr(found1 + 1, found2 - (found1 + 1));
		string matlNo = meshName.substr(found2 + 1);

		cout << varName << endl;
		cout << matlNo << endl;

		// *(void **)(&getBBox) = dlsym(libHandle, "getBBox");
		/*if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function getBBox could be located in the library!!!");
		}*/

		double* minMaxArr = (*getBBox)(folder, timestate);

		// *(void **)(&processData) = dlsym(libHandle, "processData");
		/*if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function processData could be located in the library!!!");
		}*/

		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-v");
		strcpy(arr2d[4], varName.c_str());
		strcpy(arr2d[5], "-m");
		strcpy(arr2d[6], matlNo.c_str());
		strcpy(arr2d[7], "-o");
		strcpy(arr2d[8], "test"); // anything will do

		timeStep *timeStepObjPtr = (*processData)(9, arr2d, timestate, false, 0, false);
	    timeStep &timeStepObj = *timeStepObjPtr;

		cellVals& cellValColln = *(timeStepObj.cellValColln);
		
		int ndims = 3; 
		int dims[3] = {cellValColln.x + 1, cellValColln.y + 1, cellValColln.z + 1}; // for node centered -> remove +1
		vtkFloatArray *coords[3] = {0,0,0};
		
		double dx, dy, dz;
		dx = (minMaxArr[3] - minMaxArr[0]) / cellValColln.x; // for node centered -> -1
		dy = (minMaxArr[4] - minMaxArr[1]) / cellValColln.y;
		dz = (minMaxArr[5] - minMaxArr[2]) / cellValColln.z;
		
		double dtdx, dtdy, dtdz;
		dtdx = dtdy = dtdz = 0.;
		
		if (meshName.find("NC") != string::npos) {
		  cout << "NC Mesh\n";
		  dims[0] = cellValColln.x;
		  dims[1] = cellValColln.y;
		  dims[2] = cellValColln.z;
		  		
		  dx = (minMaxArr[3] - minMaxArr[0]) / (cellValColln.x - 1);
		  dy = (minMaxArr[4] - minMaxArr[1]) / (cellValColln.y - 1);
		  dz = (minMaxArr[5] - minMaxArr[2]) / (cellValColln.z - 1);
		}  
		else if (meshName.find("SFC") != string::npos) {
		  cout << "SFC Mesh\n";
		  dims[0] = cellValColln.x;
		  dims[1] = cellValColln.y;
		  dims[2] = cellValColln.z;
		  		
		  dx = (minMaxArr[3] - minMaxArr[0]) / cellValColln.x;
		  dy = (minMaxArr[4] - minMaxArr[1]) / cellValColln.y;
		  dz = (minMaxArr[5] - minMaxArr[2]) / cellValColln.z;
		  
		  if (meshName.find("SFCX") != string::npos) {
		    cout << "SFCX\n";
		    dx = (minMaxArr[3] - minMaxArr[0]) / (cellValColln.x - 1);
		    dtdy = dy / 2.;
		    dtdz = dz / 2.;
		  }
		  else if (meshName.find("SFCY") != string::npos) {
			cout << "SFCY\n";
			dy = (minMaxArr[4] - minMaxArr[1]) / (cellValColln.y - 1);
		    dtdx = dx / 2.;
		    dtdz = dz / 2.;
	      }
		  else if (meshName.find("SFCZ") != string::npos) {
		    cout << "SFCZ\n";
			dz = (minMaxArr[5] - minMaxArr[2]) / (cellValColln.z - 1);
		    dtdx = dx / 2.;
		    dtdy = dy / 2.;
	      }			
		}
		
		// Read the X coordinates from the file. 
		coords[0] = vtkFloatArray::New(); 
		coords[0]->SetNumberOfTuples(dims[0]); 
		float *xarray = (float *)coords[0]->GetVoidPointer(0); 
		for (int i = 0; i < dims[0]; i++) {
		  xarray[i] =  (minMaxArr[0] + dtdx) + i * dx;
		  // cout << xarray[i] << " ";
		}
		
		// cout << "\n";
		
		// Read the Y coordinates from the file. 
		coords[1] = vtkFloatArray::New(); 
		coords[1]->SetNumberOfTuples(dims[1]); 
		float *yarray = (float *)coords[1]->GetVoidPointer(0); 
		for (int i = 0; i < dims[1]; i++) {
		  yarray[i] =  (minMaxArr[1] + dtdy) + i * dy;
		  // cout << yarray[i] << " ";
		}
		
		// cout << "\n";
		
		// Read the Z coordinates from the file. 
		coords[2] = vtkFloatArray::New(); 
		coords[2]->SetNumberOfTuples(dims[2]); 
		float *zarray = (float *)coords[2]->GetVoidPointer(0); 
		for (int i = 0; i < dims[2]; i++) {
		  zarray[i] =  (minMaxArr[2] + dtdz) + i * dz;
		  // cout << zarray[i] << " ";
		}
		
		// cout << "\n";

		if (meshName.find("SFC") != string::npos) {
		  unsigned int nnodes = dims[0] * dims [1] * dims[2];
		  	
		  vtkPoints *points = vtkPoints::New(); 
		  points->SetNumberOfPoints(nnodes); 
		  float *pts = (float *) points->GetVoidPointer(0); 
		  
		  for (int p = 0; p < dims[0]; p++) {
		    for (int q = 0; q < dims[1]; q++) {
			  for (int r = 0; r < dims[2]; r++) {
				// cout << xarray[p] << " " << yarray[q] << " " << zarray[r] << endl;
			    *pts++ = xarray[p];
				*pts++ = yarray[q];
				*pts++ = zarray[r];
			  }
		    }
		  }

          // 
		  // Create a vtkUnstructuredGrid to contain the point cells. 
		  // 
		
		  vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
		  ugrid->SetPoints(points); 
		  points->Delete(); 
		  ugrid->Allocate(nnodes); 
		  vtkIdType onevertex; 
		
		  for(int i = 0; i < nnodes; ++i) { 
		    onevertex = i; 
			ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex); 
		  }

		  coords[0]->Delete();
		  coords[1]->Delete();
		  coords[2]->Delete();
		  
		  cout << "Out GetMesh\n";

		  return ugrid;
		}
		else {
		
		  // 
		  // Create the vtkRectilinearGrid object and set its dimensions 
		  // and coordinates. 
		  // 
		  vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New(); 
		  rgrid->SetDimensions(dims); 
		  rgrid->SetXCoordinates(coords[0]); 
		  coords[0]->Delete(); 
		  rgrid->SetYCoordinates(coords[1]); 
		  coords[1]->Delete();
		  rgrid->SetZCoordinates(coords[2]); 
		  coords[2]->Delete(); 

		  cout << "Out GetMesh\n";

		  return rgrid;
	    }	   
	}
	else if (meshName.find("mesh_particle") != string::npos) { // particle data
		cout << "\nIn GetMesh\n";
		cout << meshName << endl;

		size_t found = meshName.find("/");
		string matl = meshName.substr(found + 1);
		
		int matlNo = 0;
		
		if (matl.compare("*") != 0)
		  matlNo = atoi(matl.c_str());

		cout << matlNo << endl;

		// *(void **)(&processData) = dlsym(libHandle, "processData");
		/*if((error = dlerror()) != NULL) {
			EXCEPTION1(InvalidDBTypeException, "The function processData could be located in the library!!!");
		}*/

		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-p");
		strcpy(arr2d[4], "-o");
		strcpy(arr2d[5], "test"); // anything will do

		timeStep *timeStepObjPtr;
		
		if (matl.compare("*") == 0) {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false); 
		  cout << "All data\n";
        }
        else {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true);
		  cout << "Some data\n";
		}  

		timeStep &timeStepObj = *timeStepObjPtr;

		variables& varCollnRef = *(timeStepObj.varColln);

		unsigned int i, ndims, nnodes, count = 0;
		
		ndims = 3;
		
		if ((varCollnRef.size() % PARTICLE_INTERVAL) != 0) 
		  nnodes = (varCollnRef.size() / PARTICLE_INTERVAL) + 1;
		else
		  nnodes = varCollnRef.size() / PARTICLE_INTERVAL;

		cout << nnodes << endl;

		float *xarray = new float[nnodes];
		float *yarray = new float[nnodes]; 
		float *zarray = new float[nnodes];

		float *xc = xarray; 
		float *yc = yarray; 
		float *zc = zarray; 

		for (i = 0; i < nnodes; ++i) {
		  variable& varRef = varCollnRef[i * PARTICLE_INTERVAL];
		  *xc++ = varRef.x;
		  *yc++ = varRef.y;
		  *zc++ = varRef.z;
          // cout << varRef.x << " " << varRef.y << " " << varRef.z << endl;
		}

		// 
		// Create the vtkPoints object and copy points into it. 
		// 
		
		vtkPoints *points = vtkPoints::New(); 
		points->SetNumberOfPoints(nnodes); 
		float *pts = (float *) points->GetVoidPointer(0); 
		
		xc = xarray; 
		yc = yarray; 
		zc = zarray; 
		
		if(ndims == 3) 
		{ 
			for(i = 0; i < nnodes; ++i) 
			{ 
				*pts++ = *xc++; 
				*pts++ = *yc++; 
				*pts++ = *zc++;
			}
		} 
		else if(ndims == 2) 
		{ 
			for(i = 0; i < nnodes; ++i) 
			{ 
				*pts++ = *xc++; 
				*pts++ = *yc++; 
				*pts++ = 0.; 
			} 
		}	

		// 
		// Create a vtkUnstructuredGrid to contain the point cells. 
		// 
		
		vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
		ugrid->SetPoints(points); 
		points->Delete(); 
		ugrid->Allocate(nnodes); 
		vtkIdType onevertex; 
		
		for(int i = 0; i < nnodes; ++i) 
		{ 
			onevertex = i; 
			ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex); 
		} 

		// Delete temporary arrays. 
		delete [] xarray; 
		delete [] yarray; 
		delete [] zarray;

		cout << "Out GetMesh\n";

		return ugrid;
	}
}


// ****************************************************************************
//  Method: avtudaReaderFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

vtkDataArray *
avtudaReaderFileFormat::GetVar(int timestate, const char *varname)
{
    // YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

	cout << "\nIn GetVar\n";
	
	string varName(varname);
	
	// *(void **)(&processData) = dlsym(libHandle, "processData");
	/*if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function processData could be located in the library!!!");
	}*/

	vtkFloatArray *rv = vtkFloatArray::New();

	if (varName.find("p.") == string::npos) {
	    size_t found = varName.find("/");
		
		string matlNo = varName.substr(found + 1);
		varName = varName.substr(0, found);

		cout << varName << endl;
		cout << matlNo << endl;
	
		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-v");
		strcpy(arr2d[4], varName.c_str());
		strcpy(arr2d[5], "-m");
		strcpy(arr2d[6], matlNo.c_str());
		strcpy(arr2d[7], "-o");
		strcpy(arr2d[8], "test"); // anything will do

		timeStep *timeStepObjPtr = (*processData)(9, arr2d, timestate, true, 0, false);
	    timeStep &timeStepObj = *timeStepObjPtr;
		
		cellVals& cellValColln = *(timeStepObj.cellValColln);
		typeDouble& cellValVec = *(cellValColln.cellValVec);

		rv->SetNumberOfTuples(cellValVec.size());

		for (unsigned int i = 0; i < cellValVec.size(); ++i) {
		  rv->SetTuple1(i, cellValVec[i]);  // you must determine value for ith entry.
		}
	}
	else {
		size_t found = varName.find("/");
		
		string matl = varName.substr(found + 1);
		varName = varName.substr(0, found);

		int matlNo = 0;
		
		if (matl.compare("*") != 0)
		  matlNo = atoi(matl.c_str());

		cout << varName << endl;
		cout << matlNo << endl;
		
		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-p");
		strcpy(arr2d[4], "-o");
		strcpy(arr2d[5], "test"); // anything will do

		timeStep *timeStepObjPtr;
		
		if (matl.compare("*") == 0) {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false); 
		  cout << "All data\n";
		}  
        else { 
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true);
		  cout << "Some data\n";
		}  
	    
		timeStep &timeStepObj = *timeStepObjPtr;

		variables& varColln = *(timeStepObj.varColln);

		int ntuples = 0;

		if ((varColln.size() % PARTICLE_INTERVAL) != 0) 
		  ntuples = (varColln.size() / PARTICLE_INTERVAL) + 1;
		else
		  ntuples = varColln.size() / PARTICLE_INTERVAL;

		cout << ntuples << endl;
		
		//
		// If you do have a scalar variable, here is some code that may be helpful.
		//
		
		// int ntuples = varColln.size(); // this is the number of entries in the variable.
		rv->SetNumberOfTuples(ntuples);
		for (int i = 0 ; i < ntuples ; i++) {
			variable& varRef = varColln[i * PARTICLE_INTERVAL];
			unknownData& dataRef = varRef.data;
			
			for (int j = 0;  j < dataRef.size(); j++) {
				if (strcmp(varName.c_str(), dataRef[j].name.c_str()) == 0)
					rv->SetTuple1(i, dataRef[j].value);  // you must determine value for ith entry.
			}
		}
	}

	cout << "Out GetVar\n";

    //
    return rv;
    //
}


// ****************************************************************************
//  Method: avtudaReaderFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: sshankar -- generated by xml2avt
//  Creation:   Fri Feb 22 16:41:04 PST 2008
//
// ****************************************************************************

vtkDataArray *
avtudaReaderFileFormat::GetVectorVar(int timestate, const char *varname)
{
	// YOU MUST IMPLEMENT THIS
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //
	
	cout << "\nIn GetVectorVar\n";
	
	string varName(varname);
	
	// *(void **)(&processData) = dlsym(libHandle, "processData");
	/*if((error = dlerror()) != NULL) {
		EXCEPTION1(InvalidDBTypeException, "The function processData could be located in the library!!!");
	}*/

	vtkFloatArray *rv = vtkFloatArray::New();

	if (varName.find("p.") == string::npos) {
	    size_t found = varName.find("/");
		
		string matlNo = varName.substr(found + 1);
		varName = varName.substr(0, found);

		cout << varName << endl;
		cout << matlNo << endl;
	
		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-v");
		strcpy(arr2d[4], varName.c_str());
		strcpy(arr2d[5], "-m");
		strcpy(arr2d[6], matlNo.c_str());
		strcpy(arr2d[7], "-o");
		strcpy(arr2d[8], "test"); // anything will do

		timeStep *timeStepObjPtr = (*processData)(9, arr2d, timestate, true, 0, false);
	    timeStep &timeStepObj = *timeStepObjPtr;
		
		cellVals& cellValColln = *(timeStepObj.cellValColln);
		typeDouble& cellValVec = *(cellValColln.cellValVec);
        int dim = cellValColln.dim;
		
		int ncomps /*= 3*/;  // This is the rank of the vector - typically 2 or 3.

        if (dim == 5) // Tensors
		  ncomps = 9;
		else if (dim == 4) // Vectors
		  ncomps = 3;
		// else if (dim == 3) // Scalars + Tensors
		  // ncomps = 1; // This case would lead to problem as it has not been added to meta data

		int ntuples = cellValVec.size() / ncomps; // this is the number of entries in the variable.
		
		cout << ncomps << " " << cellValVec.size() << " " << ntuples << endl;

		rv->SetNumberOfComponents(ncomps);
		rv->SetNumberOfTuples(ntuples);

		double* one_entry = new double[ncomps];
		unsigned int count = 0;
		
		for (unsigned int i = 0; i < ntuples; ++i) {
		  for (unsigned int j = 0; j < ncomps; ++j) {
		    one_entry[j] = cellValVec[count++];
		  }

		  rv->SetTuple(i, one_entry); 
		}

		delete [] one_entry;
	}
    else {
		size_t found = varName.find("/");
		
		string matl = varName.substr(found + 1);
		varName = varName.substr(0, found);

		int matlNo = 0;
		
		if (matl.compare("*") != 0)
		  matlNo = atoi(matl.c_str());

		cout << varName << endl;
		cout << matlNo << endl;
		
		strcpy(arr2d[0], "uda2nrrd"); // anything will do
		strcpy(arr2d[1], "-uda");
		strcpy(arr2d[2], folder.c_str());
		strcpy(arr2d[3], "-p");
		strcpy(arr2d[4], "-o");
		strcpy(arr2d[5], "test"); // anything will do

		timeStep *timeStepObjPtr;
		
		if (matl.compare("*") == 0) {
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, false); 
		  cout << "All data\n";
		}  
        else { 
		  timeStepObjPtr = (*processData)(6, arr2d, timestate, false, matlNo, true);
		  cout << "Some data\n";
		}  
	    
		timeStep &timeStepObj = *timeStepObjPtr;

		variables& varColln = *(timeStepObj.varColln);
		
		int ntuples = 0;
        int ncomps = 0;  // Vector -> 3, Tensor ->  9
		
		// Detemine whether we have a vector or a tensor
		
		udaVars* udaVarsPtr = (*getVarList)(folder);
	    udaVars& udaVarsObj = *(udaVarsPtr);
		
		for (int k = 0; k < udaVarsObj.size(); k++) {
		  if (udaVarsObj[k].find(varName) != string::npos) { // should be a vector or a tensor
		    if (udaVarsObj[k].find("Vector") != string::npos)
			  ncomps = 3;
			else if (udaVarsObj[k].find("Matrix3") != string::npos)   
			  ncomps = 9;
		  }
	    }	  	   

		if ((varColln.size() % PARTICLE_INTERVAL) != 0) 
		  ntuples = (varColln.size() / PARTICLE_INTERVAL) + 1;
		else
		  ntuples = varColln.size() / PARTICLE_INTERVAL;
		
		cout << ncomps << " " << ntuples << endl;

		rv->SetNumberOfComponents(ncomps);
		rv->SetNumberOfTuples(ntuples);
		
		float* one_entry = new float[ncomps];
		//
		// If you do have a scalar variable, here is some code that may be helpful.
		//
		
		// int ntuples = varColln.size(); // this is the number of entries in the variable.
			
		if (ncomps == 3) { // Vectors
			for (int i = 0 ; i < ntuples ; i++) {
				variable& varRef = varColln[i * PARTICLE_INTERVAL];
				vecValData& vecDataRef = varRef.vecData;
				
				for (int j = 0;  j < vecDataRef.size(); j++) {
					if (strcmp(varName.c_str(), vecDataRef[j].name.c_str()) == 0) {
					  one_entry[0] = vecDataRef[j].x; one_entry[1] = vecDataRef[j].y; one_entry[2] = vecDataRef[j].z; 
					  rv->SetTuple(i, one_entry);  // you must determine value for ith entry.
					}	
				}
			}		
		}
		else if (ncomps == 9) { // Tensors
			for (int i = 0 ; i < ntuples ; i++) {
				variable& varRef = varColln[i * PARTICLE_INTERVAL];
				tenValData& tenDataRef = varRef.tenData;

				for (int j = 0;  j < tenDataRef.size(); j++) {
				    if (strcmp(varName.c_str(), tenDataRef[j].name.c_str()) == 0) {
					  one_entry[0] = (float)tenDataRef[j].mat[0][0];
					  one_entry[1] = (float)tenDataRef[j].mat[0][1];
					  one_entry[2] = (float)tenDataRef[j].mat[0][2];
					  one_entry[3] = (float)tenDataRef[j].mat[1][0];
					  one_entry[4] = (float)tenDataRef[j].mat[1][1];
					  one_entry[5] = (float)tenDataRef[j].mat[1][2];
					  one_entry[6] = (float)tenDataRef[j].mat[2][0];
					  one_entry[7] = (float)tenDataRef[j].mat[2][1];
					  one_entry[8] = (float)tenDataRef[j].mat[2][2];
					  rv->SetTuple(i, one_entry);  // you must determine value for ith entry.
					}	
				}
			}		
		}

		delete [] one_entry;
	}

	cout << "Out GetVectorVar\n";

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    return rv;
    //
}
