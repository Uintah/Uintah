Index: CCA/Components/DataArchiver/DataArchiver.h
===================================================================
--- CCA/Components/DataArchiver/DataArchiver.h	(revision 55760)
+++ CCA/Components/DataArchiver/DataArchiver.h	(working copy)
@@ -172,7 +172,8 @@
        virtual double getNextOutputTime() const { return d_nextOutputTime; }
 
        //! Get the timestep the next output will occur
-       virtual int getNextOutputTimestep() const { return d_nextOutputTimestep; }
+       virtual int  getNextOutputTimestep() const { return d_nextOutputTimestep; }
+       virtual void postponeNextOutputTimestep() { d_nextOutputTimestep++; } // Pushes output back by one timestep.
 
        //! Get the time the next checkpoint will occur
        virtual double getNextCheckpointTime() const { return d_nextCheckpointTime; }
Index: CCA/Components/LoadBalancers/LoadBalancerCommon.h
===================================================================
--- CCA/Components/LoadBalancers/LoadBalancerCommon.h	(revision 55760)
+++ CCA/Components/LoadBalancers/LoadBalancerCommon.h	(working copy)
@@ -151,7 +151,8 @@
   virtual void resetCostForecaster();
 
   //! Returns n - data gets output every n procs.
-  virtual int getNthProc() { return m_output_Nth_proc; }
+  virtual int  getNthProc() { return m_output_Nth_proc; }
+  virtual void setNthProc( int nth ) { m_output_Nth_proc = nth; }
 
   //! Returns the processor the patch will be output on (not patchwiseProcessor
   //! if outputNthProc is set)
Index: CCA/Components/LoadBalancers/LoadBalancerFactory.cc
===================================================================
--- CCA/Components/LoadBalancers/LoadBalancerFactory.cc	(revision 55760)
+++ CCA/Components/LoadBalancers/LoadBalancerFactory.cc	(working copy)
@@ -23,6 +23,7 @@
  */
 
 #include <CCA/Components/LoadBalancers/LoadBalancerFactory.h>
+
 #include <CCA/Components/LoadBalancers/DynamicLoadBalancer.h>
 #include <CCA/Components/LoadBalancers/ParticleLoadBalancer.h>
 #include <CCA/Components/LoadBalancers/RoundRobinLoadBalancer.h>
Index: CCA/Components/SimulationController/AMRSimulationController.cc
===================================================================
--- CCA/Components/SimulationController/AMRSimulationController.cc	(revision 55760)
+++ CCA/Components/SimulationController/AMRSimulationController.cc	(working copy)
@@ -155,8 +155,8 @@
   
   bool first = true;
   
-  if (d_restarting) {
-    d_scheduler->setRestartInitTimestep(first);
+  if( d_restarting ) {
+    d_scheduler->setRestartInitTimestep( true );
   }
 
   double time;
@@ -169,8 +169,8 @@
 
   //__________________________________
   //  reduceUda
-  if (d_reduceUda) {
-    Dir fromDir(d_fromDir);
+  if( d_reduceUda ) {
+    Dir fromDir( d_fromDir );
     d_output->reduceUdaSetup( fromDir );
     d_timeinfo->delt_factor = 1;
     d_timeinfo->delt_min    = 0;
@@ -184,10 +184,25 @@
   // setup, compile, and run the taskgraph for the initialization timestep
   doInitialTimestep( currentGrid, time );
 
+  //////////////////////////////////////////////////////////
+  // copied from the main time loop... should this just be placed here instead?
+  //if( first ) {
+      getMemoryStats( d_sharedState->getCurrentTopLevelTimeStep() );
+      getPAPIStats( );
+      d_sharedState->d_runTimeStats.reduce( d_regridder &&
+                                            d_regridder->useDynamicDilation(),
+                                            d_myworld );
+      calcWallTime();
+      
+      printSimulationStats( d_sharedState->getCurrentTopLevelTimeStep(), 0, time );
+  //}
+  //////////////////////////////////////////////////////////
+
   setStartSimTime( time );
   initSimulationStatsVars();
+
 #ifndef DISABLE_SCI_MALLOC
-  AllocatorSetDefaultTagLineNumber(d_sharedState->getCurrentTopLevelTimeStep());
+  AllocatorSetDefaultTagLineNumber( d_sharedState->getCurrentTopLevelTimeStep() );
 #endif
 
   // If VisIt has been included into the build, initialize the lib sim
@@ -228,19 +243,41 @@
   ////////////////////////////////////////////////////////////////////////////
   // The main time loop; here the specified problem is actually getting solved
    
-  int    iterations = d_sharedState->getCurrentTopLevelTimeStep();
-  double delt = 0;
+  int          iterations = d_sharedState->getCurrentTopLevelTimeStep();
+  double       delt = 0;
   delt_vartype delt_var;
-  double start;
   
   d_lb->resetCostForecaster();
 
   d_scheduler->setInitTimestep(false);
 
+  static int  requested_nth_output_proc = -1;
+  static bool need_to_recompile = false;
+  static bool put_back          = false;
+
+  if( requested_nth_output_proc == -1 ) {
+    requested_nth_output_proc = d_lb->getNthProc();
+
+    proc0cout << "Input file requests output to be saved by every " << requested_nth_output_proc << "th processor.\n";
+    proc0cout << "  - However, setting output to every process until we hit a checkpoint\n";
+    d_lb->setNthProc( 1 );
+    d_lb->possiblyDynamicallyReallocate( currentGrid, LoadBalancer::regrid );
+  }
+
+  //
+  // Note, the 'current timestep' (d_sharedState->getCurrentTopLevelTimeStep()) changes in the middle
+  // of this loop.  It is actually the previous time step number until it hits d_sharedState->incrementCurrentTopLevelTimeStep();
+  // I'm not sure that this effects anything, but the 'recompile for checkpoint' and 'regridding' sections,
+  // in theory, if they look at it, will see the previous time step number.  However, the 'executeTimestep()' sees
+  // the 'current' time step number.
+  //
+  
   while( ( time < d_timeinfo->maxTime ) &&
          ( iterations < d_timeinfo->maxTimestep ) && 
          ( d_timeinfo->max_wall_time == 0 || getWallTime() < d_timeinfo->max_wall_time )  ) {
 
+    //    proc0cout << "a: " << d_sharedState->getCurrentTopLevelTimeStep() << ": Is checkpoint: " << d_output->isCheckpointTimestep() << ", is output: " << d_output->isOutputTimestep() << "\n";
+
 #ifdef USE_GPERFTOOLS
     if (gheapprofile.active()){
       char heapename[512];
@@ -249,29 +286,58 @@
     }
 #endif
      
-    MALLOC_TRACE_TAG_SCOPE("AMRSimulationController::run()::control loop");
-    if(dbg_barrier.active()) {
-      for(int i=0;i<5;i++) {
-        barrier_times[i]=0;
+    MALLOC_TRACE_TAG_SCOPE( "AMRSimulationController::run()::control loop" );
+    if( dbg_barrier.active() ) {
+      for(int i = 0; i < 5; i++ ) {
+        barrier_times[i] = 0;
       }
     }
      
+    if( d_output ) {
+      int currentTimeStep = d_sharedState->getCurrentTopLevelTimeStep();
+      //proc0cout << "At this point timestep is set to: " << currentTimeStep << "\n";
+      //proc0cout << "next checkpoint is: " << d_output->getNextCheckpointTimestep() << "\n";
+
+      // Because "incrementCurrentTopLevelTimeStep()" has not yet been called
+      // at this point in the loop, we need to add 1 to the currentTimeStep to know if we
+      // really are on a checkpoint or output time step.
+      if( ( currentTimeStep + 1 ) == d_output->getNextCheckpointTimestep() ) {
+
+        if( requested_nth_output_proc > 1 ) {
+          proc0cout << "this is a checkpoint timestep (" << ( currentTimeStep + 1 )
+                    << ") - need to recompile with nth proc set to: " << requested_nth_output_proc << "\n";
+          d_lb->setNthProc( requested_nth_output_proc );
+          d_lb->possiblyDynamicallyReallocate( currentGrid, LoadBalancer::regrid );
+          need_to_recompile = true;
+        }
+      }
+      if( ( currentTimeStep + 1 ) == d_output->getNextOutputTimestep() ) {
+        proc0cout << "this is an output timestep: " << (currentTimeStep + 1) << "\n";
+        if( need_to_recompile ) { // If this is also a checkpoint time step
+          proc0cout << "   Postposing...\n";
+          d_output->postponeNextOutputTimestep();
+          if( d_output->isOutputTimestep() ) {
+            proc0cout << "THIS IS AN ERROR, should not get here\n";
+          }
+        }
+      }
+    }
+
     //__________________________________
     //    Regridding
-    if (d_regridder )
-    {
-      if (d_regridder->doRegridOnce() && d_regridder->isAdaptive()) {
+    if ( d_regridder ) {
+      if( d_regridder->doRegridOnce() && d_regridder->isAdaptive() ) {
         proc0cout << "______________________________________________________________________\n";
         proc0cout << " Regridding once.\n";
-        doRegridding(currentGrid, false);
-        d_regridder->setAdaptivity(false);
+        doRegridding( currentGrid, false );
+        d_regridder->setAdaptivity( false );
         proc0cout << "______________________________________________________________________\n";
       }
       
-      if (d_regridder->needsToReGrid(currentGrid) && (!first || !d_restarting)) {
+      if( d_regridder->needsToReGrid( currentGrid ) && ( !first || !d_restarting ) ) {
         proc0cout << "______________________________________________________________________\n";
         proc0cout << " Need to regrid.\n";
-        doRegridding(currentGrid, false);
+        doRegridding( currentGrid, false );
         proc0cout << "______________________________________________________________________\n";
       }
     }
@@ -297,9 +363,8 @@
     // Note: this code is not explicit to VisIt but it is currently
     // the only component that is making use of the ability to
     // overirde adjusting delta T.
-    if( d_sharedState->getVisIt() && d_sharedState->adjustDelT() == false )
-    {
-      d_sharedState->adjustDelT(true);
+    if( d_sharedState->getVisIt() && d_sharedState->adjustDelT() == false ) {
+      d_sharedState->adjustDelT( true );
     }
     else
 #endif
@@ -306,10 +371,10 @@
     {
       // delt adjusted based on timeinfo parameters
       adjustDelT( delt, d_prev_delt, first, time );
-      newDW->override(delt_vartype(delt), d_sharedState->get_delt_label());
+      newDW->override( delt_vartype(delt), d_sharedState->get_delt_label() );
     }
 
-    if(log_dw_mem){
+    if( log_dw_mem ) {
       // Remember, this isn't logged if DISABLE_SCI_MALLOC is set
       // (So usually in optimized mode this will not be run.)
       d_scheduler->logMemoryUse();
@@ -321,17 +386,17 @@
 #endif
     }
      
-    if(dbg_barrier.active()) {
-      start=Time::currentSeconds();
-      Uintah::MPI::Barrier(d_myworld->getComm());
-      barrier_times[2]+=Time::currentSeconds()-start;
+    if( dbg_barrier.active() ) {
+      double start_time = Time::currentSeconds();
+      Uintah::MPI::Barrier( d_myworld->getComm() );
+      barrier_times[2] += Time::currentSeconds() - start_time;
     }
 
     // Yes, I know this is kind of hacky, but this is the only way to
     // get a new grid from UdaReducer. Needs to be done before
     // advanceDataWarehouse.
-    if (d_reduceUda){
-      currentGrid = static_cast<UdaReducer*>(d_sim)->getGrid();
+    if ( d_reduceUda ) {
+      currentGrid = static_cast<UdaReducer*>( d_sim )->getGrid();
     }
 
     // After one step (either timestep or initialization) and correction
@@ -344,8 +409,9 @@
     // number so components can tell what timestep they are on. 
     d_sharedState->setElapsedTime( time );
     d_sharedState->incrementCurrentTopLevelTimeStep();
+
 #ifndef DISABLE_SCI_MALLOC
-    AllocatorSetDefaultTagLineNumber(d_sharedState->getCurrentTopLevelTimeStep());
+    AllocatorSetDefaultTagLineNumber( d_sharedState->getCurrentTopLevelTimeStep() );
 #endif
     // Each component has their own init_delt specified.  On a switch
     // from one component to the next, we need to adjust the delt to
@@ -356,25 +422,57 @@
     double old_init_delt = d_timeinfo->max_initial_delt;
     double new_init_delt = 0.;
 
-    bool nr;
-    if( (nr=needRecompile( time, delt, currentGrid )) || first ) {
+    bool nr = needRecompile( time, delt, currentGrid ) || need_to_recompile || put_back;
+
+//    if ( d_output ) {
+//      // This is not correct if we have switched to a different component, since the delt will be wrong...
+//     d_output->finalizeTimestep( time, delt, currentGrid, d_scheduler, nr || first );
+//     d_output->sched_allOutputTasks( delt, currentGrid, d_scheduler, nr || first );
+//    }
+
+    if( nr || first ) {
         
-      if(nr){ // Recompile taskgraph, re-assign BCs, reset recompile flag.
+      if( nr ) { // Recompile taskgraph, re-assign BCs, reset recompile flag.
         currentGrid->assignBCS( d_grid_ps, d_lb );
         currentGrid->performConsistencyCheck();
         d_sharedState->setRecompileTaskGraph( false );
       }
-       
+
+      if( put_back ) {
+        proc0cout << "this is the timestep following a checkpoint - need to put the task graph back with a recompile - seting nth output to 1\n";
+        d_lb->setNthProc( 1 );
+        d_lb->possiblyDynamicallyReallocate( currentGrid, LoadBalancer::regrid );
+        put_back = false;
+      }
+      if( need_to_recompile ) {
+        proc0cout << "set need_to_recompile to false, and put_back to true\n";
+        need_to_recompile = false;
+        put_back = true;
+      }
+
       new_init_delt = d_timeinfo->max_initial_delt;
-       
+
+      //      if( need_to_recompile || put_back || first ) {
+      //        d_lb->possiblyDynamicallyReallocate( currentGrid, LoadBalancer::regrid );
+      //      }
+
       if (new_init_delt != old_init_delt) {
         // writes to the DW in the next section below
         delt = new_init_delt;
       }
+
+//  This was necessary when we were doing Nth == 1 for Checkpoints... but now that
+//  we are doing Nth == 1 for normal outputs, and Nth == 8 for checkpoints, it causes problems...?  Dd.
+//
+//      if ( d_output ) {
+//        d_output->sched_allOutputTasks( delt, currentGrid, d_scheduler, nr || first );
+//      }
+
+      proc0cout << "about to recompile taskgraph\n";
       recompile( time, delt, currentGrid, totalFine );
     }
     else {
-      if (d_output){
+      if ( d_output ) {
         // This is not correct if we have switched to a different
         // component, since the delt will be wrong 
         d_output->finalizeTimestep( time, delt, currentGrid, d_scheduler, 0 );
@@ -385,16 +483,16 @@
       }
     }
 
-    if(dbg_barrier.active()) {
-      start=Time::currentSeconds();
-      Uintah::MPI::Barrier(d_myworld->getComm());
-      barrier_times[3]+=Time::currentSeconds()-start;
+    if( dbg_barrier.active() ) {
+      double start_time = Time::currentSeconds();
+      Uintah::MPI::Barrier( d_myworld->getComm() );
+      barrier_times[3] += Time::currentSeconds() - start_time;
     }
 
     // adjust the delt for each level and store it in all applicable dws.
     double delt_fine = delt;
-    int skip=totalFine;
-    for(int i=0;i<currentGrid->numLevels();i++){
+    int    skip      = totalFine;
+    for( int i = 0; i < currentGrid->numLevels(); i++ ) {
       const Level* level = currentGrid->getLevel(i).get_rep();
       
       if( d_doAMR && i != 0 && !d_sharedState->isLockstepAMR() ) {
@@ -434,20 +532,7 @@
       }
     }
 
-    // For the first time through the loop print the initial runtime
-    // performance stats. Use a time step of -1 to note that these
-    // stats are from before the executeTimestep.
-    if( first ) {
-      getMemoryStats( d_sharedState->getCurrentTopLevelTimeStep()-1 );
-      getPAPIStats( );
-      d_sharedState->d_runTimeStats.reduce(d_regridder &&
-					   d_regridder->useDynamicDilation(),
-					   d_myworld );
-      
-      calcWallTime();
-      
-      printSimulationStats( d_sharedState->getCurrentTopLevelTimeStep()-1, delt, time );
-    }
+    //    proc0cout << "b: " << d_sharedState->getCurrentTopLevelTimeStep() << ": Is checkpoint: " << d_output->isCheckpointTimestep() << ", is output: " << d_output->isOutputTimestep() << "\n";
 
     // Execute the current timestep, restarting if necessary
     executeTimestep( time, delt, currentGrid, totalFine );
@@ -457,9 +542,9 @@
 
     // If debugging output the barrier times.
     if( dbg_barrier.active() ) {
-      start = Time::currentSeconds();
+      double start_time = Time::currentSeconds();
       Uintah::MPI::Barrier( d_myworld->getComm() );
-      barrier_times[4]+=Time::currentSeconds()-start;
+      barrier_times[4]+=Time::currentSeconds() - start_time;
       double avg[5];
       Uintah::MPI::Reduce( barrier_times, avg, 5, MPI_DOUBLE, MPI_SUM, 0, d_myworld->getComm() );
        
@@ -473,9 +558,7 @@
       }
     }
 
-    // Get the next checkpoint timestep.
     if( d_output ) {
-      d_output->findNext_OutputCheckPoint_Timestep( delt, currentGrid );
       d_output->writeto_xml_files( delt, currentGrid );
     }
 
@@ -487,10 +570,16 @@
     ++iterations;
     
     if( first ) {
-      d_scheduler->setRestartInitTimestep(false);
+      d_scheduler->setRestartInitTimestep( false );
       first = false;
     }
     
+    //    proc0cout << "c: " << d_sharedState->getCurrentTopLevelTimeStep() << ": Is checkpoint: " << d_output->isCheckpointTimestep() << ", is output: " << d_output->isOutputTimestep() << "\n";
+
+    if( d_output ) {
+      d_output->findNext_OutputCheckPoint_Timestep( delt, currentGrid );
+    }
+
     calcWallTime();
 
 #ifdef HAVE_VISIT
@@ -497,10 +586,9 @@
     bool last  = false;
 
     // Check to see if at the last iteration
-    last = ( (time >= d_timeinfo->maxTime) ||
-	     (iterations >= d_timeinfo->maxTimestep) ||
-	     (d_timeinfo->max_wall_time != 0 &&
-	      getWallTime() >= d_timeinfo->max_wall_time) );
+    last = ( ( time >= d_timeinfo->maxTime ) ||
+	     ( iterations >= d_timeinfo->maxTimestep ) ||
+	     ( d_timeinfo->max_wall_time != 0 && getWallTime() >= d_timeinfo->max_wall_time ) );
 #endif
     
 
@@ -511,7 +599,6 @@
 					 d_regridder->useDynamicDilation(),
 					 d_myworld );
     
-    
     printSimulationStats( d_sharedState->getCurrentTopLevelTimeStep(), delt, time );
 
     // Reduce the mpi run time stats.
@@ -518,11 +605,10 @@
     MPIScheduler *mpiScheduler = 
       dynamic_cast<MPIScheduler*>(d_scheduler.get_rep());
     
-    if( mpiScheduler )
-    {
-      mpiScheduler->mpi_info_.reduce(d_regridder && 
-				     d_regridder->useDynamicDilation(),
-				     d_myworld);
+    if( mpiScheduler ) {
+      mpiScheduler->mpi_info_.reduce( d_regridder && 
+                                      d_regridder->useDynamicDilation(),
+                                      d_myworld );
     }
 
     // Print MPI statistics
@@ -563,7 +649,9 @@
     // Reset memory use tracking variable
     d_scheduler->resetMaxMemValue();
 
-  } // end while ( time is not up, etc )
+    //    proc0cout << "d: " << d_sharedState->getCurrentTopLevelTimeStep() << ": Is checkpoint: " << d_output->isCheckpointTimestep() << ", is output: " << d_output->isOutputTimestep() << "\n";
+
+  } // end while main time loop ( time is not up, etc )
   
   // d_ups->releaseDocument();
 #ifdef USE_GPERFTOOLS
@@ -825,9 +913,9 @@
   d_scheduler->mapDataWarehouse(Task::CoarseOldDW, 0);
   d_scheduler->mapDataWarehouse(Task::CoarseNewDW, 1);
   
-  if(d_restarting){
+  if( d_restarting ) {
   
-    d_lb->possiblyDynamicallyReallocate(grid, LoadBalancer::restart);
+    d_lb->possiblyDynamicallyReallocate( grid, LoadBalancer::restart );
     // tsaad & bisaac: At this point, during a restart, a grid does NOT have knowledge of the boundary conditions.
     // (See other comments in SimulationController.cc for why that is the case). Here, and given a
     // legitimate load balancer, we can assign the BCs to the grid in an efficient manner.
@@ -859,7 +947,7 @@
   else {
     d_sharedState->setCurrentTopLevelTimeStep( 0 );
     // for dynamic lb's, set up initial patch config
-    d_lb->possiblyDynamicallyReallocate(grid, LoadBalancer::init); 
+    d_lb->possiblyDynamicallyReallocate( grid, LoadBalancer::init );
     grid->assignBCS( d_grid_ps, d_lb );
     grid->performConsistencyCheck();
     t = d_timeinfo->initTime;
@@ -866,9 +954,9 @@
 
     bool needNewLevel = false;
     do {
-      if (needNewLevel) {
-        d_scheduler->initialize(1, 1);
-        d_scheduler->advanceDataWarehouse(grid, true);
+      if ( needNewLevel ) {
+        d_scheduler->initialize( 1, 1 );
+        d_scheduler->advanceDataWarehouse( grid, true );
       }
 
       proc0cout << "Compiling initialization taskgraph...\n";
@@ -887,12 +975,12 @@
           }
         }
       }
-      scheduleComputeStableTimestep(grid,d_scheduler);
+      scheduleComputeStableTimestep( grid, d_scheduler );
 
-      if(d_output){
-        double delT = 0;
-        bool recompile = true;
-        d_output->finalizeTimestep(t, delT, grid, d_scheduler, recompile);
+      if( d_output ) {
+        double delT      = 0;
+        bool   recompile = true;
+        d_output->finalizeTimestep( t, delT, grid, d_scheduler, recompile );
         d_output->sched_allOutputTasks( delT,grid, d_scheduler, recompile );
       }
       
@@ -905,9 +993,9 @@
       d_scheduler->execute();
 
       needNewLevel = d_regridder && d_regridder->isAdaptive() && grid->numLevels()<d_regridder->maxLevels() && doRegridding(grid, true);
-    } while (needNewLevel);
+    } while ( needNewLevel );
 
-    if(d_output){
+    if( d_output ) {
       d_output->findNext_OutputCheckPoint_Timestep( 0, grid );
       d_output->writeto_xml_files(0, grid );
     }
@@ -1010,8 +1098,9 @@
 }
 
 //______________________________________________________________________
+
 void
-AMRSimulationController::recompile(double t, double delt, GridP& currentGrid, int totalFine)
+AMRSimulationController::recompile( double time, double delt, GridP & currentGrid, int totalFine )
 {
   MALLOC_TRACE_TAG_SCOPE("AMRSimulationController::Recompile()");
 
@@ -1024,12 +1113,12 @@
   
   // Set up new DWs, DW mappings.
   d_scheduler->clearMappings();
-  d_scheduler->mapDataWarehouse(Task::OldDW, 0);
-  d_scheduler->mapDataWarehouse(Task::NewDW, totalFine);
-  d_scheduler->mapDataWarehouse(Task::CoarseOldDW, 0);
-  d_scheduler->mapDataWarehouse(Task::CoarseNewDW, totalFine);  
+  d_scheduler->mapDataWarehouse( Task::OldDW, 0 );
+  d_scheduler->mapDataWarehouse( Task::NewDW, totalFine );
+  d_scheduler->mapDataWarehouse( Task::CoarseOldDW, 0 );
+  d_scheduler->mapDataWarehouse( Task::CoarseNewDW, totalFine );
   
-  if (d_doMultiTaskgraphing) {
+  if ( d_doMultiTaskgraphing ) {
     for (int i = 0; i < currentGrid->numLevels(); i++) {
       // taskgraphs 0-numlevels-1
       if ( i > 0) {
@@ -1067,16 +1156,16 @@
     d_scheduler->addTaskGraph(Scheduler::IntermediateTaskGraph);
   }
   else {
-    subCycleCompile(currentGrid, 0, totalFine, 0, 0);
+    subCycleCompile( currentGrid, 0, totalFine, 0, 0 );
     d_scheduler->clearMappings();
-    d_scheduler->mapDataWarehouse(Task::OldDW, 0);
-    d_scheduler->mapDataWarehouse(Task::NewDW, totalFine);
+    d_scheduler->mapDataWarehouse( Task::OldDW, 0 );
+    d_scheduler->mapDataWarehouse( Task::NewDW, totalFine );
   }
     
-  for(int i = currentGrid->numLevels()-1; i >= 0; i--){
-    dbg << d_myworld->myrank() << "   final TG " << i << endl;
+  for( int i = currentGrid->numLevels() - 1; i >= 0; i-- ) {
+    dbg << d_myworld->myrank() << "   final TG " << i << "\n";
     
-    if (d_regridder) {
+    if ( d_regridder ) {
       d_regridder->scheduleInitializeErrorEstimate(currentGrid->getLevel(i));
       d_sim->scheduleErrorEstimate(currentGrid->getLevel(i), d_scheduler);
       
@@ -1085,21 +1174,24 @@
       }
     }    
   }
-  scheduleComputeStableTimestep(currentGrid, d_scheduler);
+  scheduleComputeStableTimestep( currentGrid, d_scheduler );
 
   if(d_output){
-    d_output->finalizeTimestep(t, delt, currentGrid, d_scheduler, true);
+    d_output->finalizeTimestep( time, delt, currentGrid, d_scheduler, true );
     d_output->sched_allOutputTasks( delt, currentGrid, d_scheduler, true );
   }
   
   d_scheduler->compile();
  
-  double dt=Time::currentSeconds() - start;
+  double dt = Time::currentSeconds() - start;
 
   proc0cout << "DONE TASKGRAPH RE-COMPILE (" << dt << " seconds)\n";
-  d_sharedState->d_runTimeStats[SimulationState::CompilationTime] += dt;
-}
+  d_sharedState->d_runTimeStats[ SimulationState::CompilationTime ] += dt;
+
+} // end recompile()
+
 //______________________________________________________________________
+
 void
 AMRSimulationController::executeTimestep(double t, double& delt, GridP& currentGrid, int totalFine)
 {
@@ -1106,7 +1198,7 @@
   MALLOC_TRACE_TAG_SCOPE("AMRSimulationController::executeTimestep()");
 
   // If the timestep needs to be restarted, this loop will execute multiple times.
-  bool success = true;
+  bool   success   = true;
   double orig_delt = delt;
   do {
     bool restartable = d_sim->restartableTimesteps();
@@ -1115,35 +1207,37 @@
     // if (Uintah::Parallel::getMaxThreads() < 1) { 
 
       // Standard data warehouse scrubbing.
-      if( scrubDataWarehouse && d_lb->getNthProc() == 1 )
-      {
-	if (restartable)
+      if( scrubDataWarehouse && d_lb->getNthProc() == 1 ) {
+	if ( restartable ) {
 	  d_scheduler->get_dw(0)->setScrubbing(DataWarehouse::ScrubNonPermanent);
-	else
+        }
+	else {
 	  d_scheduler->get_dw(0)->setScrubbing(DataWarehouse::ScrubComplete);
-	
+        }
 	// The other data warehouse as well as those for other levels.
-	for(int i=1; i<=totalFine; ++i)
+	for( int i = 1; i <= totalFine; ++i ) {
 	  d_scheduler->get_dw(i)->setScrubbing(DataWarehouse::ScrubNonPermanent);
+        }
       }
       // If not scubbing or getNthProc requires the variables after
       // they would have been scrubbed so turn off all scrubbing.
-      else //if( !scrubDataWarehouse || d_lb->getNthProc() > 1 )
-      {
-	for(int i=0; i<=totalFine; ++i)
-	  d_scheduler->get_dw(i)->setScrubbing(DataWarehouse::ScrubNone);
+      else { //if( !scrubDataWarehouse || d_lb->getNthProc() > 1 )
+	for( int i = 0; i <= totalFine; ++i ) {
+	  d_scheduler->get_dw(i)->setScrubbing( DataWarehouse::ScrubNone );
+        }
       }
     // }
     
-    if (d_scheduler->getNumTaskGraphs() == 1){
+    if( d_scheduler->getNumTaskGraphs() == 1 ) {
       d_scheduler->execute(0, d_lastRecompileTimestep == d_sharedState->getCurrentTopLevelTimeStep() ? 0 : 1);
-    }else {
+    }
+    else {
       subCycleExecute(currentGrid, 0, totalFine, 0, true);
     }
     
     //__________________________________
     //  If timestep has been restarted
-    if(d_scheduler->get_dw(totalFine)->timestepRestarted()){
+    if( d_scheduler->get_dw( totalFine )->timestepRestarted() ) {
       ASSERT(restartable);
       
       // Figure out new delt
@@ -1189,13 +1283,15 @@
       }
       success = false;
       
-    } else {
+    }
+    else {
+      if( d_scheduler->get_dw( 1 )->timestepAborted() ) {
+        throw InternalError( "Execution aborted, cannot restart timestep\n", __FILE__, __LINE__ );
+      }
       success = true;
-      if(d_scheduler->get_dw(1)->timestepAborted()){
-        throw InternalError("Execution aborted, cannot restart timestep\n", __FILE__, __LINE__);
-      }
     }
-  } while(!success);
+  } while( !success );
+
 } // end executeTimestep()
 
 //______________________________________________________________________
Index: CCA/Ports/LoadBalancer.cc
===================================================================
--- CCA/Ports/LoadBalancer.cc	(revision 55760)
+++ CCA/Ports/LoadBalancer.cc	(working copy)
@@ -22,7 +22,6 @@
  * IN THE SOFTWARE.
  */
 
-
 #include <CCA/Ports/LoadBalancer.h>
 
 using namespace Uintah;
Index: CCA/Ports/LoadBalancer.h
===================================================================
--- CCA/Ports/LoadBalancer.h	(revision 55760)
+++ CCA/Ports/LoadBalancer.h	(working copy)
@@ -137,7 +137,8 @@
   virtual bool possiblyDynamicallyReallocate(const GridP&, int state) = 0;
 
   //! Returns the value of n (every n procs it performs output tasks).
-  virtual int getNthProc() { return 1; }
+  virtual int  getNthProc() = 0;
+  virtual void setNthProc( int nth ) = 0;
 
   //! Returns the processor the patch will be output on (not patchwiseProcessor
   //! if outputNthProc is set)
Index: CCA/Ports/Output.h
===================================================================
--- CCA/Ports/Output.h	(revision 55760)
+++ CCA/Ports/Output.h	(working copy)
@@ -135,7 +135,8 @@
     virtual double getNextOutputTime() const = 0;
 
     // Get the timestep the next output will occur
-    virtual int getNextOutputTimestep() const = 0;
+    virtual int  getNextOutputTimestep() const = 0;
+    virtual void postponeNextOutputTimestep() = 0; // Pushes output back by one timestep.
 
     // Get the time the next checkpoint will occur
     virtual double getNextCheckpointTime() const = 0;
