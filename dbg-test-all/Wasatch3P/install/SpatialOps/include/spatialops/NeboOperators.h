/* This file was generated by fulmar version 0.9.2. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_OPERATORS_H
   #define NEBO_OPERATORS_H

   namespace SpatialOps {
      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct SumOp;
      template<typename Operand1, typename Operand2>
       struct SumOp<Initial, Operand1, Operand2> {
         public:
          SumOp<SeqWalk,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             SumOp<Resize,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             SumOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct SumOp<Resize, Operand1, Operand2> {
            public:
             SumOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType> typedef SeqWalkType;

             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct SumOp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          SumOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) + operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct SumOp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             SumOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return (operand1_.eval(x, y, z) + operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator +(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial,
                NeboScalar<Initial, typename FieldType::value_type>,
                NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type>,
                                   SubExpr2>,
                             FieldType> operator +(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          SumOp<Initial,
                NeboScalar<Initial, typename FieldType::value_type>,
                SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              NeboScalar<Initial, T>,
                                              NeboConstSingleValueField<Initial,
                                                                        T> >,
                                        T> operator +(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          SumOp<Initial,
                NeboScalar<Initial, T>,
                NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              NeboScalar<Initial, T>,
                                              SubExpr2>,
                                        T> operator +(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          SumOp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type> >,
                             FieldType> operator +(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator +(FieldType const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   SubExpr2>,
                             FieldType> operator +(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          SumOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type> >,
                             FieldType> operator +(FieldType const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          SumOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   SubExpr2>,
                             FieldType> operator +(FieldType const & arg1,
                                                   NeboSingleValueExpression<SubExpr2,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg2) {
          SumOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type> >,
                             FieldType> operator +(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          SumOp<Initial,
                SubExpr1,
                NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator +(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator +(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          SumOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type> >,
                             FieldType> operator +(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          SumOp<Initial,
                SubExpr1,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator +(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboSingleValueExpression<SubExpr2,
                                            typename FieldType::value_type>
                  const & arg2) {
          SumOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              NeboConstSingleValueField<Initial,
                                                                        T>,
                                              NeboScalar<Initial, T> >,
                                        T> operator +(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          SumOp<Initial,
                NeboConstSingleValueField<Initial, T>,
                NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator +(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type>,
                NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                   SubExpr2>,
                             FieldType> operator +(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          SumOp<Initial,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type>,
                SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              NeboConstSingleValueField<Initial,
                                                                        T>,
                                              NeboConstSingleValueField<Initial,
                                                                        T> >,
                                        T> operator +(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          SumOp<Initial,
                NeboConstSingleValueField<Initial, T>,
                NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              NeboConstSingleValueField<Initial,
                                                                        T>,
                                              SubExpr2>,
                                        T> operator +(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          SumOp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              SubExpr1,
                                              NeboScalar<Initial, T> >,
                                        T> operator +(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          SumOp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<SumOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator +(NeboSingleValueExpression<SubExpr1,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          SumOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<SumOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator +(NeboSingleValueExpression<SubExpr1,
                                            typename FieldType::value_type>
                  const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          SumOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<SumOp<Initial,
                                              SubExpr1,
                                              NeboConstSingleValueField<Initial,
                                                                        T> >,
                                        T> operator +(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          SumOp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<SumOp<Initial, SubExpr1, SubExpr2>, T>
       operator +(NeboSingleValueExpression<SubExpr1, T> const & arg1,
                  NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          SumOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct DiffOp;
      template<typename Operand1, typename Operand2>
       struct DiffOp<Initial, Operand1, Operand2> {
         public:
          DiffOp<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             DiffOp<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             DiffOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct DiffOp<Resize, Operand1, Operand2> {
            public:
             DiffOp<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType> typedef SeqWalkType;

             DiffOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct DiffOp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          DiffOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) - operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct DiffOp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             DiffOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return (operand1_.eval(x, y, z) - operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator -(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    SubExpr2>,
                             FieldType> operator -(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DiffOp<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               NeboScalar<Initial, T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator -(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          DiffOp<Initial,
                 NeboScalar<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               NeboScalar<Initial, T>,
                                               SubExpr2>,
                                        T> operator -(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          DiffOp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> operator -(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator -(FieldType const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> operator -(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DiffOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> operator -(FieldType const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          DiffOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> operator -(FieldType const & arg1,
                                                   NeboSingleValueExpression<SubExpr2,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg2) {
          DiffOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> operator -(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DiffOp<Initial,
                 SubExpr1,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator -(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator -(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          DiffOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> operator -(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          DiffOp<Initial,
                 SubExpr1,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator -(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboSingleValueExpression<SubExpr2,
                                            typename FieldType::value_type>
                  const & arg2) {
          DiffOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboScalar<Initial, T> >,
                                        T> operator -(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          DiffOp<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator -(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    SubExpr2>,
                             FieldType> operator -(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DiffOp<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator -(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          DiffOp<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               SubExpr2>,
                                        T> operator -(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          DiffOp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, T> >,
                                        T> operator -(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          DiffOp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DiffOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator -(NeboSingleValueExpression<SubExpr1,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DiffOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DiffOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator -(NeboSingleValueExpression<SubExpr1,
                                            typename FieldType::value_type>
                  const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          DiffOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<DiffOp<Initial,
                                               SubExpr1,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator -(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          DiffOp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<DiffOp<Initial, SubExpr1, SubExpr2>, T>
       operator -(NeboSingleValueExpression<SubExpr1, T> const & arg1,
                  NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          DiffOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct ProdOp;
      template<typename Operand1, typename Operand2>
       struct ProdOp<Initial, Operand1, Operand2> {
         public:
          ProdOp<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             ProdOp<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             ProdOp<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct ProdOp<Resize, Operand1, Operand2> {
            public:
             ProdOp<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType> typedef SeqWalkType;

             ProdOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct ProdOp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          ProdOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) * operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct ProdOp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             ProdOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return (operand1_.eval(x, y, z) * operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator *(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    SubExpr2>,
                             FieldType> operator *(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          ProdOp<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               NeboScalar<Initial, T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator *(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          ProdOp<Initial,
                 NeboScalar<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               NeboScalar<Initial, T>,
                                               SubExpr2>,
                                        T> operator *(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          ProdOp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> operator *(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator *(FieldType const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> operator *(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          ProdOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> operator *(FieldType const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          ProdOp<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> operator *(FieldType const & arg1,
                                                   NeboSingleValueExpression<SubExpr2,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg2) {
          ProdOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> operator *(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          ProdOp<Initial,
                 SubExpr1,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator *(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator *(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          ProdOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> operator *(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          ProdOp<Initial,
                 SubExpr1,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator *(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboSingleValueExpression<SubExpr2,
                                            typename FieldType::value_type>
                  const & arg2) {
          ProdOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboScalar<Initial, T> >,
                                        T> operator *(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          ProdOp<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator *(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    SubExpr2>,
                             FieldType> operator *(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          ProdOp<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator *(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          ProdOp<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               SubExpr2>,
                                        T> operator *(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          ProdOp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, T> >,
                                        T> operator *(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          ProdOp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<ProdOp<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator *(NeboSingleValueExpression<SubExpr1,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          ProdOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<ProdOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator *(NeboSingleValueExpression<SubExpr1,
                                            typename FieldType::value_type>
                  const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          ProdOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<ProdOp<Initial,
                                               SubExpr1,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator *(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          ProdOp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<ProdOp<Initial, SubExpr1, SubExpr2>, T>
       operator *(NeboSingleValueExpression<SubExpr1, T> const & arg1,
                  NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          ProdOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct DivOp;
      template<typename Operand1, typename Operand2>
       struct DivOp<Initial, Operand1, Operand2> {
         public:
          DivOp<SeqWalk,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             DivOp<Resize,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             DivOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct DivOp<Resize, Operand1, Operand2> {
            public:
             DivOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType> typedef SeqWalkType;

             DivOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct DivOp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          DivOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) / operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct DivOp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             DivOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return (operand1_.eval(x, y, z) / operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator /(typename FieldType::
                                                   value_type const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial,
                NeboScalar<Initial, typename FieldType::value_type>,
                NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type>,
                                   SubExpr2>,
                             FieldType> operator /(typename FieldType::
                                                   value_type const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DivOp<Initial,
                NeboScalar<Initial, typename FieldType::value_type>,
                SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              NeboScalar<Initial, T>,
                                              NeboConstSingleValueField<Initial,
                                                                        T> >,
                                        T> operator /(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          DivOp<Initial,
                NeboScalar<Initial, T>,
                NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              NeboScalar<Initial, T>,
                                              SubExpr2>,
                                        T> operator /(typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          DivOp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type> >,
                             FieldType> operator /(FieldType const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator /(FieldType const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   SubExpr2>,
                             FieldType> operator /(FieldType const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DivOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type> >,
                             FieldType> operator /(FieldType const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          DivOp<Initial,
                NeboConstField<Initial, FieldType>,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                   SubExpr2>,
                             FieldType> operator /(FieldType const & arg1,
                                                   NeboSingleValueExpression<SubExpr2,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg2) {
          DivOp<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboScalar<Initial,
                                              typename FieldType::value_type> >,
                             FieldType> operator /(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   typename FieldType::
                                                   value_type const & arg2) {
          DivOp<Initial,
                SubExpr1,
                NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator /(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator /(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          DivOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type> >,
                             FieldType> operator /(NeboExpression<SubExpr1,
                                                                  FieldType>
                                                   const & arg1,
                                                   SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg2) {
          DivOp<Initial,
                SubExpr1,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator /(NeboExpression<SubExpr1, FieldType> const & arg1,
                  NeboSingleValueExpression<SubExpr2,
                                            typename FieldType::value_type>
                  const & arg2) {
          DivOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              NeboConstSingleValueField<Initial,
                                                                        T>,
                                              NeboScalar<Initial, T> >,
                                        T> operator /(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          DivOp<Initial,
                NeboConstSingleValueField<Initial, T>,
                NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator /(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type>,
                NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   NeboConstSingleValueField<Initial,
                                                             typename FieldType::
                                                             value_type>,
                                   SubExpr2>,
                             FieldType> operator /(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            typename
                                                                            FieldType::
                                                                            value_type>
                                                   const & arg1,
                                                   NeboExpression<SubExpr2,
                                                                  FieldType>
                                                   const & arg2) {
          DivOp<Initial,
                NeboConstSingleValueField<Initial,
                                          typename FieldType::value_type>,
                SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              NeboConstSingleValueField<Initial,
                                                                        T>,
                                              NeboConstSingleValueField<Initial,
                                                                        T> >,
                                        T> operator /(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          DivOp<Initial,
                NeboConstSingleValueField<Initial, T>,
                NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              NeboConstSingleValueField<Initial,
                                                                        T>,
                                              SubExpr2>,
                                        T> operator /(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg1,
                                                      NeboSingleValueExpression<SubExpr2,
                                                                                T>
                                                      const & arg2) {
          DivOp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              SubExpr1,
                                              NeboScalar<Initial, T> >,
                                        T> operator /(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      typename SpatialOps::
                                                      SpatialField<SpatialOps::
                                                                   SingleValue,
                                                                   T>::
                                                      value_type const & arg2) {
          DivOp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<DivOp<Initial,
                                   SubExpr1,
                                   NeboConstField<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                             FieldType> operator /(NeboSingleValueExpression<SubExpr1,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                                   const & arg1,
                                                   FieldType const & arg2) {
          DivOp<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<DivOp<Initial, SubExpr1, SubExpr2>, FieldType>
       operator /(NeboSingleValueExpression<SubExpr1,
                                            typename FieldType::value_type>
                  const & arg1,
                  NeboExpression<SubExpr2, FieldType> const & arg2) {
          DivOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<DivOp<Initial,
                                              SubExpr1,
                                              NeboConstSingleValueField<Initial,
                                                                        T> >,
                                        T> operator /(NeboSingleValueExpression<SubExpr1,
                                                                                T>
                                                      const & arg1,
                                                      SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg2) {
          DivOp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<DivOp<Initial, SubExpr1, SubExpr2>, T>
       operator /(NeboSingleValueExpression<SubExpr1, T> const & arg1,
                  NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          DivOp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct SinFcn;
      template<typename Operand>
       struct SinFcn<Initial, Operand> {
         public:
          SinFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             SinFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             SinFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          SinFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct SinFcn<Resize, Operand> {
            public:
             SinFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             SinFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct SinFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          SinFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::sin(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct SinFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             SinFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::sin(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<SinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> sin(FieldType const & arg) {
          SinFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<SinFcn<Initial, SubExpr>, FieldType> sin(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          SinFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<SinFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> sin(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          SinFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<SinFcn<Initial, SubExpr>, T> sin(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          SinFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct CosFcn;
      template<typename Operand>
       struct CosFcn<Initial, Operand> {
         public:
          CosFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             CosFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             CosFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          CosFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct CosFcn<Resize, Operand> {
            public:
             CosFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             CosFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct CosFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          CosFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::cos(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct CosFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             CosFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::cos(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<CosFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> cos(FieldType const & arg) {
          CosFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<CosFcn<Initial, SubExpr>, FieldType> cos(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          CosFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<CosFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> cos(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          CosFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<CosFcn<Initial, SubExpr>, T> cos(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          CosFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct TanFcn;
      template<typename Operand>
       struct TanFcn<Initial, Operand> {
         public:
          TanFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             TanFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             TanFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          TanFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct TanFcn<Resize, Operand> {
            public:
             TanFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             TanFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct TanFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          TanFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::tan(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct TanFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             TanFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::tan(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<TanFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> tan(FieldType const & arg) {
          TanFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<TanFcn<Initial, SubExpr>, FieldType> tan(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          TanFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<TanFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> tan(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          TanFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<TanFcn<Initial, SubExpr>, T> tan(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          TanFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct ExpFcn;
      template<typename Operand>
       struct ExpFcn<Initial, Operand> {
         public:
          ExpFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             ExpFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             ExpFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          ExpFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct ExpFcn<Resize, Operand> {
            public:
             ExpFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             ExpFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct ExpFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          ExpFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::exp(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct ExpFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             ExpFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::exp(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<ExpFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> exp(FieldType const & arg) {
          ExpFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<ExpFcn<Initial, SubExpr>, FieldType> exp(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          ExpFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<ExpFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> exp(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          ExpFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<ExpFcn<Initial, SubExpr>, T> exp(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          ExpFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct TanhFcn;
      template<typename Operand>
       struct TanhFcn<Initial, Operand> {
         public:
          TanhFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             TanhFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             TanhFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType
             ;
          #endif
          /* __CUDACC__ */

          TanhFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct TanhFcn<Resize, Operand> {
            public:
             TanhFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType
             ;

             TanhFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct TanhFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          TanhFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::tanh(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct TanhFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             TanhFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::tanh(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<TanhFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                    Result> >,
                             FieldType> tanh(FieldType const & arg) {
          TanhFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<TanhFcn<Initial, SubExpr>, FieldType> tanh(NeboExpression<SubExpr,
                                                                                       FieldType>
                                                                        const &
                                                                        arg) {
          TanhFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<TanhFcn<Initial,
                                                NeboConstSingleValueField<Initial,
                                                                          T> >,
                                        T> tanh(SpatialOps::SpatialField<SpatialOps::
                                                                         SingleValue,
                                                                         T>
                                                const & arg) {
          TanhFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<TanhFcn<Initial, SubExpr>, T> tanh(NeboSingleValueExpression<SubExpr,
                                                                                                     T>
                                                                           const
                                                                           & arg) {
          TanhFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct AbsFcn;
      template<typename Operand>
       struct AbsFcn<Initial, Operand> {
         public:
          AbsFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             AbsFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             AbsFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          AbsFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct AbsFcn<Resize, Operand> {
            public:
             AbsFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             AbsFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct AbsFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          AbsFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::abs(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct AbsFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             AbsFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::abs(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<AbsFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> abs(FieldType const & arg) {
          AbsFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<AbsFcn<Initial, SubExpr>, FieldType> abs(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          AbsFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<AbsFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> abs(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          AbsFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<AbsFcn<Initial, SubExpr>, T> abs(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          AbsFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct NegFcn;
      template<typename Operand>
       struct NegFcn<Initial, Operand> {
         public:
          NegFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NegFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NegFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NegFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct NegFcn<Resize, Operand> {
            public:
             NegFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             NegFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct NegFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          NegFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return -(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct NegFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             NegFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return -(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<NegFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> operator -(FieldType const & arg) {
          NegFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<NegFcn<Initial, SubExpr>, FieldType> operator -(NeboExpression<SubExpr,
                                                                                            FieldType>
                                                                             const
                                                                             &
                                                                             arg) {
          NegFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<NegFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> operator -(SpatialOps::SpatialField<SpatialOps::
                                                                               SingleValue,
                                                                               T>
                                                      const & arg) {
          NegFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<NegFcn<Initial, SubExpr>, T> operator -(NeboSingleValueExpression<SubExpr,
                                                                                                          T>
                                                                                const
                                                                                &
                                                                                arg) {
          NegFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct PowFcn;
      template<typename Operand1, typename Operand2>
       struct PowFcn<Initial, Operand1, Operand2> {
         public:
          PowFcn<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             PowFcn<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             PowFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct PowFcn<Resize, Operand1, Operand2> {
            public:
             PowFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType> typedef SeqWalkType;

             PowFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct PowFcn<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          PowFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::pow(operand1_.eval(x, y, z), operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct PowFcn<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             PowFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::pow(operand1_.eval(x, y, z), operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> pow(typename FieldType::value_type const
                                            & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    SubExpr2>,
                             FieldType> pow(typename FieldType::value_type const
                                            & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          PowFcn<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               NeboScalar<Initial, T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> pow(typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          PowFcn<Initial,
                 NeboScalar<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               NeboScalar<Initial, T>,
                                               SubExpr2>,
                                        T> pow(typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg1,
                                               NeboSingleValueExpression<SubExpr2,
                                                                         T>
                                               const & arg2) {
          PowFcn<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> pow(FieldType const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> pow(FieldType const & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> pow(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          PowFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> pow(FieldType const & arg1,
                                            SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg2) {
          PowFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> pow(FieldType const & arg1,
                                            NeboSingleValueExpression<SubExpr2,
                                                                      typename
                                                                      FieldType::
                                                                      value_type>
                                            const & arg2) {
          PowFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          PowFcn<Initial,
                 SubExpr1,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial, SubExpr1, SubExpr2>, FieldType> pow(NeboExpression<SubExpr1,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboExpression<SubExpr2,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          PowFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> pow(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg2) {
          PowFcn<Initial,
                 SubExpr1,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial, SubExpr1, SubExpr2>, FieldType> pow(NeboExpression<SubExpr1,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboSingleValueExpression<SubExpr2,
                                                                                                           typename
                                                                                                           FieldType::
                                                                                                           value_type>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          PowFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboScalar<Initial, T> >,
                                        T> pow(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg2) {
          PowFcn<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> pow(SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    SubExpr2>,
                             FieldType> pow(SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          PowFcn<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> pow(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          PowFcn<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               SubExpr2>,
                                        T> pow(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               NeboSingleValueExpression<SubExpr2,
                                                                         T>
                                               const & arg2) {
          PowFcn<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, T> >,
                                        T> pow(NeboSingleValueExpression<SubExpr1,
                                                                         T>
                                               const & arg1,
                                               typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg2) {
          PowFcn<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<PowFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> pow(NeboSingleValueExpression<SubExpr1,
                                                                      typename
                                                                      FieldType::
                                                                      value_type>
                                            const & arg1,
                                            FieldType const & arg2) {
          PowFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<PowFcn<Initial, SubExpr1, SubExpr2>, FieldType> pow(NeboSingleValueExpression<SubExpr1,
                                                                                                           typename
                                                                                                           FieldType::
                                                                                                           value_type>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboExpression<SubExpr2,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          PowFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<PowFcn<Initial,
                                               SubExpr1,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> pow(NeboSingleValueExpression<SubExpr1,
                                                                         T>
                                               const & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          PowFcn<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<PowFcn<Initial, SubExpr1, SubExpr2>, T>
       pow(NeboSingleValueExpression<SubExpr1, T> const & arg1,
           NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          PowFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct SqrtFcn;
      template<typename Operand>
       struct SqrtFcn<Initial, Operand> {
         public:
          SqrtFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             SqrtFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             SqrtFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType
             ;
          #endif
          /* __CUDACC__ */

          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct SqrtFcn<Resize, Operand> {
            public:
             SqrtFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType
             ;

             SqrtFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct SqrtFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          SqrtFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::sqrt(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct SqrtFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             SqrtFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::sqrt(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<SqrtFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                    Result> >,
                             FieldType> sqrt(FieldType const & arg) {
          SqrtFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<SqrtFcn<Initial, SubExpr>, FieldType> sqrt(NeboExpression<SubExpr,
                                                                                       FieldType>
                                                                        const &
                                                                        arg) {
          SqrtFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<SqrtFcn<Initial,
                                                NeboConstSingleValueField<Initial,
                                                                          T> >,
                                        T> sqrt(SpatialOps::SpatialField<SpatialOps::
                                                                         SingleValue,
                                                                         T>
                                                const & arg) {
          SqrtFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<SqrtFcn<Initial, SubExpr>, T> sqrt(NeboSingleValueExpression<SubExpr,
                                                                                                     T>
                                                                           const
                                                                           & arg) {
          SqrtFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct LogFcn;
      template<typename Operand>
       struct LogFcn<Initial, Operand> {
         public:
          LogFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             LogFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             LogFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          LogFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct LogFcn<Resize, Operand> {
            public:
             LogFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             LogFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct LogFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          LogFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::log(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct LogFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             LogFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::log(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<LogFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> log(FieldType const & arg) {
          LogFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<LogFcn<Initial, SubExpr>, FieldType> log(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          LogFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<LogFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> log(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          LogFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<LogFcn<Initial, SubExpr>, T> log(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          LogFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct Log10Fcn;
      template<typename Operand>
       struct Log10Fcn<Initial, Operand> {
         public:
          Log10Fcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             Log10Fcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             Log10Fcn<GPUWalk, typename Operand::GPUWalkType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          Log10Fcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct Log10Fcn<Resize, Operand> {
            public:
             Log10Fcn<SeqWalk, typename Operand::SeqWalkType> typedef
             SeqWalkType;

             Log10Fcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct Log10Fcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          Log10Fcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return std::log10(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct Log10Fcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             Log10Fcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return std::log10(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<Log10Fcn<Initial,
                                      NeboConstField<Initial,
                                                     typename NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                     Result> >,
                             FieldType> log10(FieldType const & arg) {
          Log10Fcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<Log10Fcn<Initial, SubExpr>, FieldType> log10(NeboExpression<SubExpr,
                                                                                         FieldType>
                                                                          const
                                                                          & arg) {
          Log10Fcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<Log10Fcn<Initial,
                                                 NeboConstSingleValueField<Initial,
                                                                           T> >,
                                        T> log10(SpatialOps::SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                 const & arg) {
          Log10Fcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<Log10Fcn<Initial, SubExpr>, T> log10(NeboSingleValueExpression<SubExpr,
                                                                                                       T>
                                                                             const
                                                                             &
                                                                             arg) {
          Log10Fcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct ErfFcn;
      template<typename Operand>
       struct ErfFcn<Initial, Operand> {
         public:
          ErfFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             ErfFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             ErfFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          ErfFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct ErfFcn<Resize, Operand> {
            public:
             ErfFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             ErfFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct ErfFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          ErfFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return boost::math::erf(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct ErfFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             ErfFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return erf(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<ErfFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> erf(FieldType const & arg) {
          ErfFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<ErfFcn<Initial, SubExpr>, FieldType> erf(NeboExpression<SubExpr,
                                                                                     FieldType>
                                                                      const &
                                                                      arg) {
          ErfFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<ErfFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> erf(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg) {
          ErfFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<ErfFcn<Initial, SubExpr>, T> erf(NeboSingleValueExpression<SubExpr,
                                                                                                   T>
                                                                         const &
                                                                         arg) {
          ErfFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct ErfcFcn;
      template<typename Operand>
       struct ErfcFcn<Initial, Operand> {
         public:
          ErfcFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             ErfcFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             ErfcFcn<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType
             ;
          #endif
          /* __CUDACC__ */

          ErfcFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct ErfcFcn<Resize, Operand> {
            public:
             ErfcFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType
             ;

             ErfcFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct ErfcFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          ErfcFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return boost::math::erfc(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct ErfcFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             ErfcFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return erfc(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<ErfcFcn<Initial,
                                     NeboConstField<Initial,
                                                    typename NeboFieldCheck<typename
                                                                            FieldType::
                                                                            field_type,
                                                                            FieldType>::
                                                    Result> >,
                             FieldType> erfc(FieldType const & arg) {
          ErfcFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<ErfcFcn<Initial, SubExpr>, FieldType> erfc(NeboExpression<SubExpr,
                                                                                       FieldType>
                                                                        const &
                                                                        arg) {
          ErfcFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<ErfcFcn<Initial,
                                                NeboConstSingleValueField<Initial,
                                                                          T> >,
                                        T> erfc(SpatialOps::SpatialField<SpatialOps::
                                                                         SingleValue,
                                                                         T>
                                                const & arg) {
          ErfcFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<ErfcFcn<Initial, SubExpr>, T> erfc(NeboSingleValueExpression<SubExpr,
                                                                                                     T>
                                                                           const
                                                                           & arg) {
          ErfcFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct InvErfFcn;
      template<typename Operand>
       struct InvErfFcn<Initial, Operand> {
         public:
          InvErfFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             InvErfFcn<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             InvErfFcn<GPUWalk, typename Operand::GPUWalkType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          InvErfFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct InvErfFcn<Resize, Operand> {
            public:
             InvErfFcn<SeqWalk, typename Operand::SeqWalkType> typedef
             SeqWalkType;

             InvErfFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct InvErfFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          InvErfFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return boost::math::erf_inv(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct InvErfFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             InvErfFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return erfinv(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<InvErfFcn<Initial,
                                       NeboConstField<Initial,
                                                      typename NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                      Result> >,
                             FieldType> inv_erf(FieldType const & arg) {
          InvErfFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<InvErfFcn<Initial, SubExpr>, FieldType> inv_erf(NeboExpression<SubExpr,
                                                                                            FieldType>
                                                                             const
                                                                             &
                                                                             arg) {
          InvErfFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<InvErfFcn<Initial,
                                                  NeboConstSingleValueField<Initial,
                                                                            T> >,
                                        T> inv_erf(SpatialOps::SpatialField<SpatialOps::
                                                                            SingleValue,
                                                                            T>
                                                   const & arg) {
          InvErfFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<InvErfFcn<Initial, SubExpr>, T> inv_erf(NeboSingleValueExpression<SubExpr,
                                                                                                          T>
                                                                                const
                                                                                &
                                                                                arg) {
          InvErfFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct InvErfcFcn;
      template<typename Operand>
       struct InvErfcFcn<Initial, Operand> {
         public:
          InvErfcFcn<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType
          ;

          #ifdef ENABLE_THREADS
             InvErfcFcn<Resize, typename Operand::ResizeType> typedef ResizeType
             ;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             InvErfcFcn<GPUWalk, typename Operand::GPUWalkType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          InvErfcFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct InvErfcFcn<Resize, Operand> {
            public:
             InvErfcFcn<SeqWalk, typename Operand::SeqWalkType> typedef
             SeqWalkType;

             InvErfcFcn(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct InvErfcFcn<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          InvErfcFcn(Operand const & operand)
          : operand_(operand)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return boost::math::erfc_inv(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct InvErfcFcn<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             InvErfcFcn(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return erfcinv(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* Field */
      template<typename FieldType>
       inline NeboExpression<InvErfcFcn<Initial,
                                        NeboConstField<Initial,
                                                       typename NeboFieldCheck<typename
                                                                               FieldType::
                                                                               field_type,
                                                                               FieldType>::
                                                       Result> >,
                             FieldType> inv_erfc(FieldType const & arg) {
          InvErfcFcn<Initial, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg)));
       }

      /* SubExpr */
      template<typename SubExpr, typename FieldType>
       inline NeboExpression<InvErfcFcn<Initial, SubExpr>, FieldType> inv_erfc(NeboExpression<SubExpr,
                                                                                              FieldType>
                                                                               const
                                                                               &
                                                                               arg) {
          InvErfcFcn<Initial, SubExpr> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<InvErfcFcn<Initial,
                                                   NeboConstSingleValueField<Initial,
                                                                             T> >,
                                        T> inv_erfc(SpatialOps::SpatialField<SpatialOps::
                                                                             SingleValue,
                                                                             T>
                                                    const & arg) {
          InvErfcFcn<Initial, NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg)));
       }

      /* SingleValueExpr */
      template<typename SubExpr, typename T>
       inline NeboSingleValueExpression<InvErfcFcn<Initial, SubExpr>, T>
       inv_erfc(NeboSingleValueExpression<SubExpr, T> const & arg) {
          InvErfcFcn<Initial, SubExpr> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct EqualCmp;
      template<typename Operand1, typename Operand2>
       struct EqualCmp<Initial, Operand1, Operand2> {
         public:
          EqualCmp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             EqualCmp<Resize,
                      typename Operand1::ResizeType,
                      typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             EqualCmp<GPUWalk,
                      typename Operand1::GPUWalkType,
                      typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct EqualCmp<Resize, Operand1, Operand2> {
            public:
             EqualCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType> typedef SeqWalkType;

             EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct EqualCmp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) == operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct EqualCmp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             EqualCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) == operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial,
                                                        typename FieldType::
                                                        value_type>,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result> >,
                                    FieldType> operator ==(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboScalar<Initial, typename FieldType::value_type>,
                   NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboScalar<Initial,
                                                        typename FieldType::
                                                        value_type>,
                                             SubExpr2>,
                                    FieldType> operator ==(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial,
                   NeboScalar<Initial, typename FieldType::value_type>,
                   SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        NeboScalar<Initial, T>,
                                                        NeboConstSingleValueField<Initial,
                                                                                  T>
                                               >,
                                               T> operator ==(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          EqualCmp<Initial,
                   NeboScalar<Initial, T>,
                   NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        NeboScalar<Initial, T>,
                                                        SubExpr2>,
                                               T> operator ==(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          EqualCmp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             NeboScalar<Initial,
                                                        typename FieldType::
                                                        value_type> >,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result> >,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             SubExpr2>,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             NeboConstSingleValueField<Initial,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                    >,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          EqualCmp<Initial,
                   NeboConstField<Initial, FieldType>,
                   NeboConstSingleValueField<Initial,
                                             typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result>,
                                             SubExpr2>,
                                    FieldType> operator ==(FieldType const &
                                                           arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          EqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboScalar<Initial,
                                                        typename FieldType::
                                                        value_type> >,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          EqualCmp<Initial,
                   SubExpr1,
                   NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result> >,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboConstSingleValueField<Initial,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                    >,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          EqualCmp<Initial,
                   SubExpr1,
                   NeboConstSingleValueField<Initial,
                                             typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator ==(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          EqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        NeboConstSingleValueField<Initial,
                                                                                  T>,
                                                        NeboScalar<Initial, T> >,
                                               T> operator ==(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          EqualCmp<Initial,
                   NeboConstSingleValueField<Initial, T>,
                   NeboScalar<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstSingleValueField<Initial,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result> >,
                                    FieldType> operator ==(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial,
                   NeboConstSingleValueField<Initial,
                                             typename FieldType::value_type>,
                   NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             NeboConstSingleValueField<Initial,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>,
                                             SubExpr2>,
                                    FieldType> operator ==(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial,
                   NeboConstSingleValueField<Initial,
                                             typename FieldType::value_type>,
                   SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        NeboConstSingleValueField<Initial,
                                                                                  T>,
                                                        NeboConstSingleValueField<Initial,
                                                                                  T>
                                               >,
                                               T> operator ==(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          EqualCmp<Initial,
                   NeboConstSingleValueField<Initial, T>,
                   NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        NeboConstSingleValueField<Initial,
                                                                                  T>,
                                                        SubExpr2>,
                                               T> operator ==(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          EqualCmp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboScalar<Initial, T> >,
                                               T> operator ==(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          EqualCmp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial,
                                             SubExpr1,
                                             NeboConstField<Initial,
                                                            typename
                                                            NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                            Result> >,
                                    FieldType> operator ==(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          EqualCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<EqualCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator ==(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          EqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboConstSingleValueField<Initial,
                                                                                  T>
                                               >,
                                               T> operator ==(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          EqualCmp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<EqualCmp<Initial,
                                                        SubExpr1,
                                                        SubExpr2>,
                                               T> operator ==(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          EqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct InequalCmp;
      template<typename Operand1, typename Operand2>
       struct InequalCmp<Initial, Operand1, Operand2> {
         public:
          InequalCmp<SeqWalk,
                     typename Operand1::SeqWalkType,
                     typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             InequalCmp<Resize,
                        typename Operand1::ResizeType,
                        typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             InequalCmp<GPUWalk,
                        typename Operand1::GPUWalkType,
                        typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct InequalCmp<Resize, Operand1, Operand2> {
            public:
             InequalCmp<SeqWalk,
                        typename Operand1::SeqWalkType,
                        typename Operand2::SeqWalkType> typedef SeqWalkType;

             InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct InequalCmp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) != operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct InequalCmp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             InequalCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) != operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial,
                                                          typename FieldType::
                                                          value_type>,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result> >,
                                    FieldType> operator !=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboScalar<Initial, typename FieldType::value_type>,
                     NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboScalar<Initial,
                                                          typename FieldType::
                                                          value_type>,
                                               SubExpr2>,
                                    FieldType> operator !=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial,
                     NeboScalar<Initial, typename FieldType::value_type>,
                     SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          NeboScalar<Initial, T>,
                                                          NeboConstSingleValueField<Initial,
                                                                                    T>
                                               >,
                                               T> operator !=(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          InequalCmp<Initial,
                     NeboScalar<Initial, T>,
                     NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          NeboScalar<Initial, T>,
                                                          SubExpr2>,
                                               T> operator !=(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          InequalCmp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               NeboScalar<Initial,
                                                          typename FieldType::
                                                          value_type> >,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result> >,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               SubExpr2>,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               NeboConstSingleValueField<Initial,
                                                                         typename
                                                                         FieldType::
                                                                         value_type>
                                    >,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          InequalCmp<Initial,
                     NeboConstField<Initial, FieldType>,
                     NeboConstSingleValueField<Initial,
                                               typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result>,
                                               SubExpr2>,
                                    FieldType> operator !=(FieldType const &
                                                           arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          InequalCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial,
                                                          typename FieldType::
                                                          value_type> >,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          InequalCmp<Initial,
                     SubExpr1,
                     NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result> >,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboConstSingleValueField<Initial,
                                                                         typename
                                                                         FieldType::
                                                                         value_type>
                                    >,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          InequalCmp<Initial,
                     SubExpr1,
                     NeboConstSingleValueField<Initial,
                                               typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator !=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          InequalCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          NeboConstSingleValueField<Initial,
                                                                                    T>,
                                                          NeboScalar<Initial, T>
                                               >,
                                               T> operator !=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          InequalCmp<Initial,
                     NeboConstSingleValueField<Initial, T>,
                     NeboScalar<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         typename
                                                                         FieldType::
                                                                         value_type>,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result> >,
                                    FieldType> operator !=(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial,
                     NeboConstSingleValueField<Initial,
                                               typename FieldType::value_type>,
                     NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         typename
                                                                         FieldType::
                                                                         value_type>,
                                               SubExpr2>,
                                    FieldType> operator !=(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial,
                     NeboConstSingleValueField<Initial,
                                               typename FieldType::value_type>,
                     SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          NeboConstSingleValueField<Initial,
                                                                                    T>,
                                                          NeboConstSingleValueField<Initial,
                                                                                    T>
                                               >,
                                               T> operator !=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          InequalCmp<Initial,
                     NeboConstSingleValueField<Initial, T>,
                     NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          NeboConstSingleValueField<Initial,
                                                                                    T>,
                                                          SubExpr2>,
                                               T> operator !=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          InequalCmp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          SubExpr1,
                                                          NeboScalar<Initial, T>
                                               >,
                                               T> operator !=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          InequalCmp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial,
                                               SubExpr1,
                                               NeboConstField<Initial,
                                                              typename
                                                              NeboFieldCheck<typename
                                                                             FieldType::
                                                                             field_type,
                                                                             FieldType>::
                                                              Result> >,
                                    FieldType> operator !=(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          InequalCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<InequalCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator !=(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          InequalCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          SubExpr1,
                                                          NeboConstSingleValueField<Initial,
                                                                                    T>
                                               >,
                                               T> operator !=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          InequalCmp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<InequalCmp<Initial,
                                                          SubExpr1,
                                                          SubExpr2>,
                                               T> operator !=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          InequalCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct LessThanCmp;
      template<typename Operand1, typename Operand2>
       struct LessThanCmp<Initial, Operand1, Operand2> {
         public:
          LessThanCmp<SeqWalk,
                      typename Operand1::SeqWalkType,
                      typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             LessThanCmp<Resize,
                         typename Operand1::ResizeType,
                         typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             LessThanCmp<GPUWalk,
                         typename Operand1::GPUWalkType,
                         typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct LessThanCmp<Resize, Operand1, Operand2> {
            public:
             LessThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType> typedef SeqWalkType;

             LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct LessThanCmp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) < operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct LessThanCmp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             LessThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) < operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial,
                                                           typename FieldType::
                                                           value_type>,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result> >,
                                    FieldType> operator <(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial,
                      NeboScalar<Initial, typename FieldType::value_type>,
                      NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboScalar<Initial,
                                                           typename FieldType::
                                                           value_type>,
                                                SubExpr2>,
                                    FieldType> operator <(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial,
                      NeboScalar<Initial, typename FieldType::value_type>,
                      SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           NeboScalar<Initial, T>,
                                                           NeboConstSingleValueField<Initial,
                                                                                     T>
                                               >,
                                               T> operator <(typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg1,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg2) {
          LessThanCmp<Initial,
                      NeboScalar<Initial, T>,
                      NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           NeboScalar<Initial, T>,
                                                           SubExpr2>,
                                               T> operator <(typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg1,
                                                             NeboSingleValueExpression<SubExpr2,
                                                                                       T>
                                                             const & arg2) {
          LessThanCmp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                NeboScalar<Initial,
                                                           typename FieldType::
                                                           value_type> >,
                                    FieldType> operator <(FieldType const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result> >,
                                    FieldType> operator <(FieldType const & arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                SubExpr2>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                NeboConstSingleValueField<Initial,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>
                                    >,
                                    FieldType> operator <(FieldType const & arg1,
                                                          SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg2) {
          LessThanCmp<Initial,
                      NeboConstField<Initial, FieldType>,
                      NeboConstSingleValueField<Initial,
                                                typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result>,
                                                SubExpr2>,
                                    FieldType> operator <(FieldType const & arg1,
                                                          NeboSingleValueExpression<SubExpr2,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg2) {
          LessThanCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboScalar<Initial,
                                                           typename FieldType::
                                                           value_type> >,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          LessThanCmp<Initial,
                      SubExpr1,
                      NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result> >,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboConstSingleValueField<Initial,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>
                                    >,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg2) {
          LessThanCmp<Initial,
                      SubExpr1,
                      NeboConstSingleValueField<Initial,
                                                typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator <(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          NeboSingleValueExpression<SubExpr2,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg2) {
          LessThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           NeboConstSingleValueField<Initial,
                                                                                     T>,
                                                           NeboScalar<Initial, T>
                                               >,
                                               T> operator <(SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg1,
                                                             typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg2) {
          LessThanCmp<Initial,
                      NeboConstSingleValueField<Initial, T>,
                      NeboScalar<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstSingleValueField<Initial,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result> >,
                                    FieldType> operator <(SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial,
                      NeboConstSingleValueField<Initial,
                                                typename FieldType::value_type>,
                      NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                NeboConstSingleValueField<Initial,
                                                                          typename
                                                                          FieldType::
                                                                          value_type>,
                                                SubExpr2>,
                                    FieldType> operator <(SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial,
                      NeboConstSingleValueField<Initial,
                                                typename FieldType::value_type>,
                      SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           NeboConstSingleValueField<Initial,
                                                                                     T>,
                                                           NeboConstSingleValueField<Initial,
                                                                                     T>
                                               >,
                                               T> operator <(SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg1,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg2) {
          LessThanCmp<Initial,
                      NeboConstSingleValueField<Initial, T>,
                      NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           NeboConstSingleValueField<Initial,
                                                                                     T>,
                                                           SubExpr2>,
                                               T> operator <(SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg1,
                                                             NeboSingleValueExpression<SubExpr2,
                                                                                       T>
                                                             const & arg2) {
          LessThanCmp<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           SubExpr1,
                                                           NeboScalar<Initial, T>
                                               >,
                                               T> operator <(NeboSingleValueExpression<SubExpr1,
                                                                                       T>
                                                             const & arg1,
                                                             typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg2) {
          LessThanCmp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial,
                                                SubExpr1,
                                                NeboConstField<Initial,
                                                               typename
                                                               NeboFieldCheck<typename
                                                                              FieldType::
                                                                              field_type,
                                                                              FieldType>::
                                                               Result> >,
                                    FieldType> operator <(NeboSingleValueExpression<SubExpr1,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          LessThanCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator <(NeboSingleValueExpression<SubExpr1,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          LessThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           SubExpr1,
                                                           NeboConstSingleValueField<Initial,
                                                                                     T>
                                               >,
                                               T> operator <(NeboSingleValueExpression<SubExpr1,
                                                                                       T>
                                                             const & arg1,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg2) {
          LessThanCmp<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<LessThanCmp<Initial,
                                                           SubExpr1,
                                                           SubExpr2>,
                                               T> operator <(NeboSingleValueExpression<SubExpr1,
                                                                                       T>
                                                             const & arg1,
                                                             NeboSingleValueExpression<SubExpr2,
                                                                                       T>
                                                             const & arg2) {
          LessThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct LessThanEqualCmp;
      template<typename Operand1, typename Operand2>
       struct LessThanEqualCmp<Initial, Operand1, Operand2> {
         public:
          LessThanEqualCmp<SeqWalk,
                           typename Operand1::SeqWalkType,
                           typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             LessThanEqualCmp<Resize,
                              typename Operand1::ResizeType,
                              typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             LessThanEqualCmp<GPUWalk,
                              typename Operand1::GPUWalkType,
                              typename Operand2::GPUWalkType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct LessThanEqualCmp<Resize, Operand1, Operand2> {
            public:
             LessThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType> typedef
             SeqWalkType;

             LessThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct LessThanEqualCmp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          LessThanEqualCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) <= operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct LessThanEqualCmp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             LessThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) <= operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial,
                                                                typename
                                                                FieldType::
                                                                value_type>,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result> >,
                                    FieldType> operator <=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboScalar<Initial, typename FieldType::value_type>,
                           NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboScalar<Initial,
                                                                typename
                                                                FieldType::
                                                                value_type>,
                                                     SubExpr2>,
                                    FieldType> operator <=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboScalar<Initial, typename FieldType::value_type>,
                           SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                NeboScalar<Initial,
                                                                           T>,
                                                                NeboConstSingleValueField<Initial,
                                                                                          T>
                                               >,
                                               T> operator <=(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboScalar<Initial, T>,
                           NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                NeboScalar<Initial,
                                                                           T>,
                                                                SubExpr2>,
                                               T> operator <=(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          LessThanEqualCmp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     NeboScalar<Initial,
                                                                typename
                                                                FieldType::
                                                                value_type> >,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result> >,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     SubExpr2>,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     NeboConstSingleValueField<Initial,
                                                                               typename
                                                                               FieldType::
                                                                               value_type>
                                    >,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstField<Initial, FieldType>,
                           NeboConstSingleValueField<Initial,
                                                     typename FieldType::
                                                     value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result>,
                                                     SubExpr2>,
                                    FieldType> operator <=(FieldType const &
                                                           arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          LessThanEqualCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboScalar<Initial,
                                                                typename
                                                                FieldType::
                                                                value_type> >,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result> >,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboConstSingleValueField<Initial,
                                                                               typename
                                                                               FieldType::
                                                                               value_type>
                                    >,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboConstSingleValueField<Initial,
                                                     typename FieldType::
                                                     value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator <=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          LessThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                NeboConstSingleValueField<Initial,
                                                                                          T>,
                                                                NeboScalar<Initial,
                                                                           T> >,
                                               T> operator <=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstSingleValueField<Initial, T>,
                           NeboScalar<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstSingleValueField<Initial,
                                                                               typename
                                                                               FieldType::
                                                                               value_type>,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result> >,
                                    FieldType> operator <=(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstSingleValueField<Initial,
                                                     typename FieldType::
                                                     value_type>,
                           NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     NeboConstSingleValueField<Initial,
                                                                               typename
                                                                               FieldType::
                                                                               value_type>,
                                                     SubExpr2>,
                                    FieldType> operator <=(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstSingleValueField<Initial,
                                                     typename FieldType::
                                                     value_type>,
                           SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                NeboConstSingleValueField<Initial,
                                                                                          T>,
                                                                NeboConstSingleValueField<Initial,
                                                                                          T>
                                               >,
                                               T> operator <=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstSingleValueField<Initial, T>,
                           NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                NeboConstSingleValueField<Initial,
                                                                                          T>,
                                                                SubExpr2>,
                                               T> operator <=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          LessThanEqualCmp<Initial,
                           NeboConstSingleValueField<Initial, T>,
                           SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                SubExpr1,
                                                                NeboScalar<Initial,
                                                                           T> >,
                                               T> operator <=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          LessThanEqualCmp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial,
                                                     SubExpr1,
                                                     NeboConstField<Initial,
                                                                    typename
                                                                    NeboFieldCheck<typename
                                                                                   FieldType::
                                                                                   field_type,
                                                                                   FieldType>::
                                                                    Result> >,
                                    FieldType> operator <=(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<LessThanEqualCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator <=(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          LessThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                SubExpr1,
                                                                NeboConstSingleValueField<Initial,
                                                                                          T>
                                               >,
                                               T> operator <=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          LessThanEqualCmp<Initial,
                           SubExpr1,
                           NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<LessThanEqualCmp<Initial,
                                                                SubExpr1,
                                                                SubExpr2>,
                                               T> operator <=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          LessThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct GreaterThanCmp;
      template<typename Operand1, typename Operand2>
       struct GreaterThanCmp<Initial, Operand1, Operand2> {
         public:
          GreaterThanCmp<SeqWalk,
                         typename Operand1::SeqWalkType,
                         typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             GreaterThanCmp<Resize,
                            typename Operand1::ResizeType,
                            typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             GreaterThanCmp<GPUWalk,
                            typename Operand1::GPUWalkType,
                            typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct GreaterThanCmp<Resize, Operand1, Operand2> {
            public:
             GreaterThanCmp<SeqWalk,
                            typename Operand1::SeqWalkType,
                            typename Operand2::SeqWalkType> typedef SeqWalkType;

             GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct GreaterThanCmp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) > operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct GreaterThanCmp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             GreaterThanCmp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) > operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result> >,
                                    FieldType> operator >(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial,
                         NeboScalar<Initial, typename FieldType::value_type>,
                         NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboScalar<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                                   SubExpr2>,
                                    FieldType> operator >(typename FieldType::
                                                          value_type const &
                                                          arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial,
                         NeboScalar<Initial, typename FieldType::value_type>,
                         SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              NeboScalar<Initial,
                                                                         T>,
                                                              NeboConstSingleValueField<Initial,
                                                                                        T>
                                               >,
                                               T> operator >(typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg1,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg2) {
          GreaterThanCmp<Initial,
                         NeboScalar<Initial, T>,
                         NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              NeboScalar<Initial,
                                                                         T>,
                                                              SubExpr2>,
                                               T> operator >(typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg1,
                                                             NeboSingleValueExpression<SubExpr2,
                                                                                       T>
                                                             const & arg2) {
          GreaterThanCmp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   NeboScalar<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                                    FieldType> operator >(FieldType const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result> >,
                                    FieldType> operator >(FieldType const & arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   SubExpr2>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   NeboConstSingleValueField<Initial,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                    >,
                                    FieldType> operator >(FieldType const & arg1,
                                                          SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstField<Initial, FieldType>,
                         NeboConstSingleValueField<Initial,
                                                   typename FieldType::
                                                   value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result>,
                                                   SubExpr2>,
                                    FieldType> operator >(FieldType const & arg1,
                                                          NeboSingleValueExpression<SubExpr2,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg2) {
          GreaterThanCmp<Initial, NeboConstField<Initial, FieldType>, SubExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboScalar<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          typename FieldType::
                                                          value_type const &
                                                          arg2) {
          GreaterThanCmp<Initial,
                         SubExpr1,
                         NeboScalar<Initial, typename FieldType::value_type> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result> >,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboConstSingleValueField<Initial,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>
                                    >,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg2) {
          GreaterThanCmp<Initial,
                         SubExpr1,
                         NeboConstSingleValueField<Initial,
                                                   typename FieldType::
                                                   value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator >(NeboExpression<SubExpr1,
                                                                         FieldType>
                                                          const & arg1,
                                                          NeboSingleValueExpression<SubExpr2,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              NeboConstSingleValueField<Initial,
                                                                                        T>,
                                                              NeboScalar<Initial,
                                                                         T> >,
                                               T> operator >(SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg1,
                                                             typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg2) {
          GreaterThanCmp<Initial,
                         NeboConstSingleValueField<Initial, T>,
                         NeboScalar<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstSingleValueField<Initial,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result> >,
                                    FieldType> operator >(SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstSingleValueField<Initial,
                                                   typename FieldType::
                                                   value_type>,
                         NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   NeboConstSingleValueField<Initial,
                                                                             typename
                                                                             FieldType::
                                                                             value_type>,
                                                   SubExpr2>,
                                    FieldType> operator >(SpatialOps::
                                                          SpatialField<SpatialOps::
                                                                       SingleValue,
                                                                       typename
                                                                       FieldType::
                                                                       value_type>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstSingleValueField<Initial,
                                                   typename FieldType::
                                                   value_type>,
                         SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              NeboConstSingleValueField<Initial,
                                                                                        T>,
                                                              NeboConstSingleValueField<Initial,
                                                                                        T>
                                               >,
                                               T> operator >(SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg1,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstSingleValueField<Initial, T>,
                         NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              NeboConstSingleValueField<Initial,
                                                                                        T>,
                                                              SubExpr2>,
                                               T> operator >(SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg1,
                                                             NeboSingleValueExpression<SubExpr2,
                                                                                       T>
                                                             const & arg2) {
          GreaterThanCmp<Initial,
                         NeboConstSingleValueField<Initial, T>,
                         SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              SubExpr1,
                                                              NeboScalar<Initial,
                                                                         T> >,
                                               T> operator >(NeboSingleValueExpression<SubExpr1,
                                                                                       T>
                                                             const & arg1,
                                                             typename SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>::
                                                             value_type const &
                                                             arg2) {
          GreaterThanCmp<Initial, SubExpr1, NeboScalar<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial,
                                                   SubExpr1,
                                                   NeboConstField<Initial,
                                                                  typename
                                                                  NeboFieldCheck<typename
                                                                                 FieldType::
                                                                                 field_type,
                                                                                 FieldType>::
                                                                  Result> >,
                                    FieldType> operator >(NeboSingleValueExpression<SubExpr1,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg1,
                                                          FieldType const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, NeboConstField<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanCmp<Initial, SubExpr1, SubExpr2>,
                                    FieldType> operator >(NeboSingleValueExpression<SubExpr1,
                                                                                    typename
                                                                                    FieldType::
                                                                                    value_type>
                                                          const & arg1,
                                                          NeboExpression<SubExpr2,
                                                                         FieldType>
                                                          const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              SubExpr1,
                                                              NeboConstSingleValueField<Initial,
                                                                                        T>
                                               >,
                                               T> operator >(NeboSingleValueExpression<SubExpr1,
                                                                                       T>
                                                             const & arg1,
                                                             SpatialOps::
                                                             SpatialField<SpatialOps::
                                                                          SingleValue,
                                                                          T>
                                                             const & arg2) {
          GreaterThanCmp<Initial,
                         SubExpr1,
                         NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanCmp<Initial,
                                                              SubExpr1,
                                                              SubExpr2>,
                                               T> operator >(NeboSingleValueExpression<SubExpr1,
                                                                                       T>
                                                             const & arg1,
                                                             NeboSingleValueExpression<SubExpr2,
                                                                                       T>
                                                             const & arg2) {
          GreaterThanCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct GreaterThanEqualCmp;
      template<typename Operand1, typename Operand2>
       struct GreaterThanEqualCmp<Initial, Operand1, Operand2> {
         public:
          GreaterThanEqualCmp<SeqWalk,
                              typename Operand1::SeqWalkType,
                              typename Operand2::SeqWalkType> typedef
          SeqWalkType;

          #ifdef ENABLE_THREADS
             GreaterThanEqualCmp<Resize,
                                 typename Operand1::ResizeType,
                                 typename Operand2::ResizeType> typedef
             ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             GreaterThanEqualCmp<GPUWalk,
                                 typename Operand1::GPUWalkType,
                                 typename Operand2::GPUWalkType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          GreaterThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct GreaterThanEqualCmp<Resize, Operand1, Operand2> {
            public:
             GreaterThanEqualCmp<SeqWalk,
                                 typename Operand1::SeqWalkType,
                                 typename Operand2::SeqWalkType> typedef
             SeqWalkType;

             GreaterThanEqualCmp(Operand1 const & operand1,
                                 Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct GreaterThanEqualCmp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          GreaterThanEqualCmp(Operand1 const & operand1,
                              Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) >= operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct GreaterThanEqualCmp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             GreaterThanEqualCmp(Operand1 const & operand1,
                                 Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) >= operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial,
                                                                   typename
                                                                   FieldType::
                                                                   value_type>,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result> >,
                                    FieldType> operator >=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboScalar<Initial, typename FieldType::value_type>,
                              NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboScalar<Initial,
                                                                   typename
                                                                   FieldType::
                                                                   value_type>,
                                                        SubExpr2>,
                                    FieldType> operator >=(typename FieldType::
                                                           value_type const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboScalar<Initial, typename FieldType::value_type>,
                              SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   NeboScalar<Initial,
                                                                              T>,
                                                                   NeboConstSingleValueField<Initial,
                                                                                             T>
                                               >,
                                               T> operator >=(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboScalar<Initial, T>,
                              NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   NeboScalar<Initial,
                                                                              T>,
                                                                   SubExpr2>,
                                               T> operator >=(typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          GreaterThanEqualCmp<Initial, NeboScalar<Initial, T>, SubExpr2> typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        NeboScalar<Initial,
                                                                   typename
                                                                   FieldType::
                                                                   value_type> >,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboScalar<Initial, typename FieldType::value_type>
          > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result> >,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        SubExpr2>,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        NeboConstSingleValueField<Initial,
                                                                                  typename
                                                                                  FieldType::
                                                                                  value_type>
                                    >,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              NeboConstSingleValueField<Initial,
                                                        typename FieldType::
                                                        value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result>,
                                                        SubExpr2>,
                                    FieldType> operator >=(FieldType const &
                                                           arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstField<Initial, FieldType>,
                              SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboScalar<Initial,
                                                                   typename
                                                                   FieldType::
                                                                   value_type> >,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           typename FieldType::
                                                           value_type const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboScalar<Initial, typename FieldType::value_type>
          > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result> >,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        SubExpr2>,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboConstSingleValueField<Initial,
                                                                                  typename
                                                                                  FieldType::
                                                                                  value_type>
                                    >,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboConstSingleValueField<Initial,
                                                        typename FieldType::
                                                        value_type> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        SubExpr2>,
                                    FieldType> operator >=(NeboExpression<SubExpr1,
                                                                          FieldType>
                                                           const & arg1,
                                                           NeboSingleValueExpression<SubExpr2,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   NeboConstSingleValueField<Initial,
                                                                                             T>,
                                                                   NeboScalar<Initial,
                                                                              T>
                                               >,
                                               T> operator >=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstSingleValueField<Initial, T>,
                              NeboScalar<Initial, T> > typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstSingleValueField<Initial,
                                                                                  typename
                                                                                  FieldType::
                                                                                  value_type>,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result> >,
                                    FieldType> operator >=(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstSingleValueField<Initial,
                                                        typename FieldType::
                                                        value_type>,
                              NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        NeboConstSingleValueField<Initial,
                                                                                  typename
                                                                                  FieldType::
                                                                                  value_type>,
                                                        SubExpr2>,
                                    FieldType> operator >=(SpatialOps::
                                                           SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        typename
                                                                        FieldType::
                                                                        value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstSingleValueField<Initial,
                                                        typename FieldType::
                                                        value_type>,
                              SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   NeboConstSingleValueField<Initial,
                                                                                             T>,
                                                                   NeboConstSingleValueField<Initial,
                                                                                             T>
                                               >,
                                               T> operator >=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstSingleValueField<Initial, T>,
                              NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   NeboConstSingleValueField<Initial,
                                                                                             T>,
                                                                   SubExpr2>,
                                               T> operator >=(SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          GreaterThanEqualCmp<Initial,
                              NeboConstSingleValueField<Initial, T>,
                              SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   SubExpr1,
                                                                   NeboScalar<Initial,
                                                                              T>
                                               >,
                                               T> operator >=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              typename
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>::
                                                              value_type const &
                                                              arg2) {
          GreaterThanEqualCmp<Initial, SubExpr1, NeboScalar<Initial, T> >
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        NeboConstField<Initial,
                                                                       typename
                                                                       NeboFieldCheck<typename
                                                                                      FieldType::
                                                                                      field_type,
                                                                                      FieldType>::
                                                                       Result> >,
                                    FieldType> operator >=(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           FieldType const &
                                                           arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboBooleanExpression<GreaterThanEqualCmp<Initial,
                                                        SubExpr1,
                                                        SubExpr2>,
                                    FieldType> operator >=(NeboSingleValueExpression<SubExpr1,
                                                                                     typename
                                                                                     FieldType::
                                                                                     value_type>
                                                           const & arg1,
                                                           NeboExpression<SubExpr2,
                                                                          FieldType>
                                                           const & arg2) {
          GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   SubExpr1,
                                                                   NeboConstSingleValueField<Initial,
                                                                                             T>
                                               >,
                                               T> operator >=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              SpatialOps::
                                                              SpatialField<SpatialOps::
                                                                           SingleValue,
                                                                           T>
                                                              const & arg2) {
          GreaterThanEqualCmp<Initial,
                              SubExpr1,
                              NeboConstSingleValueField<Initial, T> > typedef
          ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboBooleanSingleValueExpression<GreaterThanEqualCmp<Initial,
                                                                   SubExpr1,
                                                                   SubExpr2>,
                                               T> operator >=(NeboSingleValueExpression<SubExpr1,
                                                                                        T>
                                                              const & arg1,
                                                              NeboSingleValueExpression<SubExpr2,
                                                                                        T>
                                                              const & arg2) {
          GreaterThanEqualCmp<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct AndOp;
      template<typename Operand1, typename Operand2>
       struct AndOp<Initial, Operand1, Operand2> {
         public:
          AndOp<SeqWalk,
                typename Operand1::SeqWalkType,
                typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             AndOp<Resize,
                   typename Operand1::ResizeType,
                   typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             AndOp<GPUWalk,
                   typename Operand1::GPUWalkType,
                   typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct AndOp<Resize, Operand1, Operand2> {
            public:
             AndOp<SeqWalk,
                   typename Operand1::SeqWalkType,
                   typename Operand2::SeqWalkType> typedef SeqWalkType;

             AndOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct AndOp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          AndOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) && operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct AndOp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             AndOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) && operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboScalar<Initial, bool>,
                                          SubBoolExpr2>,
                                    FieldType> operator &&(bool const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          AndOp<Initial, NeboScalar<Initial, bool>, SubBoolExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, bool>(arg1), arg2.expr()));
       }

      /* Boolean X Mask */
      template<typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboScalar<Initial, bool>,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                                    FieldType> operator &&(bool const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          AndOp<Initial,
                NeboScalar<Initial, bool>,
                NeboMask<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, bool>(arg1),
                                       NeboMask<Initial, FieldType>(arg2)));
       }

      /* Boolean X SubBoolSingleValueExpr */
      template<typename SubBoolSingleValueExpr2, typename T>
       inline NeboBooleanSingleValueExpression<AndOp<Initial,
                                                     NeboScalar<Initial, bool>,
                                                     SubBoolSingleValueExpr2>,
                                               T> operator &&(bool const & arg1,
                                                              NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                               T>
                                                              const & arg2) {
          AndOp<Initial, NeboScalar<Initial, bool>, SubBoolSingleValueExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, bool>(arg1), arg2.expr()));
       }

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolExpr1,
                                          NeboScalar<Initial, bool> >,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           bool const & arg2) {
          AndOp<Initial, SubBoolExpr1, NeboScalar<Initial, bool> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, bool>(arg2)));
       }

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial, SubBoolExpr1, SubBoolExpr2>,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          AndOp<Initial, SubBoolExpr1, SubBoolExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubBoolExpr X Mask */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolExpr1,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          AndOp<Initial, SubBoolExpr1, NeboMask<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboMask<Initial, FieldType>(arg2)));
       }

      /* SubBoolExpr X SubBoolSingleValueExpr */
      template<typename SubBoolExpr1,
               typename SubBoolSingleValueExpr2,
               typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolExpr1,
                                          SubBoolSingleValueExpr2>,
                                    FieldType> operator &&(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg2) {
          AndOp<Initial, SubBoolExpr1, SubBoolSingleValueExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* Mask X Boolean */
      template<typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                          NeboScalar<Initial, bool> >,
                                    FieldType> operator &&(SpatialMask<FieldType>
                                                           const & arg1,
                                                           bool const & arg2) {
          AndOp<Initial,
                NeboMask<Initial, FieldType>,
                NeboScalar<Initial, bool> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, bool>(arg2)));
       }

      /* Mask X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                          SubBoolExpr2>,
                                    FieldType> operator &&(SpatialMask<FieldType>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          AndOp<Initial, NeboMask<Initial, FieldType>, SubBoolExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1), arg2.expr()));
       }

      /* Mask X Mask */
      template<typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                                    FieldType> operator &&(SpatialMask<FieldType>
                                                           const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          AndOp<Initial,
                NeboMask<Initial, FieldType>,
                NeboMask<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1),
                                       NeboMask<Initial, FieldType>(arg2)));
       }

      /* Mask X SubBoolSingleValueExpr */
      template<typename SubBoolSingleValueExpr2, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                          SubBoolSingleValueExpr2>,
                                    FieldType> operator &&(SpatialMask<FieldType>
                                                           const & arg1,
                                                           NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg2) {
          AndOp<Initial, NeboMask<Initial, FieldType>, SubBoolSingleValueExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1), arg2.expr()));
       }

      /* SubBoolSingleValueExpr X Boolean */
      template<typename SubBoolSingleValueExpr1, typename T>
       inline NeboBooleanSingleValueExpression<AndOp<Initial,
                                                     SubBoolSingleValueExpr1,
                                                     NeboScalar<Initial, bool> >,
                                               T> operator &&(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                               T>
                                                              const & arg1,
                                                              bool const & arg2) {
          AndOp<Initial, SubBoolSingleValueExpr1, NeboScalar<Initial, bool> >
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, bool>(arg2)));
       }

      /* SubBoolSingleValueExpr X SubBoolExpr */
      template<typename SubBoolSingleValueExpr1,
               typename SubBoolExpr2,
               typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolSingleValueExpr1,
                                          SubBoolExpr2>,
                                    FieldType> operator &&(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          AndOp<Initial, SubBoolSingleValueExpr1, SubBoolExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubBoolSingleValueExpr X Mask */
      template<typename SubBoolSingleValueExpr1, typename FieldType>
       inline NeboBooleanExpression<AndOp<Initial,
                                          SubBoolSingleValueExpr1,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                                    FieldType> operator &&(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          AndOp<Initial, SubBoolSingleValueExpr1, NeboMask<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboMask<Initial, FieldType>(arg2)));
       }

      /* SubBoolSingleValueExpr X SubBoolSingleValueExpr */
      template<typename SubBoolSingleValueExpr1,
               typename SubBoolSingleValueExpr2,
               typename T>
       inline NeboBooleanSingleValueExpression<AndOp<Initial,
                                                     SubBoolSingleValueExpr1,
                                                     SubBoolSingleValueExpr2>,
                                               T> operator &&(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                               T>
                                                              const & arg1,
                                                              NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                               T>
                                                              const & arg2) {
          AndOp<Initial, SubBoolSingleValueExpr1, SubBoolSingleValueExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct OrOp;
      template<typename Operand1, typename Operand2>
       struct OrOp<Initial, Operand1, Operand2> {
         public:
          OrOp<SeqWalk,
               typename Operand1::SeqWalkType,
               typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             OrOp<Resize,
                  typename Operand1::ResizeType,
                  typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             OrOp<GPUWalk,
                  typename Operand1::GPUWalkType,
                  typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct OrOp<Resize, Operand1, Operand2> {
            public:
             OrOp<SeqWalk,
                  typename Operand1::SeqWalkType,
                  typename Operand2::SeqWalkType> typedef SeqWalkType;

             OrOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct OrOp<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          OrOp(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return (operand1_.eval(x, y, z) || operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct OrOp<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             OrOp(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return (operand1_.eval(x, y, z) || operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Boolean X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboScalar<Initial, bool>,
                                         SubBoolExpr2>,
                                    FieldType> operator ||(bool const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          OrOp<Initial, NeboScalar<Initial, bool>, SubBoolExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, bool>(arg1), arg2.expr()));
       }

      /* Boolean X Mask */
      template<typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboScalar<Initial, bool>,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                                    FieldType> operator ||(bool const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          OrOp<Initial, NeboScalar<Initial, bool>, NeboMask<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, bool>(arg1),
                                       NeboMask<Initial, FieldType>(arg2)));
       }

      /* Boolean X SubBoolSingleValueExpr */
      template<typename SubBoolSingleValueExpr2, typename T>
       inline NeboBooleanSingleValueExpression<OrOp<Initial,
                                                    NeboScalar<Initial, bool>,
                                                    SubBoolSingleValueExpr2>,
                                               T> operator ||(bool const & arg1,
                                                              NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                               T>
                                                              const & arg2) {
          OrOp<Initial, NeboScalar<Initial, bool>, SubBoolSingleValueExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, bool>(arg1), arg2.expr()));
       }

      /* SubBoolExpr X Boolean */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolExpr1,
                                         NeboScalar<Initial, bool> >,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           bool const & arg2) {
          OrOp<Initial, SubBoolExpr1, NeboScalar<Initial, bool> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, bool>(arg2)));
       }

      /* SubBoolExpr X SubBoolExpr */
      template<typename SubBoolExpr1, typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial, SubBoolExpr1, SubBoolExpr2>,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          OrOp<Initial, SubBoolExpr1, SubBoolExpr2> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubBoolExpr X Mask */
      template<typename SubBoolExpr1, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolExpr1,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          OrOp<Initial, SubBoolExpr1, NeboMask<Initial, FieldType> > typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboMask<Initial, FieldType>(arg2)));
       }

      /* SubBoolExpr X SubBoolSingleValueExpr */
      template<typename SubBoolExpr1,
               typename SubBoolSingleValueExpr2,
               typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolExpr1,
                                         SubBoolSingleValueExpr2>,
                                    FieldType> operator ||(NeboBooleanExpression<SubBoolExpr1,
                                                                                 FieldType>
                                                           const & arg1,
                                                           NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg2) {
          OrOp<Initial, SubBoolExpr1, SubBoolSingleValueExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* Mask X Boolean */
      template<typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                         NeboScalar<Initial, bool> >,
                                    FieldType> operator ||(SpatialMask<FieldType>
                                                           const & arg1,
                                                           bool const & arg2) {
          OrOp<Initial, NeboMask<Initial, FieldType>, NeboScalar<Initial, bool> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1),
                                       NeboScalar<Initial, bool>(arg2)));
       }

      /* Mask X SubBoolExpr */
      template<typename SubBoolExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                         SubBoolExpr2>,
                                    FieldType> operator ||(SpatialMask<FieldType>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          OrOp<Initial, NeboMask<Initial, FieldType>, SubBoolExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1), arg2.expr()));
       }

      /* Mask X Mask */
      template<typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                                    FieldType> operator ||(SpatialMask<FieldType>
                                                           const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          OrOp<Initial,
               NeboMask<Initial, FieldType>,
               NeboMask<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1),
                                       NeboMask<Initial, FieldType>(arg2)));
       }

      /* Mask X SubBoolSingleValueExpr */
      template<typename SubBoolSingleValueExpr2, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result>,
                                         SubBoolSingleValueExpr2>,
                                    FieldType> operator ||(SpatialMask<FieldType>
                                                           const & arg1,
                                                           NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg2) {
          OrOp<Initial, NeboMask<Initial, FieldType>, SubBoolSingleValueExpr2>
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg1), arg2.expr()));
       }

      /* SubBoolSingleValueExpr X Boolean */
      template<typename SubBoolSingleValueExpr1, typename T>
       inline NeboBooleanSingleValueExpression<OrOp<Initial,
                                                    SubBoolSingleValueExpr1,
                                                    NeboScalar<Initial, bool> >,
                                               T> operator ||(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                               T>
                                                              const & arg1,
                                                              bool const & arg2) {
          OrOp<Initial, SubBoolSingleValueExpr1, NeboScalar<Initial, bool> >
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, bool>(arg2)));
       }

      /* SubBoolSingleValueExpr X SubBoolExpr */
      template<typename SubBoolSingleValueExpr1,
               typename SubBoolExpr2,
               typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolSingleValueExpr1,
                                         SubBoolExpr2>,
                                    FieldType> operator ||(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg1,
                                                           NeboBooleanExpression<SubBoolExpr2,
                                                                                 FieldType>
                                                           const & arg2) {
          OrOp<Initial, SubBoolSingleValueExpr1, SubBoolExpr2> typedef
          ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubBoolSingleValueExpr X Mask */
      template<typename SubBoolSingleValueExpr1, typename FieldType>
       inline NeboBooleanExpression<OrOp<Initial,
                                         SubBoolSingleValueExpr1,
                                         NeboMask<Initial,
                                                  typename NeboFieldCheck<typename
                                                                          FieldType::
                                                                          field_type,
                                                                          FieldType>::
                                                  Result> >,
                                    FieldType> operator ||(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                            typename
                                                                                            FieldType::
                                                                                            value_type>
                                                           const & arg1,
                                                           SpatialMask<FieldType>
                                                           const & arg2) {
          OrOp<Initial, SubBoolSingleValueExpr1, NeboMask<Initial, FieldType> >
          typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboMask<Initial, FieldType>(arg2)));
       }

      /* SubBoolSingleValueExpr X SubBoolSingleValueExpr */
      template<typename SubBoolSingleValueExpr1,
               typename SubBoolSingleValueExpr2,
               typename T>
       inline NeboBooleanSingleValueExpression<OrOp<Initial,
                                                    SubBoolSingleValueExpr1,
                                                    SubBoolSingleValueExpr2>,
                                               T> operator ||(NeboBooleanSingleValueExpression<SubBoolSingleValueExpr1,
                                                                                               T>
                                                              const & arg1,
                                                              NeboBooleanSingleValueExpression<SubBoolSingleValueExpr2,
                                                                                               T>
                                                              const & arg2) {
          OrOp<Initial, SubBoolSingleValueExpr1, SubBoolSingleValueExpr2>
          typedef ReturnType;

          NeboBooleanSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand>
       struct NotOp;
      template<typename Operand>
       struct NotOp<Initial, Operand> {
         public:
          NotOp<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NotOp<Resize, typename Operand::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NotOp<GPUWalk, typename Operand::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NotOp(Operand const & operand)
          : operand_(operand)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return operand_.ghosts_with_bc();
          }

          inline GhostData ghosts_without_bc(void) const {
             return operand_.ghosts_without_bc();
          }

          inline bool has_extents(void) const {
             return (operand_.has_extents());
          }

          inline IntVec extents(void) const { return operand_.extents(); }

          inline IntVec has_bc(void) const { return operand_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return (operand_.cpu_ready()); }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand_.gpu_init(extents,
                                                     ghosts,
                                                     hasBC,
                                                     deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand const operand_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand>
          struct NotOp<Resize, Operand> {
            public:
             NotOp<SeqWalk, typename Operand::SeqWalkType> typedef SeqWalkType;

             NotOp(Operand const & operand)
             : operand_(operand)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand_.init(extents, ghosts, hasBC));
             }

            private:
             Operand const operand_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand>
       struct NotOp<SeqWalk, Operand> {
         public:
          typename Operand::value_type typedef value_type;

          NotOp(Operand const & operand)
          : operand_(operand)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return !(operand_.eval(x, y, z));
          }

         private:
          Operand operand_;
      };
      #ifdef __CUDACC__
         template<typename Operand>
          struct NotOp<GPUWalk, Operand> {
            public:
             typename Operand::value_type typedef value_type;

             NotOp(Operand const & operand)
             : operand_(operand)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return !(operand_.eval(x, y, z));
             }

            private:
             Operand operand_;
         }
      #endif
      /* __CUDACC__ */;

      /* SubBoolExpr */
      template<typename SubBoolExpr, typename FieldType>
       inline NeboBooleanExpression<NotOp<Initial, SubBoolExpr>, FieldType>
       operator !(NeboBooleanExpression<SubBoolExpr, FieldType> const & arg) {
          NotOp<Initial, SubBoolExpr> typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg.expr()));
       }

      /* Mask */
      template<typename FieldType>
       inline NeboBooleanExpression<NotOp<Initial,
                                          NeboMask<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                                    FieldType> operator !(SpatialMask<FieldType>
                                                          const & arg) {
          NotOp<Initial, NeboMask<Initial, FieldType> > typedef ReturnType;

          NeboBooleanExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboMask<Initial, FieldType>(arg)));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct MaxFcn;
      template<typename Operand1, typename Operand2>
       struct MaxFcn<Initial, Operand1, Operand2> {
         public:
          MaxFcn<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             MaxFcn<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             MaxFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct MaxFcn<Resize, Operand1, Operand2> {
            public:
             MaxFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType> typedef SeqWalkType;

             MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct MaxFcn<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return ((operand1_.eval(x, y, z) > operand2_.eval(x, y, z)) ?
                     operand1_.eval(x, y, z) : operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct MaxFcn<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             MaxFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return ((operand1_.eval(x, y, z) > operand2_.eval(x, y, z)) ?
                        operand1_.eval(x, y, z) : operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> max(typename FieldType::value_type const
                                            & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    SubExpr2>,
                             FieldType> max(typename FieldType::value_type const
                                            & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MaxFcn<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               NeboScalar<Initial, T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> max(typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          MaxFcn<Initial,
                 NeboScalar<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               NeboScalar<Initial, T>,
                                               SubExpr2>,
                                        T> max(typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg1,
                                               NeboSingleValueExpression<SubExpr2,
                                                                         T>
                                               const & arg2) {
          MaxFcn<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> max(FieldType const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MaxFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> max(FieldType const & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> max(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MaxFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> max(FieldType const & arg1,
                                            SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg2) {
          MaxFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> max(FieldType const & arg1,
                                            NeboSingleValueExpression<SubExpr2,
                                                                      typename
                                                                      FieldType::
                                                                      value_type>
                                            const & arg2) {
          MaxFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> max(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MaxFcn<Initial,
                 SubExpr1,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> max(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial, SubExpr1, SubExpr2>, FieldType> max(NeboExpression<SubExpr1,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboExpression<SubExpr2,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          MaxFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    SubExpr1,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> max(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg2) {
          MaxFcn<Initial,
                 SubExpr1,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial, SubExpr1, SubExpr2>, FieldType> max(NeboExpression<SubExpr1,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboSingleValueExpression<SubExpr2,
                                                                                                           typename
                                                                                                           FieldType::
                                                                                                           value_type>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          MaxFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboScalar<Initial, T> >,
                                        T> max(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg2) {
          MaxFcn<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> max(SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    SubExpr2>,
                             FieldType> max(SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MaxFcn<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> max(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          MaxFcn<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               SubExpr2>,
                                        T> max(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               NeboSingleValueExpression<SubExpr2,
                                                                         T>
                                               const & arg2) {
          MaxFcn<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, T> >,
                                        T> max(NeboSingleValueExpression<SubExpr1,
                                                                         T>
                                               const & arg1,
                                               typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg2) {
          MaxFcn<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MaxFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> max(NeboSingleValueExpression<SubExpr1,
                                                                      typename
                                                                      FieldType::
                                                                      value_type>
                                            const & arg1,
                                            FieldType const & arg2) {
          MaxFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MaxFcn<Initial, SubExpr1, SubExpr2>, FieldType> max(NeboSingleValueExpression<SubExpr1,
                                                                                                           typename
                                                                                                           FieldType::
                                                                                                           value_type>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboExpression<SubExpr2,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          MaxFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial,
                                               SubExpr1,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> max(NeboSingleValueExpression<SubExpr1,
                                                                         T>
                                               const & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          MaxFcn<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<MaxFcn<Initial, SubExpr1, SubExpr2>, T>
       max(NeboSingleValueExpression<SubExpr1, T> const & arg1,
           NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          MaxFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };

      template<typename CurrentMode, typename Operand1, typename Operand2>
       struct MinFcn;
      template<typename Operand1, typename Operand2>
       struct MinFcn<Initial, Operand1, Operand2> {
         public:
          MinFcn<SeqWalk,
                 typename Operand1::SeqWalkType,
                 typename Operand2::SeqWalkType> typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             MinFcn<Resize,
                    typename Operand1::ResizeType,
                    typename Operand2::ResizeType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             MinFcn<GPUWalk,
                    typename Operand1::GPUWalkType,
                    typename Operand2::GPUWalkType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          MinFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return min(operand1_.ghosts_with_bc(), operand2_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return min(operand1_.ghosts_without_bc(), operand2_.ghosts_without_bc());
          }

          inline bool has_extents(void) const {
             return (operand1_.has_extents() || operand2_.has_extents());
          }

          inline IntVec extents(void) const {
             #ifndef NDEBUG
                if((operand1_.has_extents() || operand2_.has_extents())) {
                   IntVec extents;

                   if(operand1_.has_extents()) { extents = operand1_.extents(); }
                   else { extents = operand2_.extents(); };

                   if(operand1_.has_extents()) {
                      assert(extents == operand1_.extents());
                   };

                   if(operand2_.has_extents()) {
                      assert(extents == operand2_.extents());
                   };
                }
             #endif
             /* NDEBUG */;

             return (operand1_.has_extents() ? operand1_.extents() : (operand2_.extents()));
          }

          inline IntVec has_bc(void) const {
             return (operand1_.has_extents() ? operand1_.has_bc() : (operand2_.has_bc()));
          }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                operand2_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(operand1_.resize(), operand2_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const {
                return (operand1_.cpu_ready() && operand2_.cpu_ready());
             }

             inline bool gpu_ready(int const deviceIndex) const {
                return (operand1_.gpu_ready(deviceIndex) && operand2_.gpu_ready(deviceIndex));
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(operand1_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex),
                                   operand2_.gpu_init(extents,
                                                      ghosts,
                                                      hasBC,
                                                      deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   operand1_.gpu_prep(deviceIndex); operand2_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Operand1 const operand1_;

          Operand2 const operand2_;
      };
      #ifdef ENABLE_THREADS
         template<typename Operand1, typename Operand2>
          struct MinFcn<Resize, Operand1, Operand2> {
            public:
             MinFcn<SeqWalk,
                    typename Operand1::SeqWalkType,
                    typename Operand2::SeqWalkType> typedef SeqWalkType;

             MinFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(operand1_.init(extents, ghosts, hasBC),
                                   operand2_.init(extents, ghosts, hasBC));
             }

            private:
             Operand1 const operand1_;

             Operand2 const operand2_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Operand1, typename Operand2>
       struct MinFcn<SeqWalk, Operand1, Operand2> {
         public:
          typename Operand1::value_type typedef value_type;

          MinFcn(Operand1 const & operand1, Operand2 const & operand2)
          : operand1_(operand1), operand2_(operand2)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return ((operand1_.eval(x, y, z) < operand2_.eval(x, y, z)) ?
                     operand1_.eval(x, y, z) : operand2_.eval(x, y, z));
          }

         private:
          Operand1 operand1_;

          Operand2 operand2_;
      };
      #ifdef __CUDACC__
         template<typename Operand1, typename Operand2>
          struct MinFcn<GPUWalk, Operand1, Operand2> {
            public:
             typename Operand1::value_type typedef value_type;

             MinFcn(Operand1 const & operand1, Operand2 const & operand2)
             : operand1_(operand1), operand2_(operand2)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return ((operand1_.eval(x, y, z) < operand2_.eval(x, y, z)) ?
                        operand1_.eval(x, y, z) : operand2_.eval(x, y, z));
             }

            private:
             Operand1 operand1_;

             Operand2 operand2_;
         }
      #endif
      /* __CUDACC__ */;

      /* Scalar X Field */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> min(typename FieldType::value_type const
                                            & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Scalar X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type>,
                                    SubExpr2>,
                             FieldType> min(typename FieldType::value_type const
                                            & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MinFcn<Initial,
                 NeboScalar<Initial, typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg1),
                                       arg2.expr()));
       }

      /* Scalar X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               NeboScalar<Initial, T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> min(typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          MinFcn<Initial,
                 NeboScalar<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* Scalar X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               NeboScalar<Initial, T>,
                                               SubExpr2>,
                                        T> min(typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg1,
                                               NeboSingleValueExpression<SubExpr2,
                                                                         T>
                                               const & arg2) {
          MinFcn<Initial, NeboScalar<Initial, T>, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboScalar<Initial, T>(arg1), arg2.expr()));
       }

      /* Field X Scalar */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> min(FieldType const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MinFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* Field X Field */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> min(FieldType const & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* Field X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> min(FieldType const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MinFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* Field X SingleValue */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> min(FieldType const & arg1,
                                            SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg2) {
          MinFcn<Initial,
                 NeboConstField<Initial, FieldType>,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* Field X SingleValueExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result>,
                                    SubExpr2>,
                             FieldType> min(FieldType const & arg1,
                                            NeboSingleValueExpression<SubExpr2,
                                                                      typename
                                                                      FieldType::
                                                                      value_type>
                                            const & arg2) {
          MinFcn<Initial, NeboConstField<Initial, FieldType>, SubExpr2> typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstField<Initial, FieldType>(arg1),
                                       arg2.expr()));
       }

      /* SubExpr X Scalar */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    SubExpr1,
                                    NeboScalar<Initial,
                                               typename FieldType::value_type> >,
                             FieldType> min(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            typename FieldType::value_type const
                                            & arg2) {
          MinFcn<Initial,
                 SubExpr1,
                 NeboScalar<Initial, typename FieldType::value_type> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboScalar<Initial,
                                                  typename FieldType::value_type>(arg2)));
       }

      /* SubExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> min(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SubExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial, SubExpr1, SubExpr2>, FieldType> min(NeboExpression<SubExpr1,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboExpression<SubExpr2,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          MinFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SubExpr X SingleValue */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    SubExpr1,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type> >,
                             FieldType> min(NeboExpression<SubExpr1, FieldType>
                                            const & arg1,
                                            SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg2) {
          MinFcn<Initial,
                 SubExpr1,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type> >
          typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg2)));
       }

      /* SubExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial, SubExpr1, SubExpr2>, FieldType> min(NeboExpression<SubExpr1,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboSingleValueExpression<SubExpr2,
                                                                                                           typename
                                                                                                           FieldType::
                                                                                                           value_type>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          MinFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValue X Scalar */
      template<typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboScalar<Initial, T> >,
                                        T> min(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg2) {
          MinFcn<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValue X Field */
      template<typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> min(SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 NeboConstField<Initial, FieldType> > typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValue X SubExpr */
      template<typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    NeboConstSingleValueField<Initial,
                                                              typename FieldType::
                                                              value_type>,
                                    SubExpr2>,
                             FieldType> min(SpatialOps::SpatialField<SpatialOps::
                                                                     SingleValue,
                                                                     typename
                                                                     FieldType::
                                                                     value_type>
                                            const & arg1,
                                            NeboExpression<SubExpr2, FieldType>
                                            const & arg2) {
          MinFcn<Initial,
                 NeboConstSingleValueField<Initial,
                                           typename FieldType::value_type>,
                 SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial,
                                                                 typename
                                                                 FieldType::
                                                                 value_type>(arg1),
                                       arg2.expr()));
       }

      /* SingleValue X SingleValue */
      template<typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> min(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          MinFcn<Initial,
                 NeboConstSingleValueField<Initial, T>,
                 NeboConstSingleValueField<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValue X SingleValueExpr */
      template<typename SubExpr2, typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               NeboConstSingleValueField<Initial,
                                                                         T>,
                                               SubExpr2>,
                                        T> min(SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg1,
                                               NeboSingleValueExpression<SubExpr2,
                                                                         T>
                                               const & arg2) {
          MinFcn<Initial, NeboConstSingleValueField<Initial, T>, SubExpr2>
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(NeboConstSingleValueField<Initial, T>(arg1),
                                       arg2.expr()));
       }

      /* SingleValueExpr X Scalar */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               SubExpr1,
                                               NeboScalar<Initial, T> >,
                                        T> min(NeboSingleValueExpression<SubExpr1,
                                                                         T>
                                               const & arg1,
                                               typename SpatialOps::SpatialField<SpatialOps::
                                                                                 SingleValue,
                                                                                 T>::
                                               value_type const & arg2) {
          MinFcn<Initial, SubExpr1, NeboScalar<Initial, T> > typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), NeboScalar<Initial, T>(arg2)));
       }

      /* SingleValueExpr X Field */
      template<typename SubExpr1, typename FieldType>
       inline NeboExpression<MinFcn<Initial,
                                    SubExpr1,
                                    NeboConstField<Initial,
                                                   typename NeboFieldCheck<typename
                                                                           FieldType::
                                                                           field_type,
                                                                           FieldType>::
                                                   Result> >,
                             FieldType> min(NeboSingleValueExpression<SubExpr1,
                                                                      typename
                                                                      FieldType::
                                                                      value_type>
                                            const & arg1,
                                            FieldType const & arg2) {
          MinFcn<Initial, SubExpr1, NeboConstField<Initial, FieldType> > typedef
          ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstField<Initial, FieldType>(arg2)));
       }

      /* SingleValueExpr X SubExpr */
      template<typename SubExpr1, typename SubExpr2, typename FieldType>
       inline NeboExpression<MinFcn<Initial, SubExpr1, SubExpr2>, FieldType> min(NeboSingleValueExpression<SubExpr1,
                                                                                                           typename
                                                                                                           FieldType::
                                                                                                           value_type>
                                                                                 const
                                                                                 &
                                                                                 arg1,
                                                                                 NeboExpression<SubExpr2,
                                                                                                FieldType>
                                                                                 const
                                                                                 &
                                                                                 arg2) {
          MinFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboExpression<ReturnType, FieldType> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       }

      /* SingleValueExpr X SingleValue */
      template<typename SubExpr1, typename T>
       inline NeboSingleValueExpression<MinFcn<Initial,
                                               SubExpr1,
                                               NeboConstSingleValueField<Initial,
                                                                         T> >,
                                        T> min(NeboSingleValueExpression<SubExpr1,
                                                                         T>
                                               const & arg1,
                                               SpatialOps::SpatialField<SpatialOps::
                                                                        SingleValue,
                                                                        T> const
                                               & arg2) {
          MinFcn<Initial, SubExpr1, NeboConstSingleValueField<Initial, T> >
          typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(),
                                       NeboConstSingleValueField<Initial, T>(arg2)));
       }

      /* SingleValueExpr X SingleValueExpr */
      template<typename SubExpr1, typename SubExpr2, typename T>
       inline NeboSingleValueExpression<MinFcn<Initial, SubExpr1, SubExpr2>, T>
       min(NeboSingleValueExpression<SubExpr1, T> const & arg1,
           NeboSingleValueExpression<SubExpr2, T> const & arg2) {
          MinFcn<Initial, SubExpr1, SubExpr2> typedef ReturnType;

          NeboSingleValueExpression<ReturnType, T> typedef ReturnTerm;

          return ReturnTerm(ReturnType(arg1.expr(), arg2.expr()));
       };
   } /* SpatialOps */

#endif
/* NEBO_OPERATORS_H */
