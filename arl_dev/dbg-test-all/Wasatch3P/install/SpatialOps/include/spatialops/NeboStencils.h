/* This file was generated by fulmar version 0.9.2. */

/*
 * Copyright (c) 2014 The University of Utah
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef NEBO_STENCILS_H
   #define NEBO_STENCILS_H

   namespace SpatialOps {
      template<int Length>
       struct NeboStencilCoefCollection {
         public:
          NeboStencilCoefCollection(NeboStencilCoefCollection<Length - 1> const
                                    & o,
                                    double const c)
          : others_(o), coef_(c)
          {}

          inline NeboStencilCoefCollection<Length + 1> const operator ()(double
                                                                         const c) const {
             return NeboStencilCoefCollection<Length + 1>(*this, c);
          }

          #ifdef __CUDACC__
             __host__ __device__
          #endif
          /* __CUDACC__ */ inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));
             };

             if(index >= Length) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));
             };

             return (index == Length - 1 ? coef() : others().get_coef(index));
          }

          #ifdef __CUDACC__
             __host__ __device__
          #endif
          /* __CUDACC__ */ inline NeboStencilCoefCollection<Length - 1> const
          others(void) const { return others_; }

          inline double last(void) const { return others().last(); }

          inline NeboStencilCoefCollection<Length - 1> all_but_last(void) const {
             return NeboStencilCoefCollection<Length - 1>(others().all_but_last(),
                                                          coef_);
          }

         private:
          NeboStencilCoefCollection<Length - 1> const others_;

          double const coef_;
      };

      template<>
       struct NeboStencilCoefCollection<1> {
         public:
          NeboStencilCoefCollection(double const c)
          : coef_(c)
          {}

          NeboStencilCoefCollection(NeboNil nil, double const c)
          : coef_(c)
          {}

          inline NeboStencilCoefCollection<2> const operator ()(double const c) const {
             return NeboStencilCoefCollection<2>(*this, c);
          }

          #ifdef __CUDACC__
             __host__ __device__
          #endif
          /* __CUDACC__ */ inline double coef(void) const { return coef_; }

          inline double get_coef(int const index) const {
             if(index < 0) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "given negative value for coefficient index";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));
             };

             if(index > 1) {
                std::ostringstream msg;
                msg << "Nebo error in " << "Nebo Stencil Coefficient Collection"
                << ":\n";
                msg << "trying to access a coefficient that does not exist";
                msg << "\n";
                msg << "\t - " << __FILE__ << " : " << __LINE__;
                throw(std::runtime_error(msg.str()));
             };

             return coef();
          }

          inline double last(void) const { return coef_; }

          inline NeboNil all_but_last(void) const { return NeboNil(); }

         private:
          double const coef_;
      };

      inline NeboStencilCoefCollection<1> const build_coef_collection(double
                                                                      const c) {
         return NeboStencilCoefCollection<1>(c);
      };

      inline NeboStencilCoefCollection<2> const build_two_point_coef_collection(double
                                                                                const
                                                                                c1,
                                                                                double
                                                                                const
                                                                                c2) {
         return NeboStencilCoefCollection<1>(c1)(c2);
      };

      inline NeboStencilCoefCollection<3> const
      build_three_point_coef_collection(double const c1,
                                        double const c2,
                                        double const c3) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3);
      };

      inline NeboStencilCoefCollection<4> const build_four_point_coef_collection(double
                                                                                 const
                                                                                 c1,
                                                                                 double
                                                                                 const
                                                                                 c2,
                                                                                 double
                                                                                 const
                                                                                 c3,
                                                                                 double
                                                                                 const
                                                                                 c4) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3)(c4);
      };

      inline NeboStencilCoefCollection<5> const build_five_point_coef_collection(double
                                                                                 const
                                                                                 c1,
                                                                                 double
                                                                                 const
                                                                                 c2,
                                                                                 double
                                                                                 const
                                                                                 c3,
                                                                                 double
                                                                                 const
                                                                                 c4,
                                                                                 double
                                                                                 const
                                                                                 c5) {
         return NeboStencilCoefCollection<1>(c1)(c2)(c3)(c4)(c5);
      };

      template<typename PointType, typename CollectionType>
       struct NeboStencilPointCollection {
         public:
          PointType typedef Point;

          CollectionType typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          Point typedef First;

          Collection typedef AllButFirst;

          typename Collection::Last typedef Last;

          NeboStencilPointCollection<Point, typename Collection::AllButLast>
          typedef AllButLast;

          enum {length = 1 + Collection::length};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          static inline GhostData possible_ghosts(void) {
             return min(additive_reductive_point_to_ghost(Point::int_vec()),
                        Collection::possible_ghosts());
          }

          static inline GhostData possible_ghosts(GhostData const & ghosts) {
             return ghosts + possible_ghosts();
          }

          static inline GhostData possible_additive_ghosts(void) {
             return min(addative_point_to_ghost(Point::int_vec()),
                        Collection::possible_ghosts());
          }

          static inline GhostData possible_additive_ghosts(GhostData const &
                                                           ghosts) {
             return ghosts + possible_additive_ghosts();
          }
      };

      template<typename PointType>
       struct NeboStencilPointCollection<PointType, NeboNil> {
         public:
          PointType typedef Point;

          NeboNil typedef Collection;

          NeboStencilPointCollection<Point, Collection> typedef MyType;

          Point typedef Last;

          NeboNil typedef AllButLast;

          enum {length = 1};

          template<typename NewPoint>
           struct AddPoint {
             NeboStencilPointCollection<NewPoint, MyType> typedef Result;
          };

          static inline GhostData possible_ghosts(void) {
             return additive_reductive_point_to_ghost(Point::int_vec());
          }

          static inline GhostData possible_ghosts(GhostData const & ghosts) {
             return ghosts + possible_ghosts();
          }

          static inline GhostData possible_additive_ghosts(void) {
             return additive_point_to_ghost(Point::int_vec());
          }

          static inline GhostData possible_additive_ghosts(GhostData const &
                                                           ghosts) {
             return ghosts + possible_additive_ghosts();
          }
      };

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          NeboStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
          typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboStencil<GPUWalk, Pts, typename Arg::GPUWalkType, FieldType>
             typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return Pts::possible_ghosts(arg_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return Pts::possible_ghosts(arg_.ghosts_without_bc());
          }

          inline bool has_extents(void) const { return arg_.has_extents(); }

          inline IntVec extents(void) const { return arg_.extents(); }

          inline IntVec has_bc(void) const { return arg_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(arg_.init(extents, ghosts, hasBC), coefs_);
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize(), coefs_);
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(extents,
                                                 ghosts,
                                                 hasBC,
                                                 deviceIndex),
                                   coefs_);
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Arg const arg_;

          Coefs const coefs_;
      };
      #ifdef ENABLE_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             NeboStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
             typedef SeqWalkType;

             NeboStencil(Arg const & arg, Coefs const & coefs)
             : arg_(arg), coefs_(coefs)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(arg_.init(extents, ghosts, hasBC), coefs_);
             }

            private:
             Arg const arg_;

             Coefs const coefs_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          template<typename PointCollection>
           struct EvalExpr {
             NeboStencilCoefCollection<PointCollection::length> typedef Coefs;

             typename PointCollection::Point typedef Point;

             typename PointCollection::Collection typedef Collection;

             static inline value_type eval(Arg const & arg,
                                           Coefs const & coefs,
                                           int const x,
                                           int const y,
                                           int const z) {
                return EvalExpr<Collection>::eval(arg, coefs.others(), x, y, z)
                       + arg.eval(x + Point::value(0),
                                  y + Point::value(1),
                                  z + Point::value(2)) * coefs.coef();
             }
          };

          template<typename Point>
           struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
             NeboStencilCoefCollection<1> typedef Coefs;

             static inline value_type eval(Arg const & arg,
                                           Coefs const & coefs,
                                           int const x,
                                           int const y,
                                           int const z) {
                return arg.eval(x + Point::value(0),
                                y + Point::value(1),
                                z + Point::value(2)) * coefs.coef();
             }
          };

          NeboStencil(Arg const & arg, Coefs const & coefs)
          : arg_(arg), coefs_(coefs)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return EvalExpr<Pts>::eval(arg_, coefs_, x, y, z);
          }

         private:
          Arg arg_;

          Coefs const coefs_;
      };
      #ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             template<typename PointCollection>
              struct EvalExpr {
                NeboStencilCoefCollection<PointCollection::length> typedef Coefs
                ;

                typename PointCollection::Point typedef Point;

                typename PointCollection::Collection typedef Collection;

                __device__ static inline value_type eval(Arg const & arg,
                                                         Coefs const & coefs,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return EvalExpr<Collection>::eval(arg,
                                                     coefs.others(),
                                                     x,
                                                     y,
                                                     z) + arg.eval(x + Point::
                                                                   value_gpu(0),
                                                                   y + Point::
                                                                   value_gpu(1),
                                                                   z + Point::
                                                                   value_gpu(2))
                          * coefs.coef();
                }
             };

             template<typename Point>
              struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
                NeboStencilCoefCollection<1> typedef Coefs;

                __device__ static inline value_type eval(Arg const & arg,
                                                         Coefs const & coefs,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return arg.eval(x + Point::value_gpu(0),
                                   y + Point::value_gpu(1),
                                   z + Point::value_gpu(2)) * coefs.coef();
                }
             };

             NeboStencil(Arg const & a, Coefs const & coefs)
             : arg_(a), coefs_(coefs)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return EvalExpr<Pts>::eval(arg_, coefs_, x, y, z);
             }

            private:
             Arg arg_;

             Coefs const coefs_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboEdgelessStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboEdgelessStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          NeboEdgelessStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
          typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboEdgelessStencil<Resize,
                                 Pts,
                                 typename Arg::ResizeType,
                                 FieldType> typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboEdgelessStencil<GPUWalk,
                                 Pts,
                                 typename Arg::GPUWalkType,
                                 FieldType> typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboEdgelessStencil(Arg const & a, Coefs const & coefs)
          : arg_(a), coefs_(coefs)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return Pts::possible_additive_ghosts(arg_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return Pts::possible_additive_ghosts(arg_.ghosts_without_bc());
          }

          inline bool has_extents(void) const { return arg_.has_extent(); }

          inline IntVec extents(void) const { return arg_.extents(); }

          inline IntVec has_bc(void) const { return arg_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(arg_.init(extents, ghosts, hasBC),
                                coefs_,
                                lowest_indicies(),
                                highest_indicies());
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize(),
                                  coefs_,
                                  lowest_indicies(),
                                  highest_indicies());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(extents,
                                                 ghosts,
                                                 hasBC,
                                                 deviceIndex),
                                   coefs_);
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

          inline GhostData actual_ghosts(void) const {
             return Pts::possible_ghosts(arg_.ghosts_with_bc());
          }

          inline IntVec lowest_indicies(void) const {
             return -(actual_ghosts().get_minus());
          }

          inline IntVec highest_indicies(void) const {
             return actual_ghosts().get_plus() + extents();
          }

         private:
          Arg const arg_;

          Coefs const coefs_;
      };
      #ifdef ENABLE_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboEdgelessStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             NeboEdgelessStencil<SeqWalk,
                                 Pts,
                                 typename Arg::SeqWalkType,
                                 FieldType> typedef SeqWalkType;

             NeboEdgelessStencil(Arg const & arg,
                                 Coefs const & coefs,
                                 IntVec const & low,
                                 IntVec const & high)
             : arg_(arg), coefs_(coefs), low_(low), high_(high)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(arg_.init(extents, ghosts, hasBC),
                                   coefs_,
                                   low_,
                                   high_);
             }

            private:
             Arg const arg_;

             Coefs const coefs_;

             IntVec const low_;

             IntVec const high_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboEdgelessStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboStencilCoefCollection<Pts::length> typedef Coefs;

          template<typename PointCollection>
           struct EvalExpr {
             NeboStencilCoefCollection<PointCollection::length> typedef Coefs;

             typename PointCollection::Point typedef Point;

             typename PointCollection::Collection typedef Collection;

             static inline value_type eval(Arg const & arg,
                                           Coefs const & coefs,
                                           int const x,
                                           int const y,
                                           int const z) {
                return EvalExpr<Collection>::eval(arg, coefs.others(), x, y, z)
                       + arg.eval(x + Point::value(0),
                                  y + Point::value(1),
                                  z + Point::value(2)) * coefs.coef();
             }
          };

          template<typename Point>
           struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
             NeboStencilCoefCollection<1> typedef Coefs;

             static inline value_type eval(Arg const & arg,
                                           Coefs const & coefs,
                                           int const x,
                                           int const y,
                                           int const z) {
                return arg.eval(x + Point::value(0),
                                y + Point::value(1),
                                z + Point::value(2)) * coefs.coef();
             }
          };

          NeboEdgelessStencil(Arg const & arg,
                              Coefs const & coefs,
                              IntVec const & low,
                              IntVec const & high)
          : arg_(arg), coefs_(coefs), low_(low), high_(high)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             #ifndef NDEBUG
                IntVec index = IntVec(x, y, z);
                if(index < low_ || index >= high_) {
                   std::ostringstream msg;
                   msg << "Nebo error in " << "Nebo Edgeless Stencil" << ":\n";
                   msg << "	 - " << low_ << " < " << index << " <= " << high_;
                   msg << "\n";
                   msg << "\t - " << __FILE__ << " : " << __LINE__;
                   throw(std::runtime_error(msg.str()));;
                }
             #endif
             /* NDEBUG */;

             return EvalExpr<Pts>::eval(arg_, coefs_, x, y, z);
          }

         private:
          Arg arg_;

          Coefs const coefs_;

          IntVec const low_;

          IntVec const high_;
      };
      #ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboEdgelessStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboStencilCoefCollection<Pts::length> typedef Coefs;

             template<typename PointCollection>
              struct EvalExpr {
                NeboStencilCoefCollection<PointCollection::length> typedef Coefs
                ;

                typename PointCollection::Point typedef Point;

                typename PointCollection::Collection typedef Collection;

                __device__ static inline value_type eval(Arg const & arg,
                                                         Coefs const & coefs,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return EvalExpr<Collection>::eval(arg,
                                                     coefs.others(),
                                                     x,
                                                     y,
                                                     z) + arg.eval(x + Point::
                                                                   value_gpu(0),
                                                                   y + Point::
                                                                   value_gpu(1),
                                                                   z + Point::
                                                                   value_gpu(2))
                          * coefs.coef();
                }
             };

             template<typename Point>
              struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
                NeboStencilCoefCollection<1> typedef Coefs;

                __device__ static inline value_type eval(Arg const & arg,
                                                         Coefs const & coefs,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return arg.eval(x + Point::value_gpu(0),
                                   y + Point::value_gpu(1),
                                   z + Point::value_gpu(2)) * coefs.coef();
                }
             };

             NeboEdgelessStencil(Arg const & a, Coefs const & coefs)
             : arg_(a), coefs_(coefs)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return EvalExpr<Pts>::eval(arg_, coefs_, x, y, z);
             }

            private:
             Arg arg_;

             Coefs const coefs_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename CurrentMode,
               typename Pts,
               typename Arg,
               typename FieldType>
       struct NeboSumStencil;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<Initial, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          NeboSumStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
          typedef SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboSumStencil<Resize, Pts, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboSumStencil<GPUWalk, Pts, typename Arg::GPUWalkType, FieldType>
             typedef GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboSumStencil(Arg const & a)
          : arg_(a)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return Pts::possible_ghosts(arg_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return Pts::possible_ghosts(arg_.ghosts_without_bc());
          }

          inline bool has_extents(void) const { return arg_.has_extents(); }

          inline IntVec extents(void) const { return arg_.extents(); }

          inline IntVec has_bc(void) const { return arg_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(arg_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(extents,
                                                 ghosts,
                                                 hasBC,
                                                 deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Arg const arg_;
      };
      #ifdef ENABLE_THREADS
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboSumStencil<Resize, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             NeboSumStencil<SeqWalk, Pts, typename Arg::SeqWalkType, FieldType>
             typedef SeqWalkType;

             NeboSumStencil(Arg const & arg)
             : arg_(arg)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(arg_.init(extents, ghosts, hasBC));
             }

            private:
             Arg const arg_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Pts, typename Arg, typename FieldType>
       struct NeboSumStencil<SeqWalk, Pts, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          template<typename PointCollection>
           struct EvalExpr {
             typename PointCollection::Point typedef Point;

             typename PointCollection::Collection typedef Collection;

             static inline value_type eval(Arg const & arg,
                                           int const x,
                                           int const y,
                                           int const z) {
                return EvalExpr<Collection>::eval(arg, x, y, z) + arg.eval(x +
                                                                           Point::
                                                                           value(0),
                                                                           y +
                                                                           Point::
                                                                           value(1),
                                                                           z +
                                                                           Point::
                                                                           value(2));
             }
          };

          template<typename Point>
           struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
             static inline value_type eval(Arg const & arg,
                                           int const x,
                                           int const y,
                                           int const z) {
                return arg.eval(x + Point::value(0),
                                y + Point::value(1),
                                z + Point::value(2));
             }
          };

          NeboSumStencil(Arg const & arg)
          : arg_(arg)
          {}

          inline value_type eval(int const x, int const y, int const z) const {
             return EvalExpr<Pts>::eval(arg_, x, y, z);
          }

         private:
          Arg arg_;
      };
      #ifdef __CUDACC__
         template<typename Pts, typename Arg, typename FieldType>
          struct NeboSumStencil<GPUWalk, Pts, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             template<typename PointCollection>
              struct EvalExpr {
                typename PointCollection::Point typedef Point;

                typename PointCollection::Collection typedef Collection;

                __device__ static inline value_type eval(Arg const & arg,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return EvalExpr<Collection>::eval(arg, x, y, z) + arg.eval(x
                                                                              +
                                                                              Point::
                                                                              value_gpu(0),
                                                                              y
                                                                              +
                                                                              Point::
                                                                              value_gpu(1),
                                                                              z
                                                                              +
                                                                              Point::
                                                                              value_gpu(2));
                }
             };

             template<typename Point>
              struct EvalExpr<NeboStencilPointCollection<Point, NeboNil> > {
                __device__ static inline value_type eval(Arg const & arg,
                                                         int const x,
                                                         int const y,
                                                         int const z) {
                   return arg.eval(x + Point::value_gpu(0),
                                   y + Point::value_gpu(1),
                                   z + Point::value_gpu(2));
                }
             };

             NeboSumStencil(Arg const & a)
             : arg_(a)
             {}

             __device__ inline value_type eval(int const x,
                                               int const y,
                                               int const z) const {
                return EvalExpr<Pts>::eval(arg_, x, y, z);
             }

            private:
             Arg arg_;
         }
      #endif
      /* __CUDACC__ */;

      template<typename Point>
       static inline GhostData point_possible_ghosts(GhostData const & ghosts) {
          return ghosts + additive_reductive_point_to_ghost(Point::int_vec());
       };

      template<typename CurrentMode,
               typename Point,
               typename Arg,
               typename FieldType>
       struct NeboMaskShift;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<Initial, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename Arg::SeqWalkType typedef ArgSeqWalkType;

          #ifdef __CUDACC__
             typename Arg::GPUWalkType typedef ArgGPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboMaskShift<SeqWalk, Point, ArgSeqWalkType, FieldType> typedef
          SeqWalkType;

          #ifdef ENABLE_THREADS
             NeboMaskShift<Resize, Point, typename Arg::ResizeType, FieldType>
             typedef ResizeType;
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             NeboMaskShift<GPUWalk, Point, ArgGPUWalkType, FieldType> typedef
             GPUWalkType;
          #endif
          /* __CUDACC__ */

          NeboMaskShift(Arg const & a)
          : arg_(a)
          {}

          inline GhostData ghosts_with_bc(void) const {
             return point_possible_ghosts<Point>(arg_.ghosts_with_bc());
          }

          inline GhostData ghosts_without_bc(void) const {
             return point_possible_ghosts<Point>(arg_.ghosts_without_bc());
          }

          inline bool has_extents(void) const { return arg_.has_extents(); }

          inline IntVec extents(void) const { return arg_.extents(); }

          inline IntVec has_bc(void) const { return arg_.has_bc(); }

          inline SeqWalkType init(IntVec const & extents,
                                  GhostData const & ghosts,
                                  IntVec const & hasBC) const {
             return SeqWalkType(arg_.init(extents, ghosts, hasBC));
          }

          #ifdef ENABLE_THREADS
             inline ResizeType resize(void) const {
                return ResizeType(arg_.resize());
             }
          #endif
          /* ENABLE_THREADS */

          #ifdef __CUDACC__
             inline bool cpu_ready(void) const { return arg_.cpu_ready(); }

             inline bool gpu_ready(int const deviceIndex) const {
                return arg_.gpu_ready(deviceIndex);
             }

             inline GPUWalkType gpu_init(IntVec const & extents,
                                         GhostData const & ghosts,
                                         IntVec const & hasBC,
                                         int const deviceIndex) const {
                return GPUWalkType(arg_.gpu_init(extents,
                                                 ghosts,
                                                 hasBC,
                                                 deviceIndex));
             }

             #ifdef NEBO_GPU_TEST
                inline void gpu_prep(int const deviceIndex) const {
                   arg_.gpu_prep(deviceIndex);
                }
             #endif
             /* NEBO_GPU_TEST */
          #endif
          /* __CUDACC__ */

         private:
          Arg const arg_;
      };
      #ifdef ENABLE_THREADS
         template<typename Point, typename Arg, typename FieldType>
          struct NeboMaskShift<Resize, Point, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename Arg::SeqWalkType typedef ArgSeqWalkType;

             NeboMaskShift<SeqWalk, Point, ArgSeqWalkType, FieldType> typedef
             SeqWalkType;

             NeboMaskShift(Arg const & arg)
             : arg_(arg)
             {}

             inline SeqWalkType init(IntVec const & extents,
                                     GhostData const & ghosts,
                                     IntVec const & hasBC) const {
                return SeqWalkType(arg_.init(extents, ghosts, hasBC));
             }

            private:
             Arg const arg_;
         }
      #endif
      /* ENABLE_THREADS */;
      template<typename Point, typename Arg, typename FieldType>
       struct NeboMaskShift<SeqWalk, Point, Arg, FieldType> {
         public:
          FieldType typedef field_type;

          typename field_type::value_type typedef value_type;

          NeboMaskShift(Arg const & arg)
          : arg_(arg)
          {}

          inline bool eval(int const x, int const y, int const z) const {
             return arg_.eval(x + Point::value(0),
                              y + Point::value(1),
                              z + Point::value(2));
          }

         private:
          Arg arg_;
      };
      #ifdef __CUDACC__
         template<typename Point, typename Arg, typename FieldType>
          struct NeboMaskShift<GPUWalk, Point, Arg, FieldType> {
            public:
             FieldType typedef field_type;

             typename field_type::value_type typedef value_type;

             NeboMaskShift(Arg const & a)
             : arg_(a)
             {}

             __device__ inline bool eval(int const x, int const y, int const z) const {
                return arg_.eval(x + Point::value_gpu(0),
                                 y + Point::value_gpu(1),
                                 z + Point::value_gpu(2));
             }

            private:
             Arg arg_;
         }
      #endif
      /* __CUDACC__ */;
   } /* SpatialOps */

#endif
/* NEBO_STENCILS_H */
