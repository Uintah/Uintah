\section{Code overview}
\begin{itemize}
  \item \fn{Typedefs.h} : type definitions for various data structures (lists and maps of geometric objects, vectors and matrices, etc.)
  \item \fn{Utils.h/cpp} : various enums, constants as well as vector and matrix related functionality (included overloaded arithmetic operators).
	Note that matrices and vectors are both implemented as std::array without a class being wrapped around them. For convenience vec\_entries (x1, x2) and 
	mat\_entries (a11, a12, a21, a22) enums can be used to access corresponding components.
  \item \fn{BoundingBox.h/cpp} : class implementing bounding box and related functionality, notably functions determining whether a point (another bounding box)
	is inside (Contains, StrictlyContains) the bounding box. Bounding boxes are used to describe the mesh element geometry.
  \item \fn{Basis.h/cpp} : class that implements local ``hat-function'' basis function evaluation as well as derivative evaluation. The function is defined in
	physical coordinates (there is no reference element and mapping in the finite element sense).
  \item \fn{Node.h/cpp} : classes NodeData and Node. NodeData contains solution values at the node as well as node id and position. Node contains
	the pointer to the NodeData instance as well as auxiliary functions and flags. Note on flags meaning: isRegular denotes whether the node is 
	``regular''(is not located in the middle of any element's side) or ``hanging'', isActive denotes whether any data was projected to the node after the 
	value reset at the beginning of the time step (in other words: are there any particles in within elements containing the node in question).
	QNodeItem class describes the Qt image of the node, handles various interface events and contains pointer to NodeData in order to be able to interactively
	show solution values at the node.
  \item \fn{Particle.h/cpp} : classes ParticleData (keeps particle-related physical quantities), Particle (keeps basic flags and pointer to ParticleData instance) and 
	QParticleItem (represents particle image). Particle implementation is very similar to Node implementation.
  \item \fn{Mesh.h/cpp} : classes Element and Mesh. Mesh is represented as a quad tree with nodes beings instances of the Element class. 
	Mesh class is inherited from Element class, adds some general functionality that applies to the mesh as a whole. The object of the Mesh class represents the root 
	node (simulation domain) of the tree.
\end{itemize}
\section{Implementation details}
\subsection{Element and Mesh classes, mesh adaptation}
\subsubsection{Flags}
hasChildren and hasImage are pretty self-explanatory. isActive flag has to do with mesh tree structure and refinement/coarsening operations.
If Element isActive it is in the current ``slice'' of the mesh tree - the one we'll be using during the current time step. When we coarsen, we do not 
delete elements, which means that the leaf-element is not necessarily ``active'' at the moment. More information regarding the mechanism of mesh adaptation 
will be presented below.
\subsubsection{Some Element functions}
\begin{lstlisting}
void Refine(const unsigned int n);
\end{lstlisting}
Recursively refines current element n times (element is split into 4 child elements, each child split into 4 child elements, etc.).
\begin{lstlisting}
void FillActiveElementList(ElementPtrList& e, const bool check_root = true);
\end{lstlisting}
This function traverses the mesh tree, collects all the active elements into on list, representing the current
mesh, that is later passed to MPM solver.  This is a recursive function, like many other that traverse the mesh
tree, and parameter check\_root is set to true by default to check that the function is called from the root node
originally. The subsequent recursive calls of the function explicitly set the check\_root parameter to false.
\begin{lstlisting}
void GetActiveElementsContaining(ElementPtrList& e, const Vec2D& v, 
					const bool check_root = true);
\end{lstlisting}
This function returns a list of active elements (e) that contain a given point (v). The function is used internally
to build the element-to-particle map (Solver class functionality, map is updated after every time step) as well as
to create the node list and fill node neighbors information after the mesh is updated.
\begin{lstlisting}
void AppendNodeCoords(CoordList& lst);
\end{lstlisting}
Appends the coordinates of the four corners to the given list. Used internally during mesh update (first all the
nodes collected, then the list is filtered, leaving only unique ones).
\begin{lstlisting}
void SetActive();
void SetPassive();
\end{lstlisting}
SetActive sets the current (this) element to be active and all the following (down the tree) elements to be
passive. SetPassive sets element to be passive and deletes element's image (graphical representation).
\begin{lstlisting}
void CalculateMetrics(const ParticlePtrList &p_list);
void ChildrenAvgMetrics(double& sc, double& conc);
\end{lstlisting}
CalculateMetrics evaluates two quantities for the element given the list of particles that are inside the element: {\bf
score} is the actual number of particles divided by the ``ideal'' number of particles (3-4 in 2D and about 8 in 3D)
and {\bf concentration} is the total volume of particles divided by the volume of the element. ChildrenAvgMetrics
returns averaged metrics (score and concentration) for the child elements (if any). Average is taken over the
child elements that have some particles inside (we do not average over ``empty'' elements).
\begin{lstlisting}
void UpdateMetrics(const ParticlePtrList &p_list);
void SetActiveElements(const bool enc_active = false);
\end{lstlisting}
These two functions are the main driving force behind mesh refinement/coarsening process. UpdateMetrics traverses the
mesh tree, computing score and concentration for each element and performs further refinement in the following cases:
if the leaf node is reached but 1) current element is too big compared to the volume of the particles that occupy it
(concentration < const1) or 2) when there are too many particles occupy current element. SetActiveElements traverses
the mesh tree comparing current element metrics with the average metrics of its children eventually stopping, when
current element quality is ``better'' than the average children elements quality, and setting current element as
active (part of the mesh partition at the current time step). The enc\_active flag is used to avoid excessive mesh
refinement/coarsening: mesh is not coarsened unless an empty element is encountered. In other words, refinement is
always preformed based on the metrics comparison between current element and its children, coarsening is delayed
until all the particles leave the region. If the coarsening is not delayed and based on metrics comparison, we
can run into a rapid oscillation of refinement/coarsening due to minor movements of the particles.
\subsubsection{Some Mesh functions}
\begin{lstlisting}
void SetDomain(const BoundingBox& b);
void RefineUniformly(const unsigned int n);
void RefineByID(const unsigned int i);
\end{lstlisting}
SetDomain initializes the element tree root by setting domain bounding box. RefineUniformly just calls Refine from the 
Element class to set initial uniform partition by recursively splitting the simulation domain n times. RefineByID
refines element with id i once (main use is to ``manually'' create interesting mesh configurations for debugging purposes).
\begin{lstlisting}
Adapt(const ParticlePtrList& p_list);
\end{lstlisting}
Given a list of particles, adapts the mesh to particle distribution. Evaluates metrics over all the elments in the mesh tree 
and determines active elements, which form the ``slice'' of the mesh tree that represents current mesh configuration. After 
active elements are identified, element and node lists are updated.
\begin{lstlisting}
void UpdateActiveElements();
void UpdateNodes();
void UpdateNodeList();
void UpdateNodeNeighbors();
void UpdateElementNodes();
void UpdateHangingNodes();
\end{lstlisting}
These update functions together implement mesh update functionality. UpdateNodes is just a wrapper around the following 
four functions. UpdateActiveElements clears the element list and populates it with currently active elements.
UpdateNodeList collects nodes from all elements from the element list and filters them to get a list of unique nodes.
UpdateNodeNeighbors fills the neighbor information for each node (list of elements to which the node belongs).
UpdateElementNodes connects each vertex (and a basis function at that vertex) in every element with a node from a node list.
Lastly, UpdateHangingNodes finds hanging nodes (by checking whether or not the node is always some element's vertex).
Once the function finds a hanging node (by finding an element to which the node belongs to but for which it is not a vertex)
it fills the interpolation data (pointers to nodes from which to interpolate).
