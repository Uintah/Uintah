#!/usr/sbin/perl
#______________________________________________________________________
#   MAKEHTML
#
#   Todd Harman     12/15/99
#   This perl script is used to automatically extract documentation out 
#   of an existing  code provided that it contains certain keywords.
#
#   In particular this script examines every file in a make file and looks 
#   for a line that is in the following format
#  
#------------------------------------------------------------------------
#   Function:  find_delta_time--This is an example of a long long description 
#   |^^^^^^|^| |^^^^^^^^^^^^^|^^|^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...|
#      A    B         C        D                     E
#   Filename:
#   |^^^^^^^|
#       F
#
#       CODE
#
#   /*STOP_DOC*/
#     |^^^^^^|
#        G
#------------------------------------------------------------------------
#   A = $KW_function
#   B = $KW_separator1
#   C = $Function
#   D = $KW_description
#   E = $Description
#   F = $KW_startextract
#   G = $KW_stopextract
#
#   When it finds (A) it places (C) and (E) into an table or the list
#   of functions.  It then searches for (F) and when if finds it starts 
#   extracting all of the contents of the file, until it reaches (G).
#
#   It then loops back and searches for comments and concatenates HTML
#   commands to the beginning and ending of the comment.
#
#   Finally, the script search for all occurances of (A) and generates
#   an HTML link.  
#
#   This script is invoked by "make"  
#   You need to make changes to the "makefile"
#
#   The file "commonFunctions.c" is for testing with 
#______________________________________________________________________
# PERL SCRIPT VARIABLE DECLARATIONS

$,                      = ' ';          # set output field separator
$\                      = "\n";         # set output record separator
$KW_function            = "Function:";  # see description above
$KW_separator1          = ":  ";
$KW_description         = "--";
$KW_startextract        = "Filename:";
$KW_stopextract         = "STOP_DOC";
$KW_start_comment       = '\/\*';
$start_comment          = '/*';
$KW_stop_comment        = '\*\/';
$stop_comment           = '*/';
                                        #HTML commands to print when you
                                        # find a comment.
$HTML_cmd_startcomment  = "<FONT COLOR=\"570BA3\">";
$HTML_cmd_stopcomment   = "<\/FONT>";
# 
$KW_start_test_comment  = '\/\*\`';
$start_test_comment     = '/*`';
$KW_stop_test_comment   = '\`\*\/';
$stop_test_comment      = '`*/';
                                        #HTML commands to print when you
                                        # find a comment.
$HTML_cmd_start_test_comment  = "<FONT COLOR=\"#f00003\">";
$HTML_cmd_stop_test_comment   = "<\/FONT>";

@files = @ARGV;

#______________________________________________________________________
#   - HTML header information
#   - Introductory text
#_______________________________________________________________________*/
print <<'EOD';
<HTML>
<HEAD><TITLE>UINTAH-ICE CFD FUNCTION DESCRIPTIONS</TITLE></HEAD>
<BODY BGCOLOR="#F5DEB3">
<FONT SIZE="3">

<A NAME="topofpage"></A>
<PRE>
<H1>Uintah ICE Function descriptions</H1>

<H2>Introduction</H2>

The following contains a list of the functions that are currently being
used in the Uintah-ICE CFD code.
<H2>General Coding Conventions:</H2>
To be filled in.



<EM>Version 1.0</EM><P>

<EM>If you have any suggestions regarding the font
size or the colors that are used in this page please let me know.  
Thanks,
Todd</EM><P>
EOD
print (`date`);


#__________________________________
#   Now pull out the function names and
#   link them.  Note that dvipdf
#   command doen't like so strip "("
#   from the function.
#___________________________________
while (<>) 
{
    chop;	# strip record separator
    if (/$KW_function/) 
    {                              
        ($description, $function) = split ($KW_separator1, $_, 0);
        ($function,$description)  = split ($KW_description,$function);
        $shortfunction                 = substr($function,0); 
        $function                 = substr($function,0)."("; 
        $ref{$function}           = "<A href=\"#$shortfunction\">$shortfunction</A>";

        push (@function, $function);
    }
}
#__________________________________
#   sort the function list and 
#   close the table
#___________________________________
@function = sort(@function);

#______________________________________________________________________
# For each file extract documentation from the source code: output HTML code
#_______________________________________________________________________*/
@ARGV = @files;
while (<>)
{
    s/\&/\&amp\;/g;
    s/\>/\&gt\;/g;
    s/\</\&lt\;/g;
  chop;				# strip record separator
  #__________________________________
  # Find $KW_function and 
  # extract the function name description
  #___________________________________*/
  /$KW_function/ && do
  {
    print '';
    print '<HR>';
    ($Description, $function)   = split ($KW_separator1, $_, 0);
    ($function,$Description)    = split ($KW_description,$function);
    
    print "<B><FONT SIZE=3 FACE=\"arial\"><A NAME=\"$function\">$function</A>  $Description</FONT></B>";
    #$function                   = substr($function,0)."(";
    print "<A HREF=\"uintah_cfd_v2.pdf\">Go to the blueprint</A>";
    next;
  };
  #__________________________________
  # Find $KW_startextract and 
  # start extracting code   
  #___________________________________
  /$KW_startextract/ && do
  {
    ($throwaway, $filename)   = split ($KW_separator1, $_, 0);
    
    print "<PRE> Filename: $filename"  if $echo == 0;
    print " Filename: $filename"  if $echo == 0;
    $echo = 1;
    print &Getline0();
    next;
  };


  #__________________________________
  #   When you find $KW_stopextract
  #   then stop extracting code
  #___________________________________
  /.$KW_stopextract./ && do
  {
    print '<PRE>' if $echo == 1;
    $echo = 0;
    print "<A HREF=\"#topofpage\">back to the top</A>"; 
    next;
  };
  

next if ! $echo;

   #__________________________________
   #  Color all the Testing comments
   # keywords are /* and */
   #___________________________________*/  
   ((/$KW_start_test_comment/) ||  (/$KW_stop_test_comment/) ) && do
   {
        $text = substr($_,0);
        $text =~s/$KW_start_test_comment/$HTML_cmd_start_test_comment$start_test_comment/g;
                                           #change color here
        $text =~s/$KW_stop_test_comment/$stop_test_comment$HTML_cmd_stop_test_comment/g;
        print $text;
        next; 
    };   
   #__________________________________
   #  Color all the comments
   # keywords are /* and */
   #___________________________________*/  
   ((/$KW_start_comment/) ||  (/$KW_stop_comment/) ) && do
   {
        $text = substr($_,0);
        $text =~s/$KW_start_comment/$HTML_cmd_startcomment$start_comment/g;
                                           #change color here
        $text =~s/$KW_stop_comment/$stop_comment$HTML_cmd_stopcomment/g;
        print $text;
        next; 
    }; 


    #______________________________________________________________________
    # Replace function names with links.  
    # when a function name is recognized,
    # it's replaced by a tag in the line to avoid multiple recognitions
    # (by functions which have similar substrings).  The tags are replaced
    # by the actual links after all identifications have been made.
    #_______________________________________________________________________*/  
    /./ && do
      {

        $line   = substr($_, 0);
        $reps   = 0;
        $repstr = '';
        foreach $function (@function)
        {
          print $function
          $start    = index($line, $function);
          next if $start == -1;
          $tag      = sprintf("REPLACE<%04d>", $reps);
          
          $line     = join('', substr($line, 0, $start), $tag,
		        substr($line, $start+length($function)));
                            
          $repstr .= "\$line =~ s:$tag:$ref{$function}:;\n";
          ++$reps;
        }
        eval $repstr if $repstr ne '';
        print $line;
        next;
      };
  print;
}



print <<'EOD';
<HR>
</BODY></HTML>
EOD


#______________________________________________________________________
#   Some function thingy.
#______________________________________________________________________ 
sub Getline0 {
    if ($getline_ok = (($_ = <>) ne '')) {
	chop;	# strip record separator
    }
    $_;
    
}

 

   
