/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit CrowdMonitor.scc instead 
 */

#ifndef SCI_THREAD_CROWDMONITOR_H
#define SCI_THREAD_CROWDMONITOR_H 1

/*
 * Multiple reader, single writer synchronization primitive.  Some
 * applications do not need the strict level of synchronization
 * provided by the <b>Mutex</b>.  The <b>CrowdMonitor</b> relaxes
 * the synchronization by allowing multiple threads access to a
 * resource (usually a data area), on the condition that the thread
 * will only read the data.  When a thread needs to write the data,
 * it can access the monitor in write mode (using <i>write_lock</i>).
 * At any given time, one writer thread can be active, or multiple
 * reader threads can be active.  <b>CrowdMonitor</b> guards against
 * multiple writers accessing a data, and against a thread writing
 * to the data while other threads are reading it.

 * <p> Calling <i>read_lock</i> within a <i>write_lock/write_unlock</i>
 * section may result in a deadlock.  Likewise, calling <i>write_lock</i>
 * within a <i>read_lock/read_unlock</i> section may result in a deadlock.
 * Calling <i>read_unlock</i> or <i>write_unlock</i> when the lock is
 * not held is not legal and may result in undefined behavior.
 */

#include "Mutex.h"
#include "ConditionVariable.h"




class CrowdMonitor_private;
class CrowdMonitor {
    const char* name;
    ConditionVariable write_waiters;
    ConditionVariable read_waiters;
    int nreaders_waiting;
    int nwriters_waiting;
    int nreaders;
    int nwriters;
    Mutex lock;
public:
    CrowdMonitor(const char* name)
     ;
    ~CrowdMonitor() ;
    void read_lock() ;
    void read_unlock() ;
    void write_lock() ;
    void write_unlock() ;
};

#endif
